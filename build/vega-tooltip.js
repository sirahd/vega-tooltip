(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.vegaTooltip = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return rollup != null
        ? rollup(array) : (sortValues != null
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],3:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

var namespace = function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
};

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

var creator = function(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
};

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

var selection_on = function(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
};

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

var sourceEvent = function() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
};

var point = function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
};

var mouse = function(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
};

function none() {}

var selector = function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
};

var selection_select = function(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

function empty() {
  return [];
}

var selectorAll = function(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
};

var selection_selectAll = function(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
};

var selection_filter = function(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

var sparse = function(update) {
  return new Array(update.length);
};

var selection_enter = function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
};

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

var selection_data = function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
};

var selection_exit = function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
};

var selection_merge = function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
};

var selection_order = function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
};

var selection_sort = function(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
};

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

var selection_call = function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
};

var selection_nodes = function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
};

var selection_node = function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
};

var selection_size = function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
};

var selection_empty = function() {
  return !this.node();
};

var selection_each = function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
};

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

var selection_attr = function(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
};

var defaultView = function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
};

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

var selection_style = function(name, value, priority) {
  var node;
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : defaultView(node = this.node())
          .getComputedStyle(node, null)
          .getPropertyValue(name);
};

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

var selection_property = function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
};

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

var selection_classed = function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
};

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

var selection_text = function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
};

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

var selection_html = function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
};

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

var selection_raise = function() {
  return this.each(raise);
};

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

var selection_lower = function() {
  return this.each(lower);
};

var selection_append = function(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
};

function constantNull() {
  return null;
}

var selection_insert = function(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
};

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

var selection_remove = function() {
  return this.each(remove);
};

var selection_datum = function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
};

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (event) {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

var selection_dispatch = function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
};

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

var select = function(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
};

var selectAll = function(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
};

var touch = function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
};

var touches = function(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
};

exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],4:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.d3_dsv = {})));
}(this, function (exports) { 'use strict';

  function dsv(delimiter) {
    return new Dsv(delimiter);
  }

  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + "]";
    }).join(",") + "}");
  }

  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
      return f(object(row), i, columns);
    };
  }

  // Compute unique columns in order of discovery.
  function inferColumns(rows) {
    var columnSet = Object.create(null),
        columns = [];

    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });

    return columns;
  }

  function Dsv(delimiter) {
    var reFormat = new RegExp("[\"" + delimiter + "\n]"),
        delimiterCode = delimiter.charCodeAt(0);

    this.parse = function(text, f) {
      var convert, columns, rows = this.parseRows(text, function(row, i) {
        if (convert) return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns;
      return rows;
    };

    this.parseRows = function(text, f) {
      var EOL = {}, // sentinel value for end-of-line
          EOF = {}, // sentinel value for end-of-file
          rows = [], // output rows
          N = text.length,
          I = 0, // current character index
          n = 0, // the current line number
          t, // the current token
          eol; // is the current token followed by EOL?

      function token() {
        if (I >= N) return EOF; // special case: end of file
        if (eol) return eol = false, EOL; // special case: end of line

        // special case: quotes
        var j = I, c;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, "\"");
        }

        // common case: find next delimiter or newline
        while (I < N) {
          var k = 1;
          c = text.charCodeAt(I++);
          if (c === 10) eol = true; // \n
          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
          else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }

        // special case: last token before EOF
        return text.slice(j);
      }

      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }

      return rows;
    }

    this.format = function(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      })).join("\n");
    };

    this.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };

    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }

    function formatValue(text) {
      return reFormat.test(text) ? "\"" + text.replace(/\"/g, "\"\"") + "\"" : text;
    }
  }

  dsv.prototype = Dsv.prototype;

  var csv = dsv(",");
  var tsv = dsv("\t");

  var version = "0.1.14";

  exports.version = version;
  exports.dsv = dsv;
  exports.csv = csv;
  exports.tsv = tsv;

}));
},{}],5:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define('d3-format', ['exports'], factory) :
  factory((global.d3_format = {}));
}(this, function (exports) { 'use strict';

  // Computes the decimal coefficient and exponent of the specified number x with
  // significant digits p, where x is positive and p is in [1, 21] or undefined.
  // For example, formatDecimal(1.23) returns ["123", 0].
  function formatDecimal(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
    var i, coefficient = x.slice(0, i);

    // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
    // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  };

  function exponent(x) {
    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
  };

  function formatGroup(grouping, thousands) {
    return function(value, width) {
      var i = value.length,
          t = [],
          j = 0,
          g = grouping[0],
          length = 0;

      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }

      return t.reverse().join(thousands);
    };
  };

  var prefixExponent;

  function formatPrefixAuto(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1],
        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
        n = coefficient.length;
    return i === n ? coefficient
        : i > n ? coefficient + new Array(i - n + 1).join("0")
        : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
        : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
  };

  function formatRounded(x, p) {
    var d = formatDecimal(x, p);
    if (!d) return x + "";
    var coefficient = d[0],
        exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
        : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  };

  function formatDefault(x, p) {
    x = x.toPrecision(p);

    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (x[i]) {
        case ".": i0 = i1 = i; break;
        case "0": if (i0 === 0) i0 = i; i1 = i; break;
        case "e": break out;
        default: if (i0 > 0) i0 = 0; break;
      }
    }

    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
  };

  var formatTypes = {
    "": formatDefault,
    "%": function(x, p) { return (x * 100).toFixed(p); },
    "b": function(x) { return Math.round(x).toString(2); },
    "c": function(x) { return x + ""; },
    "d": function(x) { return Math.round(x).toString(10); },
    "e": function(x, p) { return x.toExponential(p); },
    "f": function(x, p) { return x.toFixed(p); },
    "g": function(x, p) { return x.toPrecision(p); },
    "o": function(x) { return Math.round(x).toString(8); },
    "p": function(x, p) { return formatRounded(x * 100, p); },
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
    "x": function(x) { return Math.round(x).toString(16); }
  };

  // [[fill]align][sign][symbol][0][width][,][.precision][type]
  var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

  function formatSpecifier(specifier) {
    return new FormatSpecifier(specifier);
  };

  function FormatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

    var match,
        fill = match[1] || " ",
        align = match[2] || ">",
        sign = match[3] || "-",
        symbol = match[4] || "",
        zero = !!match[5],
        width = match[6] && +match[6],
        comma = !!match[7],
        precision = match[8] && +match[8].slice(1),
        type = match[9] || "";

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // Map invalid types to the default format.
    else if (!formatTypes[type]) type = "";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    this.fill = fill;
    this.align = align;
    this.sign = sign;
    this.symbol = symbol;
    this.zero = zero;
    this.width = width;
    this.comma = comma;
    this.precision = precision;
    this.type = type;
  }

  FormatSpecifier.prototype.toString = function() {
    return this.fill
        + this.align
        + this.sign
        + this.symbol
        + (this.zero ? "0" : "")
        + (this.width == null ? "" : Math.max(1, this.width | 0))
        + (this.comma ? "," : "")
        + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
        + this.type;
  };

  var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

  function identity(x) {
    return x;
  }

  function locale(locale) {
    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
        currency = locale.currency,
        decimal = locale.decimal;

    function format(specifier) {
      specifier = formatSpecifier(specifier);

      var fill = specifier.fill,
          align = specifier.align,
          sign = specifier.sign,
          symbol = specifier.symbol,
          zero = specifier.zero,
          width = specifier.width,
          comma = specifier.comma,
          precision = specifier.precision,
          type = specifier.type;

      // Compute the prefix and suffix.
      // For SI-prefix, the suffix is lazily computed.
      var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
          suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

      // What format function should we use?
      // Is this an integer type?
      // Can this type generate exponential notation?
      var formatType = formatTypes[type],
          maybeSuffix = !type || /[defgprs%]/.test(type);

      // Set the default precision if not specified,
      // or clamp the specified precision to the supported range.
      // For significant precision, it must be in [1, 21].
      // For fixed precision, it must be in [0, 20].
      precision = precision == null ? (type ? 6 : 12)
          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
          : Math.max(0, Math.min(20, precision));

      return function(value) {
        var valuePrefix = prefix,
            valueSuffix = suffix;

        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;

          // Convert negative to positive, and compute the prefix.
          // Note that -0 is not less than 0, but 1 / -0 is!
          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);

          // Perform the initial formatting.
          value = formatType(value, precision);

          // If the original value was negative, it may be rounded to zero during
          // formatting; treat this as (positive) zero.
          if (valueNegative) {
            var i = -1, n = value.length, c;
            valueNegative = false;
            while (++i < n) {
              if (c = value.charCodeAt(i), (48 < c && c < 58)
                  || (type === "x" && 96 < c && c < 103)
                  || (type === "X" && 64 < c && c < 71)) {
                valueNegative = true;
                break;
              }
            }
          }

          // Compute the prefix and suffix.
          valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

          // Break the formatted value into the integer “value” part that can be
          // grouped, and fractional or exponential “suffix” part that is not.
          if (maybeSuffix) {
            var i = -1, n = value.length, c;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }

        // If the fill character is not "0", grouping is applied before padding.
        if (comma && !zero) value = group(value, Infinity);

        // Compute the padding.
        var length = valuePrefix.length + value.length + valueSuffix.length,
            padding = length < width ? new Array(width - length + 1).join(fill) : "";

        // If the fill character is "0", grouping is applied after padding.
        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

        // Reconstruct the final output based on the desired alignment.
        switch (align) {
          case "<": return valuePrefix + value + valueSuffix + padding;
          case "=": return valuePrefix + padding + value + valueSuffix;
          case "^": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
        }
        return padding + valuePrefix + value + valueSuffix;
      };
    }

    function formatPrefix(specifier, value) {
      var f = format((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
          k = Math.pow(10, -e),
          prefix = prefixes[8 + e / 3];
      return function(value) {
        return f(k * value) + prefix;
      };
    }

    return {
      format: format,
      formatPrefix: formatPrefix
    };
  };

  var defaultLocale = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  var caES = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  });

  var csCZ = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0Kč"],
  });

  var deCH = locale({
    decimal: ",",
    thousands: "'",
    grouping: [3],
    currency: ["", "\xa0CHF"]
  });

  var deDE = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  });

  var enCA = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });

  var enGB = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["£", ""]
  });

  var esES = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  });

  var fiFI = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0€"]
  });

  var frCA = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "$"]
  });

  var frFR = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0€"]
  });

  var heIL = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["₪", ""]
  });

  var huHU = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0Ft"]
  });

  var itIT = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€", ""]
  });

  var jaJP = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["", "円"]
  });

  var koKR = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["₩", ""]
  });

  var mkMK = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "\xa0ден."]
  });

  var nlNL = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["€\xa0", ""]
  });

  var plPL = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["", "zł"]
  });

  var ptBR = locale({
    decimal: ",",
    thousands: ".",
    grouping: [3],
    currency: ["R$", ""]
  });

  var ruRU = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "\xa0руб."]
  });

  var svSE = locale({
    decimal: ",",
    thousands: "\xa0",
    grouping: [3],
    currency: ["", "SEK"]
  });

  var zhCN = locale({
    decimal: ".",
    thousands: ",",
    grouping: [3],
    currency: ["¥", ""]
  });

  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  };

  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  };

  function precisionRound(step, max) {
    step = Math.abs(step), max = Math.abs(max) - step;
    return Math.max(0, exponent(max) - exponent(step)) + 1;
  };

  var format = defaultLocale.format;
  var formatPrefix = defaultLocale.formatPrefix;

  var version = "0.4.2";

  exports.version = version;
  exports.format = format;
  exports.formatPrefix = formatPrefix;
  exports.locale = locale;
  exports.localeCaEs = caES;
  exports.localeCsCz = csCZ;
  exports.localeDeCh = deCH;
  exports.localeDeDe = deDE;
  exports.localeEnCa = enCA;
  exports.localeEnGb = enGB;
  exports.localeEnUs = defaultLocale;
  exports.localeEsEs = esES;
  exports.localeFiFi = fiFI;
  exports.localeFrCa = frCA;
  exports.localeFrFr = frFR;
  exports.localeHeIl = heIL;
  exports.localeHuHu = huHU;
  exports.localeItIt = itIT;
  exports.localeJaJp = jaJP;
  exports.localeKoKr = koKR;
  exports.localeMkMk = mkMK;
  exports.localeNlNl = nlNL;
  exports.localePlPl = plPL;
  exports.localePtBr = ptBR;
  exports.localeRuRu = ruRU;
  exports.localeSvSe = svSE;
  exports.localeZhCn = zhCN;
  exports.formatSpecifier = formatSpecifier;
  exports.precisionFixed = precisionFixed;
  exports.precisionPrefix = precisionPrefix;
  exports.precisionRound = precisionRound;

}));
},{}],6:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
  typeof define === 'function' && define.amd ? define('d3-time-format', ['exports', 'd3-time'], factory) :
  factory((global.d3_time_format = {}),global.d3_time);
}(this, function (exports,d3Time) { 'use strict';

  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date.setFullYear(d.y);
      return date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }

  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date.setUTCFullYear(d.y);
      return date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }

  function newYear(y) {
    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
  }

  function locale$1(locale) {
    var locale_dateTime = locale.dateTime,
        locale_date = locale.date,
        locale_time = locale.time,
        locale_periods = locale.periods,
        locale_weekdays = locale.days,
        locale_shortWeekdays = locale.shortDays,
        locale_months = locale.months,
        locale_shortMonths = locale.shortMonths;

    var periodRe = formatRe(locale_periods),
        periodLookup = formatLookup(locale_periods),
        weekdayRe = formatRe(locale_weekdays),
        weekdayLookup = formatLookup(locale_weekdays),
        shortWeekdayRe = formatRe(locale_shortWeekdays),
        shortWeekdayLookup = formatLookup(locale_shortWeekdays),
        monthRe = formatRe(locale_months),
        monthLookup = formatLookup(locale_months),
        shortMonthRe = formatRe(locale_shortMonths),
        shortMonthLookup = formatLookup(locale_shortMonths);

    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "S": formatSeconds,
      "U": formatWeekNumberSunday,
      "w": formatWeekdayNumber,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };

    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "S": formatUTCSeconds,
      "U": formatUTCWeekNumberSunday,
      "w": formatUTCWeekdayNumber,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };

    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "S": parseSeconds,
      "U": parseWeekNumberSunday,
      "w": parseWeekdayNumber,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };

    // These recursive directive definitions must be deferred.
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);

    function newFormat(specifier, formats) {
      return function(date) {
        var string = [],
            i = -1,
            j = 0,
            n = specifier.length,
            c,
            pad,
            format;

        if (!(date instanceof Date)) date = new Date(+date);

        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            else pad = c === "e" ? " " : "0";
            if (format = formats[c]) c = format(date, pad);
            string.push(c);
            j = i + 1;
          }
        }

        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }

    function newParse(specifier, newDate) {
      return function(string) {
        var d = newYear(1900),
            i = parseSpecifier(d, specifier, string += "", 0);
        if (i != string.length) return null;

        // The am-pm flag is 0 for AM, and 1 for PM.
        if ("p" in d) d.H = d.H % 12 + d.p * 12;

        // Convert day-of-week and week-of-year to day-of-year.
        if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
        }

        // If a time zone is specified, all fields are interpreted as UTC and then
        // offset according to the specified time zone.
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }

        // Otherwise, all fields are in local time.
        return newDate(d);
      };
    }

    function parseSpecifier(d, specifier, string, j) {
      var i = 0,
          n = specifier.length,
          m = string.length,
          c,
          parse;

      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }

      return j;
    }

    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
    }

    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }

    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }

    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }

    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }

    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }

    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }

    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }

    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }

    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }

    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }

    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }

    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }

    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }

    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.parse = newParse(specifier, localDate);
        f.toString = function() { return specifier; };
        return f;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.parse = newParse(specifier, utcDate);
        f.toString = function() { return specifier; };
        return f;
      }
    };
  };

  var pads = {"-": "", "_": " ", "0": "0"};
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  function pad(value, fill, width) {
    var sign = value < 0 ? "-" : "",
        string = (sign ? -value : value) + "",
        length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }

  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }

  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }

  function formatLookup(names) {
    var map = {}, i = -1, n = names.length;
    while (++i < n) map[names[i].toLowerCase()] = i;
    return map;
  }

  function parseWeekdayNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }

  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }

  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }

  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
  }

  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }

  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }

  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }

  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }

  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }

  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }

  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }

  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }

  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }

  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }

  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }

  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }

  function formatDayOfYear(d, p) {
    return pad(1 + d3Time.day.count(d3Time.year(d), d), p, 3);
  }

  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }

  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }

  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }

  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }

  function formatWeekNumberSunday(d, p) {
    return pad(d3Time.sunday.count(d3Time.year(d), d), p, 2);
  }

  function formatWeekdayNumber(d) {
    return d.getDay();
  }

  function formatWeekNumberMonday(d, p) {
    return pad(d3Time.monday.count(d3Time.year(d), d), p, 2);
  }

  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }

  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 10000, p, 4);
  }

  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+"))
        + pad(z / 60 | 0, "0", 2)
        + pad(z % 60, "0", 2);
  }

  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }

  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }

  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }

  function formatUTCDayOfYear(d, p) {
    return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
  }

  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }

  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }

  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }

  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }

  function formatUTCWeekNumberSunday(d, p) {
    return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
  }

  function formatUTCWeekdayNumber(d) {
    return d.getUTCDay();
  }

  function formatUTCWeekNumberMonday(d, p) {
    return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
  }

  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }

  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 10000, p, 4);
  }

  function formatUTCZone() {
    return "+0000";
  }

  function formatLiteralPercent() {
    return "%";
  }

  var locale = locale$1({
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  var caES = locale$1({
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["diumenge", "dilluns", "dimarts", "dimecres", "dijous", "divendres", "dissabte"],
    shortDays: ["dg.", "dl.", "dt.", "dc.", "dj.", "dv.", "ds."],
    months: ["gener", "febrer", "març", "abril", "maig", "juny", "juliol", "agost", "setembre", "octubre", "novembre", "desembre"],
    shortMonths: ["gen.", "febr.", "març", "abr.", "maig", "juny", "jul.", "ag.", "set.", "oct.", "nov.", "des."]
  });

  var deCH = locale$1({
    dateTime: "%A, der %e. %B %Y, %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
  });

  var deDE = locale$1({
    dateTime: "%A, der %e. %B %Y, %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
    shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
    months: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
    shortMonths: ["Jan", "Feb", "Mrz", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"]
  });

  var enCA = locale$1({
    dateTime: "%a %b %e %X %Y",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  var enGB = locale$1({
    dateTime: "%a %e %b %X %Y",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });

  var esES = locale$1({
    dateTime: "%A, %e de %B de %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
    shortDays: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
    months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
    shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
  });

  var fiFI = locale$1({
    dateTime: "%A, %-d. %Bta %Y klo %X",
    date: "%-d.%-m.%Y",
    time: "%H:%M:%S",
    periods: ["a.m.", "p.m."],
    days: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"],
    shortDays: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
    months: ["tammikuu", "helmikuu", "maaliskuu", "huhtikuu", "toukokuu", "kesäkuu", "heinäkuu", "elokuu", "syyskuu", "lokakuu", "marraskuu", "joulukuu"],
    shortMonths: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kesä", "Heinä", "Elo", "Syys", "Loka", "Marras", "Joulu"]
  });

  var frCA = locale$1({
    dateTime: "%a %e %b %Y %X",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["", ""],
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["jan", "fév", "mar", "avr", "mai", "jui", "jul", "aoû", "sep", "oct", "nov", "déc"]
  });

  var frFR = locale$1({
    dateTime: "%A, le %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
    shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
    months: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
    shortMonths: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
  });

  var heIL = locale$1({
    dateTime: "%A, %e ב%B %Y %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
    shortDays: ["א׳", "ב׳", "ג׳", "ד׳", "ה׳", "ו׳", "ש׳"],
    months: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
    shortMonths: ["ינו׳", "פבר׳", "מרץ", "אפר׳", "מאי", "יוני", "יולי", "אוג׳", "ספט׳", "אוק׳", "נוב׳", "דצמ׳"]
  });

  var huHU = locale$1({
    dateTime: "%Y. %B %-e., %A %X",
    date: "%Y. %m. %d.",
    time: "%H:%M:%S",
    periods: ["de.", "du."], // unused
    days: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"],
    shortDays: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
    months: ["január", "február", "március", "április", "május", "június", "július", "augusztus", "szeptember", "október", "november", "december"],
    shortMonths: ["jan.", "feb.", "már.", "ápr.", "máj.", "jún.", "júl.", "aug.", "szept.", "okt.", "nov.", "dec."]
  });

  var itIT = locale$1({
    dateTime: "%A %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
    shortDays: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
    months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
    shortMonths: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"]
  });

  var jaJP = locale$1({
    dateTime: "%Y %b %e %a %X",
    date: "%Y/%m/%d",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"],
    shortDays: ["日", "月", "火", "水", "木", "金", "土"],
    months: ["睦月", "如月", "弥生", "卯月", "皐月", "水無月", "文月", "葉月", "長月", "神無月", "霜月", "師走"],
    shortMonths: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"]
  });

  var koKR = locale$1({
    dateTime: "%Y/%m/%d %a %X",
    date: "%Y/%m/%d",
    time: "%H:%M:%S",
    periods: ["오전", "오후"],
    days: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
    shortDays: ["일", "월", "화", "수", "목", "금", "토"],
    months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
    shortMonths: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]
  });

  var mkMK = locale$1({
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
    shortDays: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
    months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
    shortMonths: ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
  });

  var nlNL = locale$1({
    dateTime: "%a %e %B %Y %T",
    date: "%d-%m-%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
    shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
    months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
    shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"]
  });

  var plPL = locale$1({
    dateTime: "%A, %e %B %Y, %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"], // unused
    days: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
    shortDays: ["Niedz.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
    months: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
    shortMonths: ["Stycz.", "Luty", "Marz.", "Kwie.", "Maj", "Czerw.", "Lipc.", "Sierp.", "Wrz.", "Paźdz.", "Listop.", "Grudz."]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */
  });

  var ptBR = locale$1({
    dateTime: "%A, %e de %B de %Y. %X",
    date: "%d/%m/%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
    shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
    months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
    shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
  });

  var ruRU = locale$1({
    dateTime: "%A, %e %B %Y г. %X",
    date: "%d.%m.%Y",
    time: "%H:%M:%S",
    periods: ["AM", "PM"],
    days: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
    shortDays: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
    months: ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
    shortMonths: ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
  });

  var svSE = locale$1({
    dateTime: "%A den %d %B %Y %X",
    date: "%Y-%m-%d",
    time: "%H:%M:%S",
    periods: ["fm", "em"],
    days: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"],
    shortDays: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
    months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"]
  });

  var zhCN = locale$1({
    dateTime: "%a %b %e %X %Y",
    date: "%Y/%-m/%-d",
    time: "%H:%M:%S",
    periods: ["上午", "下午"],
    days: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    shortDays: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    shortMonths: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
  });

  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

  function formatIsoNative(date) {
    return date.toISOString();
  }

  formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };

  formatIsoNative.toString = function() {
    return isoSpecifier;
  };

  var formatIso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z")
      ? formatIsoNative
      : locale.utcFormat(isoSpecifier);

  var format = locale.format;
  var utcFormat = locale.utcFormat;

  var version = "0.2.1";

  exports.version = version;
  exports.format = format;
  exports.utcFormat = utcFormat;
  exports.locale = locale$1;
  exports.localeCaEs = caES;
  exports.localeDeCh = deCH;
  exports.localeDeDe = deDE;
  exports.localeEnCa = enCA;
  exports.localeEnGb = enGB;
  exports.localeEnUs = locale;
  exports.localeEsEs = esES;
  exports.localeFiFi = fiFI;
  exports.localeFrCa = frCA;
  exports.localeFrFr = frFR;
  exports.localeHeIl = heIL;
  exports.localeHuHu = huHU;
  exports.localeItIt = itIT;
  exports.localeJaJp = jaJP;
  exports.localeKoKr = koKR;
  exports.localeMkMk = mkMK;
  exports.localeNlNl = nlNL;
  exports.localePlPl = plPL;
  exports.localePtBr = ptBR;
  exports.localeRuRu = ruRU;
  exports.localeSvSe = svSE;
  exports.localeZhCn = zhCN;
  exports.isoFormat = formatIso;

}));
},{"d3-time":7}],7:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :
  factory((global.d3_time = {}));
}(this, function (exports) { 'use strict';

  var t0 = new Date;
  var t1 = new Date;
  function newInterval(floori, offseti, count, field) {

    function interval(date) {
      return floori(date = new Date(+date)), date;
    }

    interval.floor = interval;

    interval.round = function(date) {
      var d0 = new Date(+date),
          d1 = new Date(date - 1);
      floori(d0), floori(d1), offseti(d1, 1);
      return date - d0 < d1 - date ? d0 : d1;
    };

    interval.ceil = function(date) {
      return floori(date = new Date(date - 1)), offseti(date, 1), date;
    };

    interval.offset = function(date, step) {
      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
    };

    interval.range = function(start, stop, step) {
      var range = [];
      start = new Date(start - 1);
      stop = new Date(+stop);
      step = step == null ? 1 : Math.floor(step);
      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
      offseti(start, 1), floori(start);
      if (start < stop) range.push(new Date(+start));
      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));
      return range;
    };

    interval.filter = function(test) {
      return newInterval(function(date) {
        while (floori(date), !test(date)) date.setTime(date - 1);
      }, function(date, step) {
        while (--step >= 0) while (offseti(date, 1), !test(date));
      });
    };

    if (count) {
      interval.count = function(start, end) {
        t0.setTime(+start), t1.setTime(+end);
        floori(t0), floori(t1);
        return Math.floor(count(t0, t1));
      };

      interval.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null
            : !(step > 1) ? interval
            : interval.filter(field
                ? function(d) { return field(d) % step === 0; }
                : function(d) { return interval.count(0, d) % step === 0; });
      };
    }

    return interval;
  };

  var millisecond = newInterval(function() {
    // noop
  }, function(date, step) {
    date.setTime(+date + step);
  }, function(start, end) {
    return end - start;
  });

  // An optimized implementation for this simple case.
  millisecond.every = function(k) {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return newInterval(function(date) {
      date.setTime(Math.floor(date / k) * k);
    }, function(date, step) {
      date.setTime(+date + step * k);
    }, function(start, end) {
      return (end - start) / k;
    });
  };

  var second = newInterval(function(date) {
    date.setMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  }, function(date) {
    return date.getSeconds();
  });

  var minute = newInterval(function(date) {
    date.setSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  }, function(date) {
    return date.getMinutes();
  });

  var hour = newInterval(function(date) {
    date.setMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  }, function(date) {
    return date.getHours();
  });

  var day = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;
  }, function(date) {
    return date.getDate() - 1;
  });

  function weekday(i) {
    return newInterval(function(date) {
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setDate(date.getDate() + step * 7);
    }, function(start, end) {
      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;
    });
  }

  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);

  var month = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setDate(1);
  }, function(date, step) {
    date.setMonth(date.getMonth() + step);
  }, function(start, end) {
    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
  }, function(date) {
    return date.getMonth();
  });

  var year = newInterval(function(date) {
    date.setHours(0, 0, 0, 0);
    date.setMonth(0, 1);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step);
  }, function(start, end) {
    return end.getFullYear() - start.getFullYear();
  }, function(date) {
    return date.getFullYear();
  });

  var utcSecond = newInterval(function(date) {
    date.setUTCMilliseconds(0);
  }, function(date, step) {
    date.setTime(+date + step * 1e3);
  }, function(start, end) {
    return (end - start) / 1e3;
  }, function(date) {
    return date.getUTCSeconds();
  });

  var utcMinute = newInterval(function(date) {
    date.setUTCSeconds(0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 6e4);
  }, function(start, end) {
    return (end - start) / 6e4;
  }, function(date) {
    return date.getUTCMinutes();
  });

  var utcHour = newInterval(function(date) {
    date.setUTCMinutes(0, 0, 0);
  }, function(date, step) {
    date.setTime(+date + step * 36e5);
  }, function(start, end) {
    return (end - start) / 36e5;
  }, function(date) {
    return date.getUTCHours();
  });

  var utcDay = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step);
  }, function(start, end) {
    return (end - start) / 864e5;
  }, function(date) {
    return date.getUTCDate() - 1;
  });

  function utcWeekday(i) {
    return newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step * 7);
    }, function(start, end) {
      return (end - start) / 6048e5;
    });
  }

  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);

  var utcMonth = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCDate(1);
  }, function(date, step) {
    date.setUTCMonth(date.getUTCMonth() + step);
  }, function(start, end) {
    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
  }, function(date) {
    return date.getUTCMonth();
  });

  var utcYear = newInterval(function(date) {
    date.setUTCHours(0, 0, 0, 0);
    date.setUTCMonth(0, 1);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step);
  }, function(start, end) {
    return end.getUTCFullYear() - start.getUTCFullYear();
  }, function(date) {
    return date.getUTCFullYear();
  });

  var milliseconds = millisecond.range;
  var seconds = second.range;
  var minutes = minute.range;
  var hours = hour.range;
  var days = day.range;
  var sundays = sunday.range;
  var mondays = monday.range;
  var tuesdays = tuesday.range;
  var wednesdays = wednesday.range;
  var thursdays = thursday.range;
  var fridays = friday.range;
  var saturdays = saturday.range;
  var weeks = sunday.range;
  var months = month.range;
  var years = year.range;

  var utcMillisecond = millisecond;
  var utcMilliseconds = milliseconds;
  var utcSeconds = utcSecond.range;
  var utcMinutes = utcMinute.range;
  var utcHours = utcHour.range;
  var utcDays = utcDay.range;
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;
  var utcWeeks = utcSunday.range;
  var utcMonths = utcMonth.range;
  var utcYears = utcYear.range;

  var version = "0.1.1";

  exports.version = version;
  exports.milliseconds = milliseconds;
  exports.seconds = seconds;
  exports.minutes = minutes;
  exports.hours = hours;
  exports.days = days;
  exports.sundays = sundays;
  exports.mondays = mondays;
  exports.tuesdays = tuesdays;
  exports.wednesdays = wednesdays;
  exports.thursdays = thursdays;
  exports.fridays = fridays;
  exports.saturdays = saturdays;
  exports.weeks = weeks;
  exports.months = months;
  exports.years = years;
  exports.utcMillisecond = utcMillisecond;
  exports.utcMilliseconds = utcMilliseconds;
  exports.utcSeconds = utcSeconds;
  exports.utcMinutes = utcMinutes;
  exports.utcHours = utcHours;
  exports.utcDays = utcDays;
  exports.utcSundays = utcSundays;
  exports.utcMondays = utcMondays;
  exports.utcTuesdays = utcTuesdays;
  exports.utcWednesdays = utcWednesdays;
  exports.utcThursdays = utcThursdays;
  exports.utcFridays = utcFridays;
  exports.utcSaturdays = utcSaturdays;
  exports.utcWeeks = utcWeeks;
  exports.utcMonths = utcMonths;
  exports.utcYears = utcYears;
  exports.millisecond = millisecond;
  exports.second = second;
  exports.minute = minute;
  exports.hour = hour;
  exports.day = day;
  exports.sunday = sunday;
  exports.monday = monday;
  exports.tuesday = tuesday;
  exports.wednesday = wednesday;
  exports.thursday = thursday;
  exports.friday = friday;
  exports.saturday = saturday;
  exports.week = sunday;
  exports.month = month;
  exports.year = year;
  exports.utcSecond = utcSecond;
  exports.utcMinute = utcMinute;
  exports.utcHour = utcHour;
  exports.utcDay = utcDay;
  exports.utcSunday = utcSunday;
  exports.utcMonday = utcMonday;
  exports.utcTuesday = utcTuesday;
  exports.utcWednesday = utcWednesday;
  exports.utcThursday = utcThursday;
  exports.utcFriday = utcFriday;
  exports.utcSaturday = utcSaturday;
  exports.utcWeek = utcSunday;
  exports.utcMonth = utcMonth;
  exports.utcYear = utcYear;
  exports.interval = newInterval;

}));
},{}],8:[function(require,module,exports){
module.exports={
  "name": "datalib",
  "version": "1.7.3",
  "description": "JavaScript utilites for loading, summarizing and working with data.",
  "keywords": [
    "data",
    "table",
    "statistics",
    "parse",
    "csv",
    "tsv",
    "json",
    "utility"
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/vega/datalib.git"
  },
  "author": {
    "name": "Jeffrey Heer",
    "url": "http://idl.cs.washington.edu"
  },
  "contributors": [
    {
      "name": "Michael Correll",
      "url": "http://pages.cs.wisc.edu/~mcorrell/"
    },
    {
      "name": "Ryan Russell",
      "url": "https://github.com/RussellSprouts"
    }
  ],
  "license": "BSD-3-Clause",
  "dependencies": {
    "d3-dsv": "0.1",
    "d3-format": "0.4",
    "d3-time": "0.1",
    "d3-time-format": "0.2",
    "topojson": "^1.6.19",
    "request": "^2.67.0",
    "sync-request": "^2.1.0"
  },
  "devDependencies": {
    "browserify": "^12.0.1",
    "chai": "^3.4.1",
    "istanbul": "latest",
    "jshint": "^2.9.1-rc1",
    "mocha": "^2.3.4",
    "uglify-js": "^2.6.1"
  },
  "main": "src/index.js",
  "scripts": {
    "deploy": "npm run test && scripts/deploy.sh",
    "lint": "jshint src/",
    "test": "npm run lint && TZ=America/Los_Angeles mocha --recursive test/",
    "cover": "TZ=America/Los_Angeles istanbul cover _mocha -- --recursive test/",
    "build": "browserify src/index.js -d -s dl -o datalib.js",
    "postbuild": "uglifyjs datalib.js -c -m -o datalib.min.js"
  },
  "browser": {
    "buffer": false,
    "fs": false,
    "http": false,
    "request": false,
    "sync-request": false,
    "url": false
  }
}

},{}],9:[function(require,module,exports){
var util = require('./util'),
    time = require('./time'),
    utc = time.utc;

var u = module.exports;

u.$year   = util.$func('year', time.year.unit);
u.$month  = util.$func('month', time.months.unit);
u.$date   = util.$func('date', time.dates.unit);
u.$day    = util.$func('day', time.weekdays.unit);
u.$hour   = util.$func('hour', time.hours.unit);
u.$minute = util.$func('minute', time.minutes.unit);
u.$second = util.$func('second', time.seconds.unit);

u.$utcYear   = util.$func('utcYear', utc.year.unit);
u.$utcMonth  = util.$func('utcMonth', utc.months.unit);
u.$utcDate   = util.$func('utcDate', utc.dates.unit);
u.$utcDay    = util.$func('utcDay', utc.weekdays.unit);
u.$utcHour   = util.$func('utcHour', utc.hours.unit);
u.$utcMinute = util.$func('utcMinute', utc.minutes.unit);
u.$utcSecond = util.$func('utcSecond', utc.seconds.unit);

},{"./time":31,"./util":32}],10:[function(require,module,exports){
var util = require('../util'),
    Measures = require('./measures'),
    Collector = require('./collector');

function Aggregator() {
  this._cells = {};
  this._aggr = [];
  this._stream = false;
}

var Flags = Aggregator.Flags = {
  ADD_CELL: 1,
  MOD_CELL: 2
};

var proto = Aggregator.prototype;

// Parameters

proto.stream = function(v) {
  if (v == null) return this._stream;
  this._stream = !!v;
  this._aggr = [];
  return this;
};

// key accessor to use for streaming removes
proto.key = function(key) {
  if (key == null) return this._key;
  this._key = util.$(key);
  return this;
};

// Input: array of objects of the form
// {name: string, get: function}
proto.groupby = function(dims) {
  this._dims = util.array(dims).map(function(d, i) {
    d = util.isString(d) ? {name: d, get: util.$(d)}
      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}
      : (d.name && util.isFunction(d.get)) ? d : null;
    if (d == null) throw 'Invalid groupby argument: ' + d;
    return d;
  });
  return this.clear();
};

// Input: array of objects of the form
// {name: string, ops: [string, ...]}
proto.summarize = function(fields) {
  fields = summarize_args(fields);
  this._count = true;
  var aggr = (this._aggr = []),
      m, f, i, j, op, as, get;

  for (i=0; i<fields.length; ++i) {
    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {
      op = f.ops[j];
      if (op !== 'count') this._count = false;
      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));
      m.push(Measures[op](as));
    }
    get = f.get && util.$(f.get) ||
      (f.name === '*' ? util.identity : util.$(f.name));
    aggr.push({
      name: f.name,
      measures: Measures.create(
        m,
        this._stream, // streaming remove flag
        get,          // input tuple getter
        this._assign) // output tuple setter
    });
  }
  return this.clear();
};

// Convenience method to summarize by count
proto.count = function() {
  return this.summarize({'*':'count'});
};

// Override to perform custom tuple value assignment
proto._assign = function(object, name, value) {
  object[name] = value;
};

function summarize_args(fields) {
  if (util.isArray(fields)) { return fields; }
  if (fields == null) { return []; }
  var a = [], name, ops;
  for (name in fields) {
    ops = util.array(fields[name]);
    a.push({name: name, ops: ops});
  }
  return a;
}

// Cell Management

proto.clear = function() {
  return (this._cells = {}, this);
};

proto._cellkey = function(x) {
  var d = this._dims,
      n = d.length, i,
      k = String(d[0].get(x));
  for (i=1; i<n; ++i) {
    k += '|' + d[i].get(x);
  }
  return k;
};

proto._cell = function(x) {
  var key = this._dims.length ? this._cellkey(x) : '';
  return this._cells[key] || (this._cells[key] = this._newcell(x, key));
};

proto._newcell = function(x, key) {
  var cell = {
    num:   0,
    tuple: this._newtuple(x, key),
    flag:  Flags.ADD_CELL,
    aggs:  {}
  };

  var aggr = this._aggr, i;
  for (i=0; i<aggr.length; ++i) {
    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);
  }
  if (cell.collect) {
    cell.data = new Collector(this._key);
  }
  return cell;
};

proto._newtuple = function(x) {
  var dims = this._dims,
      t = {}, i, n;
  for (i=0, n=dims.length; i<n; ++i) {
    t[dims[i].name] = dims[i].get(x);
  }
  return this._ingest(t);
};

// Override to perform custom tuple ingestion
proto._ingest = util.identity;

// Process Tuples

proto._add = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num += 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.add(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].add(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_add) this._on_add(x, cell);
};

proto._rem = function(x) {
  var cell = this._cell(x),
      aggr = this._aggr, i;

  cell.num -= 1;
  if (!this._count) { // skip if count-only
    if (cell.collect) cell.data.rem(x);
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].rem(x);
    }
  }
  cell.flag |= Flags.MOD_CELL;
  if (this._on_rem) this._on_rem(x, cell);
};

proto._mod = function(curr, prev) {
  var cell0 = this._cell(prev),
      cell1 = this._cell(curr),
      aggr = this._aggr, i;

  if (cell0 !== cell1) {
    cell0.num -= 1;
    cell1.num += 1;
    if (cell0.collect) cell0.data.rem(prev);
    if (cell1.collect) cell1.data.add(curr);
  } else if (cell0.collect && !util.isObject(curr)) {
    cell0.data.rem(prev);
    cell0.data.add(curr);
  }

  for (i=0; i<aggr.length; ++i) {
    cell0.aggs[aggr[i].name].rem(prev);
    cell1.aggs[aggr[i].name].add(curr);
  }
  cell0.flag |= Flags.MOD_CELL;
  cell1.flag |= Flags.MOD_CELL;
  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);
};

proto._markMod = function(x) {
  var cell0 = this._cell(x);
  cell0.flag |= Flags.MOD_CELL;
};

proto.result = function() {
  var result = [],
      aggr = this._aggr,
      cell, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    if (cell.num > 0) {
      // consolidate collector values
      if (cell.collect) {
        cell.data.values();
      }
      // update tuple properties
      for (i=0; i<aggr.length; ++i) {
        cell.aggs[aggr[i].name].set();
      }
      // add output tuple
      result.push(cell.tuple);
    } else {
      delete this._cells[k];
    }
    cell.flag = 0;
  }

  this._rems = false;
  return result;
};

proto.changes = function(output) {
  var changes = output || {add:[], rem:[], mod:[]},
      aggr = this._aggr,
      cell, flag, i, k;

  for (k in this._cells) {
    cell = this._cells[k];
    flag = cell.flag;

    // consolidate collector values
    if (cell.collect) {
      cell.data.values();
    }

    // update tuple properties
    for (i=0; i<aggr.length; ++i) {
      cell.aggs[aggr[i].name].set();
    }

    // organize output tuples
    if (cell.num <= 0) {
      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??
      delete this._cells[k];
      if (this._on_drop) this._on_drop(cell);
    } else {
      if (this._on_keep) this._on_keep(cell);
      if (flag & Flags.ADD_CELL) {
        changes.add.push(cell.tuple);
      } else if (flag & Flags.MOD_CELL) {
        changes.mod.push(cell.tuple);
      }
    }

    cell.flag = 0;
  }

  this._rems = false;
  return changes;
};

proto.execute = function(input) {
  return this.clear().insert(input).result();
};

proto.insert = function(input) {
  this._consolidate();
  for (var i=0; i<input.length; ++i) {
    this._add(input[i]);
  }
  return this;
};

proto.remove = function(input) {
  if (!this._stream) {
    throw 'Aggregator not configured for streaming removes.' +
      ' Call stream(true) prior to calling summarize.';
  }
  for (var i=0; i<input.length; ++i) {
    this._rem(input[i]);
  }
  this._rems = true;
  return this;
};

// consolidate removals
proto._consolidate = function() {
  if (!this._rems) return;
  for (var k in this._cells) {
    if (this._cells[k].collect) {
      this._cells[k].data.values();
    }
  }
  this._rems = false;
};

module.exports = Aggregator;

},{"../util":32,"./collector":11,"./measures":13}],11:[function(require,module,exports){
var util = require('../util');
var stats = require('../stats');

var REM = '__dl_rem__';

function Collector(key) {
  this._add = [];
  this._rem = [];
  this._key = key || null;
  this._last = null;
}

var proto = Collector.prototype;

proto.add = function(v) {
  this._add.push(v);
};

proto.rem = function(v) {
  this._rem.push(v);
};

proto.values = function() {
  this._get = null;
  if (this._rem.length === 0) return this._add;

  var a = this._add,
      r = this._rem,
      k = this._key,
      x = Array(a.length - r.length),
      i, j, n, m;

  if (!util.isObject(r[0])) {
    // processing raw values
    m = stats.count.map(r);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (m[a[i]] > 0) {
        m[a[i]] -= 1;
      } else {
        x[j++] = a[i];
      }
    }
  } else if (k) {
    // has unique key field, so use that
    m = util.toMap(r, k);
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }
    }
  } else {
    // no unique key, mark tuples directly
    for (i=0, n=r.length; i<n; ++i) {
      r[i][REM] = 1;
    }
    for (i=0, j=0, n=a.length; i<n; ++i) {
      if (!a[i][REM]) { x[j++] = a[i]; }
    }
    for (i=0, n=r.length; i<n; ++i) {
      delete r[i][REM];
    }
  }

  this._rem = [];
  return (this._add = x);
};

// memoizing statistics methods

proto.extent = function(get) {
  if (this._get !== get || !this._ext) {
    var v = this.values(),
        i = stats.extent.index(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;
  }
  return this._ext;
};

proto.argmin = function(get) {
  return this.extent(get)[0];
};

proto.argmax = function(get) {
  return this.extent(get)[1];
};

proto.min = function(get) {
  var m = this.extent(get)[0];
  return m != null ? get(m) : +Infinity;
};

proto.max = function(get) {
  var m = this.extent(get)[1];
  return m != null ? get(m) : -Infinity;
};

proto.quartile = function(get) {
  if (this._get !== get || !this._q) {
    this._q = stats.quartile(this.values(), get);
    this._get = get;
  }
  return this._q;
};

proto.q1 = function(get) {
  return this.quartile(get)[0];
};

proto.q2 = function(get) {
  return this.quartile(get)[1];
};

proto.q3 = function(get) {
  return this.quartile(get)[2];
};

module.exports = Collector;

},{"../stats":29,"../util":32}],12:[function(require,module,exports){
var util = require('../util');
var Aggregator = require('./aggregator');

module.exports = function() {
  // flatten arguments into a single array
  var args = [].reduce.call(arguments, function(a, x) {
    return a.concat(util.array(x));
  }, []);
  // create and return an aggregator
  return new Aggregator()
    .groupby(args)
    .summarize({'*':'values'});
};

},{"../util":32,"./aggregator":10}],13:[function(require,module,exports){
var util = require('../util');

var types = {
  'values': measure({
    name: 'values',
    init: 'cell.collect = true;',
    set:  'cell.data.values()', idx: -1
  }),
  'count': measure({
    name: 'count',
    set:  'cell.num'
  }),
  'missing': measure({
    name: 'missing',
    set:  'this.missing'
  }),
  'valid': measure({
    name: 'valid',
    set:  'this.valid'
  }),
  'sum': measure({
    name: 'sum',
    init: 'this.sum = 0;',
    add:  'this.sum += v;',
    rem:  'this.sum -= v;',
    set:  'this.sum'
  }),
  'mean': measure({
    name: 'mean',
    init: 'this.mean = 0;',
    add:  'var d = v - this.mean; this.mean += d / this.valid;',
    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',
    set:  'this.mean'
  }),
  'average': measure({
    name: 'average',
    set:  'this.mean',
    req:  ['mean'], idx: 1
  }),
  'variance': measure({
    name: 'variance',
    init: 'this.dev = 0;',
    add:  'this.dev += d * (v - this.mean);',
    rem:  'this.dev -= d * (v - this.mean);',
    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',
    req:  ['mean'], idx: 1
  }),
  'variancep': measure({
    name: 'variancep',
    set:  'this.valid > 1 ? this.dev / this.valid : 0',
    req:  ['variance'], idx: 2
  }),
  'stdev': measure({
    name: 'stdev',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',
    req:  ['variance'], idx: 2
  }),
  'stdevp': measure({
    name: 'stdevp',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',
    req:  ['variance'], idx: 2
  }),
  'stderr': measure({
    name: 'stderr',
    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid * (this.valid-1))) : 0',
    req:  ['variance'], idx: 2
  }),
  'median': measure({
    name: 'median',
    set:  'cell.data.q2(this.get)',
    req:  ['values'], idx: 3
  }),
  'q1': measure({
    name: 'q1',
    set:  'cell.data.q1(this.get)',
    req:  ['values'], idx: 3
  }),
  'q3': measure({
    name: 'q3',
    set:  'cell.data.q3(this.get)',
    req:  ['values'], idx: 3
  }),
  'distinct': measure({
    name: 'distinct',
    set:  'this.distinct(cell.data.values(), this.get)',
    req:  ['values'], idx: 3
  }),
  'argmin': measure({
    name: 'argmin',
    add:  'if (v < this.min) this.argmin = t;',
    rem:  'if (v <= this.min) this.argmin = null;',
    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',
    req:  ['min'], str: ['values'], idx: 3
  }),
  'argmax': measure({
    name: 'argmax',
    add:  'if (v > this.max) this.argmax = t;',
    rem:  'if (v >= this.max) this.argmax = null;',
    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',
    req:  ['max'], str: ['values'], idx: 3
  }),
  'min': measure({
    name: 'min',
    init: 'this.min = +Infinity;',
    add:  'if (v < this.min) this.min = v;',
    rem:  'if (v <= this.min) this.min = NaN;',
    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',
    str:  ['values'], idx: 4
  }),
  'max': measure({
    name: 'max',
    init: 'this.max = -Infinity;',
    add:  'if (v > this.max) this.max = v;',
    rem:  'if (v >= this.max) this.max = NaN;',
    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',
    str:  ['values'], idx: 4
  }),
  'modeskew': measure({
    name: 'modeskew',
    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',
    req:  ['mean', 'variance', 'median'], idx: 5
  })
};

function measure(base) {
  return function(out) {
    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);
    m.out = out || base.name;
    return m;
  };
}

function resolve(agg, stream) {
  function collect(m, a) {
    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }
    if (a.req) a.req.forEach(helper);
    if (stream && a.str) a.str.forEach(helper);
    return m;
  }
  var map = agg.reduce(
    collect,
    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})
  );
  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });
}

function create(agg, stream, accessor, mutator) {
  var all = resolve(agg, stream),
      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',
      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',
      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',
      set = 'var t = this.tuple; var cell = this.cell;';

  all.forEach(function(a) {
    if (a.idx < 0) {
      ctr = a.init + ctr;
      add = a.add + add;
      rem = a.rem + rem;
    } else {
      ctr += a.init;
      add += a.add;
      rem += a.rem;
    }
  });
  agg.slice()
    .sort(function(a, b) { return a.idx - b.idx; })
    .forEach(function(a) {
      set += 'this.assign(t,\''+a.out+'\','+a.set+');';
    });
  set += 'return t;';

  /* jshint evil: true */
  ctr = Function('cell', 't', ctr);
  ctr.prototype.assign = mutator;
  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);
  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);
  ctr.prototype.set = Function(set);
  ctr.prototype.get = accessor;
  ctr.prototype.distinct = require('../stats').count.distinct;
  ctr.prototype.isValid = util.isValid;
  ctr.fields = agg.map(util.$('out'));
  return ctr;
}

types.create = create;
module.exports = types;

},{"../stats":29,"../util":32}],14:[function(require,module,exports){
var util = require('../util'),
    time = require('../time'),
    EPSILON = 1e-15;

function bins(opt) {
  if (!opt) { throw Error("Missing binning options."); }

  // determine range
  var maxb = opt.maxbins || 15,
      base = opt.base || 10,
      logb = Math.log(base),
      div = opt.div || [5, 2],
      min = opt.min,
      max = opt.max,
      span = max - min,
      step, level, minstep, precision, v, i, eps;

  if (opt.step) {
    // if step size is explicitly given, use that
    step = opt.step;
  } else if (opt.steps) {
    // if provided, limit choice to acceptable step sizes
    step = opt.steps[Math.min(
      opt.steps.length - 1,
      bisect(opt.steps, span/maxb, 0, opt.steps.length)
    )];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = opt.minstep || 0;
    step = Math.max(
      minstep,
      Math.pow(base, Math.round(Math.log(span) / logb) - level)
    );

    // increase step size if too many bins
    while (Math.ceil(span/step) > maxb) { step *= base; }

    // decrease step size if allowed
    for (i=0; i<div.length; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  }

  // update precision, min and max
  v = Math.log(step);
  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;
  eps = Math.pow(base, -precision - 1);
  min = Math.min(min, Math.floor(min / step + eps) * step);
  max = Math.ceil(max / step) * step;

  return {
    start: min,
    stop:  max,
    step:  step,
    unit:  {precision: precision},
    value: value,
    index: index
  };
}

function bisect(a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }
    else { hi = mid; }
  }
  return lo;
}

function value(v) {
  return this.step * Math.floor(v / this.step + EPSILON);
}

function index(v) {
  return Math.floor((v - this.start) / this.step + EPSILON);
}

function date_value(v) {
  return this.unit.date(value.call(this, v));
}

function date_index(v) {
  return index.call(this, this.unit.unit(v));
}

bins.date = function(opt) {
  if (!opt) { throw Error("Missing date binning options."); }

  // find time step, then bin
  var units = opt.utc ? time.utc : time,
      dmin = opt.min,
      dmax = opt.max,
      maxb = opt.maxbins || 20,
      minb = opt.minbins || 4,
      span = (+dmax) - (+dmin),
      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),
      spec = bins({
        min:     unit.min != null ? unit.min : unit.unit(dmin),
        max:     unit.max != null ? unit.max : unit.unit(dmax),
        maxbins: maxb,
        minstep: unit.minstep,
        steps:   unit.step
      });

  spec.unit = unit;
  spec.index = date_index;
  if (!opt.raw) spec.value = date_value;
  return spec;
};

module.exports = bins;

},{"../time":31,"../util":32}],15:[function(require,module,exports){
var bins = require('./bins'),
    gen  = require('../generate'),
    type = require('../import/type'),
    util = require('../util'),
    stats = require('../stats');

var qtype = {
  'integer': 1,
  'number': 1,
  'date': 1
};

function $bin(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return !b ? (opt.accessor || util.identity) :
    util.$func('bin', b.unit.unit ?
      function(x) { return b.value(b.unit.unit(x)); } :
      function(x) { return b.value(x); }
    )(opt.accessor);
}

function histogram(values, f, opt) {
  opt = options(values, f, opt);
  var b = spec(opt);
  return b ?
    numerical(values, opt.accessor, b) :
    categorical(values, opt.accessor, opt && opt.sort);
}

function spec(opt) {
  var t = opt.type, b = null;
  if (t == null || qtype[t]) {
    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;
    b = (t === 'date') ? bins.date(opt) : bins(opt);
  }
  return b;
}

function options() {
  var a = arguments,
      i = 0,
      values = util.isArray(a[i]) ? a[i++] : null,
      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,
      opt = util.extend({}, a[i]);

  if (values) {
    opt.type = opt.type || type(values, f);
    if (qtype[opt.type]) {
      var ext = stats.extent(values, f);
      opt = util.extend({min: ext[0], max: ext[1]}, opt);
    }
  }
  if (f) { opt.accessor = f; }
  return opt;
}

function numerical(values, f, b) {
  var h = gen.range(b.start, b.stop + b.step/2, b.step)
    .map(function(v) { return {value: b.value(v), count: 0}; });

  for (var i=0, v, j; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      j = b.index(v);
      if (j < 0 || j >= h.length || !isFinite(j)) continue;
      h[j].count += 1;
    }
  }
  h.bins = b;
  return h;
}

function categorical(values, f, sort) {
  var u = stats.unique(values, f),
      c = stats.count.map(values, f);
  return u.map(function(k) { return {value: k, count: c[k]}; })
    .sort(util.comparator(sort ? '-count' : '+value'));
}

module.exports = {
  $bin: $bin,
  histogram: histogram
};

},{"../generate":18,"../import/type":27,"../stats":29,"../util":32,"./bins":14}],16:[function(require,module,exports){
var util = require('./util'),
    type = require('./import/type'),
    stats = require('./stats'),
    template = require('./template');

module.exports = {
  table:   formatTable,  // format a data table
  summary: formatSummary // format a data table summary
};

var FMT = {
  'date':    '|time:"%m/%d/%Y %H:%M:%S"',
  'number':  '|number:".4f"',
  'integer': '|number:"d"'
};

var POS = {
  'number':  'left',
  'integer': 'left'
};

function formatTable(data, opt) {
  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);
  var fields = opt.fields || util.keys(data[0]),
      types = type.all(data);

  if (opt.start || opt.limit) {
    var a = opt.start || 0,
        b = opt.limit ? a + opt.limit : data.length;
    data = data.slice(a, b);
  }

  // determine char width of fields
  var lens = fields.map(function(name) {
    var format = FMT[types[name]] || '',
        t = template('{{' + name + format + '}}'),
        l = stats.max(data, function(x) { return t(x).length; });
    l = Math.max(Math.min(name.length, opt.minwidth), l);
    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;
  });

  // print header row
  var head = fields.map(function(name, i) {
    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);
  }).join(opt.separator);

  // build template function for each row
  var tmpl = template(fields.map(function(name, i) {
    return '{{' +
      name +
      (FMT[types[name]] || '') +
      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +
      ('|truncate:' + lens[i]) +
    '}}';
  }).join(opt.separator));

  // print table
  return head + "\n" + data.map(tmpl).join('\n');
}

function formatSummary(s) {
  s = s ? s.__summary__ ? s : stats.summary(s) : this;
  var str = [], i, n;
  for (i=0, n=s.length; i<n; ++i) {
    str.push('-- ' + s[i].field + ' --');
    if (s[i].type === 'string' || s[i].distinct < 10) {
      str.push(printCategoricalProfile(s[i]));
    } else {
      str.push(printQuantitativeProfile(s[i]));
    }
    str.push('');
  }
  return str.join('\n');
}

function printQuantitativeProfile(p) {
  return [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'min:      ' + p.min,
    'max:      ' + p.max,
    'median:   ' + p.median,
    'mean:     ' + p.mean,
    'stdev:    ' + p.stdev,
    'modeskew: ' + p.modeskew
  ].join('\n');
}

function printCategoricalProfile(p) {
  var list = [
    'valid:    ' + p.valid,
    'missing:  ' + p.missing,
    'distinct: ' + p.distinct,
    'top values: '
  ];
  var u = p.unique;
  var top = util.keys(u)
    .sort(function(a,b) { return u[b] - u[a]; })
    .slice(0, 6)
    .map(function(v) { return ' \'' + v + '\' (' + u[v] + ')'; });
  return list.concat(top).join('\n');
}
},{"./import/type":27,"./stats":29,"./template":30,"./util":32}],17:[function(require,module,exports){
var util = require('./util'),
    d3_time = require('d3-time'),
    d3_timeF = require('d3-time-format'),
    d3_numberF = require('d3-format'),
    numberF = d3_numberF, // defaults to EN-US
    timeF = d3_timeF,     // defaults to EN-US
    tmpDate = new Date(2000, 0, 1),
    monthFull, monthAbbr, dayFull, dayAbbr;


module.exports = {
  // Update number formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-format
  numberLocale: numberLocale,
  number:       function(f) { return numberF.format(f); },
  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },

  // Update time formatter to use provided locale configuration.
  // For more see https://github.com/d3/d3-time-format
  timeLocale:   timeLocale,
  time:         function(f) { return timeF.format(f); },
  utc:          function(f) { return timeF.utcFormat(f); },

  // Set number and time locale simultaneously.
  locale:       function(l) { numberLocale(l); timeLocale(l); },

  // automatic formatting functions
  auto: {
    number:   autoNumberFormat,
    linear:   linearNumberFormat,
    time:     function() { return timeAutoFormat(); },
    utc:      function() { return utcAutoFormat(); }
  },

  month:      monthFormat,      // format month name from integer code
  day:        dayFormat,        // format week day name from integer code
  quarter:    quarterFormat,    // format quarter name from timestamp
  utcQuarter: utcQuarterFormat  // format quarter name from utc timestamp
};

// -- Locales ----

// transform 'en-US' style locale string to match d3-format v0.4+ convention
function localeRef(l) {
  return l.length > 4 && 'locale' + (
    l[0].toUpperCase() + l[1].toLowerCase() +
    l[3].toUpperCase() + l[4].toLowerCase()
  );
}

function numberLocale(l) {
  var f = util.isString(l) ? d3_numberF[localeRef(l)] : d3_numberF.locale(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  numberF = f;
}

function timeLocale(l) {
  var f = util.isString(l) ? d3_timeF[localeRef(l)] : d3_timeF.locale(l);
  if (f == null) throw Error('Unrecognized locale: ' + l);
  timeF = f;
  monthFull = monthAbbr = dayFull = dayAbbr = null;
}

// -- Number Formatting ----

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function linearRange(domain, count) {
  if (!domain.length) domain = [0];
  if (count == null) count = 10;

  var start = domain[0],
      stop = domain[domain.length - 1];

  if (stop < start) { error = stop; stop = start; start = error; }

  var span = (stop - start) || (count = 1, start || stop || 1),
      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),
      error = span / count / step;

  // Filter ticks to get closer to the desired count.
  if (error >= e10) step *= 10;
  else if (error >= e5) step *= 5;
  else if (error >= e2) step *= 2;

  // Round start and stop values to step interval.
  return [
    Math.ceil(start / step) * step,
    Math.floor(stop / step) * step + step / 2, // inclusive
    step
  ];
}

function trimZero(f, decimal) {
  return function(x) {
    var s = f(x),
        n = s.indexOf(decimal);
    if (n < 0) return s;

    var idx = rightmostDigit(s, n),
        end = idx < s.length ? s.slice(idx) : '';

    while (--idx > n) {
      if (s[idx] !== '0') { ++idx; break; }
    }
    return s.slice(0, idx) + end;
  };
}

function rightmostDigit(s, n) {
  var i = s.lastIndexOf('e'), c;
  if (i > 0) return i;
  for (i=s.length; --i > n;) {
    c = s.charCodeAt(i);
    if (c >= 48 && c <= 57) return i+1; // is digit
  }
}

function autoNumberFormat(f) {
  var decimal = numberF.format('.1f')(1)[1]; // get decimal char
  if (f == null) f = ',';
  f = d3_numberF.formatSpecifier(f);
  if (f.precision == null) f.precision = 12;
  switch (f.type) {
    case '%': f.precision -= 2; break;
    case 'e': f.precision -= 1; break;
  }
  return trimZero(numberF.format(f), decimal);
}

function linearNumberFormat(domain, count, f) {
  var range = linearRange(domain, count);

  if (f == null) f = ',f';

  switch (f = d3_numberF.formatSpecifier(f), f.type) {
    case 's': {
      var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));
      if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);
      return numberF.formatPrefix(f, value);
    }
    case '':
    case 'e':
    case 'g':
    case 'p':
    case 'r': {
      if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');
      break;
    }
    case 'f':
    case '%': {
      if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - 2 * (f.type === '%');
      break;
    }
  }
  return numberF.format(f);
}

// -- Datetime Formatting ----

function timeAutoFormat() {
  var f = timeF.format,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.second(date) < d ? formatMillisecond
        : d3_time.minute(date) < d ? formatSecond
        : d3_time.hour(date) < d ? formatMinute
        : d3_time.day(date) < d ? formatHour
        : d3_time.month(date) < d ?
          (d3_time.week(date) < d ? formatDay : formatWeek)
        : d3_time.year(date) < d ? formatMonth
        : formatYear)(date);
  };
}

function utcAutoFormat() {
  var f = timeF.utcFormat,
      formatMillisecond = f('.%L'),
      formatSecond = f(':%S'),
      formatMinute = f('%I:%M'),
      formatHour = f('%I %p'),
      formatDay = f('%a %d'),
      formatWeek = f('%b %d'),
      formatMonth = f('%B'),
      formatYear = f('%Y');

  return function(date) {
    var d = +date;
    return (d3_time.utcSecond(date) < d ? formatMillisecond
        : d3_time.utcMinute(date) < d ? formatSecond
        : d3_time.utcHour(date) < d ? formatMinute
        : d3_time.utcDay(date) < d ? formatHour
        : d3_time.utcMonth(date) < d ?
          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)
        : d3_time.utcYear(date) < d ? formatMonth
        : formatYear)(date);
  };
}

function monthFormat(month, abbreviate) {
  var f = abbreviate ?
    (monthAbbr || (monthAbbr = timeF.format('%b'))) :
    (monthFull || (monthFull = timeF.format('%B')));
  return (tmpDate.setMonth(month), f(tmpDate));
}

function dayFormat(day, abbreviate) {
  var f = abbreviate ?
    (dayAbbr || (dayAbbr = timeF.format('%a'))) :
    (dayFull || (dayFull = timeF.format('%A')));
  return (tmpDate.setMonth(0), tmpDate.setDate(2 + day), f(tmpDate));
}

function quarterFormat(date) {
  return Math.floor(date.getMonth() / 3) + 1;
}

function utcQuarterFormat(date) {
  return Math.floor(date.getUTCMonth() / 3) + 1;
}

},{"./util":32,"d3-format":5,"d3-time":7,"d3-time-format":6}],18:[function(require,module,exports){
var util = require('./util'),
    gen = module.exports;

gen.repeat = function(val, n) {
  var a = Array(n), i;
  for (i=0; i<n; ++i) a[i] = val;
  return a;
};

gen.zeros = function(n) {
  return gen.repeat(0, n);
};

gen.range = function(start, stop, step) {
  if (arguments.length < 3) {
    step = 1;
    if (arguments.length < 2) {
      stop = start;
      start = 0;
    }
  }
  if ((stop - start) / step == Infinity) throw new Error('Infinite range');
  var range = [], i = -1, j;
  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);
  else while ((j = start + step * ++i) < stop) range.push(j);
  return range;
};

gen.random = {};

gen.random.uniform = function(min, max) {
  if (max === undefined) {
    max = min === undefined ? 1 : min;
    min = 0;
  }
  var d = max - min;
  var f = function() {
    return min + d * Math.random();
  };
  f.samples = function(n) {
    return gen.zeros(n).map(f);
  };
  f.pdf = function(x) {
    return (x >= min && x <= max) ? 1/d : 0;
  };
  f.cdf = function(x) {
    return x < min ? 0 : x > max ? 1 : (x - min) / d;
  };
  f.icdf = function(p) {
    return (p >= 0 && p <= 1) ? min + p*d : NaN;
  };
  return f;
};

gen.random.integer = function(a, b) {
  if (b === undefined) {
    b = a;
    a = 0;
  }
  var d = b - a;
  var f = function() {
    return a + Math.floor(d * Math.random());
  };
  f.samples = function(n) {
    return gen.zeros(n).map(f);
  };
  f.pdf = function(x) {
    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;
  };
  f.cdf = function(x) {
    var v = Math.floor(x);
    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
  };
  f.icdf = function(p) {
    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;
  };
  return f;
};

gen.random.normal = function(mean, stdev) {
  mean = mean || 0;
  stdev = stdev || 1;
  var next;
  var f = function() {
    var x = 0, y = 0, rds, c;
    if (next !== undefined) {
      x = next;
      next = undefined;
      return x;
    }
    do {
      x = Math.random()*2-1;
      y = Math.random()*2-1;
      rds = x*x + y*y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform
    next = mean + y*c*stdev;
    return mean + x*c*stdev;
  };
  f.samples = function(n) {
    return gen.zeros(n).map(f);
  };
  f.pdf = function(x) {
    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));
    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;
  };
  f.cdf = function(x) {
    // Approximation from West (2009)
    // Better Approximations to Cumulative Normal Functions
    var cd,
        z = (x - mean) / stdev,
        Z = Math.abs(z);
    if (Z > 37) {
      cd = 0;
    } else {
      var sum, exp = Math.exp(-Z*Z/2);
      if (Z < 7.07106781186547) {
        sum = 3.52624965998911e-02 * Z + 0.700383064443688;
        sum = sum * Z + 6.37396220353165;
        sum = sum * Z + 33.912866078383;
        sum = sum * Z + 112.079291497871;
        sum = sum * Z + 221.213596169931;
        sum = sum * Z + 220.206867912376;
        cd = exp * sum;
        sum = 8.83883476483184e-02 * Z + 1.75566716318264;
        sum = sum * Z + 16.064177579207;
        sum = sum * Z + 86.7807322029461;
        sum = sum * Z + 296.564248779674;
        sum = sum * Z + 637.333633378831;
        sum = sum * Z + 793.826512519948;
        sum = sum * Z + 440.413735824752;
        cd = cd / sum;
      } else {
        sum = Z + 0.65;
        sum = Z + 4 / sum;
        sum = Z + 3 / sum;
        sum = Z + 2 / sum;
        sum = Z + 1 / sum;
        cd = exp / sum / 2.506628274631;
      }
    }
    return z > 0 ? 1 - cd : cd;
  };
  f.icdf = function(p) {
    // Approximation of Probit function using inverse error function.
    if (p <= 0 || p >= 1) return NaN;
    var x = 2*p - 1,
        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),
        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),
        b = Math.log(1 - (x*x)) / v,
        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);
    return mean + stdev * Math.SQRT2 * s;
  };
  return f;
};

gen.random.bootstrap = function(domain, smooth) {
  // Generates a bootstrap sample from a set of observations.
  // Smooth bootstrapping adds random zero-centered noise to the samples.
  var val = domain.filter(util.isValid),
      len = val.length,
      err = smooth ? gen.random.normal(0, smooth) : null;
  var f = function() {
    return val[~~(Math.random()*len)] + (err ? err() : 0);
  };
  f.samples = function(n) {
    return gen.zeros(n).map(f);
  };
  return f;
};
},{"./util":32}],19:[function(require,module,exports){
var util = require('../../util');
var d3_dsv = require('d3-dsv');

function dsv(data, format) {
  if (data) {
    var h = format.header;
    data = (h ? h.join(format.delimiter) + '\n' : '') + data;
  }
  return d3_dsv.dsv(format.delimiter).parse(data);
}

dsv.delimiter = function(delim) {
  var fmt = {delimiter: delim};
  return function(data, format) {
    return dsv(data, format ? util.extend(format, fmt) : fmt);
  };
};

module.exports = dsv;

},{"../../util":32,"d3-dsv":4}],20:[function(require,module,exports){
var dsv = require('./dsv');

module.exports = {
  json: require('./json'),
  topojson: require('./topojson'),
  treejson: require('./treejson'),
  dsv: dsv,
  csv: dsv.delimiter(','),
  tsv: dsv.delimiter('\t')
};

},{"./dsv":19,"./json":21,"./topojson":22,"./treejson":23}],21:[function(require,module,exports){
var util = require('../../util');

module.exports = function(data, format) {
  var d = util.isObject(data) && !util.isBuffer(data) ?
    data : JSON.parse(data);
  if (format && format.property) {
    d = util.accessor(format.property)(d);
  }
  return d;
};

},{"../../util":32}],22:[function(require,module,exports){
var json = require('./json');

var reader = function(data, format) {
  var topojson = reader.topojson;
  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }

  var t = json(data, format), obj;

  if (format && format.feature) {
    if ((obj = t.objects[format.feature])) {
      return topojson.feature(t, obj).features;
    } else {
      throw Error('Invalid TopoJSON object: ' + format.feature);
    }
  } else if (format && format.mesh) {
    if ((obj = t.objects[format.mesh])) {
      return [topojson.mesh(t, t.objects[format.mesh])];
    } else {
      throw Error('Invalid TopoJSON object: ' + format.mesh);
    }
  } else {
    throw Error('Missing TopoJSON feature or mesh parameter.');
  }
};

reader.topojson = require('topojson');
module.exports = reader;

},{"./json":21,"topojson":37}],23:[function(require,module,exports){
var json = require('./json');

module.exports = function(tree, format) {
  return toTable(json(tree, format), format);
};

function toTable(root, fields) {
  var childrenField = fields && fields.children || 'children',
      parentField = fields && fields.parent || 'parent',
      table = [];

  function visit(node, parent) {
    node[parentField] = parent;
    table.push(node);
    var children = node[childrenField];
    if (children) {
      for (var i=0; i<children.length; ++i) {
        visit(children[i], node);
      }
    }
  }

  visit(root, null);
  return (table.root = root, table);
}

},{"./json":21}],24:[function(require,module,exports){
var util = require('../util');

// Matches absolute URLs with optional protocol
//   https://...    file://...    //...
var protocol_re = /^([A-Za-z]+:)?\/\//;

// Special treatment in node.js for the file: protocol
var fileProtocol = 'file://';

// Validate and cleanup URL to ensure that it is allowed to be accessed
// Returns cleaned up URL, or false if access is not allowed
function sanitizeUrl(opt) {
  var url = opt.url;
  if (!url && opt.file) { return fileProtocol + opt.file; }

  // In case this is a relative url (has no host), prepend opt.baseURL
  if (opt.baseURL && !protocol_re.test(url)) {
    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {
      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    }
    url = opt.baseURL + url;
  }
  // relative protocol, starts with '//'
  if (!load.useXHR && startsWith(url, '//')) {
    url = (opt.defaultProtocol || 'http') + ':' + url;
  }
  // If opt.domainWhiteList is set, only allows url, whose hostname
  // * Is the same as the origin (window.location.hostname)
  // * Equals one of the values in the whitelist
  // * Is a proper subdomain of one of the values in the whitelist
  if (opt.domainWhiteList) {
    var domain, origin;
    if (load.useXHR) {
      var a = document.createElement('a');
      a.href = url;
      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
      // IE doesn't populate all link properties when setting .href with a relative URL,
      // however .href will return an absolute URL which then can be used on itself
      // to populate these additional fields.
      if (a.host === '') {
        a.href = a.href;
      }
      domain = a.hostname.toLowerCase();
      origin = window.location.hostname;
    } else {
      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5
      var parts = require('url').parse(url);
      domain = parts.hostname;
      origin = null;
    }

    if (origin !== domain) {
      var whiteListed = opt.domainWhiteList.some(function(d) {
        var idx = domain.length - d.length;
        return d === domain ||
          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);
      });
      if (!whiteListed) {
        throw 'URL is not whitelisted: ' + url;
      }
    }
  }
  return url;
}

function load(opt, callback) {
  return load.loader(opt, callback);
}

function loader(opt, callback) {
  var error = callback || function(e) { throw e; }, url;

  try {
    url = load.sanitizeUrl(opt); // enable override
  } catch (err) {
    error(err);
    return;
  }

  if (!url) {
    error('Invalid URL: ' + opt.url);
  } else if (load.useXHR) {
    // on client, use xhr
    return load.xhr(url, opt, callback);
  } else if (startsWith(url, fileProtocol)) {
    // on server, if url starts with 'file://', strip it and load from file
    return load.file(url.slice(fileProtocol.length), opt, callback);
  } else if (url.indexOf('://') < 0) { // TODO better protocol check?
    // on server, if no protocol assume file
    return load.file(url, opt, callback);
  } else {
    // for regular URLs on server
    return load.http(url, opt, callback);
  }
}

function xhrHasResponse(request) {
  var type = request.responseType;
  return type && type !== 'text' ?
    request.response : // null on error
    request.responseText; // '' on error
}

function xhr(url, opt, callback) {
  var async = !!callback;
  var request = new XMLHttpRequest();
  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)
  if (typeof XDomainRequest !== 'undefined' &&
      !('withCredentials' in request) &&
      /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();

  function respond() {
    var status = request.status;
    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
      callback(null, request.responseText);
    } else {
      callback(request, null);
    }
  }

  if (async) {
    if ('onload' in request) {
      request.onload = request.onerror = respond;
    } else {
      request.onreadystatechange = function() {
        if (request.readyState > 3) respond();
      };
    }
  }

  request.open('GET', url, async);
  /* istanbul ignore else */
  if (request.setRequestHeader) {
    var headers = util.extend({}, load.headers, opt.headers);
    for (var name in headers) {
      request.setRequestHeader(name, headers[name]);
    }
  }
  request.send();

  if (!async && xhrHasResponse(request)) {
    return request.responseText;
  }
}

function file(filename, opt, callback) {
  var fs = require('fs');
  if (!callback) {
    return fs.readFileSync(filename, 'utf8');
  }
  fs.readFile(filename, callback);
}

function http(url, opt, callback) {
  var headers = util.extend({}, load.headers, opt.headers);

  var options = {url: url, encoding: null, gzip: true, headers: headers};
  if (!callback) {
    return require('sync-request')('GET', url, options).getBody();
  }
  require('request')(options, function(error, response, body) {
    if (!error && response.statusCode === 200) {
      callback(null, body);
    } else {
      error = error ||
        'Load failed with response code ' + response.statusCode + '.';
      callback(error, null);
    }
  });
}

function startsWith(string, searchString) {
  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;
}

// Allow these functions to be overriden by the user of the library
load.loader = loader;
load.sanitizeUrl = sanitizeUrl;
load.xhr = xhr;
load.file = file;
load.http = http;

// Default settings
load.useXHR = (typeof XMLHttpRequest !== 'undefined');
load.headers = {};

module.exports = load;

},{"../util":32,"fs":1,"request":1,"sync-request":1,"url":1}],25:[function(require,module,exports){
var util = require('../util'),
  type = require('./type'),
  formats = require('./formats'),
  timeF = require('../format').time;

function read(data, format) {
  var type = (format && format.type) || 'json';
  data = formats[type](data, format);
  if (format && format.parse) parse(data, format.parse);
  return data;
}

function parse(data, types) {
  var cols, parsers, d, i, j, clen, len = data.length;

  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);
  cols = util.keys(types);
  parsers = cols.map(function(c) {
    var t = types[c];
    if (t && t.indexOf('date:') === 0) {
      var parts = t.split(/:(.+)?/, 2),  // split on first :
          pattern = parts[1];
      if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
          (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
        pattern = pattern.slice(1, -1);
      } else {
        throw Error('Format pattern must be quoted: ' + pattern);
      }
      pattern = timeF(pattern);
      return function(v) { return pattern.parse(v); };
    }
    if (!type.parsers[t]) {
      throw Error('Illegal format pattern: ' + c + ':' + t);
    }
    return type.parsers[t];
  });

  for (i=0, clen=cols.length; i<len; ++i) {
    d = data[i];
    for (j=0; j<clen; ++j) {
      d[cols[j]] = parsers[j](d[cols[j]]);
    }
  }
  type.annotation(data, types);
}

read.formats = formats;
module.exports = read;

},{"../format":17,"../util":32,"./formats":20,"./type":27}],26:[function(require,module,exports){
var util = require('../util');
var load = require('./load');
var read = require('./read');

module.exports = util
  .keys(read.formats)
  .reduce(function(out, type) {
    out[type] = function(opt, format, callback) {
      // process arguments
      if (util.isString(opt)) { opt = {url: opt}; }
      if (arguments.length === 2 && util.isFunction(format)) {
        callback = format;
        format = undefined;
      }

      // set up read format
      format = util.extend({parse: 'auto'}, format);
      format.type = type;

      // load data
      var data = load(opt, callback ? function(error, data) {
        if (error) { callback(error, null); return; }
        try {
          // data loaded, now parse it (async)
          data = read(data, format);
          callback(null, data);
        } catch (e) {
          callback(e, null);
        }
      } : undefined);

      // data loaded, now parse it (sync)
      if (!callback) return read(data, format);
    };
    return out;
  }, {});

},{"../util":32,"./load":24,"./read":25}],27:[function(require,module,exports){
var util = require('../util');

var TYPES = '__types__';

var PARSERS = {
  boolean: util.boolean,
  integer: util.number,
  number:  util.number,
  date:    util.date,
  string:  function(x) { return x == null || x === '' ? null : x + ''; }
};

var TESTS = {
  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },
  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },
  number: function(x) { return !isNaN(+x) && !util.isDate(x); },
  date: function(x) { return !isNaN(Date.parse(x)); }
};

function annotation(data, types) {
  if (!types) return data && data[TYPES] || null;
  data[TYPES] = types;
}

function fieldNames(datum) {
  return util.keys(datum);
}

function bracket(fieldName) {
  return '[' + fieldName + ']';
}

function type(values, f) {
  values = util.array(values);
  f = util.$(f);
  var v, i, n;

  // if data array has type annotations, use them
  if (values[TYPES]) {
    v = f(values[TYPES]);
    if (util.isString(v)) return v;
  }

  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {
    v = f ? f(values[i]) : values[i];
  }

  return util.isDate(v) ? 'date' :
    util.isNumber(v)    ? 'number' :
    util.isBoolean(v)   ? 'boolean' :
    util.isString(v)    ? 'string' : null;
}

function typeAll(data, fields) {
  if (!data.length) return;
  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);
  return fields.reduce(function(types, f) {
    return (types[f] = type(data, get(f)), types);
  }, {});
}

function infer(values, f) {
  values = util.array(values);
  f = util.$(f);
  var i, j, v;

  // types to test for, in precedence order
  var types = ['boolean', 'integer', 'number', 'date'];

  for (i=0; i<values.length; ++i) {
    // get next value to test
    v = f ? f(values[i]) : values[i];
    // test value against remaining types
    for (j=0; j<types.length; ++j) {
      if (util.isValid(v) && !TESTS[types[j]](v)) {
        types.splice(j, 1);
        j -= 1;
      }
    }
    // if no types left, return 'string'
    if (types.length === 0) return 'string';
  }

  return types[0];
}

function inferAll(data, fields) {
  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);
  return fields.reduce(function(types, f) {
    types[f] = infer(data, get(f));
    return types;
  }, {});
}

type.annotation = annotation;
type.all = typeAll;
type.infer = infer;
type.inferAll = inferAll;
type.parsers = PARSERS;
module.exports = type;

},{"../util":32}],28:[function(require,module,exports){
var util = require('./util');

var dl = {
  version:    require('../package.json').version,
  load:       require('./import/load'),
  read:       require('./import/read'),
  type:       require('./import/type'),
  Aggregator: require('./aggregate/aggregator'),
  groupby:    require('./aggregate/groupby'),
  bins:       require('./bins/bins'),
  $bin:       require('./bins/histogram').$bin,
  histogram:  require('./bins/histogram').histogram,
  format:     require('./format'),
  template:   require('./template'),
  time:       require('./time')
};

util.extend(dl, util);
util.extend(dl, require('./accessor'));
util.extend(dl, require('./generate'));
util.extend(dl, require('./stats'));
util.extend(dl, require('./import/readers'));
util.extend(dl.format, require('./format-tables'));

// backwards-compatible, deprecated API
// will remove in the future
dl.print = {
  table:   dl.format.table,
  summary: dl.format.summary
};

module.exports = dl;

},{"../package.json":8,"./accessor":9,"./aggregate/aggregator":10,"./aggregate/groupby":12,"./bins/bins":14,"./bins/histogram":15,"./format":17,"./format-tables":16,"./generate":18,"./import/load":24,"./import/read":25,"./import/readers":26,"./import/type":27,"./stats":29,"./template":30,"./time":31,"./util":32}],29:[function(require,module,exports){
var util = require('./util');
var type = require('./import/type');
var gen = require('./generate');

var stats = module.exports;

// Collect unique values.
// Output: an array of unique values, in first-observed order
stats.unique = function(values, f, results) {
  f = util.$(f);
  results = results || [];
  var u = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    results.push(v);
  }
  return results;
};

// Return the length of the input array.
stats.count = function(values) {
  return values && values.length || 0;
};

// Count the number of non-null, non-undefined, non-NaN values.
stats.count.valid = function(values, f) {
  f = util.$(f);
  var v, i, n, valid = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) valid += 1;
  }
  return valid;
};

// Count the number of null or undefined values.
stats.count.missing = function(values, f) {
  f = util.$(f);
  var v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v == null) count += 1;
  }
  return count;
};

// Count the number of distinct values.
// Null, undefined and NaN are each considered distinct values.
stats.count.distinct = function(values, f) {
  f = util.$(f);
  var u = {}, v, i, n, count = 0;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (v in u) continue;
    u[v] = 1;
    count += 1;
  }
  return count;
};

// Construct a map from distinct values to occurrence counts.
stats.count.map = function(values, f) {
  f = util.$(f);
  var map = {}, v, i, n;
  for (i=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    map[v] = (v in map) ? map[v] + 1 : 1;
  }
  return map;
};

// Compute the median of an array of numbers.
stats.median = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  return stats.quantile(values, 0.5);
};

// Computes the quartile boundaries of an array of numbers.
stats.quartile = function(values, f) {
  if (f) values = values.map(util.$(f));
  values = values.filter(util.isValid).sort(util.cmp);
  var q = stats.quantile;
  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];
};

// Compute the quantile of a sorted array of numbers.
// Adapted from the D3.js implementation.
stats.quantile = function(values, f, p) {
  if (p === undefined) { p = f; f = util.identity; }
  f = util.$(f);
  var H = (values.length - 1) * p + 1,
      h = Math.floor(H),
      v = +f(values[h - 1]),
      e = H - h;
  return e ? v + e * (f(values[h]) - v) : v;
};

// Compute the sum of an array of numbers.
stats.sum = function(values, f) {
  f = util.$(f);
  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) sum += v;
  }
  return sum;
};

// Compute the mean (average) of an array of numbers.
stats.mean = function(values, f) {
  f = util.$(f);
  var mean = 0, delta, i, n, c, v;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
    }
  }
  return mean;
};

// Compute the geometric mean of an array of numbers.
stats.mean.geometric = function(values, f) {
  f = util.$(f);
  var mean = 1, c, n, v, i;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v <= 0) {
        throw Error("Geometric mean only defined for positive values.");
      }
      mean *= v;
      ++c;
    }
  }
  mean = c > 0 ? Math.pow(mean, 1/c) : 0;
  return mean;
};

// Compute the harmonic mean of an array of numbers.
stats.mean.harmonic = function(values, f) {
  f = util.$(f);
  var mean = 0, c, n, v, i;
  for (i=0, c=0, n=values.length; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      mean += 1/v;
      ++c;
    }
  }
  return c / mean;
};

// Compute the sample variance of an array of numbers.
stats.variance = function(values, f) {
  f = util.$(f);
  if (!util.isArray(values) || values.length < 2) return 0;
  var mean = 0, M2 = 0, delta, i, c, v;
  for (i=0, c=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      delta = v - mean;
      mean = mean + delta / (++c);
      M2 = M2 + delta * (v - mean);
    }
  }
  M2 = M2 / (c - 1);
  return M2;
};

// Compute the sample standard deviation of an array of numbers.
stats.stdev = function(values, f) {
  return Math.sqrt(stats.variance(values, f));
};

// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.
stats.modeskew = function(values, f) {
  var avg = stats.mean(values, f),
      med = stats.median(values, f),
      std = stats.stdev(values, f);
  return std === 0 ? 0 : (avg - med) / std;
};

// Find the minimum value in an array.
stats.min = function(values, f) {
  return stats.extent(values, f)[0];
};

// Find the maximum value in an array.
stats.max = function(values, f) {
  return stats.extent(values, f)[1];
};

// Find the minimum and maximum of an array of values.
stats.extent = function(values, f) {
  f = util.$(f);
  var a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) a = v;
      if (v > b) b = v;
    }
  }
  return [a, b];
};

// Find the integer indices of the minimum and maximum values.
stats.extent.index = function(values, f) {
  f = util.$(f);
  var x = -1, y = -1, a, b, v, i, n = values.length;
  for (i=0; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) { a = b = v; x = y = i; break; }
  }
  for (; i<n; ++i) {
    v = f ? f(values[i]) : values[i];
    if (util.isValid(v)) {
      if (v < a) { a = v; x = i; }
      if (v > b) { b = v; y = i; }
    }
  }
  return [x, y];
};

// Compute the dot product of two arrays of numbers.
stats.dot = function(values, a, b) {
  var sum = 0, i, v;
  if (!b) {
    if (values.length !== a.length) {
      throw Error('Array lengths must match.');
    }
    for (i=0; i<values.length; ++i) {
      v = values[i] * a[i];
      if (v === v) sum += v;
    }
  } else {
    a = util.$(a);
    b = util.$(b);
    for (i=0; i<values.length; ++i) {
      v = a(values[i]) * b(values[i]);
      if (v === v) sum += v;
    }
  }
  return sum;
};

// Compute the vector distance between two arrays of numbers.
// Default is Euclidean (exp=2) distance, configurable via exp argument.
stats.dist = function(values, a, b, exp) {
  var f = util.isFunction(b) || util.isString(b),
      X = values,
      Y = f ? values : a,
      e = f ? exp : b,
      L2 = e === 2 || e == null,
      n = values.length, s = 0, d, i;
  if (f) {
    a = util.$(a);
    b = util.$(b);
  }
  for (i=0; i<n; ++i) {
    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);
    s += L2 ? d*d : Math.pow(Math.abs(d), e);
  }
  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);
};

// Compute the Cohen's d effect size between two arrays of numbers.
stats.cohensd = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a,
      x1 = stats.mean(X),
      x2 = stats.mean(Y),
      n1 = stats.count.valid(X),
      n2 = stats.count.valid(Y);

  if ((n1+n2-2) <= 0) {
    // if both arrays are size 1, or one is empty, there's no effect size
    return 0;
  }
  // pool standard deviation
  var s1 = stats.variance(X),
      s2 = stats.variance(Y),
      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));
  // if there is no variance, there's no effect size
  return s===0 ? 0 : (x1 - x2) / s;
};

// Computes the covariance between two arrays of numbers
stats.covariance = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a,
      n = X.length,
      xm = stats.mean(X),
      ym = stats.mean(Y),
      sum = 0, c = 0, i, x, y, vx, vy;

  if (n !== Y.length) {
    throw Error('Input lengths must match.');
  }

  for (i=0; i<n; ++i) {
    x = X[i]; vx = util.isValid(x);
    y = Y[i]; vy = util.isValid(y);
    if (vx && vy) {
      sum += (x-xm) * (y-ym);
      ++c;
    } else if (vx || vy) {
      throw Error('Valid values must align.');
    }
  }
  return sum / (c-1);
};

// Compute ascending rank scores for an array of values.
// Ties are assigned their collective mean rank.
stats.rank = function(values, f) {
  f = util.$(f) || util.identity;
  var a = values.map(function(v, i) {
      return {idx: i, val: f(v)};
    })
    .sort(util.comparator('val'));

  var n = values.length,
      r = Array(n),
      tie = -1, p = {}, i, v, mu;

  for (i=0; i<n; ++i) {
    v = a[i].val;
    if (tie < 0 && p === v) {
      tie = i - 1;
    } else if (tie > -1 && p !== v) {
      mu = 1 + (i-1 + tie) / 2;
      for (; tie<i; ++tie) r[a[tie].idx] = mu;
      tie = -1;
    }
    r[a[i].idx] = i + 1;
    p = v;
  }

  if (tie > -1) {
    mu = 1 + (n-1 + tie) / 2;
    for (; tie<n; ++tie) r[a[tie].idx] = mu;
  }

  return r;
};

// Compute the sample Pearson product-moment correlation of two arrays of numbers.
stats.cor = function(values, a, b) {
  var fn = b;
  b = fn ? values.map(util.$(b)) : a;
  a = fn ? values.map(util.$(a)) : values;

  var dot = stats.dot(a, b),
      mua = stats.mean(a),
      mub = stats.mean(b),
      sda = stats.stdev(a),
      sdb = stats.stdev(b),
      n = values.length;

  return (dot - n*mua*mub) / ((n-1) * sda * sdb);
};

// Compute the Spearman rank correlation of two arrays of values.
stats.cor.rank = function(values, a, b) {
  var ra = b ? stats.rank(values, a) : stats.rank(values),
      rb = b ? stats.rank(values, b) : stats.rank(a),
      n = values.length, i, s, d;

  for (i=0, s=0; i<n; ++i) {
    d = ra[i] - rb[i];
    s += d * d;
  }

  return 1 - 6*s / (n * (n*n-1));
};

// Compute the distance correlation of two arrays of numbers.
// http://en.wikipedia.org/wiki/Distance_correlation
stats.cor.dist = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a;

  var A = stats.dist.mat(X),
      B = stats.dist.mat(Y),
      n = A.length,
      i, aa, bb, ab;

  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {
    aa += A[i]*A[i];
    bb += B[i]*B[i];
    ab += A[i]*B[i];
  }

  return Math.sqrt(ab / Math.sqrt(aa*bb));
};

// Simple linear regression.
// Returns a "fit" object with slope (m), intercept (b),
// r value (R), and sum-squared residual error (rss).
stats.linearRegression = function(values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a,
      n = X.length,
      xy = stats.covariance(X, Y), // will throw err if valid vals don't align
      sx = stats.stdev(X),
      sy = stats.stdev(Y),
      slope = xy / (sx*sx),
      icept = stats.mean(Y) - slope * stats.mean(X),
      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},
      res, i;

  for (i=0; i<n; ++i) {
    if (util.isValid(X[i]) && util.isValid(Y[i])) {
      res = (slope*X[i] + icept) - Y[i];
      fit.rss += res * res;
    }
  }

  return fit;
};

// Namespace for bootstrap
stats.bootstrap = {};

// Construct a bootstrapped confidence interval at a given percentile level
// Arguments are an array, an optional n (defaults to 1000),
//  an optional alpha (defaults to 0.05), and an optional smoothing parameter
stats.bootstrap.ci = function(values, a, b, c, d) {
  var X, N, alpha, smooth, bs, means, i;
  if (util.isFunction(a) || util.isString(a)) {
    X = values.map(util.$(a));
    N = b;
    alpha = c;
    smooth = d;
  } else {
    X = values;
    N = a;
    alpha = b;
    smooth = c;
  }
  N = N ? +N : 1000;
  alpha = alpha || 0.05;

  bs = gen.random.bootstrap(X, smooth);
  for (i=0, means = Array(N); i<N; ++i) {
    means[i] = stats.mean(bs.samples(X.length));
  }
  means.sort(util.numcmp);
  return [
    stats.quantile(means, alpha/2),
    stats.quantile(means, 1-(alpha/2))
  ];
};

// Namespace for z-tests
stats.z = {};

// Construct a z-confidence interval at a given significance level
// Arguments are an array and an optional alpha (defaults to 0.05).
stats.z.ci = function(values, a, b) {
  var X = values, alpha = a;
  if (util.isFunction(a) || util.isString(a)) {
    X = values.map(util.$(a));
    alpha = b;
  }
  alpha = alpha || 0.05;

  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),
      mu = stats.mean(X),
      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));
  return [mu - (z*SE), mu + (z*SE)];
};

// Perform a z-test of means. Returns the p-value.
// If a single array is provided, performs a one-sample location test.
// If two arrays or a table and two accessors are provided, performs
// a two-sample location test. A paired test is performed if specified
// by the options hash.
// The options hash format is: {paired: boolean, nullh: number}.
// http://en.wikipedia.org/wiki/Z-test
// http://en.wikipedia.org/wiki/Paired_difference_test
stats.z.test = function(values, a, b, opt) {
  if (util.isFunction(b) || util.isString(b)) { // table and accessors
    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);
  } else if (util.isArray(a)) { // two arrays
    return (b && b.paired ? ztestP : ztest2)(b, values, a);
  } else if (util.isFunction(a) || util.isString(a)) {
    return ztest1(b, values, a); // table and accessor
  } else {
    return ztest1(a, values); // one array
  }
};

// Perform a z-test of means. Returns the p-value.
// Assuming we have a list of values, and a null hypothesis. If no null
// hypothesis, assume our null hypothesis is mu=0.
function ztest1(opt, X, f) {
  var nullH = opt && opt.nullh || 0,
      gaussian = gen.random.normal(0, 1),
      mu = stats.mean(X,f),
      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));

  if (SE===0) {
    // Test not well defined when standard error is 0.
    return (mu - nullH) === 0 ? 1 : 0;
  }
  // Two-sided, so twice the one-sided cdf.
  var z = (mu - nullH) / SE;
  return 2 * gaussian.cdf(-Math.abs(z));
}

// Perform a two sample paired z-test of means. Returns the p-value.
function ztestP(opt, values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a,
      n1 = stats.count(X),
      n2 = stats.count(Y),
      diffs = Array(), i;

  if (n1 !== n2) {
    throw Error('Array lengths must match.');
  }
  for (i=0; i<n1; ++i) {
    // Only valid differences should contribute to the test statistic
    if (util.isValid(X[i]) && util.isValid(Y[i])) {
      diffs.push(X[i] - Y[i]);
    }
  }
  return stats.z.test(diffs, opt && opt.nullh || 0);
}

// Perform a two sample z-test of means. Returns the p-value.
function ztest2(opt, values, a, b) {
  var X = b ? values.map(util.$(a)) : values,
      Y = b ? values.map(util.$(b)) : a,
      n1 = stats.count.valid(X),
      n2 = stats.count.valid(Y),
      gaussian = gen.random.normal(0, 1),
      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),
      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);

  if (SE===0) {
    // Not well defined when pooled standard error is 0.
    return meanDiff===0 ? 1 : 0;
  }
  // Two-tailed, so twice the one-sided cdf.
  var z = meanDiff / SE;
  return 2 * gaussian.cdf(-Math.abs(z));
}

// Construct a mean-centered distance matrix for an array of numbers.
stats.dist.mat = function(X) {
  var n = X.length,
      m = n*n,
      A = Array(m),
      R = gen.zeros(n),
      M = 0, v, i, j;

  for (i=0; i<n; ++i) {
    A[i*n+i] = 0;
    for (j=i+1; j<n; ++j) {
      A[i*n+j] = (v = Math.abs(X[i] - X[j]));
      A[j*n+i] = v;
      R[i] += v;
      R[j] += v;
    }
  }

  for (i=0; i<n; ++i) {
    M += R[i];
    R[i] /= n;
  }
  M /= m;

  for (i=0; i<n; ++i) {
    for (j=i; j<n; ++j) {
      A[i*n+j] += M - R[i] - R[j];
      A[j*n+i] = A[i*n+j];
    }
  }

  return A;
};

// Compute the Shannon entropy (log base 2) of an array of counts.
stats.entropy = function(counts, f) {
  f = util.$(f);
  var i, p, s = 0, H = 0, n = counts.length;
  for (i=0; i<n; ++i) {
    s += (f ? f(counts[i]) : counts[i]);
  }
  if (s === 0) return 0;
  for (i=0; i<n; ++i) {
    p = (f ? f(counts[i]) : counts[i]) / s;
    if (p) H += p * Math.log(p);
  }
  return -H / Math.LN2;
};

// Compute the mutual information between two discrete variables.
// Returns an array of the form [MI, MI_distance]
// MI_distance is defined as 1 - I(a,b) / H(a,b).
// http://en.wikipedia.org/wiki/Mutual_information
stats.mutual = function(values, a, b, counts) {
  var x = counts ? values.map(util.$(a)) : values,
      y = counts ? values.map(util.$(b)) : a,
      z = counts ? values.map(util.$(counts)) : b;

  var px = {},
      py = {},
      n = z.length,
      s = 0, I = 0, H = 0, p, t, i;

  for (i=0; i<n; ++i) {
    px[x[i]] = 0;
    py[y[i]] = 0;
  }

  for (i=0; i<n; ++i) {
    px[x[i]] += z[i];
    py[y[i]] += z[i];
    s += z[i];
  }

  t = 1 / (s * Math.LN2);
  for (i=0; i<n; ++i) {
    if (z[i] === 0) continue;
    p = (s * z[i]) / (px[x[i]] * py[y[i]]);
    I += z[i] * t * Math.log(p);
    H += z[i] * t * Math.log(z[i]/s);
  }

  return [I, 1 + I/H];
};

// Compute the mutual information between two discrete variables.
stats.mutual.info = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[0];
};

// Compute the mutual information distance between two discrete variables.
// MI_distance is defined as 1 - I(a,b) / H(a,b).
stats.mutual.dist = function(values, a, b, counts) {
  return stats.mutual(values, a, b, counts)[1];
};

// Compute a profile of summary statistics for a variable.
stats.profile = function(values, f) {
  var mean = 0,
      valid = 0,
      missing = 0,
      distinct = 0,
      min = null,
      max = null,
      M2 = 0,
      vals = [],
      u = {}, delta, sd, i, v, x;

  // compute summary stats
  for (i=0; i<values.length; ++i) {
    v = f ? f(values[i]) : values[i];

    // update unique values
    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);

    if (v == null) {
      ++missing;
    } else if (util.isValid(v)) {
      // update stats
      x = (typeof v === 'string') ? v.length : v;
      if (min===null || x < min) min = x;
      if (max===null || x > max) max = x;
      delta = x - mean;
      mean = mean + delta / (++valid);
      M2 = M2 + delta * (x - mean);
      vals.push(x);
    }
  }
  M2 = M2 / (valid - 1);
  sd = Math.sqrt(M2);

  // sort values for median and iqr
  vals.sort(util.cmp);

  return {
    type:     type(values, f),
    unique:   u,
    count:    values.length,
    valid:    valid,
    missing:  missing,
    distinct: distinct,
    min:      min,
    max:      max,
    mean:     mean,
    stdev:    sd,
    median:   (v = stats.quantile(vals, 0.5)),
    q1:       stats.quantile(vals, 0.25),
    q3:       stats.quantile(vals, 0.75),
    modeskew: sd === 0 ? 0 : (mean - v) / sd
  };
};

// Compute profiles for all variables in a data set.
stats.summary = function(data, fields) {
  fields = fields || util.keys(data[0]);
  var s = fields.map(function(f) {
    var p = stats.profile(data, util.$(f));
    return (p.field = f, p);
  });
  return (s.__summary__ = true, s);
};

},{"./generate":18,"./import/type":27,"./util":32}],30:[function(require,module,exports){
var util = require('./util'),
    format = require('./format');

var context = {
  formats:    [],
  format_map: {},
  truncate:   util.truncate,
  pad:        util.pad,
  day:        format.day,
  month:      format.month,
  quarter:    format.quarter,
  utcQuarter: format.utcQuarter
};

function template(text) {
  var src = source(text, 'd');
  src = 'var __t; return ' + src + ';';

  /* jshint evil: true */
  return (new Function('d', src)).bind(context);
}

template.source = source;
template.context = context;
template.format = get_format;
module.exports = template;

// Clear cache of format objects.
// This can *break* prior template functions, so invoke with care!
template.clearFormatCache = function() {
  context.formats = [];
  context.format_map = {};
};

// Generate property access code for use within template source.
// object: the name of the object (variable) containing template data
// property: the property access string, verbatim from template tag
template.property = function(object, property) {
  var src = util.field(property).map(util.str).join('][');
  return object + '[' + src + ']';
};

// Generate source code for a template function.
// text: the template text
// variable: the name of the data object variable ('obj' by default)
// properties: optional hash for collecting all accessed properties
function source(text, variable, properties) {
  variable = variable || 'obj';
  var index = 0;
  var src = '\'';
  var regex = template_re;

  // Compile the template source, escaping string literals appropriately.
  text.replace(regex, function(match, interpolate, offset) {
    src += text
      .slice(index, offset)
      .replace(template_escaper, template_escapeChar);
    index = offset + match.length;

    if (interpolate) {
      src += '\'\n+((__t=(' +
        template_var(interpolate, variable, properties) +
        '))==null?\'\':__t)+\n\'';
    }

    // Adobe VMs need the match returned to produce the correct offest.
    return match;
  });
  return src + '\'';
}

function template_var(text, variable, properties) {
  var filters = text.match(filter_re);
  var prop = filters.shift().trim();
  var stringCast = true;

  function strcall(fn) {
    fn = fn || '';
    if (stringCast) {
      stringCast = false;
      src = 'String(' + src + ')' + fn;
    } else {
      src += fn;
    }
    return src;
  }

  function date() {
    return '(typeof ' + src + '==="number"?new Date('+src+'):'+src+')';
  }

  function formatter(type) {
    var pattern = args[0];
    if ((pattern[0] === '\'' && pattern[pattern.length-1] === '\'') ||
        (pattern[0] === '"'  && pattern[pattern.length-1] === '"')) {
      pattern = pattern.slice(1, -1);
    } else {
      throw Error('Format pattern must be quoted: ' + pattern);
    }
    a = template_format(pattern, type);
    stringCast = false;
    var arg = type === 'number' ? src : date();
    src = 'this.formats['+a+']('+arg+')';
  }

  if (properties) properties[prop] = 1;
  var src = template.property(variable, prop);

  for (var i=0; i<filters.length; ++i) {
    var f = filters[i], args = null, pidx, a, b;

    if ((pidx=f.indexOf(':')) > 0) {
      f = f.slice(0, pidx);
      args = filters[i].slice(pidx+1)
        .match(args_re)
        .map(function(s) { return s.trim(); });
    }
    f = f.trim();

    switch (f) {
      case 'length':
        strcall('.length');
        break;
      case 'lower':
        strcall('.toLowerCase()');
        break;
      case 'upper':
        strcall('.toUpperCase()');
        break;
      case 'lower-locale':
        strcall('.toLocaleLowerCase()');
        break;
      case 'upper-locale':
        strcall('.toLocaleUpperCase()');
        break;
      case 'trim':
        strcall('.trim()');
        break;
      case 'left':
        a = util.number(args[0]);
        strcall('.slice(0,' + a + ')');
        break;
      case 'right':
        a = util.number(args[0]);
        strcall('.slice(-' + a +')');
        break;
      case 'mid':
        a = util.number(args[0]);
        b = a + util.number(args[1]);
        strcall('.slice(+'+a+','+b+')');
        break;
      case 'slice':
        a = util.number(args[0]);
        strcall('.slice('+ a +
          (args.length > 1 ? ',' + util.number(args[1]) : '') +
          ')');
        break;
      case 'truncate':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.truncate(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'pad':
        a = util.number(args[0]);
        b = args[1];
        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;
        src = 'this.pad(' + strcall() + ',' + a + ',\'' + b + '\')';
        break;
      case 'number':
        formatter('number');
        break;
      case 'time':
        formatter('time');
        break;
      case 'time-utc':
        formatter('utc');
        break;
      case 'month':
        src = 'this.month(' + src + ')';
        break;
      case 'month-abbrev':
        src = 'this.month(' + src + ',true)';
        break;
      case 'day':
        src = 'this.day(' + src + ')';
        break;
      case 'day-abbrev':
        src = 'this.day(' + src + ',true)';
        break;
      case 'quarter':
        src = 'this.quarter(' + src + ')';
        break;
      case 'quarter-utc':
        src = 'this.utcQuarter(' + src + ')';
        break;
      default:
        throw Error('Unrecognized template filter: ' + f);
    }
  }

  return src;
}

var template_re = /\{\{(.+?)\}\}|$/g,
    filter_re = /(?:"[^"]*"|\'[^\']*\'|[^\|"]+|[^\|\']+)+/g,
    args_re = /(?:"[^"]*"|\'[^\']*\'|[^,"]+|[^,\']+)+/g;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var template_escapes = {
  '\'':     '\'',
  '\\':     '\\',
  '\r':     'r',
  '\n':     'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var template_escaper = /\\|'|\r|\n|\u2028|\u2029/g;

function template_escapeChar(match) {
  return '\\' + template_escapes[match];
}

function template_format(pattern, type) {
  var key = type + ':' + pattern;
  if (context.format_map[key] == null) {
    var f = format[type](pattern);
    var i = context.formats.length;
    context.formats.push(f);
    context.format_map[key] = i;
    return i;
  }
  return context.format_map[key];
}

function get_format(pattern, type) {
  return context.formats[template_format(pattern, type)];
}

},{"./format":17,"./util":32}],31:[function(require,module,exports){
var d3_time = require('d3-time');

var tempDate = new Date(),
    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD
    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);

function date(d) {
  return (tempDate.setTime(+d), tempDate);
}

// create a time unit entry
function entry(type, date, unit, step, min, max) {
  var e = {
    type: type,
    date: date,
    unit: unit
  };
  if (step) {
    e.step = step;
  } else {
    e.minstep = 1;
  }
  if (min != null) e.min = min;
  if (max != null) e.max = max;
  return e;
}

function create(type, unit, base, step, min, max) {
  return entry(type,
    function(d) { return unit.offset(base, d); },
    function(d) { return unit.count(base, d); },
    step, min, max);
}

var locale = [
  create('second', d3_time.second, baseDate),
  create('minute', d3_time.minute, baseDate),
  create('hour',   d3_time.hour,   baseDate),
  create('day',    d3_time.day,    baseDate, [1, 7]),
  create('month',  d3_time.month,  baseDate, [1, 3, 6]),
  create('year',   d3_time.year,   baseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(1970, 0, 1, 0, 0, d); },
    function(d) { return date(d).getSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(1970, 0, 1, 0, d); },
    function(d) { return date(d).getMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(1970, 0, 1, d); },
    function(d) { return date(d).getHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(1970, 0, 4+d); },
    function(d) { return date(d).getDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(1970, 0, d); },
    function(d) { return date(d).getDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(1970, d % 12, 1); },
    function(d) { return date(d).getMonth(); },
    [1], 0, 11
  )
];

var utc = [
  create('second', d3_time.utcSecond, utcBaseDate),
  create('minute', d3_time.utcMinute, utcBaseDate),
  create('hour',   d3_time.utcHour,   utcBaseDate),
  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),
  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),
  create('year',   d3_time.utcYear,   utcBaseDate),

  // periodic units
  entry('seconds',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },
    function(d) { return date(d).getUTCSeconds(); },
    null, 0, 59
  ),
  entry('minutes',
    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },
    function(d) { return date(d).getUTCMinutes(); },
    null, 0, 59
  ),
  entry('hours',
    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },
    function(d) { return date(d).getUTCHours(); },
    null, 0, 23
  ),
  entry('weekdays',
    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },
    function(d) { return date(d).getUTCDay(); },
    [1], 0, 6
  ),
  entry('dates',
    function(d) { return new Date(Date.UTC(1970, 0, d)); },
    function(d) { return date(d).getUTCDate(); },
    [1], 1, 31
  ),
  entry('months',
    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },
    function(d) { return date(d).getUTCMonth(); },
    [1], 0, 11
  )
];

var STEPS = [
  [31536e6, 5],  // 1-year
  [7776e6, 4],   // 3-month
  [2592e6, 4],   // 1-month
  [12096e5, 3],  // 2-week
  [6048e5, 3],   // 1-week
  [1728e5, 3],   // 2-day
  [864e5, 3],    // 1-day
  [432e5, 2],    // 12-hour
  [216e5, 2],    // 6-hour
  [108e5, 2],    // 3-hour
  [36e5, 2],     // 1-hour
  [18e5, 1],     // 30-minute
  [9e5, 1],      // 15-minute
  [3e5, 1],      // 5-minute
  [6e4, 1],      // 1-minute
  [3e4, 0],      // 30-second
  [15e3, 0],     // 15-second
  [5e3, 0],      // 5-second
  [1e3, 0]       // 1-second
];

function find(units, span, minb, maxb) {
  var step = STEPS[0], i, n, bins;

  for (i=1, n=STEPS.length; i<n; ++i) {
    step = STEPS[i];
    if (span > step[0]) {
      bins = span / step[0];
      if (bins > maxb) {
        return units[STEPS[i-1][1]];
      }
      if (bins >= minb) {
        return units[step[1]];
      }
    }
  }
  return units[STEPS[n-1][1]];
}

function toUnitMap(units) {
  var map = {}, i, n;
  for (i=0, n=units.length; i<n; ++i) {
    map[units[i].type] = units[i];
  }
  map.find = function(span, minb, maxb) {
    return find(units, span, minb, maxb);
  };
  return map;
}

module.exports = toUnitMap(locale);
module.exports.utc = toUnitMap(utc);
},{"d3-time":7}],32:[function(require,module,exports){
(function (Buffer){
var u = module.exports;

// utility functions

var FNAME = '__name__';

u.namedfunc = function(name, f) { return (f[FNAME] = name, f); };

u.name = function(f) { return f==null ? null : f[FNAME]; };

u.identity = function(x) { return x; };

u.true = u.namedfunc('true', function() { return true; });

u.false = u.namedfunc('false', function() { return false; });

u.duplicate = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};

u.equal = function(a, b) {
  return JSON.stringify(a) === JSON.stringify(b);
};

u.extend = function(obj) {
  for (var x, name, i=1, len=arguments.length; i<len; ++i) {
    x = arguments[i];
    for (name in x) { obj[name] = x[name]; }
  }
  return obj;
};

u.length = function(x) {
  return x != null && x.length != null ? x.length : null;
};

u.keys = function(x) {
  var keys = [], k;
  for (k in x) keys.push(k);
  return keys;
};

u.vals = function(x) {
  var vals = [], k;
  for (k in x) vals.push(x[k]);
  return vals;
};

u.toMap = function(list, f) {
  return (f = u.$(f)) ?
    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :
    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});
};

u.keystr = function(values) {
  // use to ensure consistent key generation across modules
  var n = values.length;
  if (!n) return '';
  for (var s=String(values[0]), i=1; i<n; ++i) {
    s += '|' + String(values[i]);
  }
  return s;
};

// type checking functions

var toString = Object.prototype.toString;

u.isObject = function(obj) {
  return obj === Object(obj);
};

u.isFunction = function(obj) {
  return toString.call(obj) === '[object Function]';
};

u.isString = function(obj) {
  return typeof value === 'string' || toString.call(obj) === '[object String]';
};

u.isArray = Array.isArray || function(obj) {
  return toString.call(obj) === '[object Array]';
};

u.isNumber = function(obj) {
  return typeof obj === 'number' || toString.call(obj) === '[object Number]';
};

u.isBoolean = function(obj) {
  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
};

u.isDate = function(obj) {
  return toString.call(obj) === '[object Date]';
};

u.isValid = function(obj) {
  return obj != null && obj === obj;
};

u.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;

// type coercion functions

u.number = function(s) {
  return s == null || s === '' ? null : +s;
};

u.boolean = function(s) {
  return s == null || s === '' ? null : s==='false' ? false : !!s;
};

// parse a date with optional d3.time-format format
u.date = function(s, format) {
  var d = format ? format : Date;
  return s == null || s === '' ? null : d.parse(s);
};

u.array = function(x) {
  return x != null ? (u.isArray(x) ? x : [x]) : [];
};

u.str = function(x) {
  return u.isArray(x) ? '[' + x.map(u.str) + ']'
    : u.isObject(x) || u.isString(x) ?
      // Output valid JSON and JS source strings.
      // See http://timelessrepo.com/json-isnt-a-javascript-subset
      JSON.stringify(x).replace('\u2028','\\u2028').replace('\u2029', '\\u2029')
    : x;
};

// data access functions

var field_re = /\[(.*?)\]|[^.\[]+/g;

u.field = function(f) {
  return String(f).match(field_re).map(function(d) {
    return d[0] !== '[' ? d :
      d[1] !== "'" && d[1] !== '"' ? d.slice(1, -1) :
      d.slice(2, -2).replace(/\\(["'])/g, '$1');
  });
};

u.accessor = function(f) {
  /* jshint evil: true */
  return f==null || u.isFunction(f) ? f :
    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));
};

// short-cut for accessor
u.$ = u.accessor;

u.mutator = function(f) {
  var s;
  return u.isString(f) && (s=u.field(f)).length > 1 ?
    function(x, v) {
      for (var i=0; i<s.length-1; ++i) x = x[s[i]];
      x[s[i]] = v;
    } :
    function(x, v) { x[f] = v; };
};


u.$func = function(name, op) {
  return function(f) {
    f = u.$(f) || u.identity;
    var n = name + (u.name(f) ? '_'+u.name(f) : '');
    return u.namedfunc(n, function(d) { return op(f(d)); });
  };
};

u.$valid  = u.$func('valid', u.isValid);
u.$length = u.$func('length', u.length);

u.$in = function(f, values) {
  f = u.$(f);
  var map = u.isArray(values) ? u.toMap(values) : values;
  return function(d) { return !!map[f(d)]; };
};

// comparison / sorting functions

u.comparator = function(sort) {
  var sign = [];
  if (sort === undefined) sort = [];
  sort = u.array(sort).map(function(f) {
    var s = 1;
    if      (f[0] === '-') { s = -1; f = f.slice(1); }
    else if (f[0] === '+') { s = +1; f = f.slice(1); }
    sign.push(s);
    return u.accessor(f);
  });
  return function(a, b) {
    var i, n, f, c;
    for (i=0, n=sort.length; i<n; ++i) {
      f = sort[i];
      c = u.cmp(f(a), f(b));
      if (c) return c * sign[i];
    }
    return 0;
  };
};

u.cmp = function(a, b) {
  return (a < b || a == null) && b != null ? -1 :
    (a > b || b == null) && a != null ? 1 :
    ((b = b instanceof Date ? +b : b),
     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :
    b !== b && a === a ? 1 : 0;
};

u.numcmp = function(a, b) { return a - b; };

u.stablesort = function(array, sortBy, keyFn) {
  var indices = array.reduce(function(idx, v, i) {
    return (idx[keyFn(v)] = i, idx);
  }, {});

  array.sort(function(a, b) {
    var sa = sortBy(a),
        sb = sortBy(b);
    return sa < sb ? -1 : sa > sb ? 1
         : (indices[keyFn(a)] - indices[keyFn(b)]);
  });

  return array;
};

// permutes an array using a Knuth shuffle
u.permute = function(a) {
  var m = a.length,
      swap,
      i;

  while (m) {
    i = Math.floor(Math.random() * m--);
    swap = a[m];
    a[m] = a[i];
    a[i] = swap;
  }
};

// string functions

u.pad = function(s, length, pos, padchar) {
  padchar = padchar || " ";
  var d = length - s.length;
  if (d <= 0) return s;
  switch (pos) {
    case 'left':
      return strrep(d, padchar) + s;
    case 'middle':
    case 'center':
      return strrep(Math.floor(d/2), padchar) +
         s + strrep(Math.ceil(d/2), padchar);
    default:
      return s + strrep(d, padchar);
  }
};

function strrep(n, str) {
  var s = "", i;
  for (i=0; i<n; ++i) s += str;
  return s;
}

u.truncate = function(s, length, pos, word, ellipsis) {
  var len = s.length;
  if (len <= length) return s;
  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\u2026';
  var l = Math.max(0, length - ellipsis.length);

  switch (pos) {
    case 'left':
      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));
    case 'middle':
    case 'center':
      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);
      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +
        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));
    default:
      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;
  }
};

function truncateOnWord(s, len, rev) {
  var cnt = 0, tok = s.split(truncate_word_re);
  if (rev) {
    s = (tok = tok.reverse())
      .filter(function(w) { cnt += w.length; return cnt <= len; })
      .reverse();
  } else {
    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });
  }
  return s.length ? s.join('').trim() : tok[0].slice(0, len);
}

var truncate_word_re = /([\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF])/;

}).call(this,require("buffer").Buffer)

},{"buffer":1}],33:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":34}],34:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":35,"./lib/stringify":36}],35:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],36:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],37:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.topojson = global.topojson || {})));
}(this, (function (exports) { 'use strict';

function noop() {}

function transformAbsolute(transform) {
  if (!transform) return noop;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
  };
}

function transformRelative(transform) {
  if (!transform) return noop;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    var x1 = Math.round((point[0] - dx) / kx),
        y1 = Math.round((point[1] - dy) / ky);
    point[0] = x1 - x0;
    point[1] = y1 - y0;
    x0 = x1;
    y0 = y1;
  };
}

function reverse(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}

function bisect(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}

function feature(topology, o) {
  return o.type === "GeometryCollection" ? {
    type: "FeatureCollection",
    features: o.geometries.map(function(o) { return feature$1(topology, o); })
  } : feature$1(topology, o);
}

function feature$1(topology, o) {
  var f = {
    type: "Feature",
    id: o.id,
    properties: o.properties || {},
    geometry: object(topology, o)
  };
  if (o.id == null) delete f.id;
  return f;
}

function object(topology, o) {
  var absolute = transformAbsolute(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
      points.push(p = a[k].slice());
      absolute(p, k);
    }
    if (i < 0) reverse(points, n);
  }

  function point(p) {
    p = p.slice();
    absolute(p, 0);
    return p;
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0].slice());
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0].slice());
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var t = o.type;
    return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
        : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
        : null;
  }

  var geometryType = {
    Point: function(o) { return point(o.coordinates); },
    MultiPoint: function(o) { return o.coordinates.map(point); },
    LineString: function(o) { return line(o.arcs); },
    MultiLineString: function(o) { return o.arcs.map(line); },
    Polygon: function(o) { return polygon(o.arcs); },
    MultiPolygon: function(o) { return o.arcs.map(polygon); }
  };

  return geometry(o);
}

function stitchArcs(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}

function mesh(topology) {
  return object(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, o, filter) {
  var arcs = [];

  function arc(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function line(arcs) {
    arcs.forEach(arc);
  }

  function polygon(arcs) {
    arcs.forEach(line);
  }

  function geometry(o) {
    if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
    else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
  }

  if (arguments.length > 1) {
    var geomsByArc = [],
        geom;

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function(arcs) { arcs.forEach(polygon); }
    };

    geometry(o);

    geomsByArc.forEach(arguments.length < 3
        ? function(geoms) { arcs.push(geoms[0].i); }
        : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
  } else {
    for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
  }

  return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
}

function cartesianTriangleArea(triangle) {
  var a = triangle[0], b = triangle[1], c = triangle[2];
  return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
}

function ring(ring) {
  var i = -1,
      n = ring.length,
      a,
      b = ring[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = ring[i];
    area += a[0] * b[1] - a[1] * b[0];
  }

  return area / 2;
}

function merge(topology) {
  return object(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      components = [];

  objects.forEach(function(o) {
    if (o.type === "Polygon") register(o.arcs);
    else if (o.type === "MultiPolygon") o.arcs.forEach(register);
  });

  function register(polygon) {
    polygon.forEach(function(ring$$) {
      ring$$.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring$$) {
    return Math.abs(ring(object(topology, {type: "Polygon", arcs: [ring$$]}).coordinates[0]));
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var component = [],
          neighbors = [polygon];
      polygon._ = 1;
      components.push(component);
      while (polygon = neighbors.pop()) {
        component.push(polygon);
        polygon.forEach(function(ring$$) {
          ring$$.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: components.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring$$) {
          ring$$.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = stitchArcs(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    })
  };
}

function neighbors(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}

function compareArea(a, b) {
  return a[1][2] - b[1][2];
}

function minAreaHeap() {
  var heap = {},
      array = [],
      size = 0;

  heap.push = function(object) {
    up(array[object._ = size] = object, size++);
    return size;
  };

  heap.pop = function() {
    if (size <= 0) return;
    var removed = array[0], object;
    if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
    return removed;
  };

  heap.remove = function(removed) {
    var i = removed._, object;
    if (array[i] !== removed) return; // invalid request
    if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
    return i;
  };

  function up(object, i) {
    while (i > 0) {
      var j = ((i + 1) >> 1) - 1,
          parent = array[j];
      if (compareArea(object, parent) >= 0) break;
      array[parent._ = i] = parent;
      array[object._ = i = j] = object;
    }
  }

  function down(object, i) {
    while (true) {
      var r = (i + 1) << 1,
          l = r - 1,
          j = i,
          child = array[j];
      if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
      if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
      if (j === i) break;
      array[child._ = i] = child;
      array[object._ = i = j] = object;
    }
  }

  return heap;
}

function presimplify(topology, triangleArea) {
  var absolute = transformAbsolute(topology.transform),
      relative = transformRelative(topology.transform),
      heap = minAreaHeap();

  if (!triangleArea) triangleArea = cartesianTriangleArea;

  topology.arcs.forEach(function(arc) {
    var triangles = [],
        maxArea = 0,
        triangle,
        i,
        n,
        p;

    // To store each point’s effective area, we create a new array rather than
    // extending the passed-in point to workaround a Chrome/V8 bug (getting
    // stuck in smi mode). For midpoints, the initial effective area of
    // Infinity will be computed in the next step.
    for (i = 0, n = arc.length; i < n; ++i) {
      p = arc[i];
      absolute(arc[i] = [p[0], p[1], Infinity], i);
    }

    for (i = 1, n = arc.length - 1; i < n; ++i) {
      triangle = arc.slice(i - 1, i + 2);
      triangle[1][2] = triangleArea(triangle);
      triangles.push(triangle);
      heap.push(triangle);
    }

    for (i = 0, n = triangles.length; i < n; ++i) {
      triangle = triangles[i];
      triangle.previous = triangles[i - 1];
      triangle.next = triangles[i + 1];
    }

    while (triangle = heap.pop()) {
      var previous = triangle.previous,
          next = triangle.next;

      // If the area of the current point is less than that of the previous point
      // to be eliminated, use the latter's area instead. This ensures that the
      // current point cannot be eliminated without eliminating previously-
      // eliminated points.
      if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
      else maxArea = triangle[1][2];

      if (previous) {
        previous.next = next;
        previous[2] = triangle[2];
        update(previous);
      }

      if (next) {
        next.previous = previous;
        next[0] = triangle[0];
        update(next);
      }
    }

    arc.forEach(relative);
  });

  function update(triangle) {
    heap.remove(triangle);
    triangle[1][2] = triangleArea(triangle);
    heap.push(triangle);
  }

  return topology;
}

var version = "1.6.27";

exports.version = version;
exports.mesh = mesh;
exports.meshArcs = meshArcs;
exports.merge = merge;
exports.mergeArcs = mergeArcs;
exports.feature = feature;
exports.neighbors = neighbors;
exports.presimplify = presimplify;

Object.defineProperty(exports, '__esModule', { value: true });

})));
},{}],38:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), q = [], c, i;
        return i = { next: verb("next"), "throw": verb("throw"), "return": verb("return") }, i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { return function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]), next(); }); }; }
        function next() { if (!c && q.length) resume((c = q.shift())[0], c[1]); }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(c[3], e); } }
        function step(r) { r.done ? settle(c[2], r) : r.value[0] === "yield" ? settle(c[2], { value: r.value[1], done: false }) : Promise.resolve(r.value[1]).then(r.value[0] === "delegate" ? delegate : fulfill, reject); }
        function delegate(r) { step(r.done ? r : { value: ["yield", r.value], done: false }); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { c = void 0, f(v), next(); }
    };

    __asyncDelegator = function (o) {
        var i = { next: verb("next"), "throw": verb("throw", function (e) { throw e; }), "return": verb("return", function (v) { return { value: v, done: true }; }) };
        return o = __asyncValues(o), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { return function (v) { return { value: ["delegate", (o[n] || f).call(o, v)], done: false }; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],39:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.vega = global.vega || {})));
}(this, (function (exports) { 'use strict';

/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */
var eventSelector = function(selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
};

var VIEW    = 'view';
var LBRACK  = '[';
var RBRACK  = ']';
var LBRACE  = '{';
var RBRACE  = '}';
var COLON   = ':';
var COMMA   = ',';
var NAME    = '@';
var GT      = '>';
var ILLEGAL = /[\[\]\{\}]/;
var DEFAULT_SOURCE;
var MARKS;
var DEFAULT_MARKS = {
      '*': 1,
      arc: 1,
      area: 1,
      group: 1,
      image: 1,
      line: 1,
      path: 1,
      rect: 1,
      rule: 1,
      shape: 1,
      symbol: 1,
      text: 1,
      trail: 1
    };

function isMarkType(type) {
  return MARKS.hasOwnProperty(type);
}

function find(s, i, endChar, pushChar, popChar) {
  var count = 0,
      n = s.length,
      c;
  for (; i<n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;
    else if (popChar && popChar.indexOf(c) >= 0) --count;
    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }
  return i;
}

function parseMerge(s) {
  var output = [],
      start = 0,
      n = s.length,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }
  return output;
}

function parseSelector(s) {
  return s[0] === '['
    ? parseBetween(s)
    : parseStream(s);
}

function parseBetween(s) {
  var n = s.length,
      i = 1,
      b, stream;

  i = find(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));
  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);

  stream = parseSelector(s.slice(1).trim());
  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  var stream = {source: DEFAULT_SOURCE},
      source = [],
      throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0, j,
      filter;

  // extract throttle from end
  if (s[n-1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i+1, n-1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;
    i = 0;
  }

  if (!n) throw s;

  // set name flag based on first char
  if (s[0] === NAME) markname = ++i;

  // extract first part of multi-part stream selector
  j = find(s, i, COLON);
  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  }

  // extract remaining part of stream selector
  i = find(s, i, LBRACK);
  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  }

  // extract filters
  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  }

  // marshall event stream specification
  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];
    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }
  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }
  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];

  return stream;
}

function parseThrottle(s) {
  var a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(function(_) {
    var x = +_;
    if (x !== x) throw s;
    return x;
  });
}

exports.selector = eventSelector;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],40:[function(require,module,exports){
module.exports={
  "name": "vega-lite",
  "author": "Jeffrey Heer, Dominik Moritz, Kanit \"Ham\" Wongsuphasawat",
  "version": "2.0.0-alpha.9",
  "collaborators": [
    "Kanit Wongsuphasawat <kanitw@gmail.com> (http://kanitw.yellowpigz.com)",
    "Dominik Moritz <domoritz@cs.washington.edu> (https://www.domoritz.de)",
    "Jeffrey Heer <jheer@uw.edu> (http://jheer.org)"
  ],
  "homepage": "https://vega.github.io/vega-lite/",
  "description": "Vega-lite provides a higher-level grammar for visual analysis, comparable to ggplot or Tableau, that generates complete Vega specifications.",
  "main": "build/src/vl.js",
  "types": "build/src/vl.d.ts",
  "bin": {
    "vl2png": "./bin/vl2png",
    "vl2svg": "./bin/vl2svg",
    "vl2vg": "./bin/vl2vg"
  },
  "directories": {
    "test": "test"
  },
  "scripts": {
    "tsc": "rm -rf build/*/** && tsc",
    "prebuild": "mkdir -p build/site build/examples/images build/test-gallery",
    "build": "npm run tsc && cp package.json build && browserify src/vl.ts -p tsify -d -s vl | exorcist build/vega-lite.js.map > build/vega-lite.js",
    "postbuild": "uglifyjs build/vega-lite.js -cm --in-source-map build/vega-lite.js.map --source-map build/vega-lite.min.js.map > build/vega-lite.min.js && npm run schema",
    "build:examples": "./scripts/build-examples.sh",
    "build:images": "npm run data && scripts/generate-images.sh",
    "build:toc": "bundle exec jekyll build -q && scripts/generate-toc",
    "build:site": "npm run link && browserify site/static/main.ts -p [tsify -p site] -d | exorcist build/site/main.js.map > build/site/main.js",
    "build:versions": "scripts/update-version.sh",
    "build:test-gallery": "browserify test-gallery/main.ts -p [tsify -p test-gallery] -d > build/test-gallery/main.js",
    "check:examples": "scripts/check-examples.sh",
    "check:schema": "scripts/check-schema.sh",
    "clean": "rm -rf build && rm -f vega-lite.* & find -E src test site examples -regex '.*\\.(js|js.map|d.ts|vg.json)' -delete & rm -rf data",
    "data": "rsync -r node_modules/vega-datasets/data/* data",
    "link": "npm link && npm link vega-lite",

    "deploy": "scripts/deploy.sh",
    "deploy:gh": "scripts/deploy-gh.sh",
    "deploy:schema": "scripts/deploy-schema.sh",

    "prestart": "npm run data && npm run build && scripts/index-examples",
    "start": "nodemon -x 'npm run build:test-gallery' & browser-sync start --server --files 'build/test-gallery/main.js' --index 'test-gallery/index.html'",
    "poststart": "rm examples/all-examples.json",

    "preschema": "npm run prebuild",
    "schema": "typescript-json-schema --required true --noExtraProps true src/spec.ts TopLevelExtendedSpec > build/vega-lite-schema.json && rm -f _data/vega-lite-schema.json && cp build/vega-lite-schema.json _data/",

    "presite": "npm run build && npm run data && npm run build:site && npm run build:toc && npm run build:versions",
    "site": "bundle exec jekyll serve",

    "lint": "tslint --project tsconfig.json -c tslint.json --type-check",
    "pretest": "npm run tsc && npm run schema && npm run data",
    "test": "npm run test:nocompile",
    "test:nocompile": "npm run test:only && npm run lint && npm run mocha:examples",
    "test:only": "nyc --reporter=html --reporter=text-summary npm run mocha:test",
    "test:debug": "npm run pretest && mocha --recursive --debug-brk build/test build/examples",
    "mocha:test": "mocha --require source-map-support/register --reporter dot --recursive build/test",
    "mocha:examples": "mocha --require source-map-support/register --reporter dot --recursive build/examples",

    "codecov": "nyc report --reporter=json && codecov -f coverage/*.json",
    "watch:build": "watchify src/vl.ts -p tsify -v -d -s vl -o 'exorcist build/vega-lite.js.map > build/vega-lite.js'",
    "watch:test": "nodemon -x 'npm test'",
    "watch": "nodemon -x 'npm run build && npm run test:nocompile' # already ran schema in build"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/vega/vega-lite.git"
  },
  "license": "BSD-3-Clause",
  "bugs": {
    "url": "https://github.com/vega/vega-lite/issues"
  },
  "devDependencies": {
    "@types/chai": "^3.5.0",
    "@types/d3": "^4.7.0",
    "@types/highlight.js": "^9.1.9",
    "@types/json-stable-stringify": "^1.0.31",
    "@types/mocha": "^2.2.40",
    "@types/node": "^7.0.12",
    "ajv": "5.0.1-beta.1",
    "browser-sync": "~2.18.8",
    "browserify": "~14.3.0",
    "browserify-shim": "^3.8.14",
    "chai": "~3.5.0",
    "cheerio": "~0.22.0",
    "codecov": "~2.1.0",
    "d3": "^4.7.4",
    "exorcist": "~0.4.0",
    "highlight.js": "^9.10.0",
    "mocha": "~3.2.0",
    "nodemon": "~1.11.0",
    "nyc": "~10.2.0",
    "source-map-support": "~0.4.14",
    "tsify": "~3.0.1",
    "tslint": "~5.1.0",
    "tslint-eslint-rules": "^4.0.0",
    "typescript": "^2.2.2",
    "typescript-json-schema": "^0.11.0",
    "uglify-js": "~2.8.22",
    "vega": "3.0.0-beta.28",
    "vega-datasets": "vega/vega-datasets#gh-pages",
    "vega-embed": "3.0.0-beta.10",
    "watchify": "~3.9.0",
    "yaml-front-matter": "~3.4.0"
  },
  "dependencies": {
    "json-stable-stringify": "~1.0.1",
    "tslib": "^1.6.0",
    "vega-event-selector": "^2.0.0-beta",
    "vega-util": "~1.1.4",
    "yargs": "~7.0.2"
  }
}

},{}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
exports.AGGREGATE_OPS = [
    'values',
    'count',
    'valid',
    'missing',
    'distinct',
    'sum',
    'mean',
    'average',
    'variance',
    'variancep',
    'stdev',
    'stdevp',
    'median',
    'q1',
    'q3',
    'ci0',
    'ci1',
    'modeskew',
    'min',
    'max',
    'argmin',
    'argmax',
];
exports.AGGREGATE_OP_INDEX = util_1.toSet(exports.AGGREGATE_OPS);
/** Additive-based aggregation operations.  These can be applied to stack. */
exports.SUM_OPS = [
    'count',
    'sum',
    'distinct',
    'valid',
    'missing'
];
/**
 * Aggregation operators that always produce values within the range [domainMin, domainMax].
 */
exports.SHARED_DOMAIN_OPS = [
    'mean',
    'average',
    'median',
    'q1',
    'q3',
    'min',
    'max',
];

},{"./util":124}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AXIS_PROPERTIES = [
    'domain', 'format', 'grid', 'labelPadding', 'labels', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'
];

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("./channel");
var util_1 = require("./util");
function binToString(bin) {
    if (util_1.isBoolean(bin)) {
        return 'bin';
    }
    return 'bin' + Object.keys(bin).map(function (p) { return "_" + p + "_" + bin[p]; }).join('');
}
exports.binToString = binToString;
function autoMaxBins(channel) {
    switch (channel) {
        case channel_1.ROW:
        case channel_1.COLUMN:
        case channel_1.SIZE:
        // Facets and Size shouldn't have too many bins
        // We choose 6 like shape to simplify the rule
        case channel_1.SHAPE:
            return 6; // Vega's "shape" has 6 distinct values
        default:
            return 10;
    }
}
exports.autoMaxBins = autoMaxBins;

},{"./channel":44,"./util":124}],44:[function(require,module,exports){
/*
 * Constants and utilities for encoding channels (Visual variables)
 * such as 'x', 'y', 'color'.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var scale_1 = require("./scale");
var util_1 = require("./util");
var Channel;
(function (Channel) {
    // Facet
    Channel.ROW = 'row';
    Channel.COLUMN = 'column';
    // Position
    Channel.X = 'x';
    Channel.Y = 'y';
    Channel.X2 = 'x2';
    Channel.Y2 = 'y2';
    // Mark property with scale
    Channel.COLOR = 'color';
    Channel.SHAPE = 'shape';
    Channel.SIZE = 'size';
    Channel.OPACITY = 'opacity';
    // Non-scale channel
    Channel.TEXT = 'text';
    Channel.ORDER = 'order';
    Channel.DETAIL = 'detail';
})(Channel = exports.Channel || (exports.Channel = {}));
exports.X = Channel.X;
exports.Y = Channel.Y;
exports.X2 = Channel.X2;
exports.Y2 = Channel.Y2;
exports.ROW = Channel.ROW;
exports.COLUMN = Channel.COLUMN;
exports.SHAPE = Channel.SHAPE;
exports.SIZE = Channel.SIZE;
exports.COLOR = Channel.COLOR;
exports.TEXT = Channel.TEXT;
exports.DETAIL = Channel.DETAIL;
exports.ORDER = Channel.ORDER;
exports.OPACITY = Channel.OPACITY;
exports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];
// CHANNELS without COLUMN, ROW
exports.UNIT_CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];
// UNIT_CHANNELS without X2, Y2, ORDER, DETAIL, TEXT
exports.UNIT_SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];
// UNIT_SCALE_CHANNELS with ROW, COLUMN
exports.SCALE_CHANNELS = [exports.X, exports.Y, exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY, exports.ROW, exports.COLUMN];
// UNIT_CHANNELS without X, Y, X2, Y2;
exports.NONSPATIAL_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.ORDER, exports.OPACITY, exports.TEXT, exports.DETAIL];
// UNIT_SCALE_CHANNELS without X, Y;
exports.NONSPATIAL_SCALE_CHANNELS = [exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY];
exports.LEVEL_OF_DETAIL_CHANNELS = util_1.without(exports.NONSPATIAL_CHANNELS, ['order']);
/** Channels that can serve as groupings for stacked charts. */
exports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];
/**
 * Return whether a channel supports a particular mark type.
 * @param channel  channel name
 * @param mark the mark type
 * @return whether the mark supports the channel
 */
function supportMark(channel, mark) {
    return mark in getSupportedMark(channel);
}
exports.supportMark = supportMark;
/**
 * Return a dictionary showing whether a channel supports mark type.
 * @param channel
 * @return A dictionary mapping mark types to boolean values.
 */
function getSupportedMark(channel) {
    switch (channel) {
        case exports.X:
        case exports.Y:
        case exports.COLOR:
        case exports.DETAIL:
        case exports.ORDER: // TODO: revise (order might not support rect, which is not stackable?)
        case exports.OPACITY:
        case exports.ROW:
        case exports.COLUMN:
            return {
                point: true, tick: true, rule: true, circle: true, square: true,
                bar: true, rect: true, line: true, area: true, text: true
            };
        case exports.X2:
        case exports.Y2:
            return {
                rule: true, bar: true, rect: true, area: true
            };
        case exports.SIZE:
            return {
                point: true, tick: true, rule: true, circle: true, square: true,
                bar: true, text: true, line: true
            };
        case exports.SHAPE:
            return { point: true };
        case exports.TEXT:
            return { text: true };
    }
    return {};
}
exports.getSupportedMark = getSupportedMark;
function hasScale(channel) {
    return !util_1.contains([exports.DETAIL, exports.TEXT, exports.ORDER], channel);
}
exports.hasScale = hasScale;
// Position does not work with ordinal (lookup) scale and sequential (which is only for color)
var POSITION_SCALE_TYPE_INDEX = util_1.toSet(util_1.without(scale_1.SCALE_TYPES, ['ordinal', 'sequential']));
function supportScaleType(channel, scaleType) {
    switch (channel) {
        case exports.ROW:
        case exports.COLUMN:
            return scaleType === 'band'; // row / column currently supports band only
        case exports.X:
        case exports.Y:
        case exports.SIZE: // TODO: size and opacity can support ordinal with more modification
        case exports.OPACITY:
            // Although it generally doesn't make sense to use band with size and opacity,
            // it can also work since we use band: 0.5 to get midpoint.
            return scaleType in POSITION_SCALE_TYPE_INDEX;
        case exports.COLOR:
            return scaleType !== 'band'; // band does not make sense with color
        case exports.SHAPE:
            return scaleType === 'ordinal'; // shape = lookup only
    }
    /* istanbul ignore next: it should never reach here */
    return false;
}
exports.supportScaleType = supportScaleType;
function rangeType(channel) {
    switch (channel) {
        case exports.X:
        case exports.Y:
        case exports.SIZE:
        case exports.OPACITY:
            return 'continuous';
        case exports.ROW:
        case exports.COLUMN:
        case exports.SHAPE:
            return 'discrete';
        // Color can be either continuous or discrete, depending on scale type.
        case exports.COLOR:
            return 'flexible';
        // No scale, no range type.
        case exports.X2:
        case exports.Y2:
        case exports.DETAIL:
        case exports.TEXT:
        case exports.ORDER:
            return undefined;
    }
    /* istanbul ignore next: should never reach here. */
    throw new Error('getSupportedRole not implemented for ' + channel);
}
exports.rangeType = rangeType;

},{"./scale":115,"./util":124}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
function labels(model, channel, labelsSpec, def) {
    var fieldDef = model.fieldDef(channel);
    var axis = model.axis(channel);
    var config = model.config;
    // Text
    if (fieldDef.type === type_1.TEMPORAL) {
        labelsSpec = util_1.extend({
            text: {
                signal: common_1.timeFormatExpression('datum.value', fieldDef.timeUnit, axis.format, config.axis.shortTimeLabels, config.timeFormat)
            }
        }, labelsSpec);
    }
    // Label Angle
    if (axis.labelAngle !== undefined) {
        labelsSpec.angle = { value: axis.labelAngle };
    }
    else {
        // auto rotate for X
        if (channel === channel_1.X && (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin || fieldDef.type === type_1.TEMPORAL)) {
            labelsSpec.angle = { value: 270 };
        }
    }
    // Auto set align if rotated
    // TODO: consider other value besides 270, 90
    if (labelsSpec.angle) {
        if (labelsSpec.angle.value === 270) {
            labelsSpec.align = {
                value: def.orient === 'top' ? 'left' :
                    (channel === channel_1.X || channel === channel_1.COLUMN) ? 'right' :
                        'center'
            };
        }
        else if (labelsSpec.angle.value === 90) {
            labelsSpec.align = { value: 'center' };
        }
    }
    if (labelsSpec.angle) {
        // Auto set baseline if rotated
        // TODO: consider other value besides 270, 90
        if (labelsSpec.angle.value === 270) {
            labelsSpec.baseline = { value: (channel === channel_1.X || channel === channel_1.COLUMN) ? 'middle' : 'bottom' };
        }
        else if (labelsSpec.angle.value === 90) {
            labelsSpec.baseline = { value: 'bottom' };
        }
    }
    return util_1.keys(labelsSpec).length === 0 ? undefined : labelsSpec;
}
exports.labels = labels;

},{"../../channel":44,"../../type":123,"../../util":124,"../common":48}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var axis_1 = require("../../axis");
var encode = require("./encode");
var rules = require("./rules");
var util_1 = require("../../util");
var AXIS_PARTS = ['domain', 'grid', 'labels', 'ticks', 'title'];
function parseAxisComponent(model, axisChannels) {
    return axisChannels.reduce(function (axis, channel) {
        var vgAxes = [];
        if (model.axis(channel)) {
            var main = parseMainAxis(channel, model);
            if (main && isVisibleAxis(main)) {
                vgAxes.push(main);
            }
            var grid = parseGridAxis(channel, model);
            if (grid && isVisibleAxis(grid)) {
                vgAxes.push(grid);
            }
            if (vgAxes.length > 0) {
                axis[channel] = vgAxes;
            }
        }
        return axis;
    }, {});
}
exports.parseAxisComponent = parseAxisComponent;
function isFalseOrNull(v) {
    return v === false || v === null;
}
/**
 * Return if an axis is visible (shows at least one part of the axis).
 */
function isVisibleAxis(axis) {
    return util_1.some(AXIS_PARTS, function (part) { return hasAxisPart(axis, part); });
}
function hasAxisPart(axis, part) {
    // FIXME this method can be wrong if users use a Vega theme.
    // (Not sure how to correctly handle that yet.).
    if (part === 'grid' || part === 'title') {
        return !!axis[part];
    }
    // Other parts are enabled by default, so they should not be false or null.
    return !isFalseOrNull(axis[part]);
}
/**
 * Make an inner axis for showing grid for shared axis.
 */
function parseGridAxis(channel, model) {
    // FIXME: support adding ticks for grid axis that are inner axes of faceted plots.
    return parseAxis(channel, model, true);
}
exports.parseGridAxis = parseGridAxis;
function parseMainAxis(channel, model) {
    return parseAxis(channel, model, false);
}
exports.parseMainAxis = parseMainAxis;
function parseAxis(channel, model, isGridAxis) {
    var axis = model.axis(channel);
    var vgAxis = {
        scale: model.scaleName(channel)
    };
    // 1.2. Add properties
    axis_1.AXIS_PROPERTIES.forEach(function (property) {
        var value = getSpecifiedOrDefaultValue(property, axis, channel, model, isGridAxis);
        if (value !== undefined) {
            vgAxis[property] = value;
        }
    });
    // Special case for gridScale since gridScale is not a Vega-Lite Axis property.
    var gridScale = getSpecifiedOrDefaultValue('gridScale', axis, channel, model, isGridAxis);
    if (gridScale !== undefined) {
        vgAxis.gridScale = gridScale;
    }
    // 2) Add guide encode definition groups
    var encodeSpec = axis.encode || {};
    AXIS_PARTS.forEach(function (part) {
        if (!hasAxisPart(vgAxis, part)) {
            // No need to create encode for a disabled part.
            return;
        }
        // TODO(@yuhanlu): instead of calling encode[part], break this line based on part type
        // as different require different parameters.
        var value;
        if (part === 'labels') {
            value = encode.labels(model, channel, encodeSpec.labels || {}, vgAxis);
        }
        else {
            value = encodeSpec[part] || {};
        }
        if (value !== undefined && util_1.keys(value).length > 0) {
            vgAxis.encode = vgAxis.encode || {};
            vgAxis.encode[part] = { update: value };
        }
    });
    return vgAxis;
}
function getSpecifiedOrDefaultValue(property, specifiedAxis, channel, model, isGridAxis) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'labels':
            return isGridAxis ? false : specifiedAxis[property];
        case 'domain':
            return rules.domain(property, specifiedAxis, isGridAxis, channel);
        case 'ticks':
            return rules.ticks(property, specifiedAxis, isGridAxis, channel);
        case 'format':
            return rules.format(specifiedAxis, channel, fieldDef, model.config);
        case 'grid':
            return rules.grid(model, channel, isGridAxis); // FIXME: refactor this
        case 'gridScale':
            return rules.gridScale(model, channel, isGridAxis);
        case 'orient':
            return rules.orient(specifiedAxis, channel);
        case 'tickCount':
            return rules.tickCount(specifiedAxis, channel, fieldDef); // TODO: scaleType
        case 'title':
            return rules.title(specifiedAxis, fieldDef, model.config, isGridAxis);
        case 'values':
            return rules.values(specifiedAxis);
        case 'zindex':
            return rules.zindex(specifiedAxis, isGridAxis);
    }
    // Otherwise, return specified property.
    return specifiedAxis[property];
}

},{"../../axis":42,"../../util":124,"./encode":45,"./rules":47}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var util_1 = require("../../util");
var common_1 = require("../common");
function format(specifiedAxis, channel, fieldDef, config) {
    return common_1.numberFormat(fieldDef, specifiedAxis.format, config, channel);
}
exports.format = format;
// TODO: we need to refactor this method after we take care of config refactoring
/**
 * Default rules for whether to show a grid should be shown for a channel.
 * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned
 */
function gridShow(model, channel) {
    var grid = model.axis(channel).grid;
    if (grid !== undefined) {
        return grid;
    }
    return !model.hasDiscreteScale(channel) && !model.fieldDef(channel).bin;
}
exports.gridShow = gridShow;
function grid(model, channel, isGridAxis) {
    if (channel === channel_1.ROW || channel === channel_1.COLUMN) {
        // never apply grid for ROW and COLUMN since we manually create rule-group for them
        return false;
    }
    if (!isGridAxis) {
        return undefined;
    }
    return gridShow(model, channel);
}
exports.grid = grid;
function gridScale(model, channel, isGridAxis) {
    if (isGridAxis) {
        var gridChannel = channel === 'x' ? 'y' : 'x';
        if (model.scale(gridChannel)) {
            return model.scaleName(gridChannel);
        }
    }
    return undefined;
}
exports.gridScale = gridScale;
function orient(specifiedAxis, channel) {
    var orient = specifiedAxis.orient;
    if (orient) {
        return orient;
    }
    switch (channel) {
        case channel_1.COLUMN:
            // FIXME test and decide
            return 'top';
        case channel_1.X:
            return 'bottom';
        case channel_1.ROW:
        case channel_1.Y:
            return 'left';
    }
    /* istanbul ignore next: This should never happen. */
    throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);
}
exports.orient = orient;
function tickCount(specifiedAxis, channel, fieldDef) {
    var count = specifiedAxis.tickCount;
    if (count !== undefined) {
        return count;
    }
    // FIXME depends on scale type too
    if (channel === channel_1.X && !fieldDef.bin) {
        // Vega's default tickCount often lead to a lot of label occlusion on X without 90 degree rotation
        return 5;
    }
    return undefined;
}
exports.tickCount = tickCount;
function title(specifiedAxis, fieldDef, config, isGridAxis) {
    if (isGridAxis) {
        return undefined;
    }
    if (specifiedAxis.title !== undefined) {
        return specifiedAxis.title;
    }
    // if not defined, automatically determine axis title from field def
    var fieldTitle = fielddef_1.title(fieldDef, config);
    var maxLength = specifiedAxis.titleMaxLength;
    return maxLength ? util_1.truncate(fieldTitle, maxLength) : fieldTitle;
}
exports.title = title;
function values(specifiedAxis) {
    var vals = specifiedAxis.values;
    if (specifiedAxis.values && datetime_1.isDateTime(vals[0])) {
        return vals.map(function (dt) {
            // normalize = true as end user won't put 0 = January
            return datetime_1.timestamp(dt, true);
        });
    }
    return vals;
}
exports.values = values;
function zindex(specifiedAxis, isGridAxis) {
    var z = specifiedAxis.zindex;
    if (z !== undefined) {
        return z;
    }
    if (isGridAxis) {
        // if grid is true, need to put layer on the back so that grid is behind marks
        return 0;
    }
    return 1; // otherwise return undefined and use Vega's default.
}
exports.zindex = zindex;
function domainAndTicks(property, specifiedAxis, isGridAxis, channel) {
    if (isGridAxis || channel === channel_1.ROW || channel === channel_1.COLUMN) {
        return false;
    }
    return specifiedAxis[property];
}
exports.domainAndTicks = domainAndTicks;
exports.domain = domainAndTicks;
exports.ticks = domainAndTicks;

},{"../../channel":44,"../../datetime":107,"../../fielddef":110,"../../log":113,"../../util":124,"../common":48}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../log");
var channel_1 = require("../channel");
var fielddef_1 = require("../fielddef");
var type_1 = require("../type");
var util_1 = require("../util");
var spec_1 = require("../spec");
var timeunit_1 = require("../timeunit");
var facet_1 = require("./facet");
var layer_1 = require("./layer");
var unit_1 = require("./unit");
function buildModel(spec, parent, parentGivenName, config) {
    if (spec_1.isFacetSpec(spec)) {
        return new facet_1.FacetModel(spec, parent, parentGivenName, config);
    }
    if (spec_1.isLayerSpec(spec)) {
        return new layer_1.LayerModel(spec, parent, parentGivenName, config);
    }
    if (spec_1.isUnitSpec(spec)) {
        return new unit_1.UnitModel(spec, parent, parentGivenName, config);
    }
    throw new Error(log.message.INVALID_SPEC);
}
exports.buildModel = buildModel;
function applyConfig(e, config, // TODO(#1842): consolidate MarkConfig | TextConfig?
    propsList) {
    propsList.forEach(function (property) {
        var value = config[property];
        if (value !== undefined) {
            e[property] = { value: value };
        }
    });
    return e;
}
exports.applyConfig = applyConfig;
function applyMarkConfig(e, model, propsList) {
    propsList.forEach(function (property) {
        var value = getMarkConfig(property, model.mark(), model.config);
        if (value !== undefined) {
            e[property] = { value: value };
        }
    });
    return e;
}
exports.applyMarkConfig = applyMarkConfig;
/**
 * Return value mark specific config property if exists.
 * Otherwise, return general mark specific config.
 */
function getMarkConfig(prop, mark, config) {
    var markSpecificConfig = config[mark];
    if (markSpecificConfig[prop] !== undefined) {
        return markSpecificConfig[prop];
    }
    return config.mark[prop];
}
exports.getMarkConfig = getMarkConfig;
/**
 * Returns number format for a fieldDef
 *
 * @param format explicitly specified format
 */
function numberFormat(fieldDef, format, config, channel) {
    if (fieldDef.type === type_1.QUANTITATIVE) {
        // add number format for quantitative type only
        if (format) {
            return format;
        }
        else if (fieldDef.aggregate === 'count' && channel === channel_1.TEXT) {
            // FIXME: need a more holistic way to deal with this.
            return 'd';
        }
        // TODO: need to make this work correctly for numeric ordinal / nominal type
        return config.numberFormat;
    }
    return undefined;
}
exports.numberFormat = numberFormat;
/**
 * Returns the time expression used for axis/legend labels or text mark for a temporal field
 */
function timeFormatExpression(field, timeUnit, format, shortTimeLabels, timeFormatConfig) {
    if (!timeUnit || format) {
        // If there is not time unit, or if user explicitly specify format for axis/legend/text.
        var _format = format || timeFormatConfig; // only use config.timeFormat if there is no timeUnit.
        return "timeFormat(" + field + ", '" + _format + "')";
    }
    else {
        return timeunit_1.formatExpression(timeUnit, field, shortTimeLabels);
    }
}
exports.timeFormatExpression = timeFormatExpression;
/**
 * Return Vega sort parameters (tuple of field and order).
 */
function sortParams(orderDef) {
    return (util_1.isArray(orderDef) ? orderDef : [orderDef]).reduce(function (s, orderChannelDef) {
        s.field.push(fielddef_1.field(orderChannelDef, { binSuffix: 'start' }));
        s.order.push(orderChannelDef.sort || 'ascending');
        return s;
    }, { field: [], order: [] });
}
exports.sortParams = sortParams;

},{"../channel":44,"../fielddef":110,"../log":113,"../spec":118,"../timeunit":120,"../type":123,"../util":124,"./facet":65,"./layer":66,"./unit":103}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Module for compiling Vega-lite spec into Vega spec.
 */
var config_1 = require("../config");
var data_1 = require("../data");
var log = require("../log");
var spec_1 = require("../spec");
var toplevelprops_1 = require("../toplevelprops");
var util_1 = require("../util");
var common_1 = require("./common");
var selection_1 = require("./selection/selection");
function compile(inputSpec, logger) {
    if (logger) {
        // set the singleton logger to the provided logger
        log.set(logger);
    }
    try {
        // 1. Convert input spec into a normal form
        // (Decompose all extended unit specs into composition of unit spec.)
        var spec = spec_1.normalize(inputSpec);
        // 2. Instantiate the model with default config
        var config = config_1.initConfig(inputSpec.config);
        var model = common_1.buildModel(spec, null, '', config);
        // 3. Parse each part of the model to produce components that will be assembled later
        // We traverse the whole tree to parse once for each type of components
        // (e.g., data, layout, mark, scale).
        // Please see inside model.parse() for order for compilation.
        model.parse();
        // 4. Assemble a Vega Spec from the parsed components in 3.
        return assemble(model, getTopLevelProperties(inputSpec, config));
    }
    finally {
        // Reset the singleton logger if a logger is provided
        if (logger) {
            log.reset();
        }
    }
}
exports.compile = compile;
function getTopLevelProperties(topLevelSpec, config) {
    return tslib_1.__assign({}, toplevelprops_1.extractTopLevelProperties(config), toplevelprops_1.extractTopLevelProperties(topLevelSpec));
}
function assemble(model, topLevelProperties) {
    // TODO: change type to become VgSpec
    var output = util_1.extend({
        $schema: 'http://vega.github.io/schema/vega/v3.0.json',
    }, { autosize: 'pad' }, // Currently we don't support custom autosize
    topLevelProperties, {
        // Map calculated layout width and height to width and height signals.
        signals: [
            {
                name: 'width',
                update: "data('" + model.getName(data_1.LAYOUT) + "')[0]." + model.getName('width')
            },
            {
                name: 'height',
                update: "data('" + model.getName(data_1.LAYOUT) + "')[0]." + model.getName('height')
            }
        ].concat(selection_1.assembleTopLevelSignals(model))
    }, {
        data: [].concat(model.assembleData(), model.assembleLayout([]), model.assembleSelectionData([])),
        marks: [assembleRootGroup(model)]
    });
    return {
        spec: output
        // TODO: add warning / errors here
    };
}
function assembleRootGroup(model) {
    var rootGroup = util_1.extend({
        name: model.getName('main-group'),
        type: 'group',
    }, model.description ? { description: model.description } : {}, {
        from: { data: model.getName(data_1.LAYOUT) },
        encode: {
            update: util_1.extend({
                width: { field: model.getName('width') },
                height: { field: model.getName('height') }
            }, model.assembleParentGroupProperties(model.config.cell))
        }
    });
    return util_1.extend(rootGroup, model.assembleGroup());
}
exports.assembleRootGroup = assembleRootGroup;

},{"../config":105,"../data":106,"../log":113,"../spec":118,"../toplevelprops":121,"../util":124,"./common":48,"./selection/selection":93,"tslib":38}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
function addDimension(dims, fieldDef) {
    if (fieldDef.bin) {
        dims[fielddef_1.field(fieldDef, { binSuffix: 'start' })] = true;
        dims[fielddef_1.field(fieldDef, { binSuffix: 'end' })] = true;
        // const scale = model.scale(channel);
        // if (scaleType(scale, fieldDef, channel, model.mark()) === ScaleType.ORDINAL) {
        // also produce bin_range if the binned field use ordinal scale
        dims[fielddef_1.field(fieldDef, { binSuffix: 'range' })] = true;
        // }
    }
    else {
        dims[fielddef_1.field(fieldDef)] = true;
    }
    return dims;
}
function mergeMeasures(parentMeasures, childMeasures) {
    for (var field_1 in childMeasures) {
        if (childMeasures.hasOwnProperty(field_1)) {
            // when we merge a measure, we either have to add an aggregation operator or even a new field
            var ops = childMeasures[field_1];
            for (var op in ops) {
                if (ops.hasOwnProperty(op)) {
                    if (field_1 in parentMeasures) {
                        // add operator to existing measure field
                        parentMeasures[field_1][op] = true;
                    }
                    else {
                        parentMeasures[field_1] = { op: true };
                    }
                }
            }
        }
    }
}
var AggregateNode = (function (_super) {
    tslib_1.__extends(AggregateNode, _super);
    /**
     * @param dimensions string set for dimensions
     * @param measures dictionary mapping field name => dict set of aggregation functions
     */
    function AggregateNode(dimensions, measures) {
        var _this = _super.call(this) || this;
        _this.dimensions = dimensions;
        _this.measures = measures;
        return _this;
    }
    AggregateNode.prototype.clone = function () {
        return new AggregateNode(util_1.extend({}, this.dimensions), util_1.duplicate(this.measures));
    };
    AggregateNode.make = function (model) {
        var isAggregate = false;
        model.forEachFieldDef(function (fd) {
            if (fd.aggregate) {
                isAggregate = true;
            }
        });
        var meas = {};
        var dims = {};
        if (!isAggregate) {
            // no need to create this node if the model has no aggregation
            return null;
        }
        model.forEachFieldDef(function (fieldDef, channel) {
            if (fieldDef.aggregate) {
                if (fieldDef.aggregate === 'count') {
                    meas['*'] = meas['*'] || {};
                    /* tslint:disable:no-string-literal */
                    meas['*']['count'] = true;
                    /* tslint:enable:no-string-literal */
                }
                else {
                    meas[fieldDef.field] = meas[fieldDef.field] || {};
                    meas[fieldDef.field][fieldDef.aggregate] = true;
                    // add min/max so we can use their union as unaggregated domain
                    var scale = model.scale(channel);
                    if (scale && scale.domain === 'unaggregated') {
                        meas[fieldDef.field]['min'] = true;
                        meas[fieldDef.field]['max'] = true;
                    }
                }
            }
            else {
                addDimension(dims, fieldDef);
            }
        });
        if ((Object.keys(dims).length + Object.keys(meas).length) === 0) {
            return null;
        }
        return new AggregateNode(dims, meas);
    };
    AggregateNode.prototype.merge = function (other) {
        if (!util_1.differ(this.dimensions, other.dimensions)) {
            mergeMeasures(this.measures, other.measures);
            other.remove();
        }
        else {
            log.debug('different dimensions, cannot merge');
        }
    };
    AggregateNode.prototype.addDimensions = function (fields) {
        var _this = this;
        fields.forEach(function (f) { return _this.dimensions[f] = true; });
    };
    AggregateNode.prototype.dependentFields = function () {
        var out = {};
        util_1.keys(this.dimensions).forEach(function (f) { return out[f] = true; });
        util_1.keys(this.measures).forEach(function (m) { return out[m] = true; });
        return out;
    };
    AggregateNode.prototype.producedFields = function () {
        var _this = this;
        var out = {};
        util_1.keys(this.measures).forEach(function (field) {
            util_1.keys(_this.measures[field]).forEach(function (op) {
                out[op + "_" + field] = true;
            });
        });
        return out;
    };
    AggregateNode.prototype.assemble = function () {
        var _this = this;
        var ops = [];
        var fields = [];
        util_1.keys(this.measures).forEach(function (field) {
            util_1.keys(_this.measures[field]).forEach(function (op) {
                ops.push(op);
                fields.push(field);
            });
        });
        return {
            type: 'aggregate',
            groupby: util_1.keys(this.dimensions),
            ops: ops,
            fields: fields
        };
    };
    return AggregateNode;
}(dataflow_1.DataFlowNode));
exports.AggregateNode = AggregateNode;

},{"../../fielddef":110,"../../log":113,"../../util":124,"./dataflow":53,"tslib":38}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("../../data");
var util_1 = require("../../util");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var dataflow_1 = require("./dataflow");
var facet_1 = require("./facet");
var formatparse_1 = require("./formatparse");
var nonpositivefilter_1 = require("./nonpositivefilter");
var nullfilter_1 = require("./nullfilter");
var optimizers_1 = require("./optimizers");
var optimizers = require("./optimizers");
var pathorder_1 = require("./pathorder");
var source_1 = require("./source");
var stack_1 = require("./stack");
var timeunit_1 = require("./timeunit");
var transforms_1 = require("./transforms");
exports.FACET_SCALE_PREFIX = 'scale_';
/**
 * Start optimization path from the root. Useful for removing nodes.
 */
function removeUnnecessaryNodes(node) {
    // remove empty non positive filter
    if (node instanceof nonpositivefilter_1.NonPositiveFilterNode && util_1.every(util_1.vals(node.filter), function (b) { return b === false; })) {
        node.remove();
    }
    // remove empty null filter nodes
    if (node instanceof nullfilter_1.NullFilterNode && util_1.every(util_1.vals(node.filteredFields), function (f) { return f === null; })) {
        node.remove();
    }
    // remove output nodes that are not required
    if (node instanceof dataflow_1.OutputNode && !node.required) {
        node.remove();
    }
    node.children.forEach(removeUnnecessaryNodes);
}
/**
 * Clones the subtree and ignores output nodes except for the leafs, which are renamed.
 */
function cloneSubtree(facet) {
    function clone(node) {
        if (!(node instanceof pathorder_1.OrderNode)) {
            var copy_1 = node.clone();
            if (copy_1 instanceof dataflow_1.OutputNode) {
                var newName = exports.FACET_SCALE_PREFIX + facet.model.getName(copy_1.source);
                copy_1.source = newName;
                facet.model.component.data.outputNodes[newName] = copy_1;
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            else if (copy_1 instanceof aggregate_1.AggregateNode || copy_1 instanceof stack_1.StackNode) {
                copy_1.addDimensions(facet.fields);
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            else {
                util_1.flatten(node.children.map(clone)).forEach(function (n) { return n.parent = copy_1; });
            }
            return [copy_1];
        }
        return util_1.flatten(node.children.map(clone));
    }
    return clone;
}
/**
 * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.
 * After moving down the facet node, make a copy of the subtree and make it a child of the main output.
 */
function moveFacetDown(node) {
    if (node instanceof facet_1.FacetNode) {
        if (node.numChildren() === 1 && !(node.children[0] instanceof dataflow_1.OutputNode)) {
            // move down until we hit a fork or output node
            var child = node.children[0];
            if (child instanceof aggregate_1.AggregateNode || child instanceof stack_1.StackNode) {
                child.addDimensions(node.fields);
            }
            child.swapWithParent();
            moveFacetDown(node);
        }
        else {
            // move main to facet
            moveMainDownToFacet(node.model.component.data.main);
            // replicate the subtree and place it before the facet's main node
            var copy = util_1.flatten(node.children.map(cloneSubtree(node)));
            copy.forEach(function (c) { return c.parent = node.model.component.data.main; });
        }
    }
    else {
        node.children.forEach(moveFacetDown);
    }
}
function moveMainDownToFacet(node) {
    if (node instanceof dataflow_1.OutputNode && node.type === data_1.MAIN) {
        if (node.numChildren() === 1) {
            var child = node.children[0];
            if (!(child instanceof facet_1.FacetNode)) {
                child.swapWithParent();
                moveMainDownToFacet(node);
            }
        }
    }
}
/**
 * Return all leaf nodes.
 */
function getLeaves(roots) {
    var leaves = [];
    function append(node) {
        if (node.numChildren() === 0) {
            leaves.push(node);
        }
        else {
            node.children.forEach(append);
        }
    }
    roots.forEach(append);
    return leaves;
}
/**
 * Print debug information for dataflow tree.
 */
function debug(node) {
    console.log("" + node.constructor.name + (node.debugName ? " (" + node.debugName + ")" : '') + " -> " + (node.children.map(function (c) {
        return "" + c.constructor.name + (c.debugName ? " (" + c.debugName + ")" : '');
    })));
    console.log(node);
    node.children.forEach(debug);
}
function makeWalkTree(data) {
    // to name datasources
    var datasetIndex = 0;
    /**
     * Recursively walk down the tree.
     */
    function walkTree(node, dataSource) {
        if (node instanceof formatparse_1.ParseNode) {
            if (node.parent instanceof source_1.SourceNode && dataSource.format) {
                dataSource.format.parse = node.assemble();
            }
            else {
                throw new Error('Can only instantiate parse next to source.');
            }
        }
        if (node instanceof facet_1.FacetNode) {
            if (!dataSource.name) {
                dataSource.name = "data_" + datasetIndex++;
            }
            if (!dataSource.source || dataSource.transform.length > 0) {
                data.push(dataSource);
                node.data = dataSource.name;
            }
            else {
                node.data = dataSource.source;
            }
            node.assemble().forEach(function (d) { return data.push(d); });
            // break here because the rest of the tree has to be taken care of by the facet.
            return;
        }
        if (node instanceof transforms_1.FilterNode ||
            node instanceof nullfilter_1.NullFilterNode ||
            node instanceof transforms_1.CalculateNode ||
            node instanceof aggregate_1.AggregateNode ||
            node instanceof pathorder_1.OrderNode) {
            dataSource.transform.push(node.assemble());
        }
        if (node instanceof nonpositivefilter_1.NonPositiveFilterNode ||
            node instanceof bin_1.BinNode ||
            node instanceof timeunit_1.TimeUnitNode ||
            node instanceof stack_1.StackNode) {
            dataSource.transform = dataSource.transform.concat(node.assemble());
        }
        if (node instanceof dataflow_1.OutputNode) {
            if (dataSource.source && dataSource.transform.length === 0) {
                node.source = dataSource.source;
            }
            else if (node.parent instanceof dataflow_1.OutputNode) {
                // Note that an output node may be required but we still do not assemble a
                // separate data source for it.
                node.source = dataSource.name;
                throw new Error('cannot happen');
            }
            else {
                if (!dataSource.name) {
                    dataSource.name = "data_" + datasetIndex++;
                }
                // Here we set the name of the datasource we generated. From now on
                // other assemblers can use it.
                node.source = dataSource.name;
                // if this node has more than one child, we will add a datasource automatically
                if (node.numChildren() === 1 && dataSource.transform.length > 0) {
                    data.push(dataSource);
                    var newData = {
                        name: null,
                        source: dataSource.name,
                        transform: []
                    };
                    dataSource = newData;
                }
            }
        }
        switch (node.numChildren()) {
            case 0:
                // done
                if (!dataSource.source || dataSource.transform.length > 0) {
                    // do not push empty datasources that are simply references
                    data.push(dataSource);
                }
                break;
            case 1:
                walkTree(node.children[0], dataSource);
                break;
            default:
                var source_2 = dataSource.name;
                if (!dataSource.source || dataSource.transform.length > 0) {
                    data.push(dataSource);
                }
                else {
                    source_2 = dataSource.source;
                }
                node.children.forEach(function (child) {
                    var newData = {
                        name: null,
                        source: source_2,
                        transform: []
                    };
                    walkTree(child, newData);
                });
                break;
        }
    }
    return walkTree;
}
/**
 * Assemble data sources that are derived from faceted data.
 */
function assembleFacetData(root) {
    var data = [];
    var walkTree = makeWalkTree(data);
    root.children.forEach(function (child) { return walkTree(child, {
        source: root.name,
        name: null,
        transform: []
    }); });
    return data;
}
exports.assembleFacetData = assembleFacetData;
/**
 * Create Vega Data array from a given compiled model and append all of them to the given array
 *
 * @param  model
 * @param  data array
 * @return modified data array
 */
function assembleData(roots) {
    var data = [];
    roots.forEach(removeUnnecessaryNodes);
    // parse needs to be next to sources
    getLeaves(roots).forEach(optimizers_1.optimizeFromLeaves(optimizers.parse));
    roots.forEach(moveFacetDown);
    // roots.forEach(debug);
    var walkTree = makeWalkTree(data);
    var sourceIndex = 0;
    roots.forEach(function (root) {
        // assign a name if the source does not have a name yet
        if (!root.hasName()) {
            root.dataName = "source_" + sourceIndex++;
        }
        var newData = root.assemble();
        walkTree(root, newData);
    });
    return data;
}
exports.assembleData = assembleData;

},{"../../data":106,"../../util":124,"./aggregate":50,"./bin":52,"./dataflow":53,"./facet":54,"./formatparse":55,"./nonpositivefilter":56,"./nullfilter":57,"./optimizers":58,"./pathorder":60,"./source":61,"./stack":62,"./timeunit":63,"./transforms":64}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var bin_1 = require("../../bin");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
function numberFormatExpr(expr, format) {
    return "format(" + expr + ", '" + format + "')";
}
function rangeFormula(model, fieldDef, channel) {
    var discreteDomain = scale_1.hasDiscreteDomain(model.scale(channel).type);
    if (discreteDomain) {
        // read format from axis or legend, if there is no format then use config.numberFormat
        var format = (model.axis(channel) || model.legend(channel) || {}).format ||
            model.config.numberFormat;
        var startField = fielddef_1.field(fieldDef, { datum: true, binSuffix: 'start' });
        var endField = fielddef_1.field(fieldDef, { datum: true, binSuffix: 'end' });
        return {
            formulaAs: fielddef_1.field(fieldDef, { binSuffix: 'range' }),
            formula: numberFormatExpr(startField, format) + " + ' - ' + " + numberFormatExpr(endField, format)
        };
    }
    return {};
}
var BinNode = (function (_super) {
    tslib_1.__extends(BinNode, _super);
    function BinNode(bins) {
        var _this = _super.call(this) || this;
        _this.bins = bins;
        return _this;
    }
    BinNode.prototype.clone = function () {
        return new BinNode(util_1.duplicate(this.bins));
    };
    BinNode.make = function (model) {
        var bins = model.reduceFieldDef(function (binComponent, fieldDef, channel) {
            var fieldDefBin = model.fieldDef(channel).bin;
            if (fieldDefBin) {
                var bin = util_1.isBoolean(fieldDefBin) ? {} : fieldDefBin;
                var key = bin_1.binToString(fieldDef.bin) + "_" + fieldDef.field;
                if (!(key in binComponent)) {
                    binComponent[key] = {
                        bin: bin,
                        field: fieldDef.field,
                        as: [fielddef_1.field(fieldDef, { binSuffix: 'start' }), fielddef_1.field(fieldDef, { binSuffix: 'end' })],
                        signal: util_1.varName(model.getName(key + "_bins")),
                        extentSignal: model.getName(key + '_extent')
                    };
                }
                binComponent[key] = tslib_1.__assign({}, binComponent[key], rangeFormula(model, fieldDef, channel));
            }
            return binComponent;
        }, {});
        if (Object.keys(bins).length === 0) {
            return null;
        }
        return new BinNode(bins);
    };
    BinNode.prototype.merge = function (other) {
        this.bins = util_1.extend(other.bins);
        other.remove();
    };
    BinNode.prototype.producedFields = function () {
        var out = {};
        util_1.vals(this.bins).forEach(function (c) {
            c.as.forEach(function (f) { return out[f] = true; });
        });
        return out;
    };
    BinNode.prototype.dependentFields = function () {
        var out = {};
        util_1.vals(this.bins).forEach(function (c) {
            out[c.field] = true;
        });
        return out;
    };
    BinNode.prototype.assemble = function () {
        return util_1.flatten(util_1.vals(this.bins).map(function (bin) {
            var transform = [];
            var binTrans = tslib_1.__assign({ type: 'bin', field: bin.field, as: bin.as, signal: bin.signal }, bin.bin);
            if (!bin.bin.extent) {
                transform.push({
                    type: 'extent',
                    field: bin.field,
                    signal: bin.extentSignal
                });
                binTrans.extent = { signal: bin.extentSignal };
            }
            transform.push(binTrans);
            if (bin.formula) {
                transform.push({
                    type: 'formula',
                    expr: bin.formula,
                    as: bin.formulaAs
                });
            }
            return transform;
        }));
    };
    return BinNode;
}(dataflow_1.DataFlowNode));
exports.BinNode = BinNode;

},{"../../bin":43,"../../fielddef":110,"../../scale":115,"../../util":124,"./dataflow":53,"tslib":38}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * A node in the dataflow tree.
 */
var DataFlowNode = (function () {
    function DataFlowNode(debugName) {
        this.debugName = debugName;
        this._children = [];
        this._parent = null;
    }
    /**
     * Clone this node with a deep copy.
     */
    DataFlowNode.prototype.clone = function () {
        throw new Error('Cannot clone node');
    };
    /**
     * Set of fields that are being created by this node.
     */
    DataFlowNode.prototype.producedFields = function () {
        return {};
    };
    DataFlowNode.prototype.dependentFields = function () {
        return {};
    };
    Object.defineProperty(DataFlowNode.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        /**
         * Set the parent of the node and also add this not to the parent's children.
         */
        set: function (parent) {
            this._parent = parent;
            parent.addChild(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataFlowNode.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    DataFlowNode.prototype.numChildren = function () {
        return this._children.length;
    };
    DataFlowNode.prototype.addChild = function (child) {
        this._children.push(child);
    };
    DataFlowNode.prototype.removeChild = function (oldChild) {
        this._children.splice(this._children.indexOf(oldChild), 1);
    };
    /**
     * Remove node from the dataflow.
     */
    DataFlowNode.prototype.remove = function () {
        var _this = this;
        this._children.forEach(function (child) { return child.parent = _this._parent; });
        this._parent.removeChild(this);
    };
    DataFlowNode.prototype.swapWithParent = function () {
        var parent = this._parent;
        var newParent = parent.parent;
        // reconnect the children
        this._children.forEach(function (c) { return c.parent = parent; });
        // remove old links
        this._children = []; // equivalent to removing every child link one by one
        parent.removeChild(this);
        parent.parent.removeChild(parent);
        // swap two nodes
        this.parent = newParent;
        parent.parent = this;
    };
    return DataFlowNode;
}());
exports.DataFlowNode = DataFlowNode;
var OutputNode = (function (_super) {
    tslib_1.__extends(OutputNode, _super);
    function OutputNode(source, type) {
        var _this = _super.call(this, source) || this;
        _this.type = type;
        _this._refcount = 0;
        _this._source = source;
        return _this;
    }
    OutputNode.prototype.clone = function () {
        var cloneObj = new this.constructor;
        cloneObj._source = this._source;
        cloneObj.debugName = 'clone_' + this.debugName;
        cloneObj._refcount = this._refcount;
        return cloneObj;
    };
    Object.defineProperty(OutputNode.prototype, "source", {
        /**
         * Request the datasource name.
         *
         * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
         * It is crucial to request the name from an output node to mark it as a required node.
         * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
         *
         * In the assemble phase, this will return the correct name.
         */
        get: function () {
            this._refcount++;
            return this._source;
        },
        set: function (source) {
            this._source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OutputNode.prototype, "required", {
        get: function () {
            return this._refcount > 0;
        },
        enumerable: true,
        configurable: true
    });
    return OutputNode;
}(DataFlowNode));
exports.OutputNode = OutputNode;

},{"tslib":38}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var dataflow_1 = require("./dataflow");
/**
 * A node that helps us track what fields we are faceting by.
 */
var FacetNode = (function (_super) {
    tslib_1.__extends(FacetNode, _super);
    /**
     * @param model The facet model.
     * @param name The name that this facet source will have.
     * @param data The source data for this facet data.
     */
    function FacetNode(model, name, data) {
        var _this = _super.call(this) || this;
        _this.model = model;
        _this.name = name;
        _this.data = data;
        if (model.facet.column) {
            _this.columnField = model.field(channel_1.COLUMN);
            _this.columnName = model.getName('column');
        }
        if (model.facet.row) {
            _this.rowField = model.field(channel_1.ROW);
            _this.rowName = model.getName('row');
        }
        return _this;
    }
    Object.defineProperty(FacetNode.prototype, "fields", {
        get: function () {
            var fields = [];
            if (this.columnField) {
                fields.push(this.columnField);
            }
            if (this.rowField) {
                fields.push(this.rowField);
            }
            return fields;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FacetNode.prototype, "source", {
        /**
         * The name to reference this source is its name
         */
        get: function () {
            return this.name;
        },
        enumerable: true,
        configurable: true
    });
    FacetNode.prototype.assemble = function () {
        var data = [];
        if (this.columnName) {
            data.push({
                name: this.columnName,
                source: this.data,
                transform: [{
                        type: 'aggregate',
                        groupby: [this.columnField]
                    }]
            });
        }
        if (this.rowName) {
            data.push({
                name: this.rowName,
                source: this.data,
                transform: [{
                        type: 'aggregate',
                        groupby: [this.rowField]
                    }]
            });
        }
        return data;
    };
    return FacetNode;
}(dataflow_1.DataFlowNode));
exports.FacetNode = FacetNode;

},{"../../channel":44,"./dataflow":53,"tslib":38}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var data_1 = require("../../data");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var filter_1 = require("../../filter");
var type_1 = require("../../type");
var util_1 = require("../../util");
var transform_1 = require("../../transform");
var dataflow_1 = require("./dataflow");
var ParseNode = (function (_super) {
    tslib_1.__extends(ParseNode, _super);
    function ParseNode(parse) {
        var _this = _super.call(this) || this;
        _this._parse = {};
        _this._parse = parse;
        return _this;
    }
    ParseNode.make = function (model) {
        var parse = {};
        var calcFieldMap = model.transforms.filter(transform_1.isCalculate).reduce(function (fieldMap, formula) {
            fieldMap[formula.as] = true;
            return fieldMap;
        }, {});
        // Parse filter fields
        model.transforms.filter(transform_1.isFilter).forEach(function (transform) {
            var filter = transform.filter;
            if (!util_1.isArray(filter)) {
                filter = [filter];
            }
            filter.forEach(function (f) {
                var val = null;
                // For EqualFilter, just use the equal property.
                // For RangeFilter and OneOfFilter, all array members should have
                // the same type, so we only use the first one.
                if (filter_1.isEqualFilter(f)) {
                    val = f.equal;
                }
                else if (filter_1.isRangeFilter(f)) {
                    val = f.range[0];
                }
                else if (filter_1.isOneOfFilter(f)) {
                    val = (f.oneOf || f['in'])[0];
                } // else -- for filter expression, we can't infer anything
                if (val) {
                    if (datetime_1.isDateTime(val)) {
                        parse[f['field']] = 'date';
                    }
                    else if (util_1.isNumber(val)) {
                        parse[f['field']] = 'number';
                    }
                    else if (util_1.isString(val)) {
                        parse[f['field']] = 'string';
                    }
                }
            });
        });
        // Parse encoded fields
        model.forEachFieldDef(function (fieldDef) {
            if (fieldDef.type === type_1.TEMPORAL) {
                parse[fieldDef.field] = 'date';
            }
            else if (fieldDef.type === type_1.QUANTITATIVE) {
                if (fielddef_1.isCount(fieldDef) || calcFieldMap[fieldDef.field]) {
                    return;
                }
                parse[fieldDef.field] = 'number';
            }
        });
        // Custom parse should override inferred parse
        var data = model.data;
        if (data && data_1.isUrlData(data) && data.format && data.format.parse) {
            var p_1 = data.format.parse;
            util_1.keys(p_1).forEach(function (field) {
                parse[field] = p_1[field];
            });
        }
        return new ParseNode(parse);
    };
    Object.defineProperty(ParseNode.prototype, "parse", {
        get: function () {
            return this._parse;
        },
        enumerable: true,
        configurable: true
    });
    ParseNode.prototype.merge = function (other) {
        this._parse = util_1.extend(this._parse, other.parse);
        other.remove();
    };
    ParseNode.prototype.assemble = function () {
        return this._parse;
    };
    return ParseNode;
}(dataflow_1.DataFlowNode));
exports.ParseNode = ParseNode;

},{"../../data":106,"../../datetime":107,"../../fielddef":110,"../../filter":111,"../../transform":122,"../../type":123,"../../util":124,"./dataflow":53,"tslib":38}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var NonPositiveFilterNode = (function (_super) {
    tslib_1.__extends(NonPositiveFilterNode, _super);
    function NonPositiveFilterNode(filter) {
        var _this = _super.call(this) || this;
        _this._filter = filter;
        return _this;
    }
    NonPositiveFilterNode.prototype.clone = function () {
        return new NonPositiveFilterNode(util_1.extend({}, this._filter));
    };
    NonPositiveFilterNode.make = function (model) {
        var filter = model.channels().reduce(function (nonPositiveComponent, channel) {
            var scale = model.scale(channel);
            if (!scale || !model.field(channel)) {
                // don't set anything
                return nonPositiveComponent;
            }
            nonPositiveComponent[model.field(channel)] = scale.type === scale_1.ScaleType.LOG;
            return nonPositiveComponent;
        }, {});
        if (!Object.keys(filter).length) {
            return null;
        }
        return new NonPositiveFilterNode(filter);
    };
    Object.defineProperty(NonPositiveFilterNode.prototype, "filter", {
        get: function () {
            return this._filter;
        },
        enumerable: true,
        configurable: true
    });
    NonPositiveFilterNode.prototype.assemble = function () {
        var _this = this;
        return util_1.keys(this._filter).filter(function (field) {
            // Only filter fields (keys) with value = true
            return _this._filter[field];
        }).map(function (field) {
            return {
                type: 'filter',
                expr: 'datum["' + field + '"] > 0'
            };
        });
    };
    return NonPositiveFilterNode;
}(dataflow_1.DataFlowNode));
exports.NonPositiveFilterNode = NonPositiveFilterNode;

},{"../../scale":115,"../../util":124,"./dataflow":53,"tslib":38}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var type_1 = require("../../type");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var DEFAULT_NULL_FILTERS = {
    nominal: false,
    ordinal: false,
    quantitative: true,
    temporal: true
};
var NullFilterNode = (function (_super) {
    tslib_1.__extends(NullFilterNode, _super);
    function NullFilterNode(fields) {
        var _this = _super.call(this) || this;
        _this._filteredFields = fields;
        return _this;
    }
    NullFilterNode.prototype.clone = function () {
        return new NullFilterNode(util_1.duplicate(this._filteredFields));
    };
    NullFilterNode.make = function (model) {
        var fields = model.reduceFieldDef(function (aggregator, fieldDef) {
            if (fieldDef.aggregate !== 'count') {
                if (model.config.filterInvalid ||
                    (model.config.filterInvalid === undefined && (fieldDef.field && DEFAULT_NULL_FILTERS[fieldDef.type]))) {
                    aggregator[fieldDef.field] = fieldDef;
                }
                else {
                    // define this so we know that we don't filter nulls for this field
                    // this makes it easier to merge into parents
                    aggregator[fieldDef.field] = null;
                }
            }
            return aggregator;
        }, {});
        if (Object.keys(fields).length === 0) {
            return null;
        }
        return new NullFilterNode(fields);
    };
    Object.defineProperty(NullFilterNode.prototype, "filteredFields", {
        get: function () {
            return this._filteredFields;
        },
        enumerable: true,
        configurable: true
    });
    NullFilterNode.prototype.merge = function (other) {
        var _this = this;
        var t = Object.keys(this._filteredFields).map(function (k) { return k + ' ' + util_1.hash(_this._filteredFields[k]); });
        var o = Object.keys(other.filteredFields).map(function (k) { return k + ' ' + util_1.hash(other.filteredFields[k]); });
        if (!util_1.differArray(t, o)) {
            this._filteredFields = util_1.extend(this._filteredFields, other._filteredFields);
            other.remove();
        }
    };
    NullFilterNode.prototype.assemble = function () {
        var _this = this;
        var filters = util_1.keys(this._filteredFields).reduce(function (_filters, field) {
            var fieldDef = _this._filteredFields[field];
            if (fieldDef !== null) {
                _filters.push('datum["' + fieldDef.field + '"] !== null');
                if (util_1.contains([type_1.QUANTITATIVE, type_1.TEMPORAL], fieldDef.type)) {
                    // TODO(https://github.com/vega/vega-lite/issues/1436):
                    // We can be even smarter and add NaN filter for N,O that are numbers
                    // based on the `parse` property once we have it.
                    _filters.push('!isNaN(datum["' + fieldDef.field + '"])');
                }
            }
            return _filters;
        }, []);
        return filters.length > 0 ?
            {
                type: 'filter',
                expr: filters.join(' && ')
            } : null;
    };
    return NullFilterNode;
}(dataflow_1.DataFlowNode));
exports.NullFilterNode = NullFilterNode;

},{"../../type":123,"../../util":124,"./dataflow":53,"tslib":38}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var formatparse_1 = require("./formatparse");
var source_1 = require("./source");
/**
 * Start optimization path at the leaves. Useful for merging up things.
 */
function optimizeFromLeaves(f) {
    function optimizeNextFromLeaves(node) {
        if (node.parent instanceof source_1.SourceNode) {
            return;
        }
        else if (!node || !node.parent) {
            throw new Error('A source node cannot have parents and roots haev to be source nodes.');
        }
        var next = node.parent;
        f(node);
        optimizeNextFromLeaves(next);
    }
    return optimizeNextFromLeaves;
}
exports.optimizeFromLeaves = optimizeFromLeaves;
function parse(node) {
    var parent = node.parent;
    // move parse up by merging or swapping
    if (node instanceof formatparse_1.ParseNode) {
        if (parent instanceof formatparse_1.ParseNode) {
            parent.merge(node);
        }
        else {
            node.swapWithParent();
        }
    }
}
exports.parse = parse;

},{"./formatparse":55,"./source":61}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var data_1 = require("../../data");
var facet_1 = require("../facet");
var unit_1 = require("../unit");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var dataflow_1 = require("./dataflow");
var facet_2 = require("./facet");
var formatparse_1 = require("./formatparse");
var nonpositivefilter_1 = require("./nonpositivefilter");
var nullfilter_1 = require("./nullfilter");
var pathorder_1 = require("./pathorder");
var source_1 = require("./source");
var stack_1 = require("./stack");
var timeunit_1 = require("./timeunit");
var transforms_1 = require("./transforms");
function parseRoot(model, sources) {
    if (model.data || !model.parent) {
        // if the model defines a data source or is the root, create a source node
        var source = new source_1.SourceNode(model);
        var hash = source.hash();
        if (hash in sources) {
            // use a reference if we already have a source
            return sources[hash];
        }
        else {
            // otherwise add a new one
            sources[hash] = source;
            return source;
        }
    }
    else {
        // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.
        return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
    }
}
/*
Description of the dataflow (http://asciiflow.com/):

     +--------+
     | Source |
     +---+----+
         |
         v
       Parse
         |
         v
     Transforms
(Filter, Compute, ...)
         |
         v
     Null Filter
         |
         v
      Binning
         |
         v
     Timeunit
         |
         v
      +--+--+
      | Raw |
      +-----+
         |
         v
     Aggregate
         |
         v
       Stack
         |
         v
      >0 Filter
         |
         v
     Path Order
         |
         v
   +----------+
   |   Main   +----> Layout
   +----------+
         |
         v
     +-------+
     | Facet |----> Child data...
     +-------+

*/
function parseData(model) {
    var root = parseRoot(model, model.component.data.sources);
    var outputNodes = model.component.data.outputNodes;
    // the current head of the tree that we are appending to
    var head = root;
    var parse = formatparse_1.ParseNode.make(model);
    parse.parent = root;
    head = parse;
    if (model.transforms.length > 0) {
        var _a = transforms_1.parseTransformArray(model), first = _a.first, last = _a.last;
        first.parent = head;
        head = last;
    }
    var nullFilter = nullfilter_1.NullFilterNode.make(model);
    if (nullFilter) {
        nullFilter.parent = head;
        head = nullFilter;
    }
    var bin = bin_1.BinNode.make(model);
    if (bin) {
        bin.parent = head;
        head = bin;
    }
    var tu = timeunit_1.TimeUnitNode.make(model);
    if (tu) {
        tu.parent = head;
        head = tu;
    }
    // add an output node pre aggregation
    var rawName = model.getName(data_1.RAW);
    var raw = new dataflow_1.OutputNode(rawName, data_1.RAW);
    outputNodes[rawName] = raw;
    raw.parent = head;
    head = raw;
    if (model instanceof unit_1.UnitModel) {
        var agg = aggregate_1.AggregateNode.make(model);
        if (agg) {
            agg.parent = head;
            head = agg;
        }
    }
    if (model instanceof unit_1.UnitModel) {
        var stack = stack_1.StackNode.make(model);
        if (stack) {
            stack.parent = head;
            head = stack;
        }
    }
    var nonPosFilter = nonpositivefilter_1.NonPositiveFilterNode.make(model);
    if (nonPosFilter) {
        nonPosFilter.parent = head;
        head = nonPosFilter;
    }
    if (model instanceof unit_1.UnitModel) {
        var order = pathorder_1.OrderNode.make(model);
        if (order) {
            order.parent = head;
            head = order;
        }
    }
    // output node for marks
    var mainName = model.getName(data_1.MAIN);
    var main = new dataflow_1.OutputNode(mainName, data_1.MAIN);
    outputNodes[mainName] = main;
    main.parent = head;
    head = main;
    // add facet marker
    var facetRoot = null;
    if (model instanceof facet_1.FacetModel) {
        var facetName = model.getName('facet');
        facetRoot = new facet_2.FacetNode(model, facetName, main.source);
        outputNodes[facetName] = facetRoot;
        facetRoot.parent = head;
        head = facetRoot;
    }
    return {
        sources: model.component.data.sources,
        outputNodes: outputNodes,
        main: main,
        facetRoot: facetRoot
    };
}
exports.parseData = parseData;

},{"../../data":106,"../facet":65,"../unit":103,"./aggregate":50,"./bin":52,"./dataflow":53,"./facet":54,"./formatparse":55,"./nonpositivefilter":56,"./nullfilter":57,"./pathorder":60,"./source":61,"./stack":62,"./timeunit":63,"./transforms":64}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var encoding_1 = require("../../encoding");
var fielddef_1 = require("../../fielddef");
var sort_1 = require("../../sort");
var util_1 = require("../../util");
var common_1 = require("../common");
var dataflow_1 = require("./dataflow");
var OrderNode = (function (_super) {
    tslib_1.__extends(OrderNode, _super);
    function OrderNode(sort) {
        var _this = _super.call(this) || this;
        _this.sort = sort;
        return _this;
    }
    OrderNode.prototype.clone = function () {
        return new OrderNode(util_1.duplicate(this.sort));
    };
    OrderNode.make = function (model) {
        var sort = null;
        if (util_1.contains(['line', 'area'], model.mark())) {
            if (model.mark() === 'line' && model.channelHasField('order')) {
                // For only line, sort by the order field if it is specified.
                sort = common_1.sortParams(model.encoding.order);
            }
            else {
                // For both line and area, we sort values based on dimension by default
                var dimensionChannel = model.markDef.orient === 'horizontal' ? 'y' : 'x';
                var s = model.sort(dimensionChannel);
                var sortField = sort_1.isSortField(s) ?
                    fielddef_1.field({
                        // FIXME: this op might not already exist?
                        // FIXME: what if dimensionChannel (x or y) contains custom domain?
                        aggregate: encoding_1.isAggregate(model.encoding) ? s.op : undefined,
                        field: s.field
                    }) :
                    model.field(dimensionChannel, { binSuffix: 'start' });
                sort = {
                    field: sortField,
                    order: 'descending'
                };
            }
        }
        else {
            return null;
        }
        return new OrderNode(sort);
    };
    OrderNode.prototype.assemble = function () {
        return {
            type: 'collect',
            sort: this.sort
        };
    };
    return OrderNode;
}(dataflow_1.DataFlowNode));
exports.OrderNode = OrderNode;

},{"../../encoding":108,"../../fielddef":110,"../../sort":117,"../../util":124,"../common":48,"./dataflow":53,"tslib":38}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var data_1 = require("../../data");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var SourceNode = (function (_super) {
    tslib_1.__extends(SourceNode, _super);
    function SourceNode(model) {
        var _this = _super.call(this) || this;
        var data = model.data || { name: 'source' };
        if (data_1.isInlineData(data)) {
            _this._data = {
                values: data.values,
                format: { type: 'json' }
            };
        }
        else if (data_1.isUrlData(data)) {
            // Extract extension from URL using snippet from
            // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript
            var defaultExtension = /(?:\.([^.]+))?$/.exec(data.url)[1];
            if (!util_1.contains(['json', 'csv', 'tsv', 'topojson'], defaultExtension)) {
                defaultExtension = 'json';
            }
            var dataFormat = data.format || {};
            // For backward compatibility for former `data.formatType` property
            var formatType = dataFormat.type || data['formatType'];
            var property = dataFormat.property, feature = dataFormat.feature, mesh = dataFormat.mesh;
            var format = tslib_1.__assign({ type: formatType ? formatType : defaultExtension }, (property ? { property: property } : {}), (feature ? { feature: feature } : {}), (mesh ? { mesh: mesh } : {}));
            _this._data = {
                url: data.url,
                format: format
            };
        }
        else if (data_1.isNamedData(data)) {
            _this._name = data.name;
        }
        return _this;
    }
    Object.defineProperty(SourceNode.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    SourceNode.prototype.hasName = function () {
        return !!this._name;
    };
    Object.defineProperty(SourceNode.prototype, "dataName", {
        get: function () {
            return this._name;
        },
        set: function (name) {
            this._name = name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return a unique identifir for this data source.
     */
    SourceNode.prototype.hash = function () {
        if (data_1.isInlineData(this._data)) {
            return util_1.hash(this._data);
        }
        else if (data_1.isUrlData) {
            return this._data.url + " " + util_1.hash(this._data.format);
        }
        else if (data_1.isNamedData) {
            return this._data.name;
        }
        throw new Error('Unsupported source');
    };
    SourceNode.prototype.assemble = function () {
        return tslib_1.__assign({ name: this._name }, this._data, { transform: [] });
    };
    return SourceNode;
}(dataflow_1.DataFlowNode));
exports.SourceNode = SourceNode;

},{"../../data":106,"../../util":124,"./dataflow":53,"tslib":38}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var common_1 = require("../common");
var dataflow_1 = require("./dataflow");
function getStackByFields(model) {
    return model.stack.stackBy.reduce(function (fields, by) {
        var channel = by.channel;
        var fieldDef = by.fieldDef;
        var scale = model.scale(channel);
        var _field = fielddef_1.field(fieldDef, {
            binSuffix: scale && scale_1.hasDiscreteDomain(scale.type) ? 'range' : 'start'
        });
        if (_field) {
            fields.push(_field);
        }
        return fields;
    }, []);
}
var StackNode = (function (_super) {
    tslib_1.__extends(StackNode, _super);
    function StackNode(stack) {
        var _this = _super.call(this) || this;
        _this._stack = stack;
        return _this;
    }
    StackNode.prototype.clone = function () {
        return new StackNode(util_1.duplicate(this._stack));
    };
    StackNode.make = function (model) {
        var stackProperties = model.stack;
        if (!stackProperties) {
            return null;
        }
        var groupby = [];
        if (stackProperties.groupbyChannel) {
            var groupbyFieldDef = model.fieldDef(stackProperties.groupbyChannel);
            if (groupbyFieldDef.bin) {
                // For Bin, we need to add both start and end to ensure that both get imputed
                // and included in the stack output (https://github.com/vega/vega-lite/issues/1805).
                groupby.push(model.field(stackProperties.groupbyChannel, { binSuffix: 'start' }));
                groupby.push(model.field(stackProperties.groupbyChannel, { binSuffix: 'end' }));
            }
            else {
                groupby.push(model.field(stackProperties.groupbyChannel));
            }
        }
        var stackby = getStackByFields(model);
        var orderDef = model.encoding.order;
        var sort;
        if (orderDef) {
            sort = common_1.sortParams(orderDef);
        }
        else {
            // default = descending by stackFields
            // FIXME is the default here correct for binned fields?
            sort = stackby.reduce(function (s, field) {
                s.field.push(field);
                s.order.push('descending');
                return s;
            }, { field: [], order: [] });
        }
        return new StackNode({
            groupby: groupby,
            field: model.field(stackProperties.fieldChannel),
            stackby: stackby,
            sort: sort,
            offset: stackProperties.offset,
            impute: util_1.contains(['area', 'line'], model.mark()),
        });
    };
    Object.defineProperty(StackNode.prototype, "stack", {
        get: function () {
            return this._stack;
        },
        enumerable: true,
        configurable: true
    });
    StackNode.prototype.addDimensions = function (fields) {
        this._stack.groupby = this._stack.groupby.concat(fields);
    };
    StackNode.prototype.dependentFields = function () {
        var out = {};
        out[this._stack.field] = true;
        this._stack.groupby.forEach(function (f) { return out[f] = true; });
        var field = this._stack.sort.field;
        vega_util_1.isArray(field) ? field.forEach(function (f) { return out[f] = true; }) : out[field] = true;
        return out;
    };
    StackNode.prototype.producedFields = function () {
        var out = {};
        out[this._stack.field + '_start'] = true;
        out[this._stack.field + '_end'] = true;
        return out;
    };
    StackNode.prototype.assemble = function () {
        var transform = [];
        var stack = this._stack;
        // Impute
        if (stack.impute) {
            transform.push({
                type: 'impute',
                field: stack.field,
                groupby: stack.stackby,
                orderby: stack.groupby,
                method: 'value',
                value: 0
            });
        }
        // Stack
        transform.push({
            type: 'stack',
            groupby: stack.groupby,
            field: stack.field,
            sort: stack.sort,
            as: [
                stack.field + '_start',
                stack.field + '_end'
            ],
            offset: stack.offset
        });
        return transform;
    };
    return StackNode;
}(dataflow_1.DataFlowNode));
exports.StackNode = StackNode;

},{"../../fielddef":110,"../../scale":115,"../../util":124,"../common":48,"./dataflow":53,"tslib":38,"vega-util":128}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fielddef_1 = require("../../fielddef");
var timeunit_1 = require("../../timeunit");
var type_1 = require("../../type");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var TimeUnitNode = (function (_super) {
    tslib_1.__extends(TimeUnitNode, _super);
    function TimeUnitNode(formula) {
        var _this = _super.call(this) || this;
        _this.formula = formula;
        return _this;
    }
    TimeUnitNode.prototype.clone = function () {
        return new TimeUnitNode(util_1.duplicate(this.formula));
    };
    TimeUnitNode.make = function (model) {
        var formula = model.reduceFieldDef(function (timeUnitComponent, fieldDef) {
            if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {
                var f = fielddef_1.field(fieldDef);
                timeUnitComponent[f] = {
                    as: f,
                    timeUnit: fieldDef.timeUnit,
                    field: fieldDef.field
                };
            }
            return timeUnitComponent;
        }, {});
        if (Object.keys(formula).length === 0) {
            return null;
        }
        return new TimeUnitNode(formula);
    };
    TimeUnitNode.prototype.merge = function (other) {
        this.formula = util_1.extend(this.formula, other.formula);
        other.remove();
    };
    TimeUnitNode.prototype.producedFields = function () {
        var out = {};
        util_1.vals(this.formula).forEach(function (f) {
            out[f.as] = true;
        });
        return out;
    };
    TimeUnitNode.prototype.dependentFields = function () {
        var out = {};
        util_1.vals(this.formula).forEach(function (f) {
            out[f.field] = true;
        });
        return out;
    };
    TimeUnitNode.prototype.assemble = function () {
        return util_1.vals(this.formula).map(function (c) {
            return {
                type: 'formula',
                as: c.as,
                expr: timeunit_1.fieldExpr(c.timeUnit, c.field)
            };
        });
    };
    return TimeUnitNode;
}(dataflow_1.DataFlowNode));
exports.TimeUnitNode = TimeUnitNode;

},{"../../fielddef":110,"../../timeunit":120,"../../type":123,"../../util":124,"./dataflow":53,"tslib":38}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var filter_1 = require("../../filter");
var log = require("../../log");
var transform_1 = require("../../transform");
var util_1 = require("../../util");
var dataflow_1 = require("./dataflow");
var FilterNode = (function (_super) {
    tslib_1.__extends(FilterNode, _super);
    function FilterNode(filter) {
        var _this = _super.call(this) || this;
        _this.filter = filter;
        return _this;
    }
    FilterNode.prototype.clone = function () {
        return new FilterNode(util_1.duplicate(this.filter));
    };
    FilterNode.prototype.merge = function (other) {
        this.filter = (vega_util_1.isArray(this.filter) ? this.filter : [this.filter]).concat(vega_util_1.isArray(other.filter) ? other.filter : [other.filter]);
        this.remove();
    };
    FilterNode.prototype.assemble = function () {
        return {
            type: 'filter',
            expr: filter_1.expression(this.filter)
        };
    };
    return FilterNode;
}(dataflow_1.DataFlowNode));
exports.FilterNode = FilterNode;
/**
 * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.
 */
var CalculateNode = (function (_super) {
    tslib_1.__extends(CalculateNode, _super);
    function CalculateNode(transform) {
        var _this = _super.call(this) || this;
        _this.transform = transform;
        return _this;
    }
    CalculateNode.prototype.clone = function () {
        return new CalculateNode(util_1.duplicate(this.transform));
    };
    CalculateNode.prototype.producedFields = function () {
        var out = {};
        out[this.transform.as] = true;
        return out;
    };
    CalculateNode.prototype.assemble = function () {
        return {
            type: 'formula',
            expr: this.transform.calculate,
            as: this.transform.as
        };
    };
    return CalculateNode;
}(dataflow_1.DataFlowNode));
exports.CalculateNode = CalculateNode;
/**
 * Parses a transforms array into a chain of connected dataflow nodes.
 */
function parseTransformArray(model) {
    var first;
    var last;
    var node;
    var previous;
    model.transforms.forEach(function (t, i) {
        if (transform_1.isCalculate(t)) {
            node = new CalculateNode(t);
        }
        else if (transform_1.isFilter(t)) {
            node = new FilterNode(t.filter);
        }
        else {
            log.warn(log.message.invalidTransformIgnored(t));
            return;
        }
        if (i === 0) {
            first = node;
        }
        else {
            node.parent = previous;
        }
        previous = node;
    });
    last = node;
    return { first: first, last: last };
}
exports.parseTransformArray = parseTransformArray;

},{"../../filter":111,"../../log":113,"../../transform":122,"../../util":124,"./dataflow":53,"tslib":38,"vega-util":128}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var data_1 = require("../data");
var encoding_1 = require("../encoding");
var fielddef_1 = require("../fielddef");
var log = require("../log");
var util_1 = require("../util");
var vega_schema_1 = require("../vega.schema");
var parse_1 = require("./axis/parse");
var rules_1 = require("./axis/rules");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_2 = require("./data/parse");
var layout_1 = require("./layout");
var model_1 = require("./model");
var init_1 = require("./scale/init");
var parse_3 = require("./scale/parse");
var FacetModel = (function (_super) {
    tslib_1.__extends(FacetModel, _super);
    function FacetModel(spec, parent, parentGivenName, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.scales = {};
        _this.axes = {};
        _this.legends = {};
        _this.stack = null;
        _this._spacing = {};
        var child = _this.child = common_1.buildModel(spec.spec, _this, _this.getName('child'), config);
        _this.children = [child];
        var facet = _this.facet = _this.initFacet(spec.facet);
        _this.scales = _this.initScalesAndSpacing(facet, _this.config);
        _this.axes = _this.initAxis(facet, _this.config, child);
        _this.legends = {};
        return _this;
    }
    FacetModel.prototype.initFacet = function (facet) {
        // clone to prevent side effect to the original spec
        return encoding_1.reduce(facet, function (normalizedFacet, fieldDef, channel) {
            if (!util_1.contains([channel_1.ROW, channel_1.COLUMN], channel)) {
                // Drop unsupported channel
                log.warn(log.message.incompatibleChannel(channel, 'facet'));
                return normalizedFacet;
            }
            // TODO: array of row / column ?
            if (fieldDef.field === undefined) {
                log.warn(log.message.emptyFieldDef(fieldDef, channel));
                return normalizedFacet;
            }
            // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.
            normalizedFacet[channel] = fielddef_1.normalize(fieldDef, channel);
            return normalizedFacet;
        }, {});
    };
    FacetModel.prototype.initScalesAndSpacing = function (facet, config) {
        var model = this;
        return [channel_1.ROW, channel_1.COLUMN].reduce(function (_scale, channel) {
            if (facet[channel]) {
                _scale[channel] = init_1.default(channel, facet[channel], config, undefined, // Facet doesn't have one single mark
                undefined, // TODO(#1647): support width / height here
                [] // There is no xyRangeSteps here and there is no need to input
                );
                model._spacing[channel] = spacing(facet[channel].scale || {}, model, config);
            }
            return _scale;
        }, {});
    };
    FacetModel.prototype.initAxis = function (facet, config, child) {
        var model = this;
        return [channel_1.ROW, channel_1.COLUMN].reduce(function (_axis, channel) {
            if (facet[channel]) {
                var axisSpec = facet[channel].axis;
                if (axisSpec !== false) {
                    var axisConfig = config.facet !== undefined && config.facet.axis !== undefined ? config.facet.axis : {};
                    var modelAxis = _axis[channel] = tslib_1.__assign({}, axisSpec, axisConfig);
                    if (channel === channel_1.ROW) {
                        var yAxis = child.axis(channel_1.Y);
                        if (yAxis && yAxis.orient !== 'right' && modelAxis.orient === undefined) {
                            modelAxis.orient = 'right';
                        }
                        if (model.hasDescendantWithFieldOnChannel(channel_1.X) && modelAxis.labelAngle === undefined) {
                            modelAxis.labelAngle = modelAxis.orient === 'right' ? 90 : 270;
                        }
                    }
                }
            }
            return _axis;
        }, {});
    };
    FacetModel.prototype.channelHasField = function (channel) {
        return !!this.facet[channel];
    };
    FacetModel.prototype.fieldDef = function (channel) {
        return this.facet[channel];
    };
    FacetModel.prototype.parseData = function () {
        this.component.data = parse_2.parseData(this);
        this.child.parseData();
    };
    FacetModel.prototype.parseSelection = function () {
        // TODO: @arvind can write this
        // We might need to split this into compileSelectionData and compileSelectionSignals?
    };
    FacetModel.prototype.parseLayoutData = function () {
        this.child.parseLayoutData();
        this.component.layout = layout_1.parseFacetLayout(this);
    };
    FacetModel.prototype.parseScale = function () {
        var _this = this;
        var child = this.child;
        var model = this;
        child.parseScale();
        // First, add scale for row and column.
        var scaleComponent = this.component.scales = parse_3.default(this);
        // Then, move shared/union from its child spec.
        util_1.keys(child.component.scales).forEach(function (channel) {
            // TODO: correctly implement independent scale
            if (true) {
                var scale = scaleComponent[channel] = child.component.scales[channel];
                var scaleNameWithoutPrefix = scale.name.substr(child.getName('').length);
                var newName = model.scaleName(scaleNameWithoutPrefix, true);
                child.renameScale(scale.name, newName);
                scale.name = newName;
                // Replace the scale domain with data output from a cloned subtree after the facet.
                var domain = scale.domain;
                if (vega_schema_1.isDataRefDomain(domain) || vega_schema_1.isFieldRefUnionDomain(domain)) {
                    domain.data = assemble_1.FACET_SCALE_PREFIX + _this.getName(domain.data);
                }
                else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
                    domain.fields = domain.fields.map(function (f) {
                        return tslib_1.__assign({}, f, { data: assemble_1.FACET_SCALE_PREFIX + _this.getName(f.data) });
                    });
                }
                // Once put in parent, just remove the child's scale.
                delete child.component.scales[channel];
            }
        });
    };
    FacetModel.prototype.parseMark = function () {
        this.child.parseMark();
        this.component.mark = [{
                name: this.getName('cell'),
                type: 'group',
                from: {
                    facet: {
                        name: this.component.data.facetRoot.name,
                        data: this.component.data.facetRoot.data,
                        groupby: [].concat(this.channelHasField(channel_1.ROW) ? [this.field(channel_1.ROW)] : [], this.channelHasField(channel_1.COLUMN) ? [this.field(channel_1.COLUMN)] : [])
                    }
                },
                encode: {
                    update: getFacetGroupProperties(this)
                }
            }];
    };
    FacetModel.prototype.parseAxis = function () {
        this.child.parseAxis();
        this.component.axes = parse_1.parseAxisComponent(this, [channel_1.ROW, channel_1.COLUMN]);
    };
    FacetModel.prototype.parseAxisGroup = function () {
        // TODO: with nesting, we might need to consider calling child
        // this.child.parseAxisGroup();
        var xAxisGroup = parseAxisGroups(this, channel_1.X);
        var yAxisGroup = parseAxisGroups(this, channel_1.Y);
        this.component.axisGroups = util_1.extend(xAxisGroup ? { x: xAxisGroup } : {}, yAxisGroup ? { y: yAxisGroup } : {});
    };
    FacetModel.prototype.parseGridGroup = function () {
        // TODO: with nesting, we might need to consider calling child
        // this.child.parseGridGroup();
        var child = this.child;
        this.component.gridGroups = util_1.extend(!child.channelHasField(channel_1.X) && this.channelHasField(channel_1.COLUMN) ? { column: getColumnGridGroups(this) } : {}, !child.channelHasField(channel_1.Y) && this.channelHasField(channel_1.ROW) ? { row: getRowGridGroups(this) } : {});
    };
    FacetModel.prototype.parseLegend = function () {
        this.child.parseLegend();
        // TODO: support legend for independent non-position scale across facets
        // TODO: support legend for field reference of parent data (e.g., for SPLOM)
        // For now, assuming that non-positional scales are always shared across facets
        // Thus, just move all legends from its child
        this.component.legends = this.child.component.legends;
        this.child.component.legends = {};
    };
    FacetModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    FacetModel.prototype.assembleParentGroupProperties = function () {
        return null;
    };
    FacetModel.prototype.assembleSignals = function (signals) {
        return [];
    };
    FacetModel.prototype.assembleSelectionData = function (data) {
        return [];
    };
    FacetModel.prototype.assembleLayout = function (layoutData) {
        // Postfix traversal – layout is assembled bottom-up
        this.child.assembleLayout(layoutData);
        return layout_1.assembleLayout(this, layoutData);
    };
    FacetModel.prototype.assembleMarks = function () {
        var data = assemble_1.assembleFacetData(this.component.data.facetRoot);
        var mark = this.component.mark[0];
        // correct the name of the faceted data source
        mark.from.facet.name = this.component.data.facetRoot.name;
        mark.from.facet.data = this.component.data.facetRoot.data;
        var marks = [].concat(
        // axisGroup is a mapping to VgMarkGroup
        util_1.vals(this.component.axisGroups), util_1.flatten(util_1.vals(this.component.gridGroups)), util_1.extend(mark, data.length > 0 ? { data: data } : {}, this.child.assembleGroup()));
        return marks.map(this.correctDataNames);
    };
    FacetModel.prototype.channels = function () {
        return [channel_1.ROW, channel_1.COLUMN];
    };
    FacetModel.prototype.getMapping = function () {
        return this.facet;
    };
    FacetModel.prototype.spacing = function (channel) {
        return this._spacing[channel];
    };
    FacetModel.prototype.isFacet = function () {
        return true;
    };
    return FacetModel;
}(model_1.Model));
exports.FacetModel = FacetModel;
function hasSubPlotWithXy(model) {
    return model.hasDescendantWithFieldOnChannel('x') ||
        model.hasDescendantWithFieldOnChannel('y');
}
exports.hasSubPlotWithXy = hasSubPlotWithXy;
function spacing(scale, model, config) {
    if (scale.spacing !== undefined) {
        return scale.spacing;
    }
    if (!hasSubPlotWithXy(model)) {
        // If there is no subplot with x/y, it's a simple table so there should be no spacing.
        return 0;
    }
    return config.scale.facetSpacing;
}
exports.spacing = spacing;
function getFacetGroupProperties(model) {
    var child = model.child;
    var mergedCellConfig = util_1.extend({}, child.config.cell, child.config.facet.cell);
    return util_1.extend({
        x: model.channelHasField(channel_1.COLUMN) ? {
            scale: model.scaleName(channel_1.COLUMN),
            field: model.field(channel_1.COLUMN),
            // offset by the spacing / 2
            offset: model.spacing(channel_1.COLUMN) / 2
        } : { value: model.config.scale.facetSpacing / 2 },
        y: model.channelHasField(channel_1.ROW) ? {
            scale: model.scaleName(channel_1.ROW),
            field: model.field(channel_1.ROW),
            // offset by the spacing / 2
            offset: model.spacing(channel_1.ROW) / 2
        } : { value: model.config.scale.facetSpacing / 2 },
        width: { field: { parent: model.child.sizeName('width') } },
        height: { field: { parent: model.child.sizeName('height') } }
    }, hasSubPlotWithXy(model) ? child.assembleParentGroupProperties(mergedCellConfig) : {});
}
// TODO: move the rest of the file src/compile/facet/*.ts
function parseAxisGroups(model, channel) {
    // TODO: add a case where inner spec is not a unit (facet/layer/concat)
    var axisGroup = null;
    var child = model.child;
    if (child.channelHasField(channel)) {
        if (child.axis(channel)) {
            if (true) {
                // add a group for the shared axes
                axisGroup = getSharedAxisGroup(model, channel);
                if (child.axis(channel) && rules_1.gridShow(child, channel)) {
                    // add inner axis (aka axis that shows only grid to )
                    child.component.axes[channel] = [parse_1.parseGridAxis(channel, child)];
                }
                else {
                    // Delete existing child axes
                    delete child.component.axes[channel];
                }
            }
            else {
                // TODO: implement independent axes support
            }
        }
    }
    return axisGroup;
}
function getSharedAxisGroup(model, channel) {
    var isX = channel === 'x';
    var facetChannel = isX ? 'column' : 'row';
    var hasFacet = !!model.facet[facetChannel];
    var axesGroup = {
        name: model.getName(channel + '-axes'),
        type: 'group'
    };
    if (hasFacet) {
        // Need to drive this with special data source that has one item for each column/row value.
        // TODO: We might only need to drive this with special data source if there are both row and column
        // However, it might be slightly difficult as we have to merge this with the main group.
        axesGroup.from = { data: channel === 'x' ? model.getName('column') : model.getName('row') };
    }
    if (isX) {
        axesGroup.encode = {
            update: {
                width: { field: { parent: model.child.sizeName('width') } },
                height: { field: { group: 'height' } },
                x: hasFacet ? {
                    scale: model.scaleName(channel_1.COLUMN),
                    field: model.field(channel_1.COLUMN),
                    // offset by the spacing
                    offset: model.spacing(channel_1.COLUMN) / 2
                } : {
                    // TODO: support custom spacing here
                    // offset by the spacing
                    value: model.config.scale.facetSpacing / 2
                }
            }
        };
    }
    else {
        axesGroup.encode = {
            update: {
                width: { field: { group: 'width' } },
                height: { field: { parent: model.child.sizeName('height') } },
                y: hasFacet ? {
                    scale: model.scaleName(channel_1.ROW),
                    field: model.field(channel_1.ROW),
                    // offset by the spacing
                    offset: model.spacing(channel_1.ROW) / 2
                } : {
                    // offset by the spacing
                    value: model.config.scale.facetSpacing / 2
                }
            }
        };
    }
    axesGroup.axes = [parse_1.parseMainAxis(channel, model.child)];
    return axesGroup;
}
exports.getSharedAxisGroup = getSharedAxisGroup;
function getRowGridGroups(model) {
    var facetGridConfig = model.config.facet.grid;
    var rowGrid = {
        name: model.getName('row-grid'),
        type: 'rule',
        from: {
            data: model.getDataName(data_1.MAIN)
        },
        encode: {
            update: {
                y: {
                    scale: model.scaleName(channel_1.ROW),
                    field: model.field(channel_1.ROW)
                },
                x: { value: 0, offset: -facetGridConfig.offset },
                x2: { field: { group: 'width' }, offset: facetGridConfig.offset },
                stroke: { value: facetGridConfig.color },
                strokeOpacity: { value: facetGridConfig.opacity },
                strokeWidth: { value: 0.5 }
            }
        }
    };
    return [rowGrid, {
            name: model.getName('row-grid-end'),
            type: 'rule',
            encode: {
                update: {
                    y: { field: { group: 'height' } },
                    x: { value: 0, offset: -facetGridConfig.offset },
                    x2: { field: { group: 'width' }, offset: facetGridConfig.offset },
                    stroke: { value: facetGridConfig.color },
                    strokeOpacity: { value: facetGridConfig.opacity },
                    strokeWidth: { value: 0.5 }
                }
            }
        }];
}
function getColumnGridGroups(model) {
    var facetGridConfig = model.config.facet.grid;
    var columnGrid = {
        name: model.getName('column-grid'),
        type: 'rule',
        from: {
            data: model.getDataName(data_1.MAIN)
        },
        encode: {
            update: {
                x: {
                    scale: model.scaleName(channel_1.COLUMN),
                    field: model.field(channel_1.COLUMN)
                },
                y: { value: 0, offset: -facetGridConfig.offset },
                y2: { field: { group: 'height' }, offset: facetGridConfig.offset },
                stroke: { value: facetGridConfig.color },
                strokeOpacity: { value: facetGridConfig.opacity },
                strokeWidth: { value: 0.5 }
            }
        }
    };
    return [columnGrid, {
            name: model.getName('column-grid-end'),
            type: 'rule',
            encode: {
                update: {
                    x: { field: { group: 'width' } },
                    y: { value: 0, offset: -facetGridConfig.offset },
                    y2: { field: { group: 'height' }, offset: facetGridConfig.offset },
                    stroke: { value: facetGridConfig.color },
                    strokeOpacity: { value: facetGridConfig.opacity },
                    strokeWidth: { value: 0.5 }
                }
            }
        }];
}

},{"../channel":44,"../data":106,"../encoding":108,"../fielddef":110,"../log":113,"../util":124,"../vega.schema":126,"./axis/parse":46,"./axis/rules":47,"./common":48,"./data/assemble":51,"./data/parse":59,"./layout":67,"./model":83,"./scale/init":86,"./scale/parse":87,"tslib":38}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mark_1 = require("../mark");
var util_1 = require("../util");
var vega_schema_1 = require("../vega.schema");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_1 = require("./data/parse");
var layout_1 = require("./layout");
var model_1 = require("./model");
var domain_1 = require("./scale/domain");
var LayerModel = (function (_super) {
    tslib_1.__extends(LayerModel, _super);
    function LayerModel(spec, parent, parentGivenName, config) {
        var _this = _super.call(this, spec, parent, parentGivenName, config) || this;
        _this.scales = {};
        _this.axes = {};
        _this.legends = {};
        _this.stack = null;
        _this.width = spec.width;
        _this.height = spec.height;
        _this.children = spec.layer.map(function (layer, i) {
            // FIXME: this is not always the case
            // we know that the model has to be a unit model because we pass in a unit spec
            return common_1.buildModel(layer, _this, _this.getName('layer_' + i), config);
        });
        return _this;
    }
    LayerModel.prototype.channelHasField = function (channel) {
        // layer does not have any channels
        return false;
    };
    LayerModel.prototype.hasDiscreteScale = function (channel) {
        // since we assume shared scales we can just ask the first child
        return this.children[0].hasDiscreteScale(channel);
    };
    LayerModel.prototype.fieldDef = function (channel) {
        return null; // layer does not have field defs
    };
    LayerModel.prototype.parseData = function () {
        this.component.data = parse_1.parseData(this);
        this.children.forEach(function (child) {
            child.parseData();
        });
    };
    LayerModel.prototype.parseSelection = function () {
        // TODO: @arvind can write this
        // We might need to split this into compileSelectionData and compileSelectionSignals?
    };
    LayerModel.prototype.parseLayoutData = function () {
        // TODO: correctly union ordinal scales rather than just using the layout of the first child
        this.children.forEach(function (child) {
            child.parseLayoutData();
        });
        this.component.layout = layout_1.parseLayerLayout(this);
    };
    LayerModel.prototype.parseScale = function () {
        var model = this;
        var scaleComponent = this.component.scales = {};
        this.children.forEach(function (child) {
            child.parseScale();
            // FIXME(#1602): correctly implement independent scale
            // Also need to check whether the scales are actually compatible, e.g. use the same sort or throw error
            if (true) {
                util_1.keys(child.component.scales).forEach(function (channel) {
                    var childScale = child.component.scales[channel];
                    var modelScale = scaleComponent[channel];
                    if (!childScale || vega_schema_1.isSignalRefDomain(childScale.domain) || (modelScale && vega_schema_1.isSignalRefDomain(modelScale.domain))) {
                        // TODO: merge signal ref domains
                        return;
                    }
                    if (modelScale) {
                        modelScale.domain = domain_1.unionDomains(modelScale.domain, childScale.domain);
                    }
                    else {
                        scaleComponent[channel] = childScale;
                    }
                    // rename child scale to parent scales
                    var scaleNameWithoutPrefix = childScale.name.substr(child.getName('').length);
                    var newName = model.scaleName(scaleNameWithoutPrefix, true);
                    child.renameScale(childScale.name, newName);
                    childScale.name = newName;
                    // remove merged scales from children
                    delete child.component.scales[channel];
                });
            }
        });
    };
    LayerModel.prototype.parseMark = function () {
        this.children.forEach(function (child) {
            child.parseMark();
        });
    };
    LayerModel.prototype.parseAxis = function () {
        var axisComponent = this.component.axes = {};
        this.children.forEach(function (child) {
            child.parseAxis();
            // TODO: correctly implement independent axes
            if (true) {
                util_1.keys(child.component.axes).forEach(function (channel) {
                    // TODO: support multiple axes for shared scale
                    // just use the first axis definition for each channel
                    if (!axisComponent[channel]) {
                        axisComponent[channel] = child.component.axes[channel];
                    }
                });
            }
        });
    };
    LayerModel.prototype.parseAxisGroup = function () {
        return null;
    };
    LayerModel.prototype.parseGridGroup = function () {
        return null;
    };
    LayerModel.prototype.parseLegend = function () {
        var legendComponent = this.component.legends = {};
        this.children.forEach(function (child) {
            child.parseLegend();
            // TODO: correctly implement independent axes
            if (true) {
                util_1.keys(child.component.legends).forEach(function (channel) {
                    // just use the first legend definition for each channel
                    if (!legendComponent[channel]) {
                        legendComponent[channel] = child.component.legends[channel];
                    }
                });
            }
        });
    };
    LayerModel.prototype.assembleParentGroupProperties = function (cellConfig) {
        return common_1.applyConfig({}, cellConfig, mark_1.FILL_STROKE_CONFIG.concat(['clip']));
    };
    LayerModel.prototype.assembleSignals = function (signals) {
        return [];
    };
    LayerModel.prototype.assembleSelectionData = function (data) {
        return [];
    };
    LayerModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    LayerModel.prototype.assembleScales = function () {
        // combine with scales from children
        return this.children.reduce(function (scales, c) {
            return scales.concat(c.assembleScales());
        }, _super.prototype.assembleScales.call(this));
    };
    LayerModel.prototype.assembleLayout = function (layoutData) {
        // Postfix traversal – layout is assembled bottom-up
        this.children.forEach(function (child) {
            child.assembleLayout(layoutData);
        });
        return layout_1.assembleLayout(this, layoutData);
    };
    LayerModel.prototype.assembleMarks = function () {
        // only children have marks
        return util_1.flatten(this.children.map(function (child) {
            return child.assembleMarks();
        }));
    };
    LayerModel.prototype.channels = function () {
        return [];
    };
    LayerModel.prototype.getMapping = function () {
        return null;
    };
    LayerModel.prototype.isLayer = function () {
        return true;
    };
    return LayerModel;
}(model_1.Model));
exports.LayerModel = LayerModel;

},{"../mark":114,"../util":124,"../vega.schema":126,"./common":48,"./data/assemble":51,"./data/parse":59,"./layout":67,"./model":83,"./scale/domain":85,"tslib":38}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var data_1 = require("../data");
var scale_1 = require("../scale");
var util_1 = require("../util");
function assembleLayout(model, layoutData) {
    var layoutComponent = model.component.layout;
    if (!layoutComponent.width && !layoutComponent.height) {
        return layoutData; // Do nothing
    }
    if (true) {
        var distinctFields = util_1.keys(util_1.extend(layoutComponent.width.distinct, layoutComponent.height.distinct));
        var formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)
            .map(function (f) {
            return tslib_1.__assign({ type: 'formula' }, f);
        });
        return [
            distinctFields.length > 0 ? {
                name: model.getName(data_1.LAYOUT),
                source: model.lookupDataSource(layoutComponent.width.source || layoutComponent.height.source),
                transform: [{
                        type: 'aggregate',
                        fields: distinctFields,
                        ops: distinctFields.map(function () { return 'distinct'; })
                    }].concat(formula)
            } : {
                name: model.getName(data_1.LAYOUT),
                values: [{}],
                transform: formula
            }
        ];
    }
    // FIXME: implement
    // otherwise, we need to join width and height (cross)
}
exports.assembleLayout = assembleLayout;
// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later
// For now, let's always assume shared scale
function parseUnitLayout(model) {
    return {
        width: parseUnitSizeLayout(model, channel_1.X),
        height: parseUnitSizeLayout(model, channel_1.Y)
    };
}
exports.parseUnitLayout = parseUnitLayout;
function parseUnitSizeLayout(model, channel) {
    var distinct = getDistinct(model, channel);
    return {
        source: util_1.keys(distinct).length > 0 ? model.getDataName(data_1.MAIN) : null,
        distinct: distinct,
        formula: [{
                as: model.channelSizeName(channel),
                expr: unitSizeExpr(model, channel)
            }]
    };
}
function unitSizeExpr(model, channel) {
    var scale = model.scale(channel);
    if (scale) {
        if (scale_1.hasDiscreteDomain(scale.type) && scale.rangeStep) {
            // If the spec has top level size or specified rangeStep = fit, it will be undefined here.
            var cardinality = cardinalityExpr(model, channel);
            var paddingOuter = scale.paddingOuter !== undefined ? scale.paddingOuter : scale.padding;
            var paddingInner = scale.type === 'band' ?
                // only band has real paddingInner
                (scale.paddingInner !== undefined ? scale.paddingInner : scale.padding) :
                // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
                // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
                1;
            var space = cardinality +
                (paddingInner ? " - " + paddingInner : '') +
                (paddingOuter ? " + 2*" + paddingOuter : '');
            // This formula is equivalent to
            // space = count - inner + outer * 2
            // range = rangeStep * (space > 0 ? space : 0)
            // in https://github.com/vega/vega-encode/blob/master/src/Scale.js#L112
            return "max(" + space + ", 0) * " + scale.rangeStep;
        }
    }
    return (channel === channel_1.X ? model.width : model.height) + '';
}
exports.unitSizeExpr = unitSizeExpr;
function parseFacetLayout(model) {
    return {
        width: parseFacetSizeLayout(model, channel_1.COLUMN),
        height: parseFacetSizeLayout(model, channel_1.ROW)
    };
}
exports.parseFacetLayout = parseFacetLayout;
function parseFacetSizeLayout(model, channel) {
    var childLayoutComponent = model.child.component.layout;
    var sizeType = channel === channel_1.ROW ? 'height' : 'width';
    var childSizeComponent = childLayoutComponent[sizeType];
    if (true) {
        // For shared scale, we can simply merge the layout into one data source
        var distinct = util_1.extend(getDistinct(model, channel), childSizeComponent.distinct);
        var formula = childSizeComponent.formula.concat([{
                as: model.channelSizeName(channel),
                expr: facetSizeFormula(model, channel, model.child.channelSizeName(channel))
            }]);
        delete childLayoutComponent[sizeType];
        return {
            source: model.getDataName(data_1.MAIN),
            distinct: distinct,
            formula: formula
        };
    }
    // FIXME implement independent scale as well
    // TODO: - also consider when children have different data source
}
function facetSizeFormula(model, channel, innerSize) {
    if (model.channelHasField(channel)) {
        return '(datum["' + innerSize + '"] + ' + model.spacing(channel) + ')' + ' * ' + cardinalityExpr(model, channel);
    }
    else {
        return 'datum["' + innerSize + '"] + ' + model.config.scale.facetSpacing; // need to add outer padding for facet
    }
}
function parseLayerLayout(model) {
    return {
        width: parseLayerSizeLayout(model, channel_1.X),
        height: parseLayerSizeLayout(model, channel_1.Y)
    };
}
exports.parseLayerLayout = parseLayerLayout;
function parseLayerSizeLayout(model, channel) {
    if (true) {
        // For shared scale, we can simply merge the layout into one data source
        // TODO: don't just take the layout from the first child
        var childLayoutComponent = model.children[0].component.layout;
        var sizeType_1 = channel === channel_1.Y ? 'height' : 'width';
        var childSizeComponent = childLayoutComponent[sizeType_1];
        var distinct = childSizeComponent.distinct;
        var formula = [{
                as: model.channelSizeName(channel),
                expr: childSizeComponent.formula[0].expr
            }];
        model.children.forEach(function (child) {
            delete child.component.layout[sizeType_1];
        });
        return {
            source: model.getDataName(data_1.MAIN),
            distinct: distinct,
            formula: formula
        };
    }
}
function getDistinct(model, channel) {
    if (model.channelHasField(channel) && model.hasDiscreteScale(channel)) {
        var scale = model.scale(channel);
        if (scale_1.hasDiscreteDomain(scale.type) && !(scale.domain instanceof Array)) {
            // if explicit domain is declared, use array length
            var distinctField = model.field(channel);
            var distinct = {};
            distinct[distinctField] = true;
            return distinct;
        }
    }
    return {};
}
function cardinalityExpr(model, channel) {
    var scale = model.scale(channel);
    if (scale.domain instanceof Array) {
        return scale.domain.length + '';
    }
    return model.field(channel, { datum: true, prefix: 'distinct' });
}
exports.cardinalityExpr = cardinalityExpr;

},{"../channel":44,"../data":106,"../scale":115,"../util":124,"tslib":38}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var mark_1 = require("../../mark");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
function symbols(fieldDef, symbolsSpec, model, channel) {
    var symbols = {};
    var mark = model.mark();
    switch (mark) {
        case mark_1.BAR:
        case mark_1.TICK:
        case mark_1.TEXT:
            symbols.shape = { value: 'square' };
            break;
        case mark_1.CIRCLE:
        case mark_1.SQUARE:
            symbols.shape = { value: mark };
            break;
        case mark_1.POINT:
        case mark_1.LINE:
        case mark_1.AREA:
            // use default circle
            break;
    }
    var cfg = model.config;
    var filled = model.markDef.filled;
    var config = channel === channel_1.COLOR ?
        /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the legend's `fill` or `stroke` scale should have precedence */
        util_1.without(mark_1.FILL_STROKE_CONFIG, [filled ? 'fill' : 'stroke', 'strokeDash', 'strokeDashOffset']) :
        /* For other legend, no need to omit. */
        mark_1.FILL_STROKE_CONFIG;
    config = util_1.without(config, ['strokeDash', 'strokeDashOffset']);
    common_1.applyMarkConfig(symbols, model, config);
    if (filled) {
        symbols.strokeWidth = { value: 0 };
    }
    var value;
    var colorDef = model.encoding.color;
    if (fielddef_1.isValueDef(colorDef)) {
        value = { value: colorDef.value };
    }
    if (value !== undefined) {
        // apply the value
        if (filled) {
            symbols.fill = value;
        }
        else {
            symbols.stroke = value;
        }
    }
    else if (channel !== channel_1.COLOR) {
        // For non-color legend, apply color config if there is no fill / stroke config.
        // (For color, do not override scale specified!)
        symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||
            { value: cfg.mark.color };
    }
    if (symbols.fill === undefined) {
        // fall back to mark config colors for legend fill
        if (cfg.mark.fill !== undefined) {
            symbols.fill = { value: cfg.mark.fill };
        }
        else if (cfg.mark.stroke !== undefined) {
            symbols.stroke = { value: cfg.mark.stroke };
        }
    }
    var shapeDef = model.encoding.shape;
    if (channel !== channel_1.SHAPE) {
        if (fielddef_1.isValueDef(shapeDef)) {
            symbols.shape = { value: shapeDef.value };
        }
    }
    symbols = util_1.extend(symbols, symbolsSpec || {});
    return util_1.keys(symbols).length > 0 ? symbols : undefined;
}
exports.symbols = symbols;
function labels(fieldDef, labelsSpec, model, channel) {
    var legend = model.legend(channel);
    var config = model.config;
    var labels = {};
    if (fieldDef.type === type_1.TEMPORAL) {
        labelsSpec = util_1.extend({
            text: {
                signal: common_1.timeFormatExpression('datum.value', fieldDef.timeUnit, legend.format, config.legend.shortTimeLabels, config.timeFormat)
            }
        }, labelsSpec || {});
    }
    labels = util_1.extend(labels, labelsSpec || {});
    return util_1.keys(labels).length > 0 ? labels : undefined;
}
exports.labels = labels;

},{"../../channel":44,"../../fielddef":110,"../../mark":114,"../../type":123,"../../util":124,"../common":48}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var legend_1 = require("../../legend");
var util_1 = require("../../util");
var common_1 = require("../common");
var encode = require("./encode");
var rules = require("./rules");
function parseLegendComponent(model) {
    return [channel_1.COLOR, channel_1.SIZE, channel_1.SHAPE, channel_1.OPACITY].reduce(function (legendComponent, channel) {
        if (model.legend(channel)) {
            legendComponent[channel] = parseLegend(model, channel);
        }
        return legendComponent;
    }, {});
}
exports.parseLegendComponent = parseLegendComponent;
function getLegendDefWithScale(model, channel) {
    // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels
    switch (channel) {
        case channel_1.COLOR:
            var scale = model.scaleName(channel_1.COLOR);
            return model.markDef.filled ? { fill: scale } : { stroke: scale };
        case channel_1.SIZE:
            return { size: model.scaleName(channel_1.SIZE) };
        case channel_1.SHAPE:
            return { shape: model.scaleName(channel_1.SHAPE) };
        case channel_1.OPACITY:
            return { opacity: model.scaleName(channel_1.OPACITY) };
    }
    return null;
}
function parseLegend(model, channel) {
    var fieldDef = model.fieldDef(channel);
    var legend = model.legend(channel);
    var def = getLegendDefWithScale(model, channel);
    legend_1.LEGEND_PROPERTIES.forEach(function (property) {
        var value = getSpecifiedOrDefaultValue(property, legend, channel, model);
        if (value !== undefined) {
            def[property] = value;
        }
    });
    // 2) Add mark property definition groups
    var encodeSpec = legend.encode || {};
    ['labels', 'legend', 'title', 'symbols'].forEach(function (part) {
        var value = encode[part] ?
            encode[part](fieldDef, encodeSpec[part], model, channel) :
            encodeSpec[part]; // no rule -- just default values
        if (value !== undefined && util_1.keys(value).length > 0) {
            def.encode = def.encode || {};
            def.encode[part] = { update: value };
        }
    });
    return def;
}
exports.parseLegend = parseLegend;
function getSpecifiedOrDefaultValue(property, specifiedLegend, channel, model) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'format':
            return common_1.numberFormat(fieldDef, specifiedLegend.format, model.config, channel);
        case 'title':
            return rules.title(specifiedLegend, fieldDef, model.config);
        case 'values':
            return rules.values(specifiedLegend);
        case 'type':
            return rules.type(specifiedLegend, fieldDef.type, channel, model.scale(channel).type);
    }
    // Otherwise, return specified property.
    return specifiedLegend[property];
}

},{"../../channel":44,"../../legend":112,"../../util":124,"../common":48,"./encode":68,"./rules":70}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var datetime_1 = require("../../datetime");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
function title(legend, fieldDef, config) {
    if (legend.title !== undefined) {
        return legend.title;
    }
    return fielddef_1.title(fieldDef, config);
}
exports.title = title;
function values(legend) {
    var vals = legend.values;
    if (vals && datetime_1.isDateTime(vals[0])) {
        return vals.map(function (dt) {
            // normalize = true as end user won't put 0 = January
            return datetime_1.timestamp(dt, true);
        });
    }
    return vals;
}
exports.values = values;
function type(legend, type, channel, scaleType) {
    if (legend.type) {
        return legend.type;
    }
    if (channel === channel_1.COLOR && ((type === 'quantitative' && !scale_1.isBinScale(scaleType)) || (type === 'temporal' && util_1.contains(['time', 'utc'], scaleType)))) {
        return 'gradient';
    }
    return undefined;
}
exports.type = type;

},{"../../channel":44,"../../datetime":107,"../../fielddef":110,"../../scale":115,"../../util":124}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
exports.area = {
    vgMark: 'area',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition('y', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'), mixins.color(model), mixins.nonPosition('opacity', model), mixins.markDefProperties(model.markDef, ['orient', 'interpolate', 'tension']));
    }
};

},{"./mixins":76,"tslib":38}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var scale_1 = require("../../scale");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.bar = {
    vgMark: 'rect',
    defaultRole: 'bar',
    encodeEntry: function (model) {
        var stack = model.stack;
        return tslib_1.__assign({}, x(model, stack), y(model, stack), mixins.color(model), mixins.nonPosition('opacity', model));
    }
};
function x(model, stack) {
    var config = model.config, width = model.width;
    var orient = model.markDef.orient;
    var sizeDef = model.encoding.size;
    var xDef = model.encoding.x;
    var xScaleName = model.scaleName(channel_1.X);
    var xScale = model.scale(channel_1.X);
    // x, x2, and width -- we must specify two of these in all conditions
    if (orient === 'horizontal') {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'));
    }
    else {
        if (fielddef_1.isFieldDef(xDef)) {
            if (!sizeDef && scale_1.isBinScale(xScale.type)) {
                return mixins.binnedPosition('x', model, config.bar.binSpacing);
            }
            else if (xScale.type === scale_1.ScaleType.BAND) {
                return mixins.bandPosition('x', model);
            }
        }
        // sized bin, normal point-ordinal axis, quantitative x-axis, or no x
        return mixins.centeredBandPosition('x', model, tslib_1.__assign({}, ref.midX(width, config)), defaultSizeRef(xScaleName, model.scale(channel_1.X), config));
    }
}
function y(model, stack) {
    var config = model.config, encoding = model.encoding, height = model.height;
    var orient = model.markDef.orient;
    var sizeDef = encoding.size;
    var yDef = encoding.y;
    var yScaleName = model.scaleName(channel_1.Y);
    var yScale = model.scale(channel_1.Y);
    // y, y2 & height -- we must specify two of these in all conditions
    if (orient === 'vertical') {
        return tslib_1.__assign({}, mixins.pointPosition('y', model, 'zeroOrMin'), mixins.pointPosition2(model, 'zeroOrMin'));
    }
    else {
        if (fielddef_1.isFieldDef(yDef)) {
            if (yDef.bin && !sizeDef) {
                return mixins.binnedPosition('y', model, config.bar.binSpacing);
            }
            else if (yScale.type === scale_1.ScaleType.BAND) {
                return mixins.bandPosition('y', model);
            }
        }
        return mixins.centeredBandPosition('y', model, ref.midY(height, config), defaultSizeRef(yScaleName, model.scale(channel_1.Y), config));
    }
}
function defaultSizeRef(scaleName, scale, config) {
    if (config.bar.discreteBandSize) {
        return { value: config.bar.discreteBandSize };
    }
    if (scale) {
        if (scale.type === scale_1.ScaleType.POINT) {
            if (scale.rangeStep !== null) {
                return { value: scale.rangeStep - 1 };
            }
            log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);
        }
        else if (scale.type === scale_1.ScaleType.BAND) {
            return ref.band(scaleName);
        }
        else {
            return { value: config.bar.continuousBandSize };
        }
    }
    if (config.scale.rangeStep && config.scale.rangeStep !== null) {
        return { value: config.scale.rangeStep - 1 };
    }
    // TODO: this should depends on cell's width / height?
    return { value: 20 };
}

},{"../../channel":44,"../../fielddef":110,"../../log":113,"../../scale":115,"./mixins":76,"./valueref":82,"tslib":38}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var encoding_1 = require("../../encoding");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var mark_1 = require("../../mark");
var scale_1 = require("../../scale");
var type_1 = require("../../type");
var util_1 = require("../../util");
var common_1 = require("../common");
function initMarkDef(mark, encoding, scale, config) {
    var markDef = mark_1.isMarkDef(mark) ? tslib_1.__assign({}, mark) : { type: mark };
    var specifiedOrient = markDef.orient || common_1.getMarkConfig('orient', markDef.type, config);
    markDef.orient = orient(markDef.type, encoding, scale, specifiedOrient);
    if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {
        log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));
    }
    var specifiedFilled = markDef.filled;
    if (specifiedFilled === undefined) {
        markDef.filled = filled(markDef.type, config);
    }
    return markDef;
}
exports.initMarkDef = initMarkDef;
/**
 * Initialize encoding's value with some special default values
 */
function initEncoding(mark, encoding, stacked, config) {
    var opacityConfig = common_1.getMarkConfig('opacity', mark, config);
    if (!encoding.opacity && opacityConfig === undefined) {
        var opacity = defaultOpacity(mark, encoding, stacked);
        if (opacity !== undefined) {
            encoding.opacity = { value: opacity };
        }
    }
    return encoding;
}
exports.initEncoding = initEncoding;
function defaultOpacity(mark, encoding, stacked) {
    if (util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], mark)) {
        // point-based marks
        if (!encoding_1.isAggregate(encoding)) {
            return 0.7;
        }
    }
    return undefined;
}
function filled(mark, config) {
    var filledConfig = common_1.getMarkConfig('filled', mark, config);
    return filledConfig !== undefined ? filledConfig : mark !== mark_1.POINT && mark !== mark_1.LINE && mark !== mark_1.RULE;
}
function orient(mark, encoding, scale, specifiedOrient) {
    switch (mark) {
        case mark_1.POINT:
        case mark_1.CIRCLE:
        case mark_1.SQUARE:
        case mark_1.TEXT:
        case mark_1.RECT:
            // orient is meaningless for these marks.
            return undefined;
    }
    var yIsRange = encoding.y && encoding.y2;
    var xIsRange = encoding.x && encoding.x2;
    switch (mark) {
        case mark_1.TICK:
            var xScaleType = scale['x'] ? scale['x'].type : null;
            var yScaleType = scale['y'] ? scale['y'].type : null;
            // Tick is opposite to bar, line, area and never have ranged mark.
            if (!scale_1.hasDiscreteDomain(xScaleType) && (!encoding.y ||
                scale_1.hasDiscreteDomain(yScaleType) ||
                (fielddef_1.isFieldDef(encoding.y) && encoding.y.bin))) {
                return 'vertical';
            }
            // y:Q or Ambiguous case, return horizontal
            return 'horizontal';
        case mark_1.RULE:
        case mark_1.BAR:
        case mark_1.AREA:
            // If there are range for both x and y, y (vertical) has higher precedence.
            if (yIsRange) {
                return 'vertical';
            }
            else if (xIsRange) {
                return 'horizontal';
            }
            else if (mark === mark_1.RULE) {
                if (encoding.x && !encoding.y) {
                    return 'vertical';
                }
                else if (encoding.y && !encoding.x) {
                    return 'horizontal';
                }
            }
        /* tslint:disable */
        case mark_1.LINE:
            /* tslint:enable */
            var xIsContinuous = fielddef_1.isFieldDef(encoding.x) && fielddef_1.isContinuous(encoding.x);
            var yIsContinuous = fielddef_1.isFieldDef(encoding.y) && fielddef_1.isContinuous(encoding.y);
            if (xIsContinuous && !yIsContinuous) {
                return 'horizontal';
            }
            else if (!xIsContinuous && yIsContinuous) {
                return 'vertical';
            }
            else if (xIsContinuous && yIsContinuous) {
                var xDef = encoding.x; // we can cast here since they are surely fieldDef
                var yDef = encoding.y;
                var xIsTemporal = xDef.type === type_1.TEMPORAL;
                var yIsTemporal = yDef.type === type_1.TEMPORAL;
                // temporal without timeUnit is considered continuous, but better serves as dimension
                if (xIsTemporal && !yIsTemporal) {
                    return 'vertical';
                }
                else if (!xIsTemporal && yIsTemporal) {
                    return 'horizontal';
                }
                if (!xDef.aggregate && yDef.aggregate) {
                    return 'vertical';
                }
                else if (xDef.aggregate && !yDef.aggregate) {
                    return 'horizontal';
                }
                if (specifiedOrient) {
                    // When ambiguous, use user specified one.
                    return specifiedOrient;
                }
                if (!(mark === mark_1.LINE && encoding.order)) {
                    // Except for connected scatterplot, we should log warning for unclear orientation of QxQ plots.
                    log.warn(log.message.unclearOrientContinuous(mark));
                }
                return 'vertical';
            }
            else {
                // For Discrete x Discrete case, return undefined.
                log.warn(log.message.unclearOrientDiscreteOrEmpty(mark));
                return undefined;
            }
    }
    return 'vertical';
}

},{"../../encoding":108,"../../fielddef":110,"../../log":113,"../../mark":114,"../../scale":115,"../../type":123,"../../util":124,"../common":48,"tslib":38}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
exports.line = {
    vgMark: 'line',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMin'), mixins.pointPosition('y', model, 'zeroOrMin'), mixins.color(model), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'strokeWidth' // VL's line size is strokeWidth
        }), mixins.markDefProperties(model.markDef, ['interpolate', 'tension']));
    }
};

},{"./mixins":76,"tslib":38}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var mark_1 = require("../../mark");
var util_1 = require("../../util");
var area_1 = require("./area");
var bar_1 = require("./bar");
var line_1 = require("./line");
var point_1 = require("./point");
var rect_1 = require("./rect");
var rule_1 = require("./rule");
var text_1 = require("./text");
var tick_1 = require("./tick");
var data_1 = require("../../data");
var markCompiler = {
    area: area_1.area,
    bar: bar_1.bar,
    line: line_1.line,
    point: point_1.point,
    text: text_1.text,
    tick: tick_1.tick,
    rect: rect_1.rect,
    rule: rule_1.rule,
    circle: point_1.circle,
    square: point_1.square
};
function parseMark(model) {
    if (util_1.contains([mark_1.LINE, mark_1.AREA], model.mark())) {
        return parsePathMark(model);
    }
    else {
        return parseNonPathMark(model);
    }
}
exports.parseMark = parseMark;
var FACETED_PATH_PREFIX = 'faceted-path-';
function parsePathMark(model) {
    var mark = model.mark();
    // FIXME: replace this with more general case for composition
    var details = detailFields(model);
    var pathMarks = [
        {
            name: model.getName('marks'),
            type: markCompiler[mark].vgMark,
            // If has subfacet for line/area group, need to use faceted data from below.
            // FIXME: support sorting path order (in connected scatterplot)
            from: { data: (details.length > 0 ? FACETED_PATH_PREFIX : '') + model.getDataName(data_1.MAIN) },
            encode: { update: markCompiler[mark].encodeEntry(model) }
        }
    ];
    if (details.length > 0) {
        // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)
        return [{
                name: model.getName('pathgroup'),
                type: 'group',
                from: {
                    facet: {
                        name: FACETED_PATH_PREFIX + model.getDataName(data_1.MAIN),
                        data: model.getDataName(data_1.MAIN),
                        groupby: details,
                    }
                },
                encode: {
                    update: {
                        width: { field: { group: 'width' } },
                        height: { field: { group: 'height' } }
                    }
                },
                marks: pathMarks
            }];
    }
    else {
        return pathMarks;
    }
}
function parseNonPathMark(model) {
    var mark = model.mark();
    var role = model.markDef.role || markCompiler[mark].defaultRole;
    var marks = []; // TODO: vgMarks
    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)
    marks.push(tslib_1.__assign({ name: model.getName('marks'), type: markCompiler[mark].vgMark }, (role ? { role: role } : {}), { from: { data: model.getDataName(data_1.MAIN) }, encode: { update: markCompiler[mark].encodeEntry(model) } }));
    return marks;
}
/**
 * Returns list of detail (group-by) fields
 * that the model's spec contains.
 */
function detailFields(model) {
    return channel_1.LEVEL_OF_DETAIL_CHANNELS.reduce(function (details, channel) {
        if (model.channelHasField(channel) && !model.fieldDef(channel).aggregate) {
            details.push(model.field(channel));
        }
        return details;
    }, []);
}

},{"../../channel":44,"../../data":106,"../../mark":114,"../../util":124,"./area":71,"./bar":72,"./line":74,"./point":77,"./rect":78,"./rule":79,"./text":80,"./tick":81,"tslib":38}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var util = require("../../util");
var common_1 = require("../common");
var ref = require("./valueref");
var selection_1 = require("../selection/selection");
function color(model) {
    var config = model.config;
    var filled = model.markDef.filled;
    var e = nonPosition('color', model, {
        vgChannel: filled ? 'fill' : 'stroke',
        defaultValue: common_1.getMarkConfig('color', model.mark(), config)
    });
    // If there is no fill, always fill symbols
    // with transparent fills https://github.com/vega/vega-lite/issues/1316
    if (!e.fill && util.contains(['bar', 'point', 'circle', 'square'], model.mark())) {
        e.fill = { value: 'transparent' };
    }
    return e;
}
exports.color = color;
function markDefProperties(mark, props) {
    return props.reduce(function (m, prop) {
        if (mark[prop]) {
            m[prop] = { value: mark[prop] };
        }
        return m;
    }, {});
}
exports.markDefProperties = markDefProperties;
function valueIfDefined(prop, value) {
    if (value !== undefined) {
        return _a = {}, _a[prop] = { value: value }, _a;
    }
    return undefined;
    var _a;
}
exports.valueIfDefined = valueIfDefined;
/**
 * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)
 */
function nonPosition(channel, model, opt) {
    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613
    if (opt === void 0) { opt = {}; }
    var defaultValue = opt.defaultValue, vgChannel = opt.vgChannel;
    var defaultRef = opt.defaultRef || (defaultValue !== undefined ? { value: defaultValue } : undefined);
    var channelDef = model.encoding[channel];
    var valueRef = ref.midPoint(channel, channelDef, model.scaleName(channel), model.scale(channel), defaultRef);
    return wrapCondition(model, channelDef && channelDef.condition, vgChannel || channel, valueRef);
}
exports.nonPosition = nonPosition;
/**
 * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.
 * or a simple mixin if channel def has no condition.
 */
function wrapCondition(model, condition, vgChannel, valueRef) {
    if (condition) {
        var selection = condition.selection, value = condition.value;
        return _a = {},
            _a[vgChannel] = [
                { test: selectionTest(model, selection), value: value }
            ].concat((valueRef !== undefined ? [valueRef] : [])),
            _a;
    }
    else {
        return valueRef !== undefined ? (_b = {}, _b[vgChannel] = valueRef, _b) : {};
    }
    var _a, _b;
}
function selectionTest(model, selectionName) {
    var negate = selectionName.charAt(0) === '!', name = negate ? selectionName.slice(1) : selectionName;
    return (negate ? '!' : '') + selection_1.predicate(model.component.selection[name]);
}
function text(model) {
    var channelDef = model.encoding.text;
    return wrapCondition(model, channelDef && channelDef.condition, 'text', ref.text(channelDef, model.config));
}
exports.text = text;
function bandPosition(channel, model) {
    // TODO: band scale doesn't support size yet
    var fieldDef = model.encoding[channel];
    var scaleName = model.scaleName(channel);
    var sizeChannel = channel === 'x' ? 'width' : 'height';
    return _a = {},
        _a[channel] = ref.fieldRef(fieldDef, scaleName, {}),
        _a[sizeChannel] = ref.band(scaleName),
        _a;
    var _a;
}
exports.bandPosition = bandPosition;
function centeredBandPosition(channel, model, defaultPosRef, defaultSizeRef) {
    var centerChannel = channel === 'x' ? 'xc' : 'yc';
    var sizeChannel = channel === 'x' ? 'width' : 'height';
    return tslib_1.__assign({}, pointPosition(channel, model, defaultPosRef, centerChannel), nonPosition('size', model, { defaultRef: defaultSizeRef, vgChannel: sizeChannel }));
}
exports.centeredBandPosition = centeredBandPosition;
function binnedPosition(channel, model, spacing) {
    var fieldDef = model.encoding[channel];
    var scaleName = model.scaleName(channel);
    if (channel === 'x') {
        return {
            x2: ref.bin(fieldDef, scaleName, 'start', spacing),
            x: ref.bin(fieldDef, scaleName, 'end')
        };
    }
    else {
        return {
            y2: ref.bin(fieldDef, scaleName, 'start'),
            y: ref.bin(fieldDef, scaleName, 'end', spacing)
        };
    }
}
exports.binnedPosition = binnedPosition;
/**
 * Return mixins for point (non-band) position channels.
 */
function pointPosition(channel, model, defaultRef, vgChannel) {
    // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613
    var encoding = model.encoding, stack = model.stack;
    var valueRef = ref.stackable(channel, encoding[channel], model.scaleName(channel), model.scale(channel), stack, defaultRef);
    return _a = {},
        _a[vgChannel || channel] = valueRef,
        _a;
    var _a;
}
exports.pointPosition = pointPosition;
/**
 * Return mixins for x2, y2.
 * If channel is not specified, return one channel based on orientation.
 */
function pointPosition2(model, defaultRef, channel) {
    var encoding = model.encoding, markDef = model.markDef, stack = model.stack;
    channel = channel || (markDef.orient === 'horizontal' ? 'x2' : 'y2');
    var baseChannel = channel === 'x2' ? 'x' : 'y';
    var valueRef = ref.stackable2(channel, encoding[baseChannel], encoding[channel], model.scaleName(baseChannel), model.scale(baseChannel), stack, defaultRef);
    return _a = {}, _a[channel] = valueRef, _a;
    var _a;
}
exports.pointPosition2 = pointPosition2;

},{"../../util":124,"../common":48,"../selection/selection":93,"./valueref":82,"tslib":38}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var common_1 = require("../common");
var ref = require("./valueref");
function encodeEntry(model, fixedShape) {
    var config = model.config, width = model.width, height = model.height;
    return tslib_1.__assign({}, mixins.pointPosition('x', model, ref.midX(width, config)), mixins.pointPosition('y', model, ref.midY(height, config)), mixins.color(model), mixins.nonPosition('size', model), shapeMixins(model, config, fixedShape), mixins.nonPosition('opacity', model));
}
function shapeMixins(model, config, fixedShape) {
    if (fixedShape) {
        return { shape: { value: fixedShape } };
    }
    return mixins.nonPosition('shape', model, { defaultValue: common_1.getMarkConfig('shape', 'point', config) });
}
exports.shapeMixins = shapeMixins;
exports.point = {
    vgMark: 'symbol',
    defaultRole: 'point',
    encodeEntry: function (model) {
        return encodeEntry(model);
    }
};
exports.circle = {
    vgMark: 'symbol',
    defaultRole: 'circle',
    encodeEntry: function (model) {
        return encodeEntry(model, 'circle');
    }
};
exports.square = {
    vgMark: 'symbol',
    defaultRole: 'square',
    encodeEntry: function (model) {
        return encodeEntry(model, 'square');
    }
};

},{"../common":48,"./mixins":76,"./valueref":82,"tslib":38}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var log = require("../../log");
var mark_1 = require("../../mark");
var scale_1 = require("../../scale");
var mixins = require("./mixins");
exports.rect = {
    vgMark: 'rect',
    defaultRole: undefined,
    encodeEntry: function (model) {
        return tslib_1.__assign({}, x(model), y(model), mixins.color(model), mixins.nonPosition('opacity', model));
    }
};
function x(model) {
    var xDef = model.encoding.x;
    var x2Def = model.encoding.x2;
    var xScale = model.scale(channel_1.X);
    if (fielddef_1.isFieldDef(xDef) && xDef.bin && !x2Def) {
        return mixins.binnedPosition('x', model, 0);
    }
    else if (xScale && scale_1.hasDiscreteDomain(xScale.type)) {
        /* istanbul ignore else */
        if (xScale.type === scale_1.ScaleType.BAND) {
            return mixins.bandPosition('x', model);
        }
        else {
            // We don't support rect mark with point/ordinal scale
            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, xScale.type));
        }
    }
    else {
        return tslib_1.__assign({}, mixins.pointPosition('x', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'x2'));
    }
}
function y(model) {
    var yDef = model.encoding.y;
    var y2Def = model.encoding.y2;
    var yScale = model.scale(channel_1.Y);
    if (fielddef_1.isFieldDef(yDef) && yDef.bin && !y2Def) {
        return mixins.binnedPosition('y', model, 0);
    }
    else if (yScale && scale_1.hasDiscreteDomain(yScale.type)) {
        /* istanbul ignore else */
        if (yScale.type === scale_1.ScaleType.BAND) {
            return mixins.bandPosition('y', model);
        }
        else {
            // We don't support rect mark with point/ordinal scale
            throw new Error(log.message.scaleTypeNotWorkWithMark(mark_1.RECT, yScale.type));
        }
    }
    else {
        return tslib_1.__assign({}, mixins.pointPosition('y', model, 'zeroOrMax'), mixins.pointPosition2(model, 'zeroOrMin', 'y2'));
    }
}

},{"../../channel":44,"../../fielddef":110,"../../log":113,"../../mark":114,"../../scale":115,"./mixins":76,"tslib":38}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.rule = {
    vgMark: 'rule',
    defaultRole: undefined,
    encodeEntry: function (model) {
        var config = model.config, markDef = model.markDef, width = model.width, height = model.height;
        var orient = markDef.orient;
        return tslib_1.__assign({}, mixins.pointPosition('x', model, orient === 'horizontal' ? 'zeroOrMin' : ref.midX(width, config)), mixins.pointPosition('y', model, orient === 'vertical' ? 'zeroOrMin' : ref.midY(height, config)), mixins.pointPosition2(model, 'zeroOrMax'), mixins.color(model), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'strokeWidth' // VL's rule size is strokeWidth
        }));
    }
};

},{"./mixins":76,"./valueref":82,"tslib":38}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../../channel");
var common_1 = require("../common");
var fielddef_1 = require("../../fielddef");
var type_1 = require("../../type");
var mixins = require("./mixins");
var encoding_1 = require("../../encoding");
var ref = require("./valueref");
exports.text = {
    vgMark: 'text',
    defaultRole: undefined,
    encodeEntry: function (model) {
        var config = model.config, encoding = model.encoding, height = model.height;
        var textDef = encoding.text;
        return tslib_1.__assign({}, mixins.pointPosition('x', model, xDefault(config, textDef)), mixins.pointPosition('y', model, ref.midY(height, config)), mixins.text(model), mixins.color(model), mixins.nonPosition('opacity', model), mixins.nonPosition('size', model, {
            vgChannel: 'fontSize' // VL's text size is fontSize
        }), mixins.valueIfDefined('align', align(encoding, config)));
    }
};
function xDefault(config, textDef) {
    if (fielddef_1.isFieldDef(textDef) && textDef.type === type_1.QUANTITATIVE) {
        return { field: { group: 'width' }, offset: -5 };
    }
    // TODO: allow this to fit (Be consistent with ref.midX())
    return { value: config.scale.textXRangeStep / 2 };
}
function align(encoding, config) {
    var alignConfig = common_1.getMarkConfig('align', 'text', config);
    if (alignConfig === undefined) {
        return encoding_1.channelHasField(encoding, channel_1.X) ? 'center' : 'right';
    }
    // If there is a config, Vega-parser will process this already.
    return undefined;
}

},{"../../channel":44,"../../encoding":108,"../../fielddef":110,"../../type":123,"../common":48,"./mixins":76,"./valueref":82,"tslib":38}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mixins = require("./mixins");
var ref = require("./valueref");
exports.tick = {
    vgMark: 'rect',
    defaultRole: 'tick',
    encodeEntry: function (model) {
        var config = model.config, markDef = model.markDef, width = model.width, height = model.height;
        var orient = markDef.orient;
        var vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';
        var vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';
        return tslib_1.__assign({}, mixins.pointPosition('x', model, ref.midX(width, config), 'xc'), mixins.pointPosition('y', model, ref.midY(height, config), 'yc'), mixins.nonPosition('size', model, {
            defaultValue: defaultSize(model),
            vgChannel: vgSizeChannel
        }), (_a = {}, _a[vgThicknessChannel] = { value: config.tick.thickness }, _a), mixins.color(model), mixins.nonPosition('opacity', model));
        var _a;
    }
};
function defaultSize(model) {
    var config = model.config;
    var orient = model.markDef.orient;
    var scaleRangeStep = (model.scale(orient === 'horizontal' ? 'x' : 'y') || {}).rangeStep;
    if (config.tick.bandSize !== undefined) {
        return config.tick.bandSize;
    }
    else {
        var rangeStep = scaleRangeStep !== undefined ?
            scaleRangeStep :
            config.scale.rangeStep;
        if (typeof rangeStep !== 'number') {
            // FIXME consolidate this log
            throw new Error('Function does not handle non-numeric rangeStep');
        }
        return rangeStep / 1.5;
    }
}

},{"./mixins":76,"./valueref":82,"tslib":38}],82:[function(require,module,exports){
/**
 * Utility files for producing Vega ValueRef for marks
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var fielddef_1 = require("../../fielddef");
var scale_1 = require("../../scale");
var util_1 = require("../../util");
var common_1 = require("../common");
// TODO: we need to find a way to refactor these so that scaleName is a part of scale
// but that's complicated.  For now, this is a huge step moving forward.
/**
 * @return Vega ValueRef for stackable x or y
 */
function stackable(channel, channelDef, scaleName, scale, stack, defaultRef) {
    if (channelDef && stack && channel === stack.fieldChannel) {
        // x or y use stack_end so that stacked line's point mark use stack_end too.
        return fieldRef(channelDef, scaleName, { suffix: 'end' });
    }
    return midPoint(channel, channelDef, scaleName, scale, defaultRef);
}
exports.stackable = stackable;
/**
 * @return Vega ValueRef for stackable x2 or y2
 */
function stackable2(channel, aFieldDef, a2fieldDef, scaleName, scale, stack, defaultRef) {
    if (aFieldDef && stack &&
        // If fieldChannel is X and channel is X2 (or Y and Y2)
        channel.charAt(0) === stack.fieldChannel.charAt(0)) {
        return fieldRef(aFieldDef, scaleName, { suffix: 'start' });
    }
    return midPoint(channel, a2fieldDef, scaleName, scale, defaultRef);
}
exports.stackable2 = stackable2;
/**
 * Value Ref for binned fields
 */
function bin(fieldDef, scaleName, side, offset) {
    return fieldRef(fieldDef, scaleName, { binSuffix: side }, offset);
}
exports.bin = bin;
function fieldRef(fieldDef, scaleName, opt, offset) {
    var ref = {
        scale: scaleName,
        field: fielddef_1.field(fieldDef, opt),
    };
    if (offset) {
        ref.offset = offset;
    }
    return ref;
}
exports.fieldRef = fieldRef;
function band(scaleName, band) {
    if (band === void 0) { band = true; }
    return {
        scale: scaleName,
        band: band
    };
}
exports.band = band;
/**
 * Signal that returns the middle of a bin. Should only be used with x and y.
 */
function binMidSignal(fieldDef, scaleName) {
    return {
        signal: "(" +
            ("scale(\"" + scaleName + "\", " + fielddef_1.field(fieldDef, { binSuffix: 'start', datum: true }) + ")") +
            " + " +
            ("scale(\"" + scaleName + "\", " + fielddef_1.field(fieldDef, { binSuffix: 'end', datum: true }) + ")") +
            ")/2"
    };
}
/**
 * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.
 */
function midPoint(channel, channelDef, scaleName, scale, defaultRef) {
    // TODO: datum support
    if (channelDef) {
        /* istanbul ignore else */
        if (fielddef_1.isFieldDef(channelDef)) {
            if (scale_1.isBinScale(scale.type)) {
                // Use middle only for x an y to place marks in the center between start and end of the bin range.
                // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.
                if (util_1.contains(['x', 'y'], channel)) {
                    return binMidSignal(channelDef, scaleName);
                }
                return fieldRef(channelDef, scaleName, { binSuffix: 'start' });
            }
            if (scale_1.hasDiscreteDomain(scale.type)) {
                if (scale.type === 'band') {
                    // For band, to get mid point, need to offset by half of the band
                    return fieldRef(channelDef, scaleName, { binSuffix: 'range' }, band(scaleName, 0.5));
                }
                return fieldRef(channelDef, scaleName, { binSuffix: 'range' });
            }
            else {
                return fieldRef(channelDef, scaleName, {}); // no need for bin suffix
            }
        }
        else if (channelDef.value !== undefined) {
            return { value: channelDef.value };
        }
        else {
            throw new Error('FieldDef without field or value.'); // FIXME add this to log.message
        }
    }
    if (defaultRef === 'zeroOrMin') {
        /* istanbul ignore else */
        if (channel === channel_1.X || channel === channel_1.X2) {
            return zeroOrMinX(scaleName, scale);
        }
        else if (channel === channel_1.Y || channel === channel_1.Y2) {
            return zeroOrMinY(scaleName, scale);
        }
        else {
            throw new Error("Unsupported channel " + channel + " for base function"); // FIXME add this to log.message
        }
    }
    else if (defaultRef === 'zeroOrMax') {
        /* istanbul ignore else */
        if (channel === channel_1.X || channel === channel_1.X2) {
            return zeroOrMaxX(scaleName, scale);
        }
        else if (channel === channel_1.Y || channel === channel_1.Y2) {
            return zeroOrMaxY(scaleName, scale);
        }
        else {
            throw new Error("Unsupported channel " + channel + " for base function"); // FIXME add this to log.message
        }
    }
    return defaultRef;
}
exports.midPoint = midPoint;
function text(textDef, config) {
    // text
    if (textDef) {
        if (fielddef_1.isFieldDef(textDef)) {
            if (textDef.type === 'quantitative') {
                // FIXME: what happens if we have bin?
                var format = common_1.numberFormat(textDef, textDef.format, config, 'text');
                return {
                    signal: "format(" + fielddef_1.field(textDef, { datum: true }) + ", '" + format + "')"
                };
            }
            else if (textDef.type === 'temporal') {
                return {
                    signal: common_1.timeFormatExpression(fielddef_1.field(textDef, { datum: true }), textDef.timeUnit, textDef.format, config.text.shortTimeLabels, config.timeFormat)
                };
            }
            else {
                return { field: textDef.field };
            }
        }
        else if (textDef.value) {
            return { value: textDef.value };
        }
    }
    return { value: config.text.text };
}
exports.text = text;
function midX(width, config) {
    if (width) {
        return { value: width / 2 };
    }
    if (typeof config.scale.rangeStep === 'string') {
        // TODO: For fit-mode, use middle of the width
        throw new Error('midX can not handle string rangeSteps');
    }
    return { value: config.scale.rangeStep / 2 };
}
exports.midX = midX;
function midY(height, config) {
    if (height) {
        return { value: height / 2 };
    }
    if (typeof config.scale.rangeStep === 'string') {
        // TODO: For fit-mode, use middle of the width
        throw new Error('midX can not handle string rangeSteps');
    }
    return { value: config.scale.rangeStep / 2 };
}
exports.midY = midY;
function zeroOrMinX(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the x-axis
    return { value: 0 };
}
/**
 * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist
 */
function zeroOrMaxX(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    return { field: { group: 'width' } };
}
function zeroOrMinY(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the y-axis
    return { field: { group: 'height' } };
}
/**
 * @returns {VgValueRef} base value if scale exists and return max value if scale does not exist
 */
function zeroOrMaxY(scaleName, scale) {
    if (scaleName) {
        // Log / Time / UTC scale do not support zero
        if (!util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scale.type) &&
            scale.zero !== false) {
            return {
                scale: scaleName,
                value: 0
            };
        }
    }
    // Put the mark on the y-axis
    return { value: 0 };
}

},{"../../channel":44,"../../fielddef":110,"../../scale":115,"../../util":124,"../common":48}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../channel");
var encoding_1 = require("../encoding");
var fielddef_1 = require("../fielddef");
var scale_1 = require("../scale");
var util_1 = require("../util");
var assemble_1 = require("./scale/assemble");
var NameMap = (function () {
    function NameMap() {
        this.nameMap = {};
    }
    NameMap.prototype.rename = function (oldName, newName) {
        this.nameMap[oldName] = newName;
    };
    NameMap.prototype.has = function (name) {
        return this.nameMap[name] !== undefined;
    };
    NameMap.prototype.get = function (name) {
        // If the name appears in the _nameMap, we need to read its new name.
        // We have to loop over the dict just in case the new name also gets renamed.
        while (this.nameMap[name]) {
            name = this.nameMap[name];
        }
        return name;
    };
    return NameMap;
}());
exports.NameMap = NameMap;
var Model = (function () {
    function Model(spec, parent, parentGivenName, config) {
        var _this = this;
        this.scales = {};
        this.axes = {};
        this.legends = {};
        this.children = [];
        /**
         * Corrects the data references in marks after assemble.
         */
        this.correctDataNames = function (mark) {
            // TODO: make this correct
            // for normal data references
            if (mark.from && mark.from.data) {
                mark.from.data = _this.lookupDataSource(mark.from.data);
            }
            // for access to facet data
            if (mark.from && mark.from.facet && mark.from.facet.data) {
                mark.from.facet.data = _this.lookupDataSource(mark.from.facet.data);
            }
            return mark;
        };
        this.parent = parent;
        this.config = config;
        // If name is not provided, always use parent's givenName to avoid name conflicts.
        this.name = spec.name || parentGivenName;
        // Shared name maps
        this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();
        this.sizeNameMap = parent ? parent.sizeNameMap : new NameMap();
        this.data = spec.data;
        this.description = spec.description;
        this.transforms = spec.transform || [];
        this.component = {
            data: {
                sources: parent ? parent.component.data.sources : {},
                outputNodes: parent ? parent.component.data.outputNodes : {}
            },
            layout: null, mark: null, scales: null, axes: null,
            axisGroups: null, gridGroups: null, legends: null, selection: null
        };
    }
    Model.prototype.parse = function () {
        this.parseData();
        this.parseLayoutData();
        this.parseScale(); // depends on data name
        this.parseSelection();
        this.parseAxis(); // depends on scale name
        this.parseLegend(); // depends on scale name
        this.parseAxisGroup(); // depends on child axis
        this.parseGridGroup();
        this.parseMark(); // depends on data name and scale name, axisGroup, gridGroup and children's scale, axis, legend and mark.
    };
    Model.prototype.assembleScales = function () {
        return assemble_1.assembleScale(this);
    };
    Model.prototype.assembleAxes = function () {
        return [].concat.apply([], util_1.vals(this.component.axes));
    };
    Model.prototype.assembleLegends = function () {
        return util_1.vals(this.component.legends);
    };
    Model.prototype.assembleGroup = function () {
        var group = {};
        var signals = this.assembleSignals(group.signals || []);
        if (signals.length > 0) {
            group.signals = signals;
        }
        group.marks = this.assembleMarks();
        var scales = this.assembleScales();
        if (scales.length > 0) {
            group.scales = scales;
        }
        var axes = this.assembleAxes();
        if (axes.length > 0) {
            group.axes = axes;
        }
        var legends = this.assembleLegends();
        if (legends.length > 0) {
            group.legends = legends;
        }
        return group;
    };
    Model.prototype.reduceFieldDef = function (f, init, t) {
        return encoding_1.reduce(this.getMapping(), function (acc, cd, c) {
            return fielddef_1.isFieldDef(cd) ? f(acc, cd, c) : acc;
        }, init, t);
    };
    Model.prototype.forEachFieldDef = function (f, t) {
        encoding_1.forEach(this.getMapping(), function (cd, c) {
            if (fielddef_1.isFieldDef(cd)) {
                f(cd, c);
            }
        }, t);
    };
    Model.prototype.hasDescendantWithFieldOnChannel = function (channel) {
        for (var _i = 0, _a = this.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child.isUnit()) {
                if (child.channelHasField(channel)) {
                    return true;
                }
            }
            else {
                if (child.hasDescendantWithFieldOnChannel(channel)) {
                    return true;
                }
            }
        }
        return false;
    };
    Model.prototype.getName = function (text, delimiter) {
        if (delimiter === void 0) { delimiter = '_'; }
        return (this.name ? this.name + delimiter : '') + text;
    };
    /**
     * Return the data source name for the given data source type. You probably want to call this in parse.
     */
    Model.prototype.getDataName = function (name) {
        var fullName = this.getName(name);
        return this.lookupDataSource(fullName);
    };
    /**
     * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
     */
    Model.prototype.lookupDataSource = function (name) {
        var node = this.component.data.outputNodes[name];
        if (!node) {
            // name not found in map so let's just return what we got
            return name;
        }
        return node.source;
    };
    Model.prototype.renameSize = function (oldName, newName) {
        this.sizeNameMap.rename(oldName, newName);
    };
    Model.prototype.channelSizeName = function (channel) {
        return this.sizeName(channel === channel_1.X || channel === channel_1.COLUMN ? 'width' : 'height');
    };
    Model.prototype.sizeName = function (size) {
        return this.sizeNameMap.get(this.getName(size, '_'));
    };
    /** Get "field" reference for vega */
    Model.prototype.field = function (channel, opt) {
        if (opt === void 0) { opt = {}; }
        var fieldDef = this.fieldDef(channel);
        if (fieldDef.bin) {
            opt = util_1.extend({
                binSuffix: scale_1.hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'
            }, opt);
        }
        return fielddef_1.field(fieldDef, opt);
    };
    Model.prototype.scale = function (channel) {
        return this.scales[channel];
    };
    Model.prototype.hasDiscreteScale = function (channel) {
        var scale = this.scale(channel);
        return scale && scale_1.hasDiscreteDomain(scale.type);
    };
    Model.prototype.renameScale = function (oldName, newName) {
        this.scaleNameMap.rename(oldName, newName);
    };
    /**
     * @return scale name for a given channel after the scale has been parsed and named.
     */
    Model.prototype.scaleName = function (originalScaleName, parse) {
        if (parse) {
            // During the parse phase always return a value
            // No need to refer to rename map because a scale can't be renamed
            // before it has the original name.
            return this.getName(originalScaleName);
        }
        // If there is a scale for the channel, it should either
        // be in the _scale mapping or exist in the name map
        if (
        // in the scale map (the scale is not merged by its parent)
        (this.scale && this.scales[originalScaleName]) ||
            // in the scale name map (the the scale get merged by its parent)
            this.scaleNameMap.has(this.getName(originalScaleName))) {
            return this.scaleNameMap.get(this.getName(originalScaleName));
        }
        return undefined;
    };
    Model.prototype.sort = function (channel) {
        return (this.getMapping()[channel] || {}).sort;
    };
    Model.prototype.axis = function (channel) {
        return this.axes[channel];
    };
    Model.prototype.legend = function (channel) {
        return this.legends[channel];
    };
    /**
     * Type checks
     */
    Model.prototype.isUnit = function () {
        return false;
    };
    Model.prototype.isFacet = function () {
        return false;
    };
    Model.prototype.isLayer = function () {
        return false;
    };
    return Model;
}());
exports.Model = Model;

},{"../channel":44,"../encoding":108,"../fielddef":110,"../scale":115,"../util":124,"./scale/assemble":84}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var vega_util_1 = require("vega-util");
var util_1 = require("../../util");
var vega_schema_1 = require("../../vega.schema");
function assembleScale(model) {
    return util_1.vals(model.component.scales).map(function (scale) {
        // correct references to data
        var domain = scale.domain;
        if (vega_schema_1.isDataRefDomain(domain) || vega_schema_1.isFieldRefUnionDomain(domain)) {
            domain.data = model.lookupDataSource(domain.data);
            return scale;
        }
        else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
            domain.fields = domain.fields.map(function (f) {
                return tslib_1.__assign({}, f, { data: model.lookupDataSource(f.data) });
            });
            return scale;
        }
        else if (vega_schema_1.isSignalRefDomain(domain) || vega_util_1.isArray(domain)) {
            return scale;
        }
        else {
            throw new Error('invalid scale domain');
        }
    });
}
exports.assembleScale = assembleScale;

},{"../../util":124,"../../vega.schema":126,"tslib":38,"vega-util":128}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var aggregate_1 = require("../../aggregate");
var bin_1 = require("../../bin");
var datetime_1 = require("../../datetime");
var scale_1 = require("../../scale");
var sort_1 = require("../../sort");
var util = require("../../util");
var vega_schema_1 = require("../../vega.schema");
var data_1 = require("../../data");
function initDomain(domain, fieldDef, scale, scaleConfig) {
    if (domain === 'unaggregated') {
        var _a = canUseUnaggregatedDomain(fieldDef, scale), valid = _a.valid, reason = _a.reason;
        if (!valid) {
            log.warn(reason);
            return undefined;
        }
    }
    else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {
        // Apply config if domain is not specified.
        var valid = canUseUnaggregatedDomain(fieldDef, scale).valid;
        if (valid) {
            return 'unaggregated';
        }
    }
    return domain;
}
exports.initDomain = initDomain;
function parseDomain(model, channel) {
    var scale = model.scale(channel);
    // If channel is either X or Y then union them with X2 & Y2 if they exist
    if (channel === 'x' && model.channelHasField('x2')) {
        if (model.channelHasField('x')) {
            return unionDomains(parseSingleChannelDomain(scale, model, 'x'), parseSingleChannelDomain(scale, model, 'x2'));
        }
        else {
            return parseSingleChannelDomain(scale, model, 'x2');
        }
    }
    else if (channel === 'y' && model.channelHasField('y2')) {
        if (model.channelHasField('y')) {
            return unionDomains(parseSingleChannelDomain(scale, model, 'y'), parseSingleChannelDomain(scale, model, 'y2'));
        }
        else {
            return parseSingleChannelDomain(scale, model, 'y2');
        }
    }
    return parseSingleChannelDomain(scale, model, channel);
}
exports.parseDomain = parseDomain;
function parseSingleChannelDomain(scale, model, channel) {
    var fieldDef = model.fieldDef(channel);
    if (scale.domain && scale.domain !== 'unaggregated') {
        if (datetime_1.isDateTime(scale.domain[0])) {
            return scale.domain.map(function (dt) {
                return datetime_1.timestamp(dt, true);
            });
        }
        return scale.domain;
    }
    var stack = model.stack;
    if (stack && channel === stack.fieldChannel) {
        if (stack.offset === 'normalize') {
            return [0, 1];
        }
        return {
            data: model.getDataName(data_1.MAIN),
            fields: [
                model.field(channel, { suffix: 'start' }),
                model.field(channel, { suffix: 'end' })
            ]
        };
    }
    var sort = domainSort(model, channel, scale.type);
    if (scale.domain === 'unaggregated') {
        return {
            data: model.getDataName(data_1.MAIN),
            fields: [
                model.field(channel, { aggregate: 'min' }),
                model.field(channel, { aggregate: 'max' })
            ]
        };
    }
    else if (fieldDef.bin) {
        if (scale_1.isBinScale(scale.type)) {
            var signal = model.getName(bin_1.binToString(fieldDef.bin) + "_" + fieldDef.field + "_bins");
            return { signal: "sequence(" + signal + ".start, " + signal + ".stop + " + signal + ".step, " + signal + ".step)" };
        }
        if (scale_1.hasDiscreteDomain(scale.type)) {
            // ordinal bin scale takes domain from bin_range, ordered by bin_start
            // This is useful for both axis-based scale (x, y, column, and row) and legend-based scale (other channels).
            return {
                data: model.getDataName(data_1.MAIN),
                field: model.field(channel, { binSuffix: 'range' }),
                sort: {
                    field: model.field(channel, { binSuffix: 'start' }),
                    op: 'min' // min or max doesn't matter since same _range would have the same _start
                }
            };
        }
        else {
            if (channel === 'x' || channel === 'y') {
                // X/Y position have to include start and end for non-ordinal scale
                return {
                    data: model.getDataName(data_1.MAIN),
                    fields: [
                        model.field(channel, { binSuffix: 'start' }),
                        model.field(channel, { binSuffix: 'end' })
                    ]
                };
            }
            else {
                // TODO: use bin_mid
                return {
                    data: model.getDataName(data_1.MAIN),
                    field: model.field(channel, { binSuffix: 'start' })
                };
            }
        }
    }
    else if (sort) {
        return {
            // If sort by aggregation of a specified sort field, we need to use RAW table,
            // so we can aggregate values for the scale independently from the main aggregation.
            data: util.isBoolean(sort) ? model.getDataName(data_1.MAIN) : model.getDataName(data_1.RAW),
            field: model.field(channel),
            sort: sort
        };
    }
    else {
        return {
            data: model.getDataName(data_1.MAIN),
            field: model.field(channel),
        };
    }
}
function domainSort(model, channel, scaleType) {
    if (!scale_1.hasDiscreteDomain(scaleType)) {
        return undefined;
    }
    var sort = model.sort(channel);
    // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)
    if (sort_1.isSortField(sort)) {
        return {
            op: sort.op,
            field: sort.field
        };
    }
    if (util.contains(['ascending', 'descending', undefined /* default =ascending*/], sort)) {
        return true;
    }
    // sort === 'none'
    return undefined;
}
exports.domainSort = domainSort;
/**
 * Determine if a scale can use unaggregated domain.
 * @return {Boolean} Returns true if all of the following conditons applies:
 * 1. `scale.domain` is `unaggregated`
 * 2. Aggregation function is not `count` or `sum`
 * 3. The scale is quantitative or time scale.
 */
function canUseUnaggregatedDomain(fieldDef, scaleType) {
    if (!fieldDef.aggregate) {
        return {
            valid: false,
            reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)
        };
    }
    if (aggregate_1.SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) === -1) {
        return {
            valid: false,
            reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)
        };
    }
    if (fieldDef.type === 'quantitative') {
        if (scaleType === 'log') {
            return {
                valid: false,
                reason: log.message.unaggregatedDomainWithLogScale(fieldDef)
            };
        }
    }
    return { valid: true };
}
exports.canUseUnaggregatedDomain = canUseUnaggregatedDomain;
/**
 * Convert the domain to an array of data refs or an array of values. Also, throw
 * away sorting information since we always sort the domain when we union two domains.
 */
function normalizeDomain(domain) {
    if (util.isArray(domain)) {
        return [domain];
    }
    else if (vega_schema_1.isDataRefDomain(domain)) {
        delete domain.sort;
        return [domain];
    }
    else if (vega_schema_1.isFieldRefUnionDomain(domain)) {
        return domain.fields.map(function (d) {
            return {
                data: domain.data,
                field: d
            };
        });
    }
    else if (vega_schema_1.isDataRefUnionedDomain(domain)) {
        return domain.fields.map(function (d) {
            if (util.isArray(d)) {
                return d;
            }
            return {
                field: d.field,
                data: d.data
            };
        });
    }
    /* istanbul ignore next: This should never happen. */
    throw new Error(log.message.INVAID_DOMAIN);
}
/**
 * Union two data domains. A unioned domain is always sorted.
 */
function unionDomains(domain1, domain2) {
    if (vega_schema_1.isSignalRefDomain(domain1) || vega_schema_1.isSignalRefDomain(domain2)) {
        if (!vega_schema_1.isSignalRefDomain(domain1) || !vega_schema_1.isSignalRefDomain(domain2) || domain1.signal !== domain2.signal) {
            throw new Error(log.message.UNABLE_TO_MERGE_DOMAINS);
        }
        return domain1;
    }
    var normalizedDomain1 = normalizeDomain(domain1);
    var normalizedDomain2 = normalizeDomain(domain2);
    var domains = normalizedDomain1.concat(normalizedDomain2);
    domains = util.unique(domains, util.hash);
    if (domains.length > 1) {
        var allData = domains.map(function (d) {
            if (vega_schema_1.isDataRefDomain(d)) {
                return d.data;
            }
            return null;
        });
        if (util.unique(allData, function (x) { return x; }).length === 1 && allData[0] !== null) {
            return {
                data: allData[0],
                fields: domains.map(function (d) { return d.field; })
            };
        }
        return { fields: domains, sort: true };
    }
    else {
        return domains[0];
    }
}
exports.unionDomains = unionDomains;

},{"../../aggregate":41,"../../bin":43,"../../data":106,"../../datetime":107,"../../log":113,"../../scale":115,"../../sort":117,"../../util":124,"../../vega.schema":126}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var scale_1 = require("../../scale");
var util = require("../../util");
var domain_1 = require("./domain");
var range_1 = require("./range");
var rules = require("./rules");
var type_1 = require("./type");
/**
 * All scale properties except type and all range properties.
 */
exports.NON_TYPE_RANGE_SCALE_PROPERTIES = [
    // general properties
    'domain',
    'round',
    // quantitative / time
    'clamp', 'nice',
    // quantitative
    'exponent', 'zero',
    'interpolate',
    // ordinal
    'padding', 'paddingInner', 'paddingOuter' // padding
];
/**
 * Initialize Vega-Lite Scale's properties
 *
 * Note that we have to apply these rules here because:
 * - many other scale and non-scale properties (including layout, mark) depend on scale type
 * - layout depends on padding
 * - range depends on zero and size (width and height) depends on range
 */
function init(channel, fieldDef, config, mark, topLevelSize, xyRangeSteps) {
    var specifiedScale = (fieldDef || {}).scale || {};
    var scale = {
        type: type_1.default(specifiedScale.type, channel, fieldDef, mark, topLevelSize !== undefined, specifiedScale.rangeStep, config.scale)
    };
    // Use specified value if compatible or determine default values for each property
    exports.NON_TYPE_RANGE_SCALE_PROPERTIES.forEach(function (property) {
        var specifiedValue = specifiedScale[property];
        var supportedByScaleType = scale_1.scaleTypeSupportProperty(scale.type, property);
        var channelIncompatability = scale_1.channelScalePropertyIncompatability(channel, property);
        if (specifiedValue !== undefined) {
            // If there is a specified value, check if it is compatible with scale type and channel
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scale.type, property, channel));
            }
            else if (channelIncompatability) {
                log.warn(channelIncompatability);
            }
        }
        if (supportedByScaleType && channelIncompatability === undefined) {
            var value = getValue(specifiedValue, property, scale, channel, fieldDef, config.scale);
            if (value !== undefined) {
                scale[property] = value;
            }
        }
    });
    return util.extend(scale, range_1.default(channel, scale.type, fieldDef.type, specifiedScale, config, scale.zero, mark, topLevelSize, xyRangeSteps));
}
exports.default = init;
function getValue(specifiedValue, property, scale, channel, fieldDef, scaleConfig) {
    // For domain, we might override specified value
    if (property === 'domain') {
        return domain_1.initDomain(specifiedValue, fieldDef, scale.type, scaleConfig);
    }
    // Other properties, no overriding default values
    if (specifiedValue !== undefined) {
        return specifiedValue;
    }
    return getDefaultValue(property, scale, channel, fieldDef, scaleConfig);
}
function getDefaultValue(property, scale, channel, fieldDef, scaleConfig) {
    // If we have default rule-base, determine default value first
    switch (property) {
        case 'nice':
            return rules.nice(scale.type, channel, fieldDef);
        case 'padding':
            return rules.padding(channel, scale.type, scaleConfig);
        case 'paddingInner':
            return rules.paddingInner(scale.padding, channel, scaleConfig);
        case 'paddingOuter':
            return rules.paddingOuter(scale.padding, channel, scale.type, scale.paddingInner, scaleConfig);
        case 'round':
            return rules.round(channel, scaleConfig);
        case 'zero':
            return rules.zero(scale, channel, fieldDef);
    }
    // Otherwise, use scale config
    return scaleConfig[property];
}

},{"../../log":113,"../../scale":115,"../../util":124,"./domain":85,"./range":88,"./rules":89,"./type":90}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var sort_1 = require("../../sort");
var domain_1 = require("./domain");
var range_1 = require("./range");
/**
 * Parse scales for all channels of a model.
 */
function parseScaleComponent(model) {
    // TODO: should model.channels() inlcude X2/Y2?
    return model.channels().reduce(function (scaleComponentsIndex, channel) {
        var scaleComponents = parseScale(model, channel);
        if (scaleComponents) {
            scaleComponentsIndex[channel] = scaleComponents;
        }
        return scaleComponentsIndex;
    }, {});
}
exports.default = parseScaleComponent;
exports.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = [
    'round',
    // quantitative / time
    'clamp', 'nice',
    // quantitative
    'exponent', 'interpolate', 'zero',
    // ordinal
    'padding', 'paddingInner', 'paddingOuter',
];
/**
 * Parse scales for a single channel of a model.
 */
function parseScale(model, channel) {
    if (!model.scale(channel)) {
        return null;
    }
    var scale = model.scale(channel);
    var sort = model.sort(channel);
    var scaleComponent = {
        name: model.scaleName(channel + '', true),
        type: scale.type,
        domain: domain_1.parseDomain(model, channel),
        range: range_1.parseRange(scale)
    };
    exports.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES.forEach(function (property) {
        scaleComponent[property] = scale[property];
    });
    if (sort && (sort_1.isSortField(sort) ? sort.order : sort) === 'descending') {
        scaleComponent.reverse = true;
    }
    return scaleComponent;
}
exports.parseScale = parseScale;

},{"../../sort":117,"./domain":85,"./range":88}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var util = require("../../util");
function parseRange(scale) {
    if (scale.rangeStep) {
        return { step: scale.rangeStep };
    }
    else if (scale.scheme) {
        var scheme = scale.scheme;
        if (scale_1.isExtendedScheme(scheme)) {
            var r = { scheme: scheme.name };
            if (scheme.count) {
                r.count = scheme.count;
            }
            if (scheme.extent) {
                r.extent = scheme.extent;
            }
            return r;
        }
        else {
            return { scheme: scheme };
        }
    }
    return scale.range;
}
exports.parseRange = parseRange;
exports.RANGE_PROPERTIES = ['range', 'rangeStep', 'scheme'];
/**
 * Return mixins that includes one of the range properties (range, rangeStep, scheme).
 */
function rangeMixins(channel, scaleType, type, specifiedScale, config, zero, mark, topLevelSize, xyRangeSteps) {
    var specifiedRangeStepIsNull = false;
    // Check if any of the range properties is specified.
    // If so, check if it is compatible and make sure that we only output one of the properties
    for (var _i = 0, RANGE_PROPERTIES_1 = exports.RANGE_PROPERTIES; _i < RANGE_PROPERTIES_1.length; _i++) {
        var property = RANGE_PROPERTIES_1[_i];
        if (specifiedScale[property] !== undefined) {
            var supportedByScaleType = scale_1.scaleTypeSupportProperty(scaleType, property);
            var channelIncompatability = scale_1.channelScalePropertyIncompatability(channel, property);
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));
            }
            else if (channelIncompatability) {
                log.warn(channelIncompatability);
            }
            else {
                switch (property) {
                    case 'range':
                        return { range: specifiedScale[property] };
                    case 'scheme':
                        return { scheme: specifiedScale[property] };
                    case 'rangeStep':
                        if (topLevelSize === undefined) {
                            var stepSize = specifiedScale[property];
                            if (stepSize !== null) {
                                return { rangeStep: stepSize };
                            }
                            else {
                                specifiedRangeStepIsNull = true;
                            }
                        }
                        else {
                            // If top-level size is specified, we ignore specified rangeStep.
                            log.warn(log.message.rangeStepDropped(channel));
                        }
                }
            }
        }
    }
    switch (channel) {
        // TODO: revise row/column when facetSpec has top-level width/height
        case channel_1.ROW:
            return { range: 'height' };
        case channel_1.COLUMN:
            return { range: 'width' };
        case channel_1.X:
        case channel_1.Y:
            if (topLevelSize === undefined) {
                if (util.contains(['point', 'band'], scaleType) && !specifiedRangeStepIsNull) {
                    if (channel === channel_1.X && mark === 'text') {
                        if (config.scale.textXRangeStep) {
                            return { rangeStep: config.scale.textXRangeStep };
                        }
                    }
                    else {
                        if (config.scale.rangeStep) {
                            return { rangeStep: config.scale.rangeStep };
                        }
                    }
                }
                // If specified range step is null or the range step config is null.
                // Use default topLevelSize rule/config
                topLevelSize = channel === channel_1.X ? config.cell.width : config.cell.height;
            }
            return { range: channel === channel_1.X ? [0, topLevelSize] : [topLevelSize, 0] };
        case channel_1.SIZE:
            // TODO: support custom rangeMin, rangeMax
            var rangeMin = sizeRangeMin(mark, zero, config);
            var rangeMax = sizeRangeMax(mark, xyRangeSteps, config);
            return { range: [rangeMin, rangeMax] };
        case channel_1.SHAPE:
        case channel_1.COLOR:
            return { range: defaultRange(channel, scaleType, type, mark) };
        case channel_1.OPACITY:
            // TODO: support custom rangeMin, rangeMax
            return { range: [config.scale.minOpacity, config.scale.maxOpacity] };
    }
    /* istanbul ignore next: should never reach here */
    throw new Error("Scale range undefined for channel " + channel);
}
exports.default = rangeMixins;
function defaultRange(channel, scaleType, type, mark) {
    switch (channel) {
        case channel_1.SHAPE:
            return 'symbol';
        case channel_1.COLOR:
            if (scaleType === 'ordinal') {
                // Only nominal data uses ordinal scale by default
                return type === 'nominal' ? 'category' : 'ordinal';
            }
            return mark === 'rect' ? 'heatmap' : 'ramp';
    }
}
function sizeRangeMin(mark, zero, config) {
    if (zero) {
        return 0;
    }
    switch (mark) {
        case 'bar':
            return config.scale.minBandSize !== undefined ? config.scale.minBandSize : config.bar.continuousBandSize;
        case 'tick':
            return config.scale.minBandSize;
        case 'line':
        case 'rule':
            return config.scale.minStrokeWidth;
        case 'text':
            return config.scale.minFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.minSize) {
                return config.scale.minSize;
            }
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMin not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
function sizeRangeMax(mark, xyRangeSteps, config) {
    var scaleConfig = config.scale;
    // TODO(#1168): make max size scale based on rangeStep / overall plot size
    switch (mark) {
        case 'bar':
        case 'tick':
            if (config.scale.maxBandSize !== undefined) {
                return config.scale.maxBandSize;
            }
            return minXYRangeStep(xyRangeSteps, config.scale) - 1;
        case 'line':
        case 'rule':
            return config.scale.maxStrokeWidth;
        case 'text':
            return config.scale.maxFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.maxSize) {
                return config.scale.maxSize;
            }
            // FIXME this case totally should be refactored
            var pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);
            return (pointStep - 2) * (pointStep - 2);
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMax not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
/**
 * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.
 */
function minXYRangeStep(xyRangeSteps, scaleConfig) {
    if (xyRangeSteps.length > 0) {
        return Math.min.apply(null, xyRangeSteps);
    }
    if (scaleConfig.rangeStep) {
        return scaleConfig.rangeStep;
    }
    return 21; // FIXME: re-evaluate the default value here.
}

},{"../../channel":44,"../../log":113,"../../scale":115,"../../util":124}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var timeunit_1 = require("../../timeunit");
var util = require("../../util");
function nice(scaleType, channel, fieldDef) {
    if (util.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scaleType)) {
        return timeunit_1.smallestUnit(fieldDef.timeUnit);
    }
    return util.contains([channel_1.X, channel_1.Y], channel); // return true for quantitative X/Y
}
exports.nice = nice;
function padding(channel, scaleType, scaleConfig) {
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        if (scaleType === scale_1.ScaleType.POINT) {
            return scaleConfig.pointPadding;
        }
    }
    return undefined;
}
exports.padding = padding;
function paddingInner(padding, channel, scaleConfig) {
    if (padding !== undefined) {
        // If user has already manually specified "padding", no need to add default paddingInner.
        return undefined;
    }
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        // Padding is only set for X and Y by default.
        // Basically it doesn't make sense to add padding for color and size.
        // paddingOuter would only be called if it's a band scale, just return the default for bandScale.
        return scaleConfig.bandPaddingInner;
    }
    return undefined;
}
exports.paddingInner = paddingInner;
function paddingOuter(padding, channel, scaleType, paddingInner, scaleConfig) {
    if (padding !== undefined) {
        // If user has already manually specified "padding", no need to add default paddingOuter.
        return undefined;
    }
    if (util.contains([channel_1.X, channel_1.Y], channel)) {
        // Padding is only set for X and Y by default.
        // Basically it doesn't make sense to add padding for color and size.
        if (scaleType === scale_1.ScaleType.BAND) {
            if (scaleConfig.bandPaddingOuter !== undefined) {
                return scaleConfig.bandPaddingOuter;
            }
            /* By default, paddingOuter is paddingInner / 2. The reason is that
                size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
                and we want the width/height to be integer by default.
                Note that step (by default) and cardinality are integers.) */
            return paddingInner / 2;
        }
    }
    return undefined;
}
exports.paddingOuter = paddingOuter;
function round(channel, scaleConfig) {
    if (util.contains(['x', 'y', 'row', 'column'], channel)) {
        return scaleConfig.round;
    }
    return undefined;
}
exports.round = round;
function zero(specifiedScale, channel, fieldDef) {
    // By default, return true only for the following cases:
    // 1) using quantitative field with size
    // While this can be either ratio or interval fields, our assumption is that
    // ratio are more common.
    if (channel === 'size' && fieldDef.type === 'quantitative') {
        return true;
    }
    // 2) non-binned, quantitative x-scale or y-scale if no custom domain is provided.
    // (For binning, we should not include zero by default because binning are calculated without zero.
    // Similar, if users explicitly provide a domain range, we should not augment zero as that will be unexpected.)
    if (!specifiedScale.domain && !fieldDef.bin && util.contains([channel_1.X, channel_1.Y], channel)) {
        return true;
    }
    return false;
}
exports.zero = zero;

},{"../../channel":44,"../../scale":115,"../../timeunit":120,"../../util":124}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("../../log");
var channel_1 = require("../../channel");
var scale_1 = require("../../scale");
var timeunit_1 = require("../../timeunit");
var scale_2 = require("../../scale");
var type_1 = require("../../type");
var util = require("../../util");
var util_1 = require("../../util");
/**
 * Determine if there is a specified scale type and if it is appropriate,
 * or determine default type if type is unspecified or inappropriate.
 */
// NOTE: CompassQL uses this method.
function type(specifiedType, channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    var defaultScaleType = defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
    if (!channel_1.hasScale(channel)) {
        // There is no scale for these channels
        return null;
    }
    if (specifiedType !== undefined) {
        // Check if explicitly specified scale type is supported by the channel
        if (!channel_1.supportScaleType(channel, specifiedType)) {
            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));
            return defaultScaleType;
        }
        // Check if explicitly specified scale type is supported by the data type
        if (!fieldDefMatchScaleType(specifiedType, fieldDef)) {
            log.warn(log.message.scaleTypeNotWorkWithFieldDef(specifiedType, defaultScaleType));
            return defaultScaleType;
        }
        return specifiedType;
    }
    return defaultScaleType;
}
exports.default = type;
/**
 * Determine appropriate default scale type.
 */
function defaultType(channel, fieldDef, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (util.contains(['row', 'column'], channel)) {
        return 'band';
    }
    switch (fieldDef.type) {
        case 'nominal':
            if (channel === 'color' || channel_1.rangeType(channel) === 'discrete') {
                return 'ordinal';
            }
            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
        case 'ordinal':
            if (channel === 'color') {
                return 'ordinal';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));
                return 'ordinal';
            }
            return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
        case 'temporal':
            if (channel === 'color') {
                // Always use `sequential` as the default color scale for continuous data
                // since it supports both array range and scheme range.
                return 'sequential';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));
                // TODO: consider using quantize (equivalent to binning) once we have it
                return 'ordinal';
            }
            if (timeunit_1.isDiscreteByDefault(fieldDef.timeUnit)) {
                return discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig);
            }
            return 'time';
        case 'quantitative':
            if (channel === 'color') {
                if (fieldDef.bin) {
                    return 'bin-ordinal';
                }
                // Use `sequential` as the default color scale for continuous data
                // since it supports both array range and scheme range.
                return 'sequential';
            }
            else if (channel_1.rangeType(channel) === 'discrete') {
                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));
                // TODO: consider using quantize (equivalent to binning) once we have it
                return 'ordinal';
            }
            if (fieldDef.bin) {
                return 'bin-linear';
            }
            return 'linear';
    }
    /* istanbul ignore next: should never reach this */
    throw new Error(log.message.invalidFieldType(fieldDef.type));
}
/**
 * Determines default scale type for nominal/ordinal field.
 * @returns BAND or POINT scale based on channel, mark, and rangeStep
 */
function discreteToContinuousType(channel, mark, hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (util.contains(['x', 'y'], channel)) {
        if (mark === 'rect') {
            // The rect mark should fit into a band.
            return 'band';
        }
        if (mark === 'bar') {
            // For bar, use band only if there is no rangeStep since we need to use band for fit mode.
            // However, for non-fit mode, point scale provides better center position.
            if (haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig)) {
                return 'point';
            }
            return 'band';
        }
    }
    // Otherwise, use ordinal point scale so we can easily get center positions of the marks.
    return 'point';
}
function haveRangeStep(hasTopLevelSize, specifiedRangeStep, scaleConfig) {
    if (hasTopLevelSize) {
        // if topLevelSize is provided, rangeStep will be dropped.
        return false;
    }
    if (specifiedRangeStep !== undefined) {
        return specifiedRangeStep !== null;
    }
    return !!scaleConfig.rangeStep;
}
function fieldDefMatchScaleType(specifiedType, fieldDef) {
    var type = fieldDef.type;
    if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {
        return specifiedType === undefined || scale_2.hasDiscreteDomain(specifiedType);
    }
    else if (type === type_1.Type.TEMPORAL) {
        if (!fieldDef.timeUnit) {
            return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], specifiedType);
        }
        else {
            return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], specifiedType) || scale_2.hasDiscreteDomain(specifiedType);
        }
    }
    else if (type === type_1.Type.QUANTITATIVE) {
        if (fieldDef.bin) {
            return specifiedType === scale_1.ScaleType.BIN_LINEAR || specifiedType === scale_1.ScaleType.BIN_ORDINAL;
        }
        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], specifiedType);
    }
    return true;
}
exports.fieldDefMatchScaleType = fieldDefMatchScaleType;

},{"../../channel":44,"../../log":113,"../../scale":115,"../../timeunit":120,"../../type":123,"../../util":124}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var channel_1 = require("../../channel");
var log_1 = require("../../log");
var util_1 = require("../../util");
var selection_1 = require("./selection");
var scales_1 = require("./transforms/scales");
exports.BRUSH = '_brush', exports.SIZE = '_size';
var interval = {
    predicate: 'vlInterval',
    signals: function (model, selCmpt) {
        var signals = [], intervals = [], name = selCmpt.name, size = name + exports.SIZE;
        if (selCmpt.translate && !(scales_1.default.has(selCmpt))) {
            events(selCmpt, function (_, evt) {
                var filters = evt.between[0].filter || (evt.between[0].filter = []);
                filters.push('!event.item || (event.item && ' +
                    ("event.item.mark.name !== " + util_1.stringValue(name + exports.BRUSH) + ")"));
            });
        }
        selCmpt.project.forEach(function (p) {
            if (p.encoding !== channel_1.X && p.encoding !== channel_1.Y) {
                log_1.warn('Interval selections only support x and y encoding channels.');
                return;
            }
            var cs = channelSignal(model, selCmpt, p.encoding);
            signals.push(cs);
            intervals.push("{field: " + util_1.stringValue(p.field) + ", extent: " + cs.name + "}");
        });
        signals.push({
            name: size,
            value: [],
            on: events(selCmpt, function (on, evt) {
                on.push({
                    events: evt.between[0],
                    update: '{x: x(unit), y: y(unit), width: 0, height: 0}'
                });
                on.push({
                    events: evt,
                    update: "{x: " + size + ".x, y: " + size + ".y, " +
                        ("width: abs(x(unit) - " + size + ".x), height: abs(y(unit) - " + size + ".y)}")
                });
                return on;
            })
        }, {
            name: name,
            update: "[" + intervals.join(', ') + "]"
        });
        return signals;
    },
    tupleExpr: function (model, selCmpt) {
        return "intervals: " + selCmpt.name;
    },
    modifyExpr: function (model, selCmpt) {
        var tpl = selCmpt.name + selection_1.TUPLE;
        return tpl + ", {unit: " + tpl + ".unit}";
    },
    marks: function (model, selCmpt, marks) {
        var name = selCmpt.name, _a = projections(selCmpt), x = _a.x, y = _a.y;
        // Do not add a brush if we're binding to scales.
        if (scales_1.default.has(selCmpt)) {
            return marks;
        }
        var update = {
            x: util_1.extend({}, x !== null ?
                { scale: model.scaleName(channel_1.X), signal: name + "[" + x + "].extent[0]" } :
                { value: 0 }),
            x2: util_1.extend({}, x !== null ?
                { scale: model.scaleName(channel_1.X), signal: name + "[" + x + "].extent[1]" } :
                { field: { group: 'width' } }),
            y: util_1.extend({}, y !== null ?
                { scale: model.scaleName(channel_1.Y), signal: name + "[" + y + "].extent[0]" } :
                { value: 0 }),
            y2: util_1.extend({}, y !== null ?
                { scale: model.scaleName(channel_1.Y), signal: name + "[" + y + "].extent[1]" } :
                { field: { group: 'height' } }),
        };
        return [{
                name: undefined,
                type: 'rect',
                encode: {
                    enter: { fill: { value: '#eee' } },
                    update: update
                }
            }].concat(marks, {
            name: name + exports.BRUSH,
            type: 'rect',
            encode: {
                enter: { fill: { value: 'transparent' } },
                update: update
            }
        });
    }
};
exports.default = interval;
function projections(selCmpt) {
    var x = null, y = null;
    selCmpt.project.forEach(function (p, i) {
        if (p.encoding === channel_1.X) {
            x = i;
        }
        else if (p.encoding === channel_1.Y) {
            y = i;
        }
    });
    return { x: x, y: y };
}
exports.projections = projections;
function channelSignal(model, selCmpt, channel) {
    var name = selection_1.channelSignalName(selCmpt, channel), size = (channel === channel_1.X ? 'width' : 'height'), coord = channel + "(unit)", invert = selection_1.invert.bind(null, model, selCmpt, channel);
    return {
        name: name,
        value: [],
        on: scales_1.default.has(selCmpt) ? [] : events(selCmpt, function (on, evt) {
            on.push({
                events: evt.between[0],
                update: invert("[" + coord + ", " + coord + "]")
            });
            on.push({
                events: evt,
                update: "[" + name + "[0], " + invert("clamp(" + coord + ", 0, " + size + ")") + ']'
            });
            return on;
        })
    };
}
function events(selCmpt, cb) {
    return selCmpt.events.reduce(function (on, evt) {
        if (!evt.between) {
            log_1.warn(evt + " is not an ordered event stream for interval selections");
            return on;
        }
        return cb(on, evt);
    }, []);
}

},{"../../channel":44,"../../log":113,"../../util":124,"./selection":93,"./transforms/scales":98}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var selection_1 = require("./selection");
var multi = {
    predicate: 'vlPoint',
    signals: function (model, selCmpt) {
        var proj = selCmpt.project, datum = '(item().isVoronoi ? datum.datum : datum)', fields = proj.map(function (p) { return util_1.stringValue(p.field); }).join(', '), values = proj.map(function (p) { return datum + "[" + util_1.stringValue(p.field) + "]"; }).join(', ');
        return [{
                name: selCmpt.name,
                value: {},
                on: [{
                        events: selCmpt.events,
                        update: "{fields: [" + fields + "], values: [" + values + "]}"
                    }]
            }];
    },
    tupleExpr: function (model, selCmpt) {
        var name = selCmpt.name;
        return "fields: " + name + ".fields, values: " + name + ".values";
    },
    modifyExpr: function (model, selCmpt) {
        return selCmpt.name + selection_1.TUPLE;
    }
};
exports.default = multi;

},{"../../util":124,"./selection":93}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var util_1 = require("../../util");
var interval_1 = require("./interval");
var multi_1 = require("./multi");
var single_1 = require("./single");
var transforms_1 = require("./transforms/transforms");
exports.STORE = '_store', exports.TUPLE = '_tuple', exports.MODIFY = '_modify';
function parseUnitSelection(model, selDefs) {
    var selCmpts = {}, selectionConfig = model.config.selection;
    var _loop_1 = function (name_1) {
        if (!selDefs.hasOwnProperty(name_1)) {
            return "continue";
        }
        var selDef = selDefs[name_1], cfg = selectionConfig[selDef.type];
        // Set default values from config if a property hasn't been specified,
        // or if it is true. E.g., "translate": true should use the default
        // event handlers for translate. However, true may be a valid value for
        // a property (e.g., "nearest": true).
        for (var key in cfg) {
            // A selection should contain either `encodings` or `fields`, only use
            // default values for these two values if neither of them is specified.
            if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {
                continue;
            }
            if (selDef[key] === undefined || selDef[key] === true) {
                selDef[key] = cfg[key] || selDef[key];
            }
        }
        var selCmpt = selCmpts[name_1] = util_1.extend({}, selDef, {
            name: model.getName(name_1),
            events: util_1.isString(selDef.on) ? vega_event_selector_1.selector(selDef.on, 'scope') : selDef.on,
            domain: 'data',
            resolve: 'union'
        });
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.parse) {
                txCompiler.parse(model, selDef, selCmpt);
            }
        });
    };
    for (var name_1 in selDefs) {
        _loop_1(name_1);
    }
    return selCmpts;
}
exports.parseUnitSelection = parseUnitSelection;
function assembleUnitSignals(model, signals) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        var name = selCmpt.name, tupleExpr = selCompiler.tupleExpr(model, selCmpt);
        var modifyExpr = selCompiler.modifyExpr(model, selCmpt);
        signals.push.apply(signals, selCompiler.signals(model, selCmpt));
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.signals) {
                signals = txCompiler.signals(model, selCmpt, signals);
            }
            if (txCompiler.modifyExpr) {
                modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
            }
        });
        signals.push({
            name: name + exports.TUPLE,
            on: [{
                    events: { signal: name },
                    update: "{unit: unit.datum && unit.datum._id, " + tupleExpr + "}"
                }]
        }, {
            name: name + exports.MODIFY,
            on: [{
                    events: { signal: name },
                    update: "modify(" + util_1.stringValue(name + exports.STORE) + ", " + modifyExpr + ")"
                }]
        });
    });
    return signals;
}
exports.assembleUnitSignals = assembleUnitSignals;
function assembleTopLevelSignals(model) {
    var signals = [{
            name: 'unit',
            value: {},
            on: [{ events: 'mousemove', update: 'group()._id ? group() : unit' }]
        }];
    forEachSelection(model, function (selCmpt, selCompiler) {
        if (selCompiler.topLevelSignals) {
            signals.push.apply(signals, selCompiler.topLevelSignals(model, selCmpt));
        }
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.topLevelSignals) {
                signals = txCompiler.topLevelSignals(model, selCmpt, signals);
            }
        });
    });
    return signals;
}
exports.assembleTopLevelSignals = assembleTopLevelSignals;
function assembleUnitData(model, data) {
    return data
        .concat(Object.keys(model.component.selection)
        .map(function (k) {
        return { name: k + exports.STORE };
    }));
}
exports.assembleUnitData = assembleUnitData;
function assembleUnitMarks(model, marks) {
    var clippedGroup = false, selMarks = marks;
    forEachSelection(model, function (selCmpt, selCompiler) {
        selMarks = selCompiler.marks ? selCompiler.marks(model, selCmpt, selMarks) : selMarks;
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            clippedGroup = clippedGroup || txCompiler.clippedGroup;
            if (txCompiler.marks) {
                selMarks = txCompiler.marks(model, selCmpt, marks, selMarks);
            }
        });
    });
    if (clippedGroup) {
        selMarks = [{
                type: 'group',
                encode: {
                    enter: {
                        width: { field: { group: 'width' } },
                        height: { field: { group: 'height' } },
                        fill: { value: 'transparent' },
                        clip: { value: true }
                    }
                },
                marks: selMarks.map(model.correctDataNames)
            }];
    }
    return selMarks;
}
exports.assembleUnitMarks = assembleUnitMarks;
var PREDICATES_OPS = {
    'single': '"intersect", "all"',
    'independent': '"intersect", "unit"',
    'union': '"union", "all"',
    'union_others': '"union", "others"',
    'intersect': '"intersect", "all"',
    'intersect_others': '"intersect", "others'
};
function predicate(selCmpt, datum) {
    var store = util_1.stringValue(selCmpt.name + exports.STORE), op = PREDICATES_OPS[selCmpt.resolve];
    datum = datum || 'datum';
    return compiler(selCmpt).predicate + ("(" + store + ", parent._id, " + datum + ", " + op + ")");
}
exports.predicate = predicate;
// Utility functions
function forEachSelection(model, cb) {
    var selections = model.component.selection;
    for (var name_2 in selections) {
        if (selections.hasOwnProperty(name_2)) {
            var sel = selections[name_2];
            cb(sel, compiler(sel));
        }
    }
}
function compiler(selCmpt) {
    switch (selCmpt.type) {
        case 'single':
            return single_1.default;
        case 'multi':
            return multi_1.default;
        case 'interval':
            return interval_1.default;
    }
    return null;
}
function invert(model, selCmpt, channel, expr) {
    var scale = util_1.stringValue(model.scaleName(channel));
    return selCmpt.domain === 'data' ? "invert(" + scale + ", " + expr + ")" : expr;
}
exports.invert = invert;
function channelSignalName(selCmpt, channel) {
    return selCmpt.name + '_' + channel;
}
exports.channelSignalName = channelSignalName;

},{"../../util":124,"./interval":91,"./multi":92,"./single":94,"./transforms/transforms":100,"vega-event-selector":39}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../util");
var multi_1 = require("./multi");
var selection_1 = require("./selection");
var single = {
    predicate: multi_1.default.predicate,
    signals: multi_1.default.signals,
    topLevelSignals: function (model, selCmpt) {
        var name = selCmpt.name;
        return [{
                name: name,
                update: "data(" + util_1.stringValue(name + selection_1.STORE) + ")[0]"
            }];
    },
    tupleExpr: function (model, selCmpt) {
        var name = selCmpt.name, values = name + ".values";
        return "fields: " + name + ".fields, values: " + values + ", " +
            selCmpt.project.map(function (p, i) {
                return p.field + ": " + values + "[" + i + "]";
            }).join(', ');
    },
    modifyExpr: function (model, selCmpt) {
        return selCmpt.name + selection_1.TUPLE + ', true';
    }
};
exports.default = single;

},{"../../util":124,"./multi":92,"./selection":93}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../../../util");
var inputBindings = {
    has: function (selCmpt) {
        return selCmpt.type === 'single' && selCmpt.bind && selCmpt.bind !== 'scales';
    },
    topLevelSignals: function (model, selCmpt, signals) {
        var name = selCmpt.name, proj = selCmpt.project, bind = selCmpt.bind, datum = '(item().isVoronoi ? datum.datum : datum)';
        proj.forEach(function (p) {
            signals.unshift({
                name: name + id(p.field),
                value: '',
                on: [{
                        events: selCmpt.events,
                        update: datum + "[" + util_1.stringValue(p.field) + "]"
                    }],
                bind: bind[p.field] || bind[p.encoding] || bind
            });
        });
        return signals;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, proj = selCmpt.project, signal = signals.filter(function (s) { return s.name === name; })[0], fields = proj.map(function (p) { return util_1.stringValue(p.field); }).join(', '), values = proj.map(function (p) { return name + id(p.field); }).join(', ');
        signal.update = "{fields: [" + fields + "], values: [" + values + "]}";
        delete signal.value;
        delete signal.on;
        return signals;
    }
};
exports.default = inputBindings;
function id(str) {
    return '_' + str.replace(/\W/g, '_');
}

},{"../../../util":124}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var VORONOI = 'voronoi';
var nearest = {
    has: function (selCmpt) {
        return selCmpt.nearest !== undefined && selCmpt.nearest !== false;
    },
    marks: function (model, selCmpt, marks, selMarks) {
        var mark = marks[0], index = selMarks.indexOf(mark), isPathgroup = mark.name === model.getName('pathgroup'), exists = (function (m) { return m.name && m.name.indexOf(VORONOI) >= 0; }), cellDef = {
            name: model.getName(VORONOI),
            type: 'path',
            from: { data: model.getName('marks') },
            encode: {
                enter: {
                    fill: { value: 'transparent' },
                    strokeWidth: { value: 0.35 },
                    stroke: { value: 'transparent' },
                    isVoronoi: { value: true }
                }
            },
            transform: [{
                    type: 'voronoi',
                    x: 'datum.x',
                    y: 'datum.y',
                    size: [{ signal: 'width' }, { signal: 'height' }]
                }]
        };
        if (isPathgroup && !mark.marks.filter(exists).length) {
            mark.marks.push(cellDef);
            selMarks.splice(index, 1, mark);
        }
        else if (!isPathgroup && !selMarks.filter(exists).length) {
            selMarks.splice(index + 1, 0, cellDef);
        }
        return selMarks;
    }
};
exports.default = nearest;

},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var project = {
    has: function (selDef) {
        return selDef.fields !== undefined || selDef.encodings !== undefined;
    },
    parse: function (model, selDef, selCmpt) {
        var fields = {};
        // TODO: find a possible channel mapping for these fields.
        (selDef.fields || []).forEach(function (f) { return fields[f] = null; });
        (selDef.encodings || []).forEach(function (e) { return fields[model.field(e)] = e; });
        var projection = selCmpt.project || (selCmpt.project = []);
        for (var field in fields) {
            if (fields.hasOwnProperty(field)) {
                projection.push({ field: field, encoding: fields[field] });
            }
        }
    }
};
exports.default = project;

},{}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = require("../../../log");
var scale_1 = require("../../../scale");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var selection_1 = require("../selection");
var scaleBindings = {
    clippedGroup: true,
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.bind && selCmpt.bind === 'scales';
    },
    parse: function (model, selDef, selCmpt) {
        var scales = model.component.scales;
        var bound = selCmpt.scales = [];
        selCmpt.project.forEach(function (p) {
            var channel = p.encoding;
            var scale = scales[channel];
            if (!scale || !scale_1.hasContinuousDomain(scale.type)) {
                log_1.warn('Scale bindings are currently only supported for scales with continuous domains.');
                return;
            }
            scale.domainRaw = { signal: selection_1.channelSignalName(selCmpt, channel) };
            bound.push(channel);
        });
    },
    topLevelSignals: function (model, selCmpt, signals) {
        return signals.concat(selCmpt.scales.map(function (channel) {
            return { name: selection_1.channelSignalName(selCmpt, channel) };
        }));
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name;
        signals = signals.filter(function (s) {
            return s.name !== name + interval_1.SIZE &&
                s.name !== name + selection_1.TUPLE && s.name !== selection_1.MODIFY;
        });
        selCmpt.scales.forEach(function (channel) {
            var signal = signals.filter(function (s) { return s.name === name + '_' + channel; })[0];
            signal.push = 'outer';
            delete signal.value;
            delete signal.update;
        });
        return signals;
    }
};
exports.default = scaleBindings;
function domain(model, channel) {
    var scale = util_1.stringValue(model.scaleName(channel));
    return "domain(" + scale + ")";
}
exports.domain = domain;

},{"../../../log":113,"../../../scale":115,"../../../util":124,"../interval":91,"../selection":93}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selection_1 = require("../selection");
var TOGGLE = '_toggle';
var toggle = {
    has: function (selCmpt) {
        return selCmpt.toggle !== undefined && selCmpt.toggle !== false;
    },
    signals: function (model, selCmpt, signals) {
        return signals.concat({
            name: selCmpt.name + TOGGLE,
            value: false,
            on: [{ events: selCmpt.events, update: selCmpt.toggle }]
        });
    },
    modifyExpr: function (model, selCmpt, expr) {
        var tpl = selCmpt.name + selection_1.TUPLE, signal = selCmpt.name + TOGGLE;
        return signal + " ? null : " + tpl + ", " +
            (signal + " ? null : true, ") +
            (signal + " ? " + tpl + " : null");
    }
};
exports.default = toggle;

},{"../selection":93}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var inputs_1 = require("./inputs");
var nearest_1 = require("./nearest");
var project_1 = require("./project");
var scales_1 = require("./scales");
var toggle_1 = require("./toggle");
var translate_1 = require("./translate");
var zoom_1 = require("./zoom");
var compilers = { project: project_1.default, toggle: toggle_1.default, scales: scales_1.default,
    translate: translate_1.default, zoom: zoom_1.default, inputs: inputs_1.default, nearest: nearest_1.default };
function forEachTransform(selCmpt, cb) {
    for (var t in compilers) {
        if (compilers[t].has(selCmpt)) {
            cb(compilers[t]);
        }
    }
}
exports.forEachTransform = forEachTransform;

},{"./inputs":95,"./nearest":96,"./project":97,"./scales":98,"./toggle":99,"./translate":101,"./zoom":102}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var channel_1 = require("../../../channel");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var scales_1 = require("./scales");
var ANCHOR = '_translate_anchor', DELTA = '_translate_delta';
var translate = {
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.translate !== undefined && selCmpt.translate !== false;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, scales = scales_1.default.has(selCmpt), size = scales ? 'unit' : name + interval_1.SIZE, anchor = name + ANCHOR, _a = interval_1.projections(selCmpt), x = _a.x, y = _a.y;
        var events = vega_event_selector_1.selector(selCmpt.translate, 'scope');
        if (!scales) {
            events = events.map(function (e) { return (e.between[0].markname = name + interval_1.BRUSH, e); });
        }
        signals.push({
            name: anchor,
            value: {},
            on: [{
                    events: events.map(function (e) { return e.between[0]; }),
                    update: '{x: x(unit), y: y(unit), ' +
                        ("width: " + size + ".width, height: " + size + ".height, ") +
                        (x !== null ? 'extent_x: ' + (scales ? scales_1.domain(model, channel_1.X) :
                            "slice(" + name + "_x)") + ', ' : '') +
                        (y !== null ? 'extent_y: ' + (scales ? scales_1.domain(model, channel_1.Y) :
                            "slice(" + name + "_y)") + ', ' : '') + '}'
                }]
        }, {
            name: name + DELTA,
            value: {},
            on: [{
                    events: events,
                    update: "{x: x(unit) - " + anchor + ".x, y: y(unit) - " + anchor + ".y}"
                }]
        });
        if (x !== null) {
            onDelta(model, selCmpt, channel_1.X, 'width', signals);
        }
        if (y !== null) {
            onDelta(model, selCmpt, channel_1.Y, 'height', signals);
        }
        return signals;
    }
};
exports.default = translate;
function getSign(selCmpt, channel) {
    var s = channel === channel_1.X ? '+' : '-';
    if (scales_1.default.has(selCmpt)) {
        s = s === '+' ? '-' : '+';
    }
    return s;
}
function onDelta(model, selCmpt, channel, size, signals) {
    var name = selCmpt.name, signal = signals.filter(function (s) { return s.name === name + '_' + channel; })[0], anchor = name + ANCHOR, delta = name + DELTA, scale = util_1.stringValue(model.scaleName(channel)), extent = ".extent_" + channel, sign = getSign(selCmpt, channel), offset = sign + " abs(span(" + anchor + extent + ")) * " +
        (delta + "." + channel + " / " + anchor + "." + size), range = "[" + anchor + extent + "[0] " + offset + ", " +
        ("" + anchor + extent + "[1] " + offset + "]"), lo = "invert(" + scale + (channel === channel_1.X ? ', 0' : ", unit." + size) + ')', hi = "invert(" + scale + (channel === channel_1.X ? ", unit." + size : ', 0') + ')';
    signal.on.push({
        events: { signal: delta },
        update: scales_1.default.has(selCmpt) ? range : "clampRange(" + range + ", " + lo + ", " + hi + ")"
    });
}

},{"../../../channel":44,"../../../util":124,"../interval":91,"./scales":98,"vega-event-selector":39}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var channel_1 = require("../../../channel");
var util_1 = require("../../../util");
var interval_1 = require("../interval");
var scales_1 = require("./scales");
var ANCHOR = '_zoom_anchor', DELTA = '_zoom_delta';
var zoom = {
    has: function (selCmpt) {
        return selCmpt.type === 'interval' && selCmpt.zoom !== undefined && selCmpt.zoom !== false;
    },
    signals: function (model, selCmpt, signals) {
        var name = selCmpt.name, delta = name + DELTA, _a = interval_1.projections(selCmpt), x = _a.x, y = _a.y, sx = util_1.stringValue(model.scaleName(channel_1.X)), sy = util_1.stringValue(model.scaleName(channel_1.Y));
        var events = vega_event_selector_1.selector(selCmpt.zoom, 'scope');
        if (!scales_1.default.has(selCmpt)) {
            events = events.map(function (e) { return (e.markname = name + interval_1.BRUSH, e); });
        }
        signals.push({
            name: name + ANCHOR,
            on: [{
                    events: events,
                    update: "{x: invert(" + sx + ", x(unit)), y: invert(" + sy + ", y(unit))}"
                }]
        }, {
            name: delta,
            on: [{
                    events: events,
                    force: true,
                    update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'
                }]
        });
        if (x !== null) {
            onDelta(model, selCmpt, 'x', 'width', signals);
        }
        if (y !== null) {
            onDelta(model, selCmpt, 'y', 'height', signals);
        }
        var size = signals.filter(function (s) { return s.name === name + interval_1.SIZE; });
        if (size.length) {
            var sname = size[0].name;
            size[0].on.push({
                events: { signal: delta },
                update: "{x: " + sname + ".x, y: " + sname + ".y, " +
                    ("width: " + sname + ".width * " + delta + " , ") +
                    ("height: " + sname + ".height * " + delta + "}")
            });
        }
        return signals;
    }
};
exports.default = zoom;
function onDelta(model, selCmpt, channel, size, signals) {
    var name = selCmpt.name, signal = signals.filter(function (s) { return s.name === name + '_' + channel; })[0], scales = scales_1.default.has(selCmpt), base = scales ? scales_1.domain(model, channel) : signal.name, anchor = "" + name + ANCHOR + "." + channel, delta = name + DELTA, scale = util_1.stringValue(model.scaleName(channel)), range = "[" + anchor + " + (" + base + "[0] - " + anchor + ") * " + delta + ", " +
        (anchor + " + (" + base + "[1] - " + anchor + ") * " + delta + "]"), lo = "invert(" + scale + (channel === channel_1.X ? ', 0' : ", unit." + size) + ')', hi = "invert(" + scale + (channel === channel_1.X ? ", unit." + size : ', 0') + ')';
    signal.on.push({
        events: { signal: delta },
        update: scales ? range : "clampRange(" + range + ", " + lo + ", " + hi + ")"
    });
}

},{"../../../channel":44,"../../../util":124,"../interval":91,"./scales":98,"vega-event-selector":39}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var channel_1 = require("../channel");
var encoding_1 = require("../encoding");
var vlEncoding = require("../encoding"); // TODO: remove
var fielddef_1 = require("../fielddef");
var mark_1 = require("../mark");
var scale_1 = require("../scale");
var stack_1 = require("../stack");
var util_1 = require("../util");
var parse_1 = require("./axis/parse");
var common_1 = require("./common");
var assemble_1 = require("./data/assemble");
var parse_2 = require("./data/parse");
var layout_1 = require("./layout");
var parse_3 = require("./legend/parse");
var init_1 = require("./mark/init");
var mark_2 = require("./mark/mark");
var model_1 = require("./model");
var init_2 = require("./scale/init");
var parse_4 = require("./scale/parse");
var selection_1 = require("./selection/selection");
/**
 * Internal model of Vega-Lite specification for the compiler.
 */
var UnitModel = (function (_super) {
    tslib_1.__extends(UnitModel, _super);
    function UnitModel(spec, parent, parentGivenName, cfg) {
        var _this = _super.call(this, spec, parent, parentGivenName, cfg) || this;
        _this.selection = {};
        _this.scales = {};
        _this.axes = {};
        _this.legends = {};
        _this.children = [];
        // FIXME(#2041): copy config.facet.cell to config.cell -- this seems incorrect and should be rewritten
        _this.initFacetCellConfig();
        // use top-level width / height or parent's top-level width / height
        // FIXME: once facet supports width/height, this is no longer correct!
        var providedWidth = spec.width !== undefined ? spec.width :
            parent ? parent['width'] : undefined; // only exists if parent is layer
        var providedHeight = spec.height !== undefined ? spec.height :
            parent ? parent['height'] : undefined; // only exists if parent is layer
        var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
        var encoding = _this.encoding = encoding_1.normalizeEncoding(spec.encoding || {}, mark);
        // calculate stack properties
        _this.stack = stack_1.stack(mark, encoding, _this.config.stack);
        _this.scales = _this.initScales(mark, encoding, providedWidth, providedHeight);
        _this.markDef = init_1.initMarkDef(spec.mark, encoding, _this.scales, _this.config);
        _this.encoding = init_1.initEncoding(mark, encoding, _this.stack, _this.config);
        _this.axes = _this.initAxes(encoding);
        _this.legends = _this.initLegend(encoding);
        // Selections will be initialized upon parse.
        _this.selection = spec.selection;
        // width / height
        var _a = _this.initSize(mark, _this.scales, providedWidth, providedHeight), _b = _a.width, width = _b === void 0 ? _this.width : _b, _c = _a.height, height = _c === void 0 ? _this.height : _c;
        _this.width = width;
        _this.height = height;
        return _this;
    }
    UnitModel.prototype.initFacetCellConfig = function () {
        var config = this.config;
        var ancestor = this.parent;
        var hasFacetAncestor = false;
        while (ancestor !== null) {
            if (ancestor.isFacet()) {
                hasFacetAncestor = true;
                break;
            }
            ancestor = ancestor.parent;
        }
        if (hasFacetAncestor) {
            config.cell = util_1.extend({}, config.cell, config.facet.cell);
        }
    };
    UnitModel.prototype.initScales = function (mark, encoding, topLevelWidth, topLevelHeight) {
        var _this = this;
        var xyRangeSteps = [];
        return channel_1.UNIT_SCALE_CHANNELS.reduce(function (scales, channel) {
            if (vlEncoding.channelHasField(encoding, channel) ||
                (channel === channel_1.X && vlEncoding.channelHasField(encoding, channel_1.X2)) ||
                (channel === channel_1.Y && vlEncoding.channelHasField(encoding, channel_1.Y2))) {
                var scale = scales[channel] = init_2.default(channel, encoding[channel], _this.config, mark, channel === channel_1.X ? topLevelWidth : channel === channel_1.Y ? topLevelHeight : undefined, xyRangeSteps // for determine point / bar size
                );
                if (channel === channel_1.X || channel === channel_1.Y) {
                    if (scale.rangeStep) {
                        xyRangeSteps.push(scale.rangeStep);
                    }
                }
            }
            return scales;
        }, {});
    };
    // TODO: consolidate this with scale?  Current scale range is in parseScale (later),
    // but not in initScale because scale range depends on size,
    // but size depends on scale type and rangeStep
    UnitModel.prototype.initSize = function (mark, scale, width, height) {
        var cellConfig = this.config.cell;
        var scaleConfig = this.config.scale;
        if (width === undefined) {
            if (scale[channel_1.X]) {
                if (!scale_1.hasDiscreteDomain(scale[channel_1.X].type) || !scale[channel_1.X].rangeStep) {
                    width = cellConfig.width;
                } // else: Do nothing, use dynamic width.
            }
            else {
                if (mark === mark_1.TEXT) {
                    // for text table without x/y scale we need wider rangeStep
                    width = scaleConfig.textXRangeStep;
                }
                else {
                    if (typeof scaleConfig.rangeStep === 'string') {
                        throw new Error('_initSize does not handle string rangeSteps');
                    }
                    width = scaleConfig.rangeStep;
                }
            }
        }
        if (height === undefined) {
            if (scale[channel_1.Y]) {
                if (!scale_1.hasDiscreteDomain(scale[channel_1.Y].type) || !scale[channel_1.Y].rangeStep) {
                    height = cellConfig.height;
                } // else: Do nothing, use dynamic height .
            }
            else {
                if (typeof scaleConfig.rangeStep === 'string') {
                    throw new Error('_initSize does not handle string rangeSteps');
                }
                height = scaleConfig.rangeStep;
            }
        }
        return { width: width, height: height };
    };
    UnitModel.prototype.initAxes = function (encoding) {
        return [channel_1.X, channel_1.Y].reduce(function (_axis, channel) {
            // Position Axis
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef) ||
                (channel === channel_1.X && fielddef_1.isFieldDef(encoding.x2)) ||
                (channel === channel_1.Y && fielddef_1.isFieldDef(encoding.y2))) {
                var axisSpec = fielddef_1.isFieldDef(channelDef) ? channelDef.axis : null;
                // We no longer support false in the schema, but we keep false here for backward compatability.
                if (axisSpec !== null && axisSpec !== false) {
                    _axis[channel] = tslib_1.__assign({}, axisSpec);
                }
            }
            return _axis;
        }, {});
    };
    UnitModel.prototype.initLegend = function (encoding) {
        return channel_1.NONSPATIAL_SCALE_CHANNELS.reduce(function (_legend, channel) {
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef)) {
                var legendSpec = channelDef.legend;
                if (legendSpec !== null && legendSpec !== false) {
                    _legend[channel] = tslib_1.__assign({}, legendSpec);
                }
            }
            return _legend;
        }, {});
    };
    UnitModel.prototype.parseData = function () {
        this.component.data = parse_2.parseData(this);
    };
    UnitModel.prototype.parseSelection = function () {
        this.component.selection = selection_1.parseUnitSelection(this, this.selection);
    };
    UnitModel.prototype.parseLayoutData = function () {
        this.component.layout = layout_1.parseUnitLayout(this);
    };
    UnitModel.prototype.parseScale = function () {
        this.component.scales = parse_4.default(this);
    };
    UnitModel.prototype.parseMark = function () {
        this.component.mark = mark_2.parseMark(this);
    };
    UnitModel.prototype.parseAxis = function () {
        this.component.axes = parse_1.parseAxisComponent(this, [channel_1.X, channel_1.Y]);
    };
    UnitModel.prototype.parseAxisGroup = function () {
        return null;
    };
    UnitModel.prototype.parseGridGroup = function () {
        return null;
    };
    UnitModel.prototype.parseLegend = function () {
        this.component.legends = parse_3.parseLegendComponent(this);
    };
    UnitModel.prototype.assembleData = function () {
        if (!this.parent) {
            // only assemble data in the root
            return assemble_1.assembleData(util_1.vals(this.component.data.sources));
        }
        return [];
    };
    UnitModel.prototype.assembleSignals = function (signals) {
        return selection_1.assembleUnitSignals(this, signals);
    };
    UnitModel.prototype.assembleSelectionData = function (data) {
        return selection_1.assembleUnitData(this, data);
    };
    UnitModel.prototype.assembleLayout = function (layoutData) {
        return layout_1.assembleLayout(this, layoutData);
    };
    UnitModel.prototype.assembleMarks = function () {
        var marks = this.component.mark || [];
        marks = selection_1.assembleUnitMarks(this, marks);
        return marks.map(this.correctDataNames);
    };
    UnitModel.prototype.assembleParentGroupProperties = function (cellConfig) {
        return common_1.applyConfig({}, cellConfig, mark_1.FILL_STROKE_CONFIG.concat(['clip']));
    };
    UnitModel.prototype.channels = function () {
        return channel_1.UNIT_CHANNELS;
    };
    UnitModel.prototype.getMapping = function () {
        return this.encoding;
    };
    UnitModel.prototype.toSpec = function (excludeConfig, excludeData) {
        var encoding = util_1.duplicate(this.encoding);
        var spec;
        spec = {
            mark: this.markDef,
            encoding: encoding
        };
        if (!excludeConfig) {
            spec.config = util_1.duplicate(this.config);
        }
        if (!excludeData) {
            spec.data = util_1.duplicate(this.data);
        }
        // remove defaults
        return spec;
    };
    UnitModel.prototype.mark = function () {
        return this.markDef.type;
    };
    UnitModel.prototype.channelHasField = function (channel) {
        return vlEncoding.channelHasField(this.encoding, channel);
    };
    UnitModel.prototype.fieldDef = function (channel) {
        // TODO: remove this || {}
        // Currently we have it to prevent null pointer exception.
        return this.encoding[channel] || {};
    };
    /** Get "field" reference for vega */
    UnitModel.prototype.field = function (channel, opt) {
        if (opt === void 0) { opt = {}; }
        var fieldDef = this.fieldDef(channel);
        if (fieldDef.bin) {
            opt = util_1.extend({
                binSuffix: scale_1.hasDiscreteDomain(this.scale(channel).type) ? 'range' : 'start'
            }, opt);
        }
        return fielddef_1.field(fieldDef, opt);
    };
    UnitModel.prototype.isUnit = function () {
        return true;
    };
    return UnitModel;
}(model_1.Model));
exports.UnitModel = UnitModel;

},{"../channel":44,"../encoding":108,"../fielddef":110,"../mark":114,"../scale":115,"../stack":119,"../util":124,"./axis/parse":46,"./common":48,"./data/assemble":51,"./data/parse":59,"./layout":67,"./legend/parse":69,"./mark/init":73,"./mark/mark":75,"./model":83,"./scale/init":86,"./scale/parse":87,"./selection/selection":93,"tslib":38}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var mark_1 = require("./mark");
exports.ERRORBAR = 'error-bar';
/**
 * Registry index for all composite mark's normalizer
 */
var normalizerRegistry = {};
function add(mark, normalizer) {
    normalizerRegistry[mark] = normalizer;
}
exports.add = add;
function remove(mark) {
    delete normalizerRegistry[mark];
}
exports.remove = remove;
/**
 * Transform a unit spec with composite mark into a normal layer spec.
 */
function normalize(
    // This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.
    spec) {
    var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
    var normalizer = normalizerRegistry[mark];
    if (normalizer) {
        return normalizer(spec);
    }
    throw new Error("Unregistered composite mark " + mark);
}
exports.normalize = normalize;
add(exports.ERRORBAR, function (spec) {
    var _m = spec.mark, encoding = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    var _s = encoding.size, encodingWithoutSize = tslib_1.__rest(encoding, ["size"]);
    var _x2 = encoding.x2, _y2 = encoding.y2, encodingWithoutX2Y2 = tslib_1.__rest(encoding, ["x2", "y2"]);
    var _x = encodingWithoutX2Y2.x, _y = encodingWithoutX2Y2.y, encodingWithoutX_X2_Y_Y2 = tslib_1.__rest(encodingWithoutX2Y2, ["x", "y"]);
    if (!encoding.x2 && !encoding.y2) {
        throw new Error('Neither x2 or y2 provided');
    }
    return tslib_1.__assign({}, outerSpec, { layer: [
            {
                mark: 'rule',
                encoding: encodingWithoutSize
            }, {
                mark: 'tick',
                encoding: encodingWithoutX2Y2
            }, {
                mark: 'tick',
                encoding: encoding.x2 ? tslib_1.__assign({ x: encoding.x2, y: encoding.y }, encodingWithoutX_X2_Y_Y2) : tslib_1.__assign({ x: encoding.x, y: encoding.y2 }, encodingWithoutX_X2_Y_Y2)
            }
        ] });
});

},{"./mark":114,"tslib":38}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var legend_1 = require("./legend");
var mark = require("./mark");
var scale_1 = require("./scale");
var selection_1 = require("./selection");
var util_1 = require("./util");
exports.defaultCellConfig = {
    width: 200,
    height: 200,
    fill: 'transparent'
};
exports.defaultFacetCellConfig = {
    stroke: '#ccc',
    strokeWidth: 1
};
var defaultFacetGridConfig = {
    color: '#000000',
    opacity: 0.4,
    offset: 0
};
exports.defaultFacetConfig = {
    axis: {},
    grid: defaultFacetGridConfig,
    cell: exports.defaultFacetCellConfig
};
exports.defaultOverlayConfig = {
    line: false
};
exports.defaultConfig = {
    padding: 5,
    numberFormat: 's',
    timeFormat: '%b %d, %Y',
    countTitle: 'Number of Records',
    cell: exports.defaultCellConfig,
    mark: mark.defaultMarkConfig,
    area: {},
    bar: mark.defaultBarConfig,
    circle: {},
    line: {},
    point: {},
    rect: {},
    rule: {},
    square: {},
    text: mark.defaultTextConfig,
    tick: mark.defaultTickConfig,
    overlay: exports.defaultOverlayConfig,
    scale: scale_1.defaultScaleConfig,
    axis: {},
    axisX: {},
    axisY: {},
    axisLeft: {},
    axisRight: {},
    axisTop: {},
    axisBottom: {},
    axisBand: {},
    legend: legend_1.defaultLegendConfig,
    facet: exports.defaultFacetConfig,
    selection: selection_1.defaultConfig,
};
function initConfig(config) {
    return util_1.mergeDeep(util_1.duplicate(exports.defaultConfig), config);
}
exports.initConfig = initConfig;

},{"./legend":112,"./mark":114,"./scale":115,"./selection":116,"./util":124}],106:[function(require,module,exports){
/*
 * Constants and utilities for data.
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isUrlData(data) {
    return !!data['url'];
}
exports.isUrlData = isUrlData;
function isInlineData(data) {
    return !!data['values'];
}
exports.isInlineData = isInlineData;
function isNamedData(data) {
    return !!data['name'];
}
exports.isNamedData = isNamedData;
exports.MAIN = 'main';
exports.RAW = 'raw';
exports.LAYOUT = 'layout';

},{}],107:[function(require,module,exports){
// DateTime definition object
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var util_1 = require("./util");
/*
 * A designated year that starts on Sunday.
 */
var SUNDAY_YEAR = 2006;
function isDateTime(o) {
    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||
        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);
}
exports.isDateTime = isDateTime;
exports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
exports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });
exports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
exports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });
function normalizeQuarter(q) {
    if (util_1.isNumber(q)) {
        if (q > 4) {
            log.warn(log.message.invalidTimeUnit('quarter', q));
        }
        // We accept 1-based quarter, so need to readjust to 0-based quarter
        return (q - 1) + '';
    }
    else {
        // Invalid quarter
        throw new Error(log.message.invalidTimeUnit('quarter', q));
    }
}
function normalizeMonth(m) {
    if (util_1.isNumber(m)) {
        // We accept 1-based month, so need to readjust to 0-based month
        return (m - 1) + '';
    }
    else {
        var lowerM = m.toLowerCase();
        var monthIndex = exports.MONTHS.indexOf(lowerM);
        if (monthIndex !== -1) {
            return monthIndex + ''; // 0 for january, ...
        }
        var shortM = lowerM.substr(0, 3);
        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);
        if (shortMonthIndex !== -1) {
            return shortMonthIndex + '';
        }
        // Invalid month
        throw new Error(log.message.invalidTimeUnit('month', m));
    }
}
function normalizeDay(d) {
    if (util_1.isNumber(d)) {
        // mod so that this can be both 0-based where 0 = sunday
        // and 1-based where 7=sunday
        return (d % 7) + '';
    }
    else {
        var lowerD = d.toLowerCase();
        var dayIndex = exports.DAYS.indexOf(lowerD);
        if (dayIndex !== -1) {
            return dayIndex + ''; // 0 for january, ...
        }
        var shortD = lowerD.substr(0, 3);
        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);
        if (shortDayIndex !== -1) {
            return shortDayIndex + '';
        }
        // Invalid day
        throw new Error(log.message.invalidTimeUnit('day', d));
    }
}
function timestamp(d, normalize) {
    var date = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date
    // FIXME support UTC
    if (d.day !== undefined) {
        if (util_1.keys(d).length > 1) {
            log.warn(log.message.droppedDay(d));
            d = util_1.duplicate(d);
            delete d.day;
        }
        else {
            // Use a year that has 1/1 as Sunday so we can setDate below
            date.setFullYear(SUNDAY_YEAR);
            var day = normalize ? normalizeDay(d.day) : d.day;
            date.setDate(+day + 1); // +1 since date start at 1 in JS
        }
    }
    if (d.year !== undefined) {
        date.setFullYear(d.year);
    }
    if (d.quarter !== undefined) {
        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;
        date.setMonth(+quarter * 3);
    }
    if (d.month !== undefined) {
        var month = normalize ? normalizeMonth(d.month) : d.month;
        date.setMonth(+month);
    }
    if (d.date !== undefined) {
        date.setDate(d.date);
    }
    if (d.hours !== undefined) {
        date.setHours(d.hours);
    }
    if (d.minutes !== undefined) {
        date.setMinutes(d.minutes);
    }
    if (d.seconds !== undefined) {
        date.setSeconds(d.seconds);
    }
    if (d.milliseconds !== undefined) {
        date.setMilliseconds(d.milliseconds);
    }
    return date.getTime();
}
exports.timestamp = timestamp;
/**
 * Return Vega Expression for a particular date time.
 * @param d
 * @param normalize whether to normalize quarter, month, day.
 */
function dateTimeExpr(d, normalize) {
    if (normalize === void 0) { normalize = false; }
    var units = [];
    if (normalize && d.day !== undefined) {
        if (util_1.keys(d).length > 1) {
            log.warn(log.message.droppedDay(d));
            d = util_1.duplicate(d);
            delete d.day;
        }
    }
    if (d.year !== undefined) {
        units.push(d.year);
    }
    else if (d.day !== undefined) {
        // Set year to 2006 for working with day since January 1 2006 is a Sunday
        units.push(SUNDAY_YEAR);
    }
    else {
        units.push(0);
    }
    if (d.month !== undefined) {
        var month = normalize ? normalizeMonth(d.month) : d.month;
        units.push(month);
    }
    else if (d.quarter !== undefined) {
        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;
        units.push(quarter + '*3');
    }
    else {
        units.push(0); // months start at zero in JS
    }
    if (d.date !== undefined) {
        units.push(d.date);
    }
    else if (d.day !== undefined) {
        // HACK: Day only works as a standalone unit
        // This is only correct because we always set year to 2006 for day
        var day = normalize ? normalizeDay(d.day) : d.day;
        units.push(day + '+1');
    }
    else {
        units.push(1); // Date starts at 1 in JS
    }
    // Note: can't use TimeUnit enum here as importing it will create
    // circular dependency problem!
    for (var _i = 0, _a = ['hours', 'minutes', 'seconds', 'milliseconds']; _i < _a.length; _i++) {
        var timeUnit = _a[_i];
        if (d[timeUnit] !== undefined) {
            units.push(d[timeUnit]);
        }
        else {
            units.push(0);
        }
    }
    return 'datetime(' + units.join(', ') + ')';
}
exports.dateTimeExpr = dateTimeExpr;

},{"./log":113,"./util":124}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// utility for encoding mapping
var channel_1 = require("./channel");
var fielddef_1 = require("./fielddef");
var log = require("./log");
var util_1 = require("./util");
function channelHasField(encoding, channel) {
    var channelDef = encoding && encoding[channel];
    if (channelDef) {
        if (util_1.isArray(channelDef)) {
            return util_1.some(channelDef, function (fieldDef) { return !!fieldDef.field; });
        }
        else {
            return fielddef_1.isFieldDef(channelDef);
        }
    }
    return false;
}
exports.channelHasField = channelHasField;
function isAggregate(encoding) {
    return util_1.some(channel_1.CHANNELS, function (channel) {
        if (channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            if (util_1.isArray(channelDef)) {
                return util_1.some(channelDef, function (fieldDef) { return !!fieldDef.aggregate; });
            }
            else {
                return fielddef_1.isFieldDef(channelDef) && !!channelDef.aggregate;
            }
        }
        return false;
    });
}
exports.isAggregate = isAggregate;
function normalizeEncoding(encoding, mark) {
    return Object.keys(encoding).reduce(function (normalizedEncoding, channel) {
        if (!channel_1.supportMark(channel, mark)) {
            // Drop unsupported channel
            log.warn(log.message.incompatibleChannel(channel, mark));
            return normalizedEncoding;
        }
        // Drop line's size if the field is aggregated.
        if (channel === 'size' && mark === 'line') {
            var channelDef = encoding[channel];
            if (fielddef_1.isFieldDef(channelDef) && channelDef.aggregate) {
                log.warn(log.message.incompatibleChannel(channel, mark, 'when the field is aggregated.'));
                return normalizedEncoding;
            }
        }
        if (util_1.isArray(encoding[channel])) {
            // Array of fieldDefs for detail channel (or production rule)
            normalizedEncoding[channel] = encoding[channel].reduce(function (channelDefs, channelDef) {
                if (!fielddef_1.isFieldDef(channelDef) && !fielddef_1.isValueDef(channelDef)) {
                    log.warn(log.message.emptyFieldDef(channelDef, channel));
                }
                else {
                    channelDefs.push(fielddef_1.normalize(channelDef, channel));
                }
                return channelDefs;
            }, []);
        }
        else {
            var channelDef = encoding[channel];
            if (!fielddef_1.isFieldDef(channelDef) && !fielddef_1.isValueDef(channelDef)) {
                log.warn(log.message.emptyFieldDef(channelDef, channel));
                return normalizedEncoding;
            }
            normalizedEncoding[channel] = fielddef_1.normalize(channelDef, channel);
        }
        return normalizedEncoding;
    }, {});
}
exports.normalizeEncoding = normalizeEncoding;
function isRanged(encoding) {
    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));
}
exports.isRanged = isRanged;
function fieldDefs(encoding) {
    var arr = [];
    channel_1.CHANNELS.forEach(function (channel) {
        if (channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            (util_1.isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {
                arr.push(fieldDef);
            });
        }
    });
    return arr;
}
exports.fieldDefs = fieldDefs;
function forEach(mapping, f, thisArg) {
    if (!mapping) {
        return;
    }
    Object.keys(mapping).forEach(function (c) {
        var channel = c;
        if (util_1.isArray(mapping[channel])) {
            mapping[channel].forEach(function (channelDef) {
                f.call(thisArg, channelDef, channel);
            });
        }
        else {
            f.call(thisArg, mapping[channel], channel);
        }
    });
}
exports.forEach = forEach;
function reduce(mapping, f, init, thisArg) {
    if (!mapping) {
        return init;
    }
    return Object.keys(mapping).reduce(function (r, c) {
        var channel = c;
        if (util_1.isArray(mapping[channel])) {
            return mapping[channel].reduce(function (r1, channelDef) {
                return f.call(thisArg, r1, channelDef, channel);
            }, r);
        }
        else {
            return f.call(thisArg, r, mapping[channel], channel);
        }
    }, init);
}
exports.reduce = reduce;

},{"./channel":44,"./fielddef":110,"./log":113,"./util":124}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],110:[function(require,module,exports){
// utility for a field definition object
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var aggregate_1 = require("./aggregate");
var bin_1 = require("./bin");
var channel_1 = require("./channel");
var log = require("./log");
var timeunit_1 = require("./timeunit");
var type_1 = require("./type");
var util_1 = require("./util");
function isFieldDef(channelDef) {
    return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');
}
exports.isFieldDef = isFieldDef;
function isValueDef(channelDef) {
    return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;
}
exports.isValueDef = isValueDef;
function field(fieldDef, opt) {
    if (opt === void 0) { opt = {}; }
    var field = fieldDef.field;
    var prefix = opt.prefix;
    var suffix = opt.suffix;
    if (isCount(fieldDef)) {
        field = 'count_*';
    }
    else {
        var fn = undefined;
        if (!opt.nofn) {
            if (fieldDef.bin) {
                fn = bin_1.binToString(fieldDef.bin);
                suffix = opt.binSuffix;
            }
            else if (fieldDef.aggregate) {
                fn = String(opt.aggregate || fieldDef.aggregate);
            }
            else if (fieldDef.timeUnit) {
                fn = String(fieldDef.timeUnit);
            }
        }
        if (fn) {
            field = fn + "_" + field;
        }
    }
    if (suffix) {
        field = field + "_" + suffix;
    }
    if (prefix) {
        field = prefix + "_" + field;
    }
    if (opt.datum) {
        field = "datum[\"" + field + "\"]";
    }
    return field;
}
exports.field = field;
function isDiscrete(fieldDef) {
    switch (fieldDef.type) {
        case 'nominal':
        case 'ordinal':
            return true;
        case 'quantitative':
            return !!fieldDef.bin;
        case 'temporal':
            // TODO: deal with custom scale type case.
            return timeunit_1.isDiscreteByDefault(fieldDef.timeUnit);
    }
    throw new Error(log.message.invalidFieldType(fieldDef.type));
}
exports.isDiscrete = isDiscrete;
function isContinuous(fieldDef) {
    return !isDiscrete(fieldDef);
}
exports.isContinuous = isContinuous;
function isCount(fieldDef) {
    return fieldDef.aggregate === 'count';
}
exports.isCount = isCount;
function title(fieldDef, config) {
    if (fieldDef.title != null) {
        return fieldDef.title;
    }
    if (isCount(fieldDef)) {
        return config.countTitle;
    }
    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');
    if (fn) {
        return fn.toUpperCase() + '(' + fieldDef.field + ')';
    }
    else {
        return fieldDef.field;
    }
}
exports.title = title;
function defaultType(fieldDef, channel) {
    if (fieldDef.timeUnit) {
        return 'temporal';
    }
    if (fieldDef.bin) {
        return 'quantitative';
    }
    switch (channel_1.rangeType(channel)) {
        case 'continuous':
            return 'quantitative';
        case 'discrete':
            return 'nominal';
        case 'flexible':
            return 'nominal';
        default:
            return 'quantitative';
    }
}
exports.defaultType = defaultType;
/**
 * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.
 */
function normalize(channelDef, channel) {
    // If a fieldDef contains a field, we need type.
    if (isFieldDef(channelDef)) {
        var fieldDef = channelDef;
        // Drop invalid aggregate
        if (fieldDef.aggregate && !aggregate_1.AGGREGATE_OP_INDEX[fieldDef.aggregate]) {
            var aggregate = fieldDef.aggregate, fieldDefWithoutAggregate = tslib_1.__rest(fieldDef, ["aggregate"]);
            log.warn(log.message.invalidAggregate(fieldDef.aggregate));
            fieldDef = fieldDefWithoutAggregate;
        }
        // Normalize bin
        if (fieldDef.bin) {
            var bin = fieldDef.bin;
            if (util_1.isBoolean(bin)) {
                fieldDef = tslib_1.__assign({}, fieldDef, { bin: { maxbins: bin_1.autoMaxBins(channel) } });
            }
            else if (!bin.maxbins && !bin.step) {
                fieldDef = tslib_1.__assign({}, fieldDef, { bin: tslib_1.__assign({}, bin, { maxbins: bin_1.autoMaxBins(channel) }) });
            }
        }
        // Normalize Type
        if (fieldDef.type) {
            var fullType = type_1.getFullName(fieldDef.type);
            if (fieldDef.type !== fullType) {
                // convert short type to full type
                fieldDef = tslib_1.__assign({}, fieldDef, { type: fullType });
            }
        }
        else {
            // If type is empty / invalid, then augment with default type
            var newType = defaultType(fieldDef, channel);
            log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));
            fieldDef = tslib_1.__assign({}, fieldDef, { type: newType });
        }
        var _a = channelCompatibility(fieldDef, channel), compatible = _a.compatible, warning = _a.warning;
        if (!compatible) {
            log.warn(warning);
        }
        return fieldDef;
    }
    return channelDef;
}
exports.normalize = normalize;
var COMPATIBLE = { compatible: true };
function channelCompatibility(fieldDef, channel) {
    switch (channel) {
        case 'row':
        case 'column':
            if (isContinuous(fieldDef) && !fieldDef.timeUnit) {
                // TODO:(https://github.com/vega/vega-lite/issues/2011):
                // with timeUnit it's not always strictly continuous
                return {
                    compatible: false,
                    warning: log.message.facetChannelShouldBeDiscrete(channel)
                };
            }
            return COMPATIBLE;
        case 'x':
        case 'y':
        case 'color':
        case 'text':
        case 'detail':
            return COMPATIBLE;
        case 'opacity':
        case 'size':
        case 'x2':
        case 'y2':
            if (isDiscrete(fieldDef) && !fieldDef.bin) {
                return {
                    compatible: false,
                    warning: "Channel " + channel + " should not be used with discrete field."
                };
            }
            return COMPATIBLE;
        case 'shape':
            if (fieldDef.type !== 'nominal') {
                return {
                    compatible: false,
                    warning: 'Shape channel should be used with nominal data only'
                };
            }
            return COMPATIBLE;
        case 'order':
            if (fieldDef.type === 'nominal') {
                return {
                    compatible: false,
                    warning: "Channel order is inappropriate for nominal field, which has no inherent order."
                };
            }
            return COMPATIBLE;
    }
    throw new Error('channelCompatability not implemented for channel ' + channel);
}
exports.channelCompatibility = channelCompatibility;

},{"./aggregate":41,"./bin":43,"./channel":44,"./log":113,"./timeunit":120,"./type":123,"./util":124,"tslib":38}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var datetime_1 = require("./datetime");
var fielddef_1 = require("./fielddef");
var timeunit_1 = require("./timeunit");
var util_1 = require("./util");
function isEqualFilter(filter) {
    return filter && !!filter.field && filter.equal !== undefined;
}
exports.isEqualFilter = isEqualFilter;
function isRangeFilter(filter) {
    if (filter && filter.field) {
        if (util_1.isArray(filter.range) && filter.range.length === 2) {
            return true;
        }
    }
    return false;
}
exports.isRangeFilter = isRangeFilter;
function isOneOfFilter(filter) {
    return filter && !!filter.field && (util_1.isArray(filter.oneOf) ||
        util_1.isArray(filter.in) // backward compatibility
    );
}
exports.isOneOfFilter = isOneOfFilter;
/**
 * Converts a filter into an expression.
 */
function expression(filter) {
    if (util_1.isArray(filter)) {
        return '(' +
            filter.map(function (f) { return expression(f); })
                .filter(function (f) { return f !== undefined; })
                .join(') && (') +
            ')';
    }
    else if (util_1.isString(filter)) {
        return filter;
    }
    else {
        var fieldExpr = filter.timeUnit ?
            // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
            // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
            // TODO: support utc
            ('time(' + timeunit_1.fieldExpr(filter.timeUnit, filter.field) + ')') :
            fielddef_1.field(filter, { datum: true });
        if (isEqualFilter(filter)) {
            return fieldExpr + '===' + valueExpr(filter.equal, filter.timeUnit);
        }
        else if (isOneOfFilter(filter)) {
            // "oneOf" was formerly "in" -- so we need to add backward compatibility
            var oneOf = filter.oneOf || filter['in'];
            return 'indexof([' +
                oneOf.map(function (v) { return valueExpr(v, filter.timeUnit); }).join(',') +
                '], ' + fieldExpr + ') !== -1';
        }
        else if (isRangeFilter(filter)) {
            var lower = filter.range[0];
            var upper = filter.range[1];
            if (lower !== null && upper !== null) {
                return 'inrange(' + fieldExpr + ', ' +
                    valueExpr(lower, filter.timeUnit) + ', ' +
                    valueExpr(upper, filter.timeUnit) + ')';
            }
            else if (lower !== null) {
                return fieldExpr + ' >= ' + lower;
            }
            else if (upper !== null) {
                return fieldExpr + ' <= ' + upper;
            }
        }
    }
    return undefined;
}
exports.expression = expression;
function valueExpr(v, timeUnit) {
    if (datetime_1.isDateTime(v)) {
        var expr = datetime_1.dateTimeExpr(v, true);
        return 'time(' + expr + ')';
    }
    if (timeunit_1.isSingleTimeUnit(timeUnit)) {
        var datetime = {};
        datetime[timeUnit] = v;
        var expr = datetime_1.dateTimeExpr(datetime, true);
        return 'time(' + expr + ')';
    }
    return JSON.stringify(v);
}

},{"./datetime":107,"./fielddef":110,"./timeunit":120,"./util":124}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultLegendConfig = {
    orient: undefined,
};
exports.LEGEND_PROPERTIES = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values', 'zindex'];

},{}],113:[function(require,module,exports){
///<reference path="../typings/vega-util.d.ts" />
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Vega-Lite's singleton logger utility.
 */
var vega_util_1 = require("vega-util");
/**
 * Main (default) Vega Logger instance for Vega-Lite
 */
var main = vega_util_1.logger(vega_util_1.Warn);
var current = main;
/**
 * Logger tool for checking if the code throws correct warning
 */
var LocalLogger = (function () {
    function LocalLogger() {
        this.warns = [];
        this.infos = [];
        this.debugs = [];
    }
    LocalLogger.prototype.level = function () {
        return this;
    };
    LocalLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.warns).push.apply(_a, args);
        return this;
        var _a;
    };
    LocalLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.infos).push.apply(_a, args);
        return this;
        var _a;
    };
    LocalLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.debugs).push.apply(_a, args);
        return this;
        var _a;
    };
    return LocalLogger;
}());
exports.LocalLogger = LocalLogger;
function runLocalLogger(f) {
    var localLogger = current = new LocalLogger();
    f(localLogger);
    reset();
}
exports.runLocalLogger = runLocalLogger;
function wrap(f) {
    return function () {
        var logger = current = new LocalLogger();
        f(logger);
        reset();
    };
}
exports.wrap = wrap;
/**
 * Set the singleton logger to be a custom logger
 */
function set(logger) {
    current = logger;
    return current;
}
exports.set = set;
/**
 * Reset the main logger to use the default Vega Logger
 */
function reset() {
    current = main;
    return current;
}
exports.reset = reset;
function warn() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.warn.apply(current, arguments);
}
exports.warn = warn;
function info() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.info.apply(current, arguments);
}
exports.info = info;
function debug() {
    var _ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _[_i] = arguments[_i];
    }
    current.debug.apply(current, arguments);
}
exports.debug = debug;
/**
 * Collection of all Vega-Lite Error Messages
 */
var message;
(function (message) {
    message.INVALID_SPEC = 'Invalid spec';
    // TRANSFORMS
    function invalidTransformIgnored(transform) {
        return "Ignoring an invalid transform: " + JSON.stringify(transform) + ".";
    }
    message.invalidTransformIgnored = invalidTransformIgnored;
    // ENCODING & FACET
    function invalidFieldType(type) {
        return "Invalid field type \"" + type + "\"";
    }
    message.invalidFieldType = invalidFieldType;
    function invalidAggregate(aggregate) {
        return "Invalid aggregation operator \"" + aggregate + "\"";
    }
    message.invalidAggregate = invalidAggregate;
    function emptyOrInvalidFieldType(type, channel, newType) {
        return "Invalid field type (" + type + ") for channel " + channel + ", using " + newType + " instead.";
    }
    message.emptyOrInvalidFieldType = emptyOrInvalidFieldType;
    function emptyFieldDef(fieldDef, channel) {
        return "Dropping " + JSON.stringify(fieldDef) + " from channel " + channel + " since it does not contain data field or value.";
    }
    message.emptyFieldDef = emptyFieldDef;
    function incompatibleChannel(channel, markOrFacet, when) {
        return channel + " dropped as it is incompatible with " + markOrFacet +
            when ? "when " + when : '';
    }
    message.incompatibleChannel = incompatibleChannel;
    function facetChannelShouldBeDiscrete(channel) {
        return channel + " encoding should be discrete (ordinal / nominal / binned).";
    }
    message.facetChannelShouldBeDiscrete = facetChannelShouldBeDiscrete;
    function discreteChannelCannotEncode(channel, type) {
        return "Using discrete channel " + channel + " to encode " + type + " field can be misleading as it does not encode " + (type === 'ordinal' ? 'order' : 'magnitude') + ".";
    }
    message.discreteChannelCannotEncode = discreteChannelCannotEncode;
    // Mark
    message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';
    function unclearOrientContinuous(mark) {
        return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode continous fields. In this case, we use vertical by default';
    }
    message.unclearOrientContinuous = unclearOrientContinuous;
    function unclearOrientDiscreteOrEmpty(mark) {
        return 'Cannot clearly determine orientation for ' + mark + ' since both x and y channel encode discrete or empty fields.';
    }
    message.unclearOrientDiscreteOrEmpty = unclearOrientDiscreteOrEmpty;
    function orientOverridden(original, actual) {
        return "Specified orient " + original + " overridden with " + actual;
    }
    message.orientOverridden = orientOverridden;
    // SCALE
    message.CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';
    function cannotUseScalePropertyWithNonColor(prop) {
        return "Cannot use " + prop + " with non-color channel.";
    }
    message.cannotUseScalePropertyWithNonColor = cannotUseScalePropertyWithNonColor;
    function unaggregateDomainHasNoEffectForRawField(fieldDef) {
        return "Using unaggregated domain with raw field has no effect (" + JSON.stringify(fieldDef) + ").";
    }
    message.unaggregateDomainHasNoEffectForRawField = unaggregateDomainHasNoEffectForRawField;
    function unaggregateDomainWithNonSharedDomainOp(aggregate) {
        return "Unaggregated domain not applicable for " + aggregate + " since it produces values outside the origin domain of the source data.";
    }
    message.unaggregateDomainWithNonSharedDomainOp = unaggregateDomainWithNonSharedDomainOp;
    function unaggregatedDomainWithLogScale(fieldDef) {
        return "Unaggregated domain is currently unsupported for log scale (" + JSON.stringify(fieldDef) + ").";
    }
    message.unaggregatedDomainWithLogScale = unaggregatedDomainWithLogScale;
    message.CANNOT_USE_RANGE_WITH_POSITION = 'Cannot use custom range with x or y channel.  Please customize width, height, padding, or rangeStep instead.';
    message.CANNOT_USE_PADDING_WITH_FACET = 'Cannot use padding with facet\'s scale.  Please use spacing instead.';
    function cannotUseRangePropertyWithFacet(propName) {
        return "Cannot use custom " + propName + " with row or column channel. Please use width, height, or spacing instead.";
    }
    message.cannotUseRangePropertyWithFacet = cannotUseRangePropertyWithFacet;
    function rangeStepDropped(channel) {
        return "rangeStep for " + channel + " is dropped as top-level " + (channel === 'x' ? 'width' : 'height') + " is provided.";
    }
    message.rangeStepDropped = rangeStepDropped;
    function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {
        return "Channel " + channel + " does not work with " + scaleType + " scale. We are using " + defaultScaleType + " scale instead.";
    }
    message.scaleTypeNotWorkWithChannel = scaleTypeNotWorkWithChannel;
    function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {
        return "FieldDef does not work with " + scaleType + " scale. We are using " + defaultScaleType + " scale instead.";
    }
    message.scaleTypeNotWorkWithFieldDef = scaleTypeNotWorkWithFieldDef;
    function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {
        return channel + "-scale's \"" + propName + "\" is dropped as it does not work with " + scaleType + " scale.";
    }
    message.scalePropertyNotWorkWithScaleType = scalePropertyNotWorkWithScaleType;
    function scaleTypeNotWorkWithMark(mark, scaleType) {
        return "Scale type \"" + scaleType + "\" does not work with mark " + mark + ".";
    }
    message.scaleTypeNotWorkWithMark = scaleTypeNotWorkWithMark;
    message.INVAID_DOMAIN = 'Invalid scale domain';
    message.UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';
    // AXIS
    message.INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';
    // STACK
    function cannotStackRangedMark(channel) {
        return "Cannot stack " + channel + " if there is already " + channel + "2";
    }
    message.cannotStackRangedMark = cannotStackRangedMark;
    function cannotStackNonLinearScale(scaleType) {
        return "Cannot stack non-linear scale (" + scaleType + ")";
    }
    message.cannotStackNonLinearScale = cannotStackNonLinearScale;
    function cannotStackNonSummativeAggregate(aggregate) {
        return "Cannot stack when the aggregate function is non-summative (" + aggregate + ")";
    }
    message.cannotStackNonSummativeAggregate = cannotStackNonSummativeAggregate;
    // TIMEUNIT
    function invalidTimeUnit(unitName, value) {
        return "Invalid " + unitName + ": " + value;
    }
    message.invalidTimeUnit = invalidTimeUnit;
    function dayReplacedWithDate(fullTimeUnit) {
        return "Time unit \"" + fullTimeUnit + "\" is not supported. We are replacing it with " +
            (fullTimeUnit + '').replace('day', 'date') + '.';
    }
    message.dayReplacedWithDate = dayReplacedWithDate;
    function droppedDay(d) {
        return 'Dropping day from datetime ' + JSON.stringify(d) +
            ' as day cannot be combined with other units.';
    }
    message.droppedDay = droppedDay;
})(message = exports.message || (exports.message = {}));

},{"vega-util":128}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var Mark;
(function (Mark) {
    Mark.AREA = 'area';
    Mark.BAR = 'bar';
    Mark.LINE = 'line';
    Mark.POINT = 'point';
    Mark.RECT = 'rect';
    Mark.RULE = 'rule';
    Mark.TEXT = 'text';
    Mark.TICK = 'tick';
    Mark.CIRCLE = 'circle';
    Mark.SQUARE = 'square';
})(Mark = exports.Mark || (exports.Mark = {}));
exports.AREA = Mark.AREA;
exports.BAR = Mark.BAR;
exports.LINE = Mark.LINE;
exports.POINT = Mark.POINT;
exports.TEXT = Mark.TEXT;
exports.TICK = Mark.TICK;
exports.RECT = Mark.RECT;
exports.RULE = Mark.RULE;
exports.CIRCLE = Mark.CIRCLE;
exports.SQUARE = Mark.SQUARE;
exports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RECT, exports.RULE, exports.CIRCLE, exports.SQUARE];
function isMarkDef(mark) {
    return mark['type'];
}
exports.isMarkDef = isMarkDef;
var PRIMITIVE_MARK_INDEX = util_1.toSet(exports.PRIMITIVE_MARKS);
function isPrimitiveMark(mark) {
    var markType = isMarkDef(mark) ? mark.type : mark;
    return markType in PRIMITIVE_MARK_INDEX;
}
exports.isPrimitiveMark = isPrimitiveMark;
exports.STROKE_CONFIG = ['stroke', 'strokeWidth',
    'strokeDash', 'strokeDashOffset', 'strokeOpacity'];
exports.FILL_CONFIG = ['fill', 'fillOpacity'];
exports.FILL_STROKE_CONFIG = [].concat(exports.STROKE_CONFIG, exports.FILL_CONFIG);
exports.defaultMarkConfig = {
    color: '#4c78a8',
};
exports.defaultBarConfig = {
    binSpacing: 1,
    continuousBandSize: 2
};
exports.defaultTextConfig = {
    baseline: 'middle',
};
exports.defaultTickConfig = {
    thickness: 1
};

},{"./util":124}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var util_1 = require("./util");
var ScaleType;
(function (ScaleType) {
    // Continuous - Quantitative
    ScaleType.LINEAR = 'linear';
    ScaleType.BIN_LINEAR = 'bin-linear';
    ScaleType.LOG = 'log';
    ScaleType.POW = 'pow';
    ScaleType.SQRT = 'sqrt';
    // Continuous - Time
    ScaleType.TIME = 'time';
    ScaleType.UTC = 'utc';
    // sequential
    ScaleType.SEQUENTIAL = 'sequential';
    // Quantile, Quantize, threshold
    ScaleType.QUANTILE = 'quantile';
    ScaleType.QUANTIZE = 'quantize';
    ScaleType.THRESHOLD = 'threshold';
    ScaleType.ORDINAL = 'ordinal';
    ScaleType.BIN_ORDINAL = 'bin-ordinal';
    ScaleType.POINT = 'point';
    ScaleType.BAND = 'band';
})(ScaleType = exports.ScaleType || (exports.ScaleType = {}));
exports.SCALE_TYPES = [
    // Continuous - Quantitative
    'linear', 'bin-linear', 'log', 'pow', 'sqrt',
    // Continuous - Time
    'time', 'utc',
    // Sequential
    'sequential',
    // Discrete
    'ordinal', 'bin-ordinal', 'point', 'band',
];
exports.CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];
var CONTINUOUS_TO_CONTINUOUS_INDEX = util_1.toSet(exports.CONTINUOUS_TO_CONTINUOUS_SCALES);
exports.CONTINUOUS_DOMAIN_SCALES = exports.CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);
var CONTINUOUS_DOMAIN_INDEX = util_1.toSet(exports.CONTINUOUS_DOMAIN_SCALES);
exports.DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];
var DISCRETE_DOMAIN_INDEX = util_1.toSet(exports.DISCRETE_DOMAIN_SCALES);
var BIN_SCALES_INDEX = util_1.toSet(['bin-linear', 'bin-ordinal']);
exports.TIME_SCALE_TYPES = ['time', 'utc'];
function hasDiscreteDomain(type) {
    return type in DISCRETE_DOMAIN_INDEX;
}
exports.hasDiscreteDomain = hasDiscreteDomain;
function isBinScale(type) {
    return type in BIN_SCALES_INDEX;
}
exports.isBinScale = isBinScale;
function hasContinuousDomain(type) {
    return type in CONTINUOUS_DOMAIN_INDEX;
}
exports.hasContinuousDomain = hasContinuousDomain;
function isContinuousToContinuous(type) {
    return type in CONTINUOUS_TO_CONTINUOUS_INDEX;
}
exports.isContinuousToContinuous = isContinuousToContinuous;
exports.defaultScaleConfig = {
    round: true,
    textXRangeStep: 90,
    rangeStep: 21,
    pointPadding: 0.5,
    bandPaddingInner: 0.1,
    facetSpacing: 16,
    minFontSize: 8,
    maxFontSize: 40,
    minOpacity: 0.3,
    maxOpacity: 0.8,
    // FIXME: revise if these *can* become ratios of rangeStep
    minSize: 9,
    minStrokeWidth: 1,
    maxStrokeWidth: 4,
    shapes: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down']
};
function isExtendedScheme(scheme) {
    return scheme && !!scheme['name'];
}
exports.isExtendedScheme = isExtendedScheme;
exports.SCALE_PROPERTIES = [
    'type', 'domain', 'range', 'round', 'rangeStep', 'scheme', 'padding', 'paddingInner', 'paddingOuter', 'clamp', 'nice',
    'exponent', 'zero', 'interpolate'
];
function scaleTypeSupportProperty(scaleType, propName) {
    switch (propName) {
        case 'type':
        case 'domain':
        case 'range':
        case 'scheme':
            return true;
        case 'interpolate':
            return util_1.contains(['linear', 'bin-linear', 'pow', 'log', 'sqrt', 'utc', 'time'], scaleType);
        case 'round':
            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';
        case 'rangeStep':
        case 'padding':
        case 'paddingOuter':
            return util_1.contains(['point', 'band'], scaleType);
        case 'paddingInner':
            return scaleType === 'band';
        case 'clamp':
            return isContinuousToContinuous(scaleType) || scaleType === 'sequential';
        case 'nice':
            return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType === 'quantize';
        case 'exponent':
            return scaleType === 'pow' || scaleType === 'log';
        case 'zero':
            // TODO: what about quantize, threshold?
            return scaleType === 'bin-ordinal' || (!hasDiscreteDomain(scaleType) && !util_1.contains(['log', 'time', 'utc', 'bin-linear'], scaleType));
    }
    /* istanbul ignore next: should never reach here*/
    throw new Error("Invalid scale property " + propName + ".");
}
exports.scaleTypeSupportProperty = scaleTypeSupportProperty;
/**
 * Returns undefined if the input channel supports the input scale property name
 */
function channelScalePropertyIncompatability(channel, propName) {
    switch (propName) {
        case 'range':
            // User should not customize range for position and facet channel directly.
            if (channel === 'x' || channel === 'y') {
                return log.message.CANNOT_USE_RANGE_WITH_POSITION;
            }
            if (channel === 'row' || channel === 'column') {
                return log.message.cannotUseRangePropertyWithFacet('range');
            }
            return undefined; // GOOD!
        // band / point
        case 'rangeStep':
            if (channel === 'row' || channel === 'column') {
                return log.message.cannotUseRangePropertyWithFacet('rangeStep');
            }
            return undefined; // GOOD!
        case 'padding':
        case 'paddingInner':
        case 'paddingOuter':
            if (channel === 'row' || channel === 'column') {
                /*
                 * We do not use d3 scale's padding for row/column because padding there
                 * is a ratio ([0, 1]) and it causes the padding to be decimals.
                 * Therefore, we manually calculate "spacing" in the layout by ourselves.
                 */
                return log.message.CANNOT_USE_PADDING_WITH_FACET;
            }
            return undefined; // GOOD!
        case 'interpolate':
        case 'scheme':
            if (channel !== 'color') {
                return log.message.cannotUseScalePropertyWithNonColor(channel);
            }
            return undefined;
        case 'type':
        case 'domain':
        case 'round':
        case 'clamp':
        case 'exponent':
        case 'nice':
        case 'zero':
            // These channel do not have strict requirement
            return undefined; // GOOD!
    }
    /* istanbul ignore next: it should never reach here */
    throw new Error('Invalid scale property "${propName}".');
}
exports.channelScalePropertyIncompatability = channelScalePropertyIncompatability;

},{"./log":113,"./util":124}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultConfig = {
    single: { on: 'click', fields: ['_id'] },
    multi: { on: 'click', fields: ['_id'], toggle: 'event.shiftKey' },
    interval: {
        on: '[mousedown, window:mouseup] > window:mousemove!',
        encodings: ['x', 'y'],
        translate: '[mousedown, window:mouseup] > window:mousemove!',
        zoom: 'wheel'
    }
};

},{}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isSortField(sort) {
    return !!sort && !!sort['field'] && !!sort['op'];
}
exports.isSortField = isSortField;

},{}],118:[function(require,module,exports){
/* Package of defining Vega-lite Specification's json schema at its utility functions */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var compositeMark = require("./compositemark");
var encoding_1 = require("./encoding");
var channel_1 = require("./channel");
var vlEncoding = require("./encoding");
var log = require("./log");
var mark_1 = require("./mark");
var stack_1 = require("./stack");
var util_1 = require("./util");
/* Custom type guards */
function isFacetSpec(spec) {
    return spec['facet'] !== undefined;
}
exports.isFacetSpec = isFacetSpec;
function isUnitSpec(spec) {
    return !!spec['mark'];
}
exports.isUnitSpec = isUnitSpec;
function isLayerSpec(spec) {
    return spec['layer'] !== undefined;
}
exports.isLayerSpec = isLayerSpec;
/**
 * Decompose extended unit specs into composition of pure unit specs.
 */
// TODO: consider moving this to another file.  Maybe vl.spec.normalize or vl.normalize
function normalize(spec) {
    if (isFacetSpec(spec)) {
        return normalizeFacet(spec, spec.config);
    }
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, spec.config);
    }
    if (isUnitSpec(spec)) {
        var hasRow = encoding_1.channelHasField(spec.encoding, channel_1.ROW);
        var hasColumn = encoding_1.channelHasField(spec.encoding, channel_1.COLUMN);
        if (hasRow || hasColumn) {
            return normalizeFacetedUnit(spec, spec.config);
        }
        return normalizeNonFacetUnit(spec, spec.config);
    }
    throw new Error(log.message.INVALID_SPEC);
}
exports.normalize = normalize;
function normalizeNonFacet(spec, config) {
    if (isLayerSpec(spec)) {
        return normalizeLayer(spec, config);
    }
    return normalizeNonFacetUnit(spec, config);
}
function normalizeFacet(spec, config) {
    var subspec = spec.spec, rest = tslib_1.__rest(spec, ["spec"]);
    return tslib_1.__assign({}, rest, { spec: normalizeNonFacet(subspec, config) });
}
function normalizeLayer(spec, config) {
    var layer = spec.layer, rest = tslib_1.__rest(spec, ["layer"]);
    return tslib_1.__assign({}, rest, { layer: layer.map(function (subspec) { return normalizeNonFacet(subspec, config); }) });
}
function normalizeFacetedUnit(spec, config) {
    // New encoding in the inside spec should not contain row / column
    // as row/column should be moved to facet
    var _a = spec.encoding, row = _a.row, column = _a.column, encoding = tslib_1.__rest(_a, ["row", "column"]);
    // Mark and encoding should be moved into the inner spec
    var mark = spec.mark, _ = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    return tslib_1.__assign({}, outerSpec, { facet: tslib_1.__assign({}, (row ? { row: row } : {}), (column ? { column: column } : {})), spec: normalizeNonFacetUnit({
            mark: mark,
            encoding: encoding
        }, config) });
}
function isNonFacetUnitSpecWithPrimitiveMark(spec) {
    return mark_1.isPrimitiveMark(spec.mark);
}
function normalizeNonFacetUnit(spec, config) {
    if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {
        // TODO: thoroughly test
        if (encoding_1.isRanged(spec.encoding)) {
            return normalizeRangedUnit(spec);
        }
        var overlayConfig = config && config.overlay;
        var overlayWithLine = overlayConfig && spec.mark === mark_1.AREA &&
            util_1.contains(['linepoint', 'line'], overlayConfig.area);
        var overlayWithPoint = overlayConfig && ((overlayConfig.line && spec.mark === mark_1.LINE) ||
            (overlayConfig.area === 'linepoint' && spec.mark === mark_1.AREA));
        // TODO: consider moving this to become another case of compositeMark
        if (overlayWithPoint || overlayWithLine) {
            return normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config);
        }
        return spec; // Nothing to normalize
    }
    else {
        return compositeMark.normalize(spec);
    }
}
function normalizeRangedUnit(spec) {
    var hasX = encoding_1.channelHasField(spec.encoding, channel_1.X);
    var hasY = encoding_1.channelHasField(spec.encoding, channel_1.Y);
    var hasX2 = encoding_1.channelHasField(spec.encoding, channel_1.X2);
    var hasY2 = encoding_1.channelHasField(spec.encoding, channel_1.Y2);
    if ((hasX2 && !hasX) || (hasY2 && !hasY)) {
        var normalizedSpec = util_1.duplicate(spec);
        if (hasX2 && !hasX) {
            normalizedSpec.encoding.x = normalizedSpec.encoding.x2;
            delete normalizedSpec.encoding.x2;
        }
        if (hasY2 && !hasY) {
            normalizedSpec.encoding.y = normalizedSpec.encoding.y2;
            delete normalizedSpec.encoding.y2;
        }
        return normalizedSpec;
    }
    return spec;
}
// FIXME(#1804): re-design this
function normalizeOverlay(spec, overlayWithPoint, overlayWithLine, config) {
    var mark = spec.mark, encoding = spec.encoding, outerSpec = tslib_1.__rest(spec, ["mark", "encoding"]);
    var layer = [{ mark: mark, encoding: encoding }];
    // Need to copy stack config to overlayed layer
    var stackProps = stack_1.stack(mark, encoding, config ? config.stack : undefined);
    var overlayEncoding = encoding;
    if (stackProps) {
        var stackFieldChannel = stackProps.fieldChannel, offset = stackProps.offset;
        overlayEncoding = tslib_1.__assign({}, encoding, (_a = {}, _a[stackFieldChannel] = tslib_1.__assign({}, encoding[stackFieldChannel], (offset ? { stack: offset } : {})), _a));
    }
    if (overlayWithLine) {
        layer.push({
            mark: {
                type: 'line',
                role: 'lineOverlay'
            },
            encoding: overlayEncoding
        });
    }
    if (overlayWithPoint) {
        layer.push({
            mark: {
                type: 'point',
                filled: true,
                role: 'pointOverlay'
            },
            encoding: overlayEncoding
        });
    }
    return tslib_1.__assign({}, outerSpec, { layer: layer });
    var _a;
}
// TODO: add vl.spec.validate & move stuff from vl.validate to here
/* Accumulate non-duplicate fieldDefs in a dictionary */
function accumulate(dict, fieldDefs) {
    fieldDefs.forEach(function (fieldDef) {
        // Consider only pure fieldDef properties (ignoring scale, axis, legend)
        var pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce(function (f, key) {
            if (fieldDef[key] !== undefined) {
                f[key] = fieldDef[key];
            }
            return f;
        }, {});
        var key = util_1.hash(pureFieldDef);
        dict[key] = dict[key] || fieldDef;
    });
    return dict;
}
/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */
function fieldDefIndex(spec, dict) {
    if (dict === void 0) { dict = {}; }
    // TODO: Support repeat and concat
    if (isLayerSpec(spec)) {
        spec.layer.forEach(function (layer) {
            if (isUnitSpec(layer)) {
                accumulate(dict, vlEncoding.fieldDefs(layer.encoding));
            }
            else {
                fieldDefIndex(layer, dict);
            }
        });
    }
    else if (isFacetSpec(spec)) {
        accumulate(dict, vlEncoding.fieldDefs(spec.facet));
        fieldDefIndex(spec.spec, dict);
    }
    else {
        accumulate(dict, vlEncoding.fieldDefs(spec.encoding));
    }
    return dict;
}
/* Returns all non-duplicate fieldDefs in a spec in a flat array */
function fieldDefs(spec) {
    return util_1.vals(fieldDefIndex(spec));
}
exports.fieldDefs = fieldDefs;
function isStacked(spec, config) {
    config = config || spec.config;
    if (mark_1.isPrimitiveMark(spec.mark)) {
        return stack_1.stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;
    }
    return false;
}
exports.isStacked = isStacked;

},{"./channel":44,"./compositemark":104,"./encoding":108,"./log":113,"./mark":114,"./stack":119,"./util":124,"tslib":38}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log = require("./log");
var aggregate_1 = require("./aggregate");
var channel_1 = require("./channel");
var encoding_1 = require("./encoding");
var fielddef_1 = require("./fielddef");
var mark_1 = require("./mark");
var scale_1 = require("./scale");
var util_1 = require("./util");
exports.STACKABLE_MARKS = [mark_1.BAR, mark_1.AREA, mark_1.RULE, mark_1.POINT, mark_1.CIRCLE, mark_1.SQUARE, mark_1.LINE, mark_1.TEXT, mark_1.TICK];
exports.STACK_BY_DEFAULT_MARKS = [mark_1.BAR, mark_1.AREA];
// Note: CompassQL uses this method and only pass in required properties of each argument object.
// If required properties change, make sure to update CompassQL.
function stack(m, encoding, stackConfig) {
    var mark = mark_1.isMarkDef(m) ? m.type : m;
    // Should have stackable mark
    if (!util_1.contains(exports.STACKABLE_MARKS, mark)) {
        return null;
    }
    // Should be aggregate plot
    if (!encoding_1.isAggregate(encoding)) {
        return null;
    }
    // Should have grouping level of detail
    var stackBy = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {
        if (encoding_1.channelHasField(encoding, channel)) {
            var channelDef = encoding[channel];
            (util_1.isArray(channelDef) ? channelDef : [channelDef]).forEach(function (fieldDef) {
                if (fielddef_1.isFieldDef(fieldDef) && !fieldDef.aggregate) {
                    sc.push({
                        channel: channel,
                        fieldDef: fieldDef
                    });
                }
            });
        }
        return sc;
    }, []);
    if (stackBy.length === 0) {
        return null;
    }
    // Has only one aggregate axis
    var hasXField = fielddef_1.isFieldDef(encoding.x);
    var hasYField = fielddef_1.isFieldDef(encoding.y);
    var xIsAggregate = fielddef_1.isFieldDef(encoding.x) && !!encoding.x.aggregate;
    var yIsAggregate = fielddef_1.isFieldDef(encoding.y) && !!encoding.y.aggregate;
    if (xIsAggregate !== yIsAggregate) {
        var fieldChannel = xIsAggregate ? channel_1.X : channel_1.Y;
        var fieldDef = encoding[fieldChannel];
        var fieldChannelAggregate = fieldDef.aggregate;
        var fieldChannelScale = fieldDef.scale;
        var stackOffset = null;
        if (fieldDef.stack !== undefined) {
            stackOffset = fieldDef.stack;
        }
        else if (util_1.contains(exports.STACK_BY_DEFAULT_MARKS, mark)) {
            // Bar and Area with sum ops are automatically stacked by default
            stackOffset = stackConfig === undefined ? 'zero' : stackConfig;
        }
        else {
            stackOffset = stackConfig;
        }
        if (!stackOffset || stackOffset === 'none') {
            return null;
        }
        // If stacked, check if it qualifies for stacking (and log warning if not qualified.)
        if (fieldChannelScale && fieldChannelScale.type && fieldChannelScale.type !== scale_1.ScaleType.LINEAR) {
            log.warn(log.message.cannotStackNonLinearScale(fieldChannelScale.type));
            return null;
        }
        if (encoding_1.channelHasField(encoding, fieldChannel === channel_1.X ? channel_1.X2 : channel_1.Y2)) {
            log.warn(log.message.cannotStackRangedMark(fieldChannel));
            return null;
        }
        if (!util_1.contains(aggregate_1.SUM_OPS, fieldChannelAggregate)) {
            log.warn(log.message.cannotStackNonSummativeAggregate(fieldChannelAggregate));
            return null;
        }
        return {
            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),
            fieldChannel: fieldChannel,
            stackBy: stackBy,
            offset: stackOffset
        };
    }
    return null;
}
exports.stack = stack;

},{"./aggregate":41,"./channel":44,"./encoding":108,"./fielddef":110,"./log":113,"./mark":114,"./scale":115,"./util":124}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var datetime_1 = require("./datetime");
var log = require("./log");
var util_1 = require("./util");
var TimeUnit;
(function (TimeUnit) {
    TimeUnit.YEAR = 'year';
    TimeUnit.MONTH = 'month';
    TimeUnit.DAY = 'day';
    TimeUnit.DATE = 'date';
    TimeUnit.HOURS = 'hours';
    TimeUnit.MINUTES = 'minutes';
    TimeUnit.SECONDS = 'seconds';
    TimeUnit.MILLISECONDS = 'milliseconds';
    TimeUnit.YEARMONTH = 'yearmonth';
    TimeUnit.YEARMONTHDATE = 'yearmonthdate';
    TimeUnit.YEARMONTHDATEHOURS = 'yearmonthdatehours';
    TimeUnit.YEARMONTHDATEHOURSMINUTES = 'yearmonthdatehoursminutes';
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS = 'yearmonthdatehoursminutesseconds';
    // MONTHDATE always include 29 February since we use year 0th (which is a leap year);
    TimeUnit.MONTHDATE = 'monthdate';
    TimeUnit.HOURSMINUTES = 'hoursminutes';
    TimeUnit.HOURSMINUTESSECONDS = 'hoursminutesseconds';
    TimeUnit.MINUTESSECONDS = 'minutesseconds';
    TimeUnit.SECONDSMILLISECONDS = 'secondsmilliseconds';
    TimeUnit.QUARTER = 'quarter';
    TimeUnit.YEARQUARTER = 'yearquarter';
    TimeUnit.QUARTERMONTH = 'quartermonth';
    TimeUnit.YEARQUARTERMONTH = 'yearquartermonth';
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));
/** Time Unit that only corresponds to only one part of Date objects. */
exports.SINGLE_TIMEUNITS = [
    TimeUnit.YEAR,
    TimeUnit.QUARTER,
    TimeUnit.MONTH,
    TimeUnit.DAY,
    TimeUnit.DATE,
    TimeUnit.HOURS,
    TimeUnit.MINUTES,
    TimeUnit.SECONDS,
    TimeUnit.MILLISECONDS,
];
var SINGLE_TIMEUNIT_INDEX = exports.SINGLE_TIMEUNITS.reduce(function (d, timeUnit) {
    d[timeUnit] = true;
    return d;
}, {});
function isSingleTimeUnit(timeUnit) {
    return !!SINGLE_TIMEUNIT_INDEX[timeUnit];
}
exports.isSingleTimeUnit = isSingleTimeUnit;
/**
 * Converts a date to only have the measurements relevant to the specified unit
 * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'
 * Note: the base date is Jan 01 1900 00:00:00
 */
function convert(unit, date) {
    var result = new Date(0, 0, 1, 0, 0, 0, 0); // start with uniform date
    exports.SINGLE_TIMEUNITS.forEach(function (singleUnit) {
        if (containsTimeUnit(unit, singleUnit)) {
            switch (singleUnit) {
                case TimeUnit.DAY:
                    throw new Error('Cannot convert to TimeUnits containing \'day\'');
                case TimeUnit.YEAR:
                    result.setFullYear(date.getFullYear());
                    break;
                case TimeUnit.QUARTER:
                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)
                    result.setMonth((Math.floor(date.getMonth() / 3)) * 3);
                    break;
                case TimeUnit.MONTH:
                    result.setMonth(date.getMonth());
                    break;
                case TimeUnit.DATE:
                    result.setDate(date.getDate());
                    break;
                case TimeUnit.HOURS:
                    result.setHours(date.getHours());
                    break;
                case TimeUnit.MINUTES:
                    result.setMinutes(date.getMinutes());
                    break;
                case TimeUnit.SECONDS:
                    result.setSeconds(date.getSeconds());
                    break;
                case TimeUnit.MILLISECONDS:
                    result.setMilliseconds(date.getMilliseconds());
                    break;
            }
        }
    });
    return result;
}
exports.convert = convert;
exports.MULTI_TIMEUNITS = [
    TimeUnit.YEARQUARTER,
    TimeUnit.YEARQUARTERMONTH,
    TimeUnit.YEARMONTH,
    TimeUnit.YEARMONTHDATE,
    TimeUnit.YEARMONTHDATEHOURS,
    TimeUnit.YEARMONTHDATEHOURSMINUTES,
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,
    TimeUnit.QUARTERMONTH,
    TimeUnit.HOURSMINUTES,
    TimeUnit.HOURSMINUTESSECONDS,
    TimeUnit.MINUTESSECONDS,
    TimeUnit.SECONDSMILLISECONDS,
];
var MULTI_TIMEUNIT_INDEX = exports.MULTI_TIMEUNITS.reduce(function (d, timeUnit) {
    d[timeUnit] = true;
    return d;
}, {});
function isMultiTimeUnit(timeUnit) {
    return !!MULTI_TIMEUNIT_INDEX[timeUnit];
}
exports.isMultiTimeUnit = isMultiTimeUnit;
exports.TIMEUNITS = [
    TimeUnit.YEAR,
    TimeUnit.QUARTER,
    TimeUnit.MONTH,
    TimeUnit.DAY,
    TimeUnit.DATE,
    TimeUnit.HOURS,
    TimeUnit.MINUTES,
    TimeUnit.SECONDS,
    TimeUnit.MILLISECONDS,
    TimeUnit.YEARQUARTER,
    TimeUnit.YEARQUARTERMONTH,
    TimeUnit.YEARMONTH,
    TimeUnit.YEARMONTHDATE,
    TimeUnit.YEARMONTHDATEHOURS,
    TimeUnit.YEARMONTHDATEHOURSMINUTES,
    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS,
    TimeUnit.QUARTERMONTH,
    TimeUnit.HOURSMINUTES,
    TimeUnit.HOURSMINUTESSECONDS,
    TimeUnit.MINUTESSECONDS,
    TimeUnit.SECONDSMILLISECONDS
];
/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */
function containsTimeUnit(fullTimeUnit, timeUnit) {
    var index = fullTimeUnit.indexOf(timeUnit);
    return index > -1 &&
        (timeUnit !== TimeUnit.SECONDS ||
            index === 0 ||
            fullTimeUnit.charAt(index - 1) !== 'i' // exclude milliseconds
        );
}
exports.containsTimeUnit = containsTimeUnit;
/**
 * Returns Vega expresssion for a given timeUnit and fieldRef
 */
function fieldExpr(fullTimeUnit, field) {
    var fieldRef = "datum[\"" + field + "\"]";
    function func(timeUnit) {
        if (timeUnit === TimeUnit.QUARTER) {
            // quarter starting at 0 (0,3,6,9).
            return "(quarter(" + fieldRef + ")-1)";
        }
        else {
            return timeUnit + "(" + fieldRef + ")";
        }
    }
    var d = exports.SINGLE_TIMEUNITS.reduce(function (_d, tu) {
        if (containsTimeUnit(fullTimeUnit, tu)) {
            _d[tu] = func(tu);
        }
        return _d;
    }, {});
    if (d.day && util_1.keys(d).length > 1) {
        log.warn(log.message.dayReplacedWithDate(fullTimeUnit));
        delete d.day;
        d.date = func(TimeUnit.DATE);
    }
    return datetime_1.dateTimeExpr(d);
}
exports.fieldExpr = fieldExpr;
/** returns the smallest nice unit for scale.nice */
function smallestUnit(timeUnit) {
    if (!timeUnit) {
        return undefined;
    }
    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
        return 'second';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
        return 'minute';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
        return 'hour';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||
        containsTimeUnit(timeUnit, TimeUnit.DATE)) {
        return 'day';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
        return 'month';
    }
    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {
        return 'year';
    }
    return undefined;
}
exports.smallestUnit = smallestUnit;
/** returns the signal expression used for axis labels for a time unit */
function formatExpression(timeUnit, field, shortTimeLabels) {
    if (!timeUnit) {
        return undefined;
    }
    var dateComponents = [];
    var expression = '';
    var hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);
    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {
        // special expression for quarter as prefix
        expression = "'Q' + quarter(" + field + ")";
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {
        // By default use short month name
        dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {
        dateComponents.push(shortTimeLabels ? '%a' : '%A');
    }
    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {
        dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year
    }
    if (hasYear) {
        dateComponents.push(shortTimeLabels ? '%y' : '%Y');
    }
    var timeComponents = [];
    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {
        timeComponents.push('%H');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {
        timeComponents.push('%M');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {
        timeComponents.push('%S');
    }
    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {
        timeComponents.push('%L');
    }
    var dateTimeComponents = [];
    if (dateComponents.length > 0) {
        dateTimeComponents.push(dateComponents.join(' '));
    }
    if (timeComponents.length > 0) {
        dateTimeComponents.push(timeComponents.join(':'));
    }
    if (dateTimeComponents.length > 0) {
        if (expression) {
            // Add space between quarter and main time format
            expression += " + ' ' + ";
        }
        expression += "timeFormat(" + field + ", '" + dateTimeComponents.join(' ') + "')";
    }
    // If expression is still an empty string, return undefined instead.
    return expression || undefined;
}
exports.formatExpression = formatExpression;
function isDiscreteByDefault(timeUnit) {
    switch (timeUnit) {
        // These time unit use discrete scale by default
        case 'hours':
        case 'day':
        case 'month':
        case 'quarter':
            return true;
    }
    return false;
}
exports.isDiscreteByDefault = isDiscreteByDefault;

},{"./datetime":107,"./log":113,"./util":124}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TOP_LEVEL_PROPERTIES = [
    'background', 'padding'
];
function extractTopLevelProperties(t) {
    return TOP_LEVEL_PROPERTIES.reduce(function (o, p) {
        if (t && t[p] !== undefined) {
            o[p] = t[p];
        }
        return o;
    }, {});
}
exports.extractTopLevelProperties = extractTopLevelProperties;

},{}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFilter(t) {
    return t['filter'] !== undefined;
}
exports.isFilter = isFilter;
function isCalculate(t) {
    return t['calculate'] !== undefined;
}
exports.isCalculate = isCalculate;

},{}],123:[function(require,module,exports){
/** Constants and utilities for data type */
/** Data type based on level of measurement */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Type;
(function (Type) {
    Type.QUANTITATIVE = 'quantitative';
    Type.ORDINAL = 'ordinal';
    Type.TEMPORAL = 'temporal';
    Type.NOMINAL = 'nominal';
})(Type = exports.Type || (exports.Type = {}));
exports.QUANTITATIVE = Type.QUANTITATIVE;
exports.ORDINAL = Type.ORDINAL;
exports.TEMPORAL = Type.TEMPORAL;
exports.NOMINAL = Type.NOMINAL;
/**
 * Get full, lowercase type name for a given type.
 * @param  type
 * @return Full type name.
 */
function getFullName(type) {
    if (type) {
        type = type.toLowerCase();
        switch (type) {
            case 'q':
            case exports.QUANTITATIVE:
                return 'quantitative';
            case 't':
            case exports.TEMPORAL:
                return 'temporal';
            case 'o':
            case exports.ORDINAL:
                return 'ordinal';
            case 'n':
            case exports.NOMINAL:
                return 'nominal';
        }
    }
    // If we get invalid input, return undefined type.
    return undefined;
}
exports.getFullName = getFullName;

},{}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var stringify = require("json-stable-stringify");
var vega_util_1 = require("vega-util");
exports.extend = vega_util_1.extend;
exports.isArray = vega_util_1.isArray;
exports.isObject = vega_util_1.isObject;
exports.isNumber = vega_util_1.isNumber;
exports.isString = vega_util_1.isString;
exports.truncate = vega_util_1.truncate;
exports.toSet = vega_util_1.toSet;
exports.stringValue = vega_util_1.stringValue;
var vega_util_2 = require("vega-util");
/**
 * Creates an object composed of the picked object properties.
 *
 * Example:  (from lodash)
 *
 * var object = {'a': 1, 'b': '2', 'c': 3};
 * pick(object, ['a', 'c']);
 * // → {'a': 1, 'c': 3}
 *
 */
function pick(obj, props) {
    var copy = {};
    props.forEach(function (prop) {
        if (obj.hasOwnProperty(prop)) {
            copy[prop] = obj[prop];
        }
    });
    return copy;
}
exports.pick = pick;
/**
 * The opposite of _.pick; this method creates an object composed of the own
 * and inherited enumerable string keyed properties of object that are not omitted.
 */
function omit(obj, props) {
    var copy = duplicate(obj);
    props.forEach(function (prop) {
        delete copy[prop];
    });
    return copy;
}
exports.omit = omit;
function hash(a) {
    if (vega_util_2.isString(a) || vega_util_2.isNumber(a) || isBoolean(a)) {
        return String(a);
    }
    return stringify(a);
}
exports.hash = hash;
function contains(array, item) {
    return array.indexOf(item) > -1;
}
exports.contains = contains;
/** Returns the array without the elements in item */
function without(array, excludedItems) {
    return array.filter(function (item) { return !contains(excludedItems, item); });
}
exports.without = without;
function union(array, other) {
    return array.concat(without(other, array));
}
exports.union = union;
/**
 * Returns true if any item returns true.
 */
function some(arr, f) {
    var i = 0;
    for (var k = 0; k < arr.length; k++) {
        if (f(arr[k], k, i++)) {
            return true;
        }
    }
    return false;
}
exports.some = some;
/**
 * Returns true if all items return true.
 */
function every(arr, f) {
    var i = 0;
    for (var k = 0; k < arr.length; k++) {
        if (!f(arr[k], k, i++)) {
            return false;
        }
    }
    return true;
}
exports.every = every;
function flatten(arrays) {
    return [].concat.apply([], arrays);
}
exports.flatten = flatten;
/**
 * recursively merges src into dest
 */
function mergeDeep(dest) {
    var src = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        src[_i - 1] = arguments[_i];
    }
    for (var _a = 0, src_1 = src; _a < src_1.length; _a++) {
        var s = src_1[_a];
        dest = deepMerge_(dest, s);
    }
    return dest;
}
exports.mergeDeep = mergeDeep;
// recursively merges src into dest
function deepMerge_(dest, src) {
    if (typeof src !== 'object' || src === null) {
        return dest;
    }
    for (var p in src) {
        if (!src.hasOwnProperty(p)) {
            continue;
        }
        if (src[p] === undefined) {
            continue;
        }
        if (typeof src[p] !== 'object' || vega_util_2.isArray(src[p]) || src[p] === null) {
            dest[p] = src[p];
        }
        else if (typeof dest[p] !== 'object' || dest[p] === null) {
            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);
        }
        else {
            mergeDeep(dest[p], src[p]);
        }
    }
    return dest;
}
function unique(values, f) {
    var results = [];
    var u = {};
    var v;
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
        var val = values_1[_i];
        v = f(val);
        if (v in u) {
            continue;
        }
        u[v] = 1;
        results.push(val);
    }
    return results;
}
exports.unique = unique;
/**
 * Returns true if the two dictionaries disagree. Applies only to defined values.
 */
function differ(dict, other) {
    for (var key in dict) {
        if (dict.hasOwnProperty(key)) {
            if (other[key] && dict[key] && other[key] !== dict[key]) {
                return true;
            }
        }
    }
    return false;
}
exports.differ = differ;
function hasIntersection(a, b) {
    for (var key in a) {
        if (key in b) {
            return true;
        }
    }
    return false;
}
exports.hasIntersection = hasIntersection;
function differArray(array, other) {
    if (array.length !== other.length) {
        return true;
    }
    array.sort();
    other.sort();
    for (var i = 0; i < array.length; i++) {
        if (other[i] !== array[i]) {
            return true;
        }
    }
    return false;
}
exports.differArray = differArray;
exports.keys = Object.keys;
function vals(x) {
    var _vals = [];
    for (var k in x) {
        if (x.hasOwnProperty(k)) {
            _vals.push(x[k]);
        }
    }
    return _vals;
}
exports.vals = vals;
function duplicate(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.duplicate = duplicate;
function isBoolean(b) {
    return b === true || b === false;
}
exports.isBoolean = isBoolean;
/**
 * Convert a string into a valid variable name
 */
function varName(s) {
    // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _
    var alphanumericS = s.replace(/\W/g, '_');
    // Add _ if the string has leading numbers.
    return (s.match(/^\d+/) ? '_' : '') + alphanumericS;
}
exports.varName = varName;

},{"json-stable-stringify":33,"vega-util":128}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mark_1 = require("./mark");
// TODO: move to vl.spec.validator?
var mark_2 = require("./mark");
var util_1 = require("./util");
/**
 * Required Encoding Channels for each mark type
 * @type {Object}
 */
exports.DEFAULT_REQUIRED_CHANNEL_MAP = {
    text: ['text'],
    line: ['x', 'y'],
    area: ['x', 'y']
};
/**
 * Supported Encoding Channel for each mark type
 */
exports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {
    bar: util_1.toSet(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),
    line: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    area: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    tick: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'detail']),
    circle: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
    square: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),
    point: util_1.toSet(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),
    text: util_1.toSet(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise
};
// TODO: consider if we should add validate method and
// requires ZSchema in the main vega-lite repo
/**
 * Further check if encoding mapping of a spec is invalid and
 * return error if it is invalid.
 *
 * This checks if
 * (1) all the required encoding channels for the mark type are specified
 * (2) all the specified encoding channels are supported by the mark type
 * @param  {[type]} spec [description]
 * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap
 * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap
 * @return {String} Return one reason why the encoding is invalid,
 *                  or null if the encoding is valid.
 */
function getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {
    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }
    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }
    var mark = mark_1.isMarkDef(spec.mark) ? spec.mark.type : spec.mark;
    var encoding = spec.encoding;
    var requiredChannels = requiredChannelMap[mark];
    var supportedChannels = supportedChannelMap[mark];
    for (var i in requiredChannels) {
        if (!(requiredChannels[i] in encoding)) {
            return 'Missing encoding channel \"' + requiredChannels[i] +
                '\" for mark \"' + mark + '\"';
        }
    }
    for (var channel in encoding) {
        if (!supportedChannels[channel]) {
            return 'Encoding channel \"' + channel +
                '\" is not supported by mark type \"' + mark + '\"';
        }
    }
    if (mark === mark_2.BAR && !encoding.x && !encoding.y) {
        return 'Missing both x and y for bar';
    }
    return null;
}
exports.getEncodingMappingError = getEncodingMappingError;

},{"./mark":114,"./util":124}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
function isDataRefUnionedDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'fields' in domain && !('data' in domain);
    }
    return false;
}
exports.isDataRefUnionedDomain = isDataRefUnionedDomain;
function isFieldRefUnionDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'fields' in domain && 'data' in domain;
    }
    return false;
}
exports.isFieldRefUnionDomain = isFieldRefUnionDomain;
function isDataRefDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'field' in domain && 'data' in domain;
    }
    return false;
}
exports.isDataRefDomain = isDataRefDomain;
function isSignalRefDomain(domain) {
    if (!util_1.isArray(domain)) {
        return 'signal' in domain;
    }
    return false;
}
exports.isSignalRefDomain = isSignalRefDomain;

},{"./util":124}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.axis = require("./axis");
exports.aggregate = require("./aggregate");
exports.bin = require("./bin");
exports.channel = require("./channel");
exports.compositeMark = require("./compositemark");
var compile_1 = require("./compile/compile");
exports.compile = compile_1.compile;
exports.config = require("./config");
exports.data = require("./data");
exports.datetime = require("./datetime");
exports.encoding = require("./encoding");
exports.facet = require("./facet");
exports.fieldDef = require("./fielddef");
exports.legend = require("./legend");
exports.mark = require("./mark");
exports.scale = require("./scale");
exports.sort = require("./sort");
exports.spec = require("./spec");
exports.stack = require("./stack");
exports.timeUnit = require("./timeunit");
exports.transform = require("./transform");
exports.type = require("./type");
exports.util = require("./util");
exports.validate = require("./validate");
exports.version = require('../package.json').version;

},{"../package.json":40,"./aggregate":41,"./axis":42,"./bin":43,"./channel":44,"./compile/compile":49,"./compositemark":104,"./config":105,"./data":106,"./datetime":107,"./encoding":108,"./facet":109,"./fielddef":110,"./legend":112,"./mark":114,"./scale":115,"./sort":117,"./spec":118,"./stack":119,"./timeunit":120,"./transform":122,"./type":123,"./util":124,"./validate":125}],128:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.vega = global.vega || {})));
}(this, (function (exports) { 'use strict';

var accessor = function(fn, fields, name) {
  return (
    fn.fields = fields || [],
    fn.fname = name,
    fn
  );
}

function accessorName(fn) {
  return fn == null ? null : fn.fname;
}

function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}

var error = function(message) {
  throw Error(message);
}

var splitAccessPath = function(p) {
  var path = [],
      q = null,
      b = 0,
      n = p.length,
      s = '',
      i, j, c;

  p = p + '';

  function push() {
    path.push(s + p.substring(i, j));
    s = '';
    i = j + 1;
  }

  for (i=j=0; j<n; ++j) {
    c = p[j];
    if (c === '\\') s += p.substring(i, j), i = ++j;
    else if (c === q) push(), q = null, b = -1;
    else if (q) continue;
    else if (i === b && c === '"') i = j + 1, q = c;
    else if (i === b && c === "'") i = j + 1, q = c;
    else if (c === '.' && !b) (j > i) ? push() : (i = j + 1);
    else if (c === '[') {
      if (j > i) push();
      b = i = j + 1;
    }
    else if (c === ']') {
      if (!b) error('Access path missing open bracket: ' + p);
      if (b > 0) push();
      b = 0;
      i = j + 1;
    }
  }

  if (b) error('Access path missing closing bracket: ' + p);
  if (q) error('Access path missing closing quote: ' + p);
  if (j > i) ++j, push();
  return path;
}

var isArray = Array.isArray;

var isObject = function(_) {
  return _ === Object(_);
}

var isString = function(_) {
  return typeof _ === 'string';
}

function $(x) {
  return isArray(x) ? '[' + x.map($) + ']'
    : isObject(x) || isString(x) ?
      // Output valid JSON and JS source strings.
      // See http://timelessrepo.com/json-isnt-a-javascript-subset
      JSON.stringify(x).replace('\u2028','\\u2028').replace('\u2029', '\\u2029')
    : x;
}

var field = function(field, name) {
  var path = splitAccessPath(field),
      code = 'return _[' + path.map($).join('][') + '];';

  return accessor(
    Function('_', code),
    [(field = path.length===1 ? path[0] : field)],
    name || field
  );
}

var empty = [];

var id = field('id');

var identity = accessor(function(_) { return _; }, empty, 'identity');

var zero = accessor(function() { return 0; }, empty, 'zero');

var one = accessor(function() { return 1; }, empty, 'one');

var truthy = accessor(function() { return true; }, empty, 'true');

var falsy = accessor(function() { return false; }, empty, 'false');

function log(method, level, input) {
  var args = [level].concat([].slice.call(input));
  console[method].apply(console, args); // eslint-disable-line no-console
}

var None  = 0;
var Warn  = 1;
var Info  = 2;
var Debug = 3;

var logger = function(_) {
  var level = _ || None;
  return {
    level: function(_) {
      return arguments.length ? (level = +_, this) : level;
    },
    warn: function() {
      if (level >= Warn) log('warn', 'WARN', arguments);
      return this;
    },
    info: function() {
      if (level >= Info) log('log', 'INFO', arguments);
      return this;
    },
    debug: function() {
      if (level >= Debug) log('log', 'DEBUG', arguments);
      return this;
    }
  }
}

var array = function(_) {
  return _ != null ? (isArray(_) ? _ : [_]) : [];
}

var compare = function(fields, orders) {
  var idx = [],
      cmp = (fields = array(fields)).map(function(f, i) {
        return f == null ? null
          : (idx.push(i), splitAccessPath(f).map($).join(']['));
      }),
      n = idx.length - 1,
      ord = array(orders),
      code = 'var u,v;return ',
      i, j, f, u, v, d, lt, gt;

  if (n < 0) return null;

  for (j=0; j<=n; ++j) {
    i = idx[j];
    f = cmp[i];
    u = '(u=a['+f+'])';
    v = '(v=b['+f+'])';
    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';
    lt = ord[i] !== 'descending' ? (gt=1, -1) : (gt=-1, 1);
    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt
      + ':(u>v||v==null)&&u!=null?' + gt
      + ':'+d+'!==u&&v===v?' + lt
      + ':v!==v&&u===u?' + gt
      + (i < n ? ':' : ':0');
  }

  return accessor(
    Function('a', 'b', code + ';'),
    fields.filter(function(_) { return _ != null; })
  );
}

var isFunction = function(_) {
  return typeof _ === 'function';
}

var constant = function(_) {
  return isFunction(_) ? _ : function() { return _; };
}

var extend = function(_) {
  for (var x, k, i=1, len=arguments.length; i<len; ++i) {
    x = arguments[i];
    for (k in x) { _[k] = x[k]; }
  }
  return _;
}

var extentIndex = function(array, f) {
  var i = -1,
      n = array.length,
      a, b, c, u, v;

  if (f == null) {
    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
    u = v = i;
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b, u = i;
      if (c < b) c = b, v = i;
    }
  } else {
    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
    u = v = i;
    while (++i < n) if ((b = f(array[i], i, array)) != null) {
      if (a > b) a = b, u = i;
      if (c < b) c = b, v = i;
    }
  }

  return [u, v];
}

var NULL = {};

var fastmap = function(input) {
  var obj = {},
      map,
      test;

  function has(key) {
    return obj.hasOwnProperty(key) && obj[key] !== NULL;
  }

  map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has,
    get: function(key) {
      return has(key) ? obj[key] : undefined;
    },
    set: function(key, value) {
      if (!has(key)) {
        ++map.size;
        if (obj[key] === NULL) --map.empty;
      }
      obj[key] = value;
      return this;
    },
    delete: function(key) {
      if (has(key)) {
        --map.size;
        ++map.empty;
        obj[key] = NULL;
      }
      return this;
    },
    clear: function() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },
    test: function(_) {
      return arguments.length ? (test = _, map) : test;
    },
    clean: function() {
      var next = {},
          size = 0,
          key, value;
      for (key in obj) {
        value = obj[key];
        if (value !== NULL && (!test || !test(value))) {
          next[key] = value;
          ++size;
        }
      }
      map.size = size;
      map.empty = 0;
      map.object = (obj = next);
    }
  };

  if (input) Object.keys(input).forEach(function(key) {
    map.set(key, input[key]);
  });

  return map;
}

var inherits = function(child, parent) {
  var proto = (child.prototype = Object.create(parent.prototype));
  proto.constructor = child;
  return proto;
}

var isNumber = function(_) {
  return typeof _ === 'number';
}

var key = function(fields) {
  fields = fields ? array(fields) : fields;
  var fn = !(fields && fields.length)
    ? function() { return ''; }
    : Function('_', 'return \'\'+' +
        fields.map(function(f) {
          return '_[' + splitAccessPath(f).map($).join('][') + ']';
        }).join('+\'|\'+') + ';');
  return accessor(fn, fields, 'key');
}

var merge = function(compare, array0, array1, output) {
  var n0 = array0.length,
      n1 = array1.length;

  if (!n1) return array0;
  if (!n0) return array1;

  var merged = output || new array0.constructor(n0 + n1),
      i0 = 0, i1 = 0, i = 0;

  for (; i0<n0 && i1<n1; ++i) {
    merged[i] = compare(array0[i0], array1[i1]) > 0
       ? array1[i1++]
       : array0[i0++];
  }

  for (; i0<n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }

  for (; i1<n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }

  return merged;
}

var repeat = function(str, reps) {
  var s = '';
  while (--reps >= 0) s += str;
  return s;
}

var pad = function(str, length, padchar, align) {
  var c = padchar || ' ',
      s = str + '',
      n = length - s.length;

  return n <= 0 ? s
    : align === 'left' ? repeat(c, n) + s
    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))
    : s + repeat(c, n);
}

var peek = function(array) {
  return array[array.length - 1];
}

var toSet = function(_) {
  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;
  return s;
}

var truncate = function(str, length, align, ellipsis) {
  var e = ellipsis != null ? ellipsis : '\u2026',
      s = str + '',
      n = s.length,
      l = Math.max(0, length - e.length);

  return n <= length ? s
    : align === 'left' ? e + s.slice(n - l)
    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))
    : s.slice(0, l) + e;
}

var visitArray = function(array, filter, visitor) {
  if (array) {
    var i = 0, n = array.length, t;
    if (filter) {
      for (; i<n; ++i) {
        if (t = filter(array[i])) visitor(t, i, array);
      }
    } else {
      array.forEach(visitor);
    }
  }
}

exports.accessor = accessor;
exports.accessorName = accessorName;
exports.accessorFields = accessorFields;
exports.id = id;
exports.identity = identity;
exports.zero = zero;
exports.one = one;
exports.truthy = truthy;
exports.falsy = falsy;
exports.logger = logger;
exports.None = None;
exports.Warn = Warn;
exports.Info = Info;
exports.Debug = Debug;
exports.array = array;
exports.compare = compare;
exports.constant = constant;
exports.error = error;
exports.extend = extend;
exports.extentIndex = extentIndex;
exports.fastmap = fastmap;
exports.field = field;
exports.inherits = inherits;
exports.isArray = isArray;
exports.isFunction = isFunction;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;
exports.key = key;
exports.merge = merge;
exports.pad = pad;
exports.peek = peek;
exports.repeat = repeat;
exports.splitAccessPath = splitAccessPath;
exports.stringValue = $;
exports.toSet = toSet;
exports.truncate = truncate;
exports.visitArray = visitArray;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var d3_collection_1 = require("d3-collection");
var d3_selection_1 = require("d3-selection");
var dl = require("datalib");
var type_1 = require("vega-lite/build/src/type");
var vl = require("vega-lite/build/src/vl");
// by default, delay showing tooltip for 100 ms
var DELAY = 100;
var tooltipPromise = undefined;
var tooltipActive = false;
/**
* Export API for Vega visualizations: vg.tooltip(vgView, options)
* options can specify whether to show all fields or to show only custom fields
* It can also provide custom title and format for fields
*/
function vega(vgView, options) {
    // TODO: change item type to vega scenegraph
    if (options === void 0) { options = {}; }
    // initialize tooltip with item data and options on mouse over
    vgView.addEventListener("mouseover.tooltipInit", function (event, item) {
        if (shouldShowTooltip(item)) {
            // clear existing promise because mouse can only point at one thing at a time
            cancelPromise();
            tooltipPromise = window.setTimeout(function () {
                init(event, item, options);
            }, options.delay || DELAY);
        }
    });
    // update tooltip position on mouse move
    // (important for large marks e.g. bars)
    vgView.addEventListener("mousemove.tooltipUpdate", function (event, item) {
        if (shouldShowTooltip(item) && tooltipActive) {
            update(event, item, options);
        }
    });
    // clear tooltip on mouse out
    vgView.addEventListener("mouseout.tooltipRemove", function (event, item) {
        if (shouldShowTooltip(item)) {
            cancelPromise();
            if (tooltipActive) {
                clear(event, item, options);
            }
        }
    });
    return {
        destroy: function () {
            // remove event listeners
            vgView.removeEventListener("mouseover.tooltipInit");
            vgView.removeEventListener("mousemove.tooltipUpdate");
            vgView.removeEventListener("mouseout.tooltipRemove");
            cancelPromise(); // clear tooltip promise
        }
    };
}
exports.vega = vega;
;
/**
* Export API for Vega-Lite visualizations: vl.tooltip(vgView, vlSpec, options)
* options can specify whether to show all fields or to show only custom fields
* It can also provide custom title and format for fields
* options can be supplemented by vlSpec
*/
function vegaLite(vgView, vlSpec, options) {
    if (options === void 0) { options = {}; }
    options = supplementOptions(options, vlSpec);
    // TODO: update this to use new vega-view api (addEventListener)
    // initialize tooltip with item data and options on mouse over
    vgView.addEventListener("mouseover", function (event, item) {
        if (shouldShowTooltip(item)) {
            // clear existing promise because mouse can only point at one thing at a time
            cancelPromise();
            // make a new promise with time delay for tooltip
            tooltipPromise = window.setTimeout(function () {
                init(event, item, options);
            }, options.delay || DELAY);
        }
    });
    // update tooltip position on mouse move
    // (important for large marks e.g. bars)
    vgView.addEventListener("mousemove", function (event, item) {
        if (shouldShowTooltip(item) && tooltipActive) {
            update(event, item, options);
        }
    });
    // clear tooltip on mouse out
    vgView.addEventListener("mouseout", function (event, item) {
        if (shouldShowTooltip(item)) {
            cancelPromise();
            if (tooltipActive) {
                clear(event, item, options);
            }
        }
    });
    return {
        destroy: function () {
            // remove event listeners
            vgView.removeEventListener("mouseover.tooltipInit");
            vgView.removeEventListener("mousemove.tooltipUpdate");
            vgView.removeEventListener("mouseout.tooltipRemove");
            cancelPromise(); // clear tooltip promise
        }
    };
}
exports.vegaLite = vegaLite;
;
/* Cancel tooltip promise */
function cancelPromise() {
    /* We don't check if tooltipPromise is valid because passing
     an invalid ID to clearTimeout does not have any effect
     (and doesn't throw an exception). */
    window.clearTimeout(tooltipPromise);
    tooltipPromise = undefined;
}
/* d3mapping from fieldDef.type to formatType */
var formatTypeMap = {
    "quantitative": "number",
    "temporal": "time",
    "ordinal": undefined,
    "nominal": undefined
};
/**
* (Vega-Lite only) Supplement options with vlSpec
*
* @param options - user-provided options
* @param vlSpec - vega-lite spec
* @return the vlSpec-supplemented options object
*
* if options.showAllFields is true or undefined, vlSpec will supplement
* options.fields with all fields in the spec
* if options.showAllFields is false, vlSpec will only supplement existing fields
* in options.fields
*/
function supplementOptions(options, vlSpec) {
    // fields to be supplemented by vlSpec
    var supplementedFields = [];
    // if showAllFields is true or undefined, supplement all fields in vlSpec
    if (options.showAllFields !== false) {
        vl.spec.fieldDefs(vlSpec).forEach(function (fieldDef) {
            // get a fieldOption in options that matches the fieldDef
            var fieldOption = getFieldOption(options.fields, fieldDef);
            // supplement the fieldOption with fieldDef and config
            var supplementedFieldOption = supplementFieldOption(fieldOption, fieldDef, vlSpec);
            supplementedFields.push(supplementedFieldOption);
        });
    }
    else {
        if (options.fields) {
            options.fields.forEach(function (fieldOption) {
                // get the fieldDef in vlSpec that matches the fieldOption
                var fieldDef = getFieldDef(vl.spec.fieldDefs(vlSpec), fieldOption);
                // supplement the fieldOption with fieldDef and config
                var supplementedFieldOption = supplementFieldOption(fieldOption, fieldDef, vlSpec);
                supplementedFields.push(supplementedFieldOption);
            });
        }
    }
    options.fields = supplementedFields;
    return options;
}
/**
* Find a fieldOption in fieldOptions that matches a fieldDef
*
* @param {Object[]} fieldOptionss - a list of field options (i.e. options.fields[])
* @param {Object} fieldDef - from vlSpec
* @return the matching fieldOption, or undefined if no match was found
*
* If the fieldDef is aggregated, find a fieldOption that matches the field name and
* the aggregation of the fieldDef.
* If the fieldDef is not aggregated, find a fieldOption that matches the field name.
*/
function getFieldOption(fieldOptions, fieldDef) {
    if (!fieldDef || !fieldOptions || fieldOptions.length <= 0)
        return undefined;
    // if aggregate, match field name and aggregate operation
    if (fieldDef.aggregate) {
        // try find the perfect match: field name equals, aggregate operation equals
        for (var i = 0; i < fieldOptions.length; i++) {
            var fieldOption = fieldOptions[i];
            if (fieldOption.field === fieldDef.field && fieldOption.aggregate === fieldDef.aggregate) {
                return fieldOption;
            }
        }
        // try find the second-best match: field name equals, field.aggregate is not specified
        for (var i = 0; i < fieldOptions.length; i++) {
            var fieldOption = fieldOptions[i];
            if (fieldOption.field === fieldDef.field && !fieldOption.aggregate) {
                return fieldOption;
            }
        }
        // return undefined if no match was found
        return undefined;
    }
    else {
        for (var i = 0; i < fieldOptions.length; i++) {
            var fieldOption = fieldOptions[i];
            if (fieldOption.field === fieldDef.field) {
                return fieldOption;
            }
        }
        // return undefined if no match was found
        return undefined;
    }
}
/**
* Find a fieldDef that matches a fieldOption
*
* @param {Object} fieldOption - a field option (a member in options.fields[])
* @return the matching fieldDef, or undefined if no match was found
*
* A matching fieldDef should have the same field name as fieldOption.
* If the matching fieldDef is aggregated, the aggregation should not contradict
* with that of the fieldOption.
*/
function getFieldDef(fieldDefs, fieldOption) {
    if (!fieldOption || !fieldOption.field || !fieldDefs) {
        return undefined;
    }
    // field name should match, aggregation should not disagree
    for (var i = 0; i < fieldDefs.length; i++) {
        var fieldDef = fieldDefs[i];
        if (fieldDef.field === fieldOption.field) {
            if (fieldDef.aggregate) {
                if (fieldDef.aggregate === fieldOption.aggregate || !fieldOption.aggregate) {
                    return fieldDef;
                }
            }
            else {
                return fieldDef;
            }
        }
    }
    // return undefined if no match was found
    return undefined;
}
/**
* Supplement a fieldOption (from options.fields[]) with a fieldDef, config
* (which provides timeFormat, numberFormat, countTitle)
* Either fieldOption or fieldDef can be undefined, but they cannot both be undefined.
* config (and its members timeFormat, numberFormat and countTitle) can be undefined.
* @return the supplemented fieldOption, or undefined on error
*/
function supplementFieldOption(fieldOption, fieldDef, vlSpec) {
    // many specs don't have config
    var config = vl.util.extend({}, vlSpec.config);
    // at least one of fieldOption and fieldDef should exist
    if (!fieldOption && !fieldDef) {
        console.error("[Tooltip] Cannot supplement a field when field and fieldDef are both empty.");
        return undefined;
    }
    // if either one of fieldOption and fieldDef is undefined, make it an empty object
    if (!fieldOption && fieldDef)
        fieldOption = {};
    if (fieldOption && !fieldDef)
        fieldDef = {};
    // the supplemented field option
    var supplementedFieldOption = {};
    // supplement a user-provided field name with underscore prefixes and suffixes to
    // match the field names in item.datum
    // for aggregation, this will add prefix "mean_" etc.
    // for timeUnit, this will add prefix "yearmonth_" etc.
    // for bin, this will add prefix "bin_" and suffix "_start". Later we will replace "_start" with "_range".
    supplementedFieldOption.field = fieldDef.field ?
        vl.fieldDef.field(fieldDef) : fieldOption.field;
    // If a fieldDef is a (TIMEUNIT)T, we check if the original T is present in the vlSpec.
    // If only (TIMEUNIT)T is present in vlSpec, we set `removeOriginalTemporalField` to T,
    // which will cause function removeDuplicateTimeFields() to remove T and only keep (TIMEUNIT)T
    // in item data.
    // If both (TIMEUNIT)T and T are in vlSpec, we set `removeOriginalTemporalField` to undefined,
    // which will leave both T and (TIMEUNIT)T in item data.
    // Note: user should never have to provide this boolean in options
    if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {
        // in most cases, if it's a (TIMEUNIT)T, we remove original T
        var originalTemporalField = fieldDef.field;
        supplementedFieldOption.removeOriginalTemporalField = originalTemporalField;
        // handle corner case: if T is present in vlSpec, then we keep both T and (TIMEUNIT)T
        var fieldDefs = vl.spec.fieldDefs(vlSpec);
        for (var i = 0; i < fieldDefs.length; i++) {
            if (fieldDefs[i].field === originalTemporalField && !fieldDefs[i].timeUnit) {
                supplementedFieldOption.removeOriginalTemporalField = undefined;
                break;
            }
        }
    }
    // supplement title
    if (!config.countTitle)
        config.countTitle = vl.config.defaultConfig.countTitle; // use vl default countTitle
    supplementedFieldOption.title = fieldOption.title ?
        fieldOption.title : vl.fieldDef.title(fieldDef, config);
    // supplement formatType
    supplementedFieldOption.formatType = fieldOption.formatType ?
        fieldOption.formatType : formatTypeMap[fieldDef.type];
    // supplement format
    if (fieldOption.format) {
        supplementedFieldOption.format = fieldOption.format;
    }
    else {
        switch (supplementedFieldOption.formatType) {
            case "time":
                supplementedFieldOption.format = fieldDef.timeUnit ?
                    // TODO(zening): use template for all time fields, to be consistent with Vega-Lite
                    vl.timeUnit.formatExpression(fieldDef.timeUnit, "", false).split("'")[1]
                    : config.timeFormat || vl.config.defaultConfig.timeFormat;
                break;
            case "number":
                supplementedFieldOption.format = config.numberFormat;
                break;
            case "string":
            default:
        }
    }
    // supplement bin from fieldDef, user should never have to provide bin in options
    if (fieldDef.bin) {
        supplementedFieldOption.field = supplementedFieldOption.field.replace("_start", "_range"); // replace suffix
        supplementedFieldOption.bin = true;
        supplementedFieldOption.formatType = "string"; // we show bin range as string (e.g. "5-10")
    }
    return supplementedFieldOption;
}
/* Initialize tooltip with data */
function init(event, item, options) {
    // get tooltip HTML placeholder
    var tooltipPlaceholder = getTooltipPlaceholder();
    // prepare data for tooltip
    var tooltipData = getTooltipData(item, options);
    if (!tooltipData || tooltipData.length === 0)
        return;
    // bind data to tooltip HTML placeholder
    bindData(tooltipPlaceholder, tooltipData);
    updatePosition(event, options);
    updateColorTheme(options);
    d3_selection_1.select("#vis-tooltip").style("visibility", "visible");
    tooltipActive = true;
    // invoke user-provided callback
    if (options.onAppear) {
        options.onAppear(event, item);
    }
}
/* Update tooltip position on mousemove */
function update(event, item, options) {
    updatePosition(event, options);
    // invoke user-provided callback
    if (options.onMove) {
        options.onMove(event, item);
    }
}
/* Clear tooltip */
function clear(event, item, options) {
    // visibility hidden instead of display none
    // because we need computed tooltip width and height to best position it
    d3_selection_1.select("#vis-tooltip").style("visibility", "hidden");
    tooltipActive = false;
    clearData();
    clearColorTheme();
    clearPosition();
    // invoke user-provided callback
    if (options.onDisappear) {
        options.onDisappear(event, item);
    }
}
/* Decide if a scenegraph item deserves tooltip */
function shouldShowTooltip(item) {
    // no data, no show
    if (!item || !item.datum)
        return false;
    // (small multiples) avoid showing tooltip for a facet's background
    if (item.datum._facetID)
        return false;
    // avoid showing tooltip for axis title and labels
    if (!item.datum._id)
        return false;
    return true;
}
/**
* Prepare data for the tooltip
* @return An array of tooltip data [{ title: ..., value: ...}]
*/
// TODO: add marktype
function getTooltipData(item, options) {
    // this array will be bind to the tooltip element
    var tooltipData;
    var itemData = d3_collection_1.map(item.datum);
    // TODO(zening): find more keys which we should remove from data (#35)
    var removeKeys = [
        "_id", "_prev", "width", "height",
        "count_start", "count_end",
        "layout_start", "layout_mid", "layout_end", "layout_path", "layout_x", "layout_y"
    ];
    removeFields(itemData, removeKeys);
    // remove duplicate time fields (if any)
    removeDuplicateTimeFields(itemData, options.fields);
    // combine multiple rows of a binned field into a single row
    combineBinFields(itemData, options.fields);
    // TODO(zening): use Vega-Lite layering to support tooltip on line and area charts (#1)
    dropFieldsForLineArea(item.mark.marktype, itemData);
    if (options.showAllFields !== false) {
        tooltipData = prepareAllFieldsData(itemData, options);
    }
    else {
        tooltipData = prepareCustomFieldsData(itemData, options);
    }
    return tooltipData;
}
/**
* Prepare custom fields data for tooltip. This function formats
* field titles and values and returns an array of formatted fields.
*
* @param {d3.map} itemData - a map of item.datum
* @param {Object} options - user-provided options
* @return An array of formatted fields specified by options [{ title: ..., value: ...}]
*/
function prepareCustomFieldsData(itemData, options) {
    var tooltipData = [];
    options.fields.forEach(function (fieldOption) {
        // prepare field title
        var title = fieldOption.title ? fieldOption.title : fieldOption.field;
        // get (raw) field value
        var value = getValue(itemData, fieldOption.field);
        if (value === undefined)
            return;
        // format value
        var formattedValue = customFormat(value, fieldOption.formatType, fieldOption.format) || autoFormat(value);
        // add formatted data to tooltipData
        tooltipData.push({ title: title, value: formattedValue });
    });
    return tooltipData;
}
/**
* Get a field value from a data map.
* @param {d3.map} itemData - a map of item.datum
* @param {string} field - the name of the field. It can contain "." to specify
* that the field is not a direct child of item.datum
* @return the field value on success, undefined otherwise
*/
// TODO(zening): Mute "Cannot find field" warnings for composite vis (issue #39)
function getValue(itemData, field) {
    var value;
    var accessors = field.split('.');
    // get the first accessor and remove it from the array
    var firstAccessor = accessors[0];
    accessors.shift();
    if (itemData.has(firstAccessor)) {
        value = itemData.get(firstAccessor);
        // if we still have accessors, use them to get the value
        accessors.forEach(function (a) {
            if (value[a]) {
                value = value[a];
            }
        });
    }
    if (value === undefined) {
        console.warn("[Tooltip] Cannot find field " + field + " in data.");
        return undefined;
    }
    else {
        return value;
    }
}
/**
* Prepare data for all fields in itemData for tooltip. This function
* formats field titles and values and returns an array of formatted fields.
*
* @param {d3.map} itemData - a map of item.datum
* @param {Object} options - user-provided options
* @return All fields in itemData, formatted, in the form of an array: [{ title: ..., value: ...}]
*
* Please note that this function expects itemData to be simple {field:value} pairs.
* It will not try to parse value if it is an object. If value is an object, please
* use prepareCustomFieldsData() instead.
*/
function prepareAllFieldsData(itemData, options) {
    var tooltipData = [];
    // here, fieldOptions still provides format
    var fieldOptions = d3_collection_1.map(options.fields, function (d) { return d.field; });
    itemData.each(function (value, field) {
        // prepare title
        var title;
        if (fieldOptions.has(field) && fieldOptions.get(field).title) {
            title = fieldOptions.get(field).title;
        }
        else {
            title = field;
        }
        // format value
        if (fieldOptions.has(field)) {
            var formatType = fieldOptions.get(field).formatType;
            var format = fieldOptions.get(field).format;
        }
        var formattedValue = customFormat(value, formatType, format) || autoFormat(value);
        // add formatted data to tooltipData
        tooltipData.push({ title: title, value: formattedValue });
    });
    return tooltipData;
}
/**
* Remove multiple fields from a tooltip data map, using removeKeys
*
* Certain meta data fields (e.g. "_id", "_prev") should be hidden in the tooltip
* by default. This function can be used to remove these fields from tooltip data.
* @param {d3.map} dataMap - the data map that contains tooltip data.
* @param {string[]} removeKeys - the fields that should be removed from dataMap.
*/
function removeFields(dataMap, removeKeys) {
    removeKeys.forEach(function (key) {
        dataMap.remove(key);
    });
}
/**
 * When a temporal field has timeUnit, itemData will give us duplicated fields
 * (e.g., Year and YEAR(Year)). In tooltip want to display the field WITH the
 * timeUnit and remove the field that doesn't have timeUnit.
 */
function removeDuplicateTimeFields(itemData, optFields) {
    if (!optFields)
        return;
    optFields.forEach(function (optField) {
        if (optField.removeOriginalTemporalField) {
            removeFields(itemData, [optField.removeOriginalTemporalField]);
        }
    });
}
/**
* Combine multiple binned fields in itemData into one field. The value of the field
* is a string that describes the bin range.
*
* @param {d3.map} itemData - a map of item.datum
* @param {Object[]} fieldOptions - a list of field options (i.e. options.fields[])
* @return itemData with combined bin fields
*/
function combineBinFields(itemData, fieldOptions) {
    if (!fieldOptions)
        return undefined;
    fieldOptions.forEach(function (fieldOption) {
        if (fieldOption.bin === true) {
            // get binned field names
            var bin_field_range = fieldOption.field;
            var bin_field_start = bin_field_range.replace('_range', '_start');
            var bin_field_mid = bin_field_range.replace('_range', '_mid');
            var bin_field_end = bin_field_range.replace('_range', '_end');
            // use start value and end value to compute range
            // save the computed range in bin_field_start
            var startValue = itemData.get(bin_field_start);
            var endValue = itemData.get(bin_field_end);
            if ((startValue !== undefined) && (endValue !== undefined)) {
                var range = startValue + '-' + endValue;
                itemData.set(bin_field_range, range);
            }
            // remove bin_field_mid, bin_field_end, and bin_field_range from itemData
            var binRemoveKeys = [];
            binRemoveKeys.push(bin_field_start, bin_field_mid, bin_field_end);
            removeFields(itemData, binRemoveKeys);
        }
    });
    return itemData;
}
/**
* Drop fields for line and area marks.
*
* Lines and areas are defined by a series of datum. We overlay point marks
* on top of lines and areas to allow tooltip to show all data in the series.
* For the line marks and area marks underneath, we only show nominal fields
* in tooltip. This is because line / area marks only give us the last datum
* in their series. It only make sense to show the nominal fields (e.g., symbol
* = APPL, AMZN, GOOG, IBM, MSFT) because these fields don't tend to change along
* the line / area border.
*/
function dropFieldsForLineArea(marktype, itemData) {
    if (marktype === "line" || marktype === "area") {
        var quanKeys = [];
        itemData.each(function (field, value) {
            switch (dl.type(value)) {
                case "number":
                case "date":
                    quanKeys.push(field);
                    break;
                case "boolean":
                case "string":
            }
        });
        removeFields(itemData, quanKeys);
    }
}
/**
* Format value using formatType and format
* @param value - a field value to be formatted
* @param formatType - the foramtType can be: "time", "number", or "string"
* @param format - a d3 time format specifier, or a d3 number format specifier, or undefined
* @return the formatted value, or undefined if value or formatType is missing
*/
function customFormat(value, formatType, format) {
    if (value === undefined || value === null)
        return;
    if (!formatType)
        return;
    switch (formatType) {
        case "time":
            return format ? dl.format.time(format)(value) : dl.format.auto.time()(value);
        case "number":
            return format ? dl.format.number(format)(value) : dl.format.auto.number()(value);
        case "string":
        default:
            return value;
    }
}
/**
* Automatically format a time, number or string value
* @return the formatted time, number or string value
*/
function autoFormat(value) {
    switch (dl.type(value)) {
        case "date":
            return dl.format.auto.time()(value);
        case "number":
            return dl.format.auto.number()(value);
        case "boolean":
        case "string":
        default:
            return value;
    }
}
/**
* Get the tooltip HTML placeholder by id selector "#vis-tooltip"
* If none exists, create a placeholder.
* @returns the HTML placeholder for tooltip
*/
function getTooltipPlaceholder() {
    var tooltipPlaceholder;
    if (d3_selection_1.select("#vis-tooltip").empty()) {
        tooltipPlaceholder = d3_selection_1.select("body").append("div")
            .attr("id", "vis-tooltip")
            .attr("class", "vg-tooltip");
    }
    else {
        tooltipPlaceholder = d3_selection_1.select("#vis-tooltip");
    }
    return tooltipPlaceholder;
}
/**
* Bind tooltipData to the tooltip placeholder
*/
function bindData(tooltipPlaceholder, tooltipData) {
    tooltipPlaceholder.selectAll("table").remove();
    var tooltipRows = tooltipPlaceholder.append("table").selectAll(".tooltip-row")
        .data(tooltipData);
    tooltipRows.exit().remove();
    var row = tooltipRows.enter().append("tr")
        .attr("class", "tooltip-row");
    row.append("td").attr("class", "key").text(function (d) { return d.title + ":"; });
    row.append("td").attr("class", "value").text(function (d) { return d.value; });
}
/**
* Clear tooltip data
*/
function clearData() {
    d3_selection_1.select("#vis-tooltip").selectAll(".tooltip-row").data([])
        .exit().remove();
}
/**
* Update tooltip position
* Default position is 10px right of and 10px below the cursor. This can be
* overwritten by options.offset
*/
function updatePosition(event, options) {
    // determine x and y offsets, defaults are 10px
    var offsetX = 10;
    var offsetY = 10;
    if (options && options.offset && (options.offset.x !== undefined) && (options.offset.x !== null)) {
        offsetX = options.offset.x;
    }
    if (options && options.offset && (options.offset.y !== undefined) && (options.offset.y !== null)) {
        offsetY = options.offset.y;
    }
    //TODO: use the correct d3 type
    d3_selection_1.select("#vis-tooltip")
        .style("top", function () {
        // by default: put tooltip 10px below cursor
        // if tooltip is close to the bottom of the window, put tooltip 10px above cursor
        var tooltipHeight = this.getBoundingClientRect().height;
        if (event.clientY + tooltipHeight + offsetY < window.innerHeight) {
            return "" + (event.clientY + offsetY) + "px";
        }
        else {
            return "" + (event.clientY - tooltipHeight - offsetY) + "px";
        }
    })
        .style("left", function () {
        // by default: put tooltip 10px to the right of cursor
        // if tooltip is close to the right edge of the window, put tooltip 10 px to the left of cursor
        var tooltipWidth = this.getBoundingClientRect().width;
        if (event.clientX + tooltipWidth + offsetX < window.innerWidth) {
            return "" + (event.clientX + offsetX) + "px";
        }
        else {
            return "" + (event.clientX - tooltipWidth - offsetX) + "px";
        }
    });
}
/* Clear tooltip position */
function clearPosition() {
    d3_selection_1.select("#vis-tooltip")
        .style("top", "-9999px")
        .style("left", "-9999px");
}
/**
* Update tooltip color theme according to options.colorTheme
*
* If colorTheme === "dark", apply dark theme to tooltip.
* Otherwise apply light color theme.
*/
function updateColorTheme(options) {
    clearColorTheme();
    if (options && options.colorTheme === "dark") {
        d3_selection_1.select("#vis-tooltip").classed("dark-theme", true);
    }
    else {
        d3_selection_1.select("#vis-tooltip").classed("light-theme", true);
    }
}
/* Clear color themes */
function clearColorTheme() {
    d3_selection_1.select("#vis-tooltip").classed("dark-theme light-theme", false);
}

},{"d3-collection":2,"d3-selection":3,"datalib":28,"vega-lite/build/src/type":123,"vega-lite/build/src/vl":127}]},{},[129])(129)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vYnVpbGQvZDMtY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kMy1zZWxlY3Rpb24vYnVpbGQvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvbm9kZV9tb2R1bGVzL2QzLWRzdi9idWlsZC9kMy1kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L2J1aWxkL2QzLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9idWlsZC9kMy10aW1lLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL25vZGVfbW9kdWxlcy9kMy10aW1lL2J1aWxkL2QzLXRpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWNjZXNzb3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2FnZ3JlZ2F0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2NvbGxlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9hZ2dyZWdhdGUvZ3JvdXBieS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9hZ2dyZWdhdGUvbWVhc3VyZXMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYmlucy9iaW5zLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvaGlzdG9ncmFtLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2Zvcm1hdC10YWJsZXMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2dlbmVyYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2Rzdi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL3RvcG9qc29uLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL3RyZWVqc29uLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9yZWFkLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9yZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RlbXBsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RpbWUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJub2RlX21vZHVsZXMvdG9wb2pzb24vYnVpbGQvdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1ldmVudC1zZWxlY3Rvci9idWlsZC92ZWdhLWV2ZW50LXNlbGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9wYWNrYWdlLmpzb24iLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9hZ2dyZWdhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9heGlzLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvYmluLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvYXhpcy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2F4aXMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2F4aXMvcnVsZXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvY29tcGlsZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9hZ2dyZWdhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvYXNzZW1ibGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvYmluLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2RhdGFmbG93LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2ZhY2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL2Zvcm1hdHBhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL25vbnBvc2l0aXZlZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL251bGxmaWx0ZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvb3B0aW1pemVycy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvZGF0YS9wYXRob3JkZXIuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2RhdGEvc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3RpbWV1bml0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9kYXRhL3RyYW5zZm9ybXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2ZhY2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sYXllci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbGF5b3V0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sZWdlbmQvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9sZWdlbmQvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL2xlZ2VuZC9ydWxlcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9hcmVhLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL2Jhci5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9pbml0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL2xpbmUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9taXhpbnMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvcG9pbnQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvcmVjdC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay9ydWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9tYXJrL3RleHQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL21hcmsvdGljay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbWFyay92YWx1ZXJlZi5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvbW9kZWwuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL2Fzc2VtYmxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zY2FsZS9kb21haW4uanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL2luaXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zY2FsZS9yYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2NhbGUvcnVsZXMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NjYWxlL3R5cGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi9pbnRlcnZhbC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL211bHRpLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vc2luZ2xlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vdHJhbnNmb3Jtcy9pbnB1dHMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL25lYXJlc3QuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL3Byb2plY3QuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL3NjYWxlcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3RyYW5zZm9ybXMvdG9nZ2xlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vdHJhbnNmb3Jtcy90cmFuc2Zvcm1zLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29tcGlsZS9zZWxlY3Rpb24vdHJhbnNmb3Jtcy90cmFuc2xhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3NlbGVjdGlvbi90cmFuc2Zvcm1zL3pvb20uanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21waWxlL3VuaXQuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9jb21wb3NpdGVtYXJrLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvY29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2RhdGV0aW1lLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZW5jb2RpbmcuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9mYWNldC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL2ZpZWxkZGVmLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbGVnZW5kLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbG9nLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvbWFyay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvc29ydC5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3NwZWMuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy9zdGFjay5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3RpbWV1bml0LmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdG9wbGV2ZWxwcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3R5cGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdmVnYS1saXRlL2J1aWxkL3NyYy92ZWdhLnNjaGVtYS5qcyIsIm5vZGVfbW9kdWxlcy92ZWdhLWxpdGUvYnVpbGQvc3JjL3ZsLmpzIiwibm9kZV9tb2R1bGVzL3ZlZ2EtdXRpbC9idWlsZC92ZWdhLXV0aWwuanMiLCJzcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzllQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNodEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6YUEsK0NBQWdEO0FBQ2hELDZDQUE2RDtBQUM3RCw0QkFBOEI7QUFHOUIsaURBQWtEO0FBQ2xELDJDQUE2QztBQUU3QywrQ0FBK0M7QUFDL0MsSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDO0FBQ2hCLElBQUksY0FBYyxHQUFXLFNBQVMsQ0FBQztBQUN2QyxJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFjMUI7Ozs7RUFJRTtBQUNGLGNBQXFCLE1BQWMsRUFBRSxPQUFvQjtJQUN2RCw0Q0FBNEM7SUFEVCx3QkFBQSxFQUFBLFlBQW9CO0lBR3ZELDhEQUE4RDtJQUM5RCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsdUJBQXVCLEVBQUUsVUFBVSxLQUFpQixFQUFFLElBQWdCO1FBQzVGLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1Qiw2RUFBNkU7WUFDN0UsYUFBYSxFQUFFLENBQUM7WUFFaEIsY0FBYyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILHdDQUF3QztJQUN4Qyx3Q0FBd0M7SUFDeEMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLHlCQUF5QixFQUFFLFVBQVUsS0FBaUIsRUFBRSxJQUFnQjtRQUM5RixFQUFFLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQzdDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQy9CLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILDZCQUE2QjtJQUM3QixNQUFNLENBQUMsZ0JBQWdCLENBQUMsd0JBQXdCLEVBQUUsVUFBVSxLQUFpQixFQUFFLElBQWdCO1FBQzdGLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixhQUFhLEVBQUUsQ0FBQztZQUVoQixFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2dCQUNsQixLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztZQUM5QixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDO1FBQ0wsT0FBTyxFQUFFO1lBQ1AseUJBQXlCO1lBQ3pCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ3BELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1lBQ3RELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO1lBRXJELGFBQWEsRUFBRSxDQUFDLENBQUMsd0JBQXdCO1FBQzNDLENBQUM7S0FDRixDQUFBO0FBQ0gsQ0FBQztBQTVDRCxvQkE0Q0M7QUFBQSxDQUFDO0FBRUY7Ozs7O0VBS0U7QUFDRixrQkFBeUIsTUFBYyxFQUFFLE1BQTRCLEVBQUUsT0FBb0I7SUFBcEIsd0JBQUEsRUFBQSxZQUFvQjtJQUV6RixPQUFPLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTdDLGdFQUFnRTtJQUNoRSw4REFBOEQ7SUFDOUQsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxVQUFVLEtBQWlCLEVBQUUsSUFBZ0I7UUFDaEYsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLDZFQUE2RTtZQUM3RSxhQUFhLEVBQUUsQ0FBQztZQUVoQixpREFBaUQ7WUFDakQsY0FBYyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDO1FBQzdCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILHdDQUF3QztJQUN4Qyx3Q0FBd0M7SUFDeEMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxVQUFVLEtBQWlCLEVBQUUsSUFBZ0I7UUFDaEYsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQztZQUM3QyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMvQixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCw2QkFBNkI7SUFDN0IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxVQUFVLEtBQWlCLEVBQUUsSUFBZ0I7UUFDL0UsRUFBRSxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLGFBQWEsRUFBRSxDQUFDO1lBRWhCLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xCLEtBQUssQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQzlCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUM7UUFDTCxPQUFPLEVBQUU7WUFDUCx5QkFBeUI7WUFDekIsTUFBTSxDQUFDLG1CQUFtQixDQUFDLHVCQUF1QixDQUFDLENBQUM7WUFDcEQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDdEQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLHdCQUF3QixDQUFDLENBQUM7WUFFckQsYUFBYSxFQUFFLENBQUMsQ0FBQyx3QkFBd0I7UUFDM0MsQ0FBQztLQUNGLENBQUE7QUFDSCxDQUFDO0FBL0NELDRCQStDQztBQUFBLENBQUM7QUFFRiw0QkFBNEI7QUFDNUI7SUFDRTs7eUNBRXFDO0lBQ3JDLE1BQU0sQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDcEMsY0FBYyxHQUFHLFNBQVMsQ0FBQztBQUM3QixDQUFDO0FBRUQsZ0RBQWdEO0FBQ2hELElBQUksYUFBYSxHQUF3QztJQUN2RCxjQUFjLEVBQUUsUUFBUTtJQUN4QixVQUFVLEVBQUUsTUFBTTtJQUNsQixTQUFTLEVBQUUsU0FBUztJQUNwQixTQUFTLEVBQUUsU0FBUztDQUNyQixDQUFBO0FBRUQ7Ozs7Ozs7Ozs7O0VBV0U7QUFDRiwyQkFBMkIsT0FBZSxFQUFFLE1BQTRCO0lBQ3RFLHNDQUFzQztJQUN0QyxJQUFJLGtCQUFrQixHQUFrQixFQUFFLENBQUM7SUFFM0MseUVBQXlFO0lBQ3pFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLEtBQUssS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNwQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxRQUFRO1lBQ2xELHlEQUF5RDtZQUN6RCxJQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztZQUUzRCxzREFBc0Q7WUFDdEQsSUFBSSx1QkFBdUIsR0FBRyxxQkFBcUIsQ0FBQyxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRW5GLGtCQUFrQixDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ25ELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELElBQUksQ0FBQyxDQUFDO1FBQ0osRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDbkIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxXQUFXO2dCQUMxQywwREFBMEQ7Z0JBQzFELElBQUksUUFBUSxHQUFHLFdBQVcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQztnQkFFbkUsc0RBQXNEO2dCQUN0RCxJQUFJLHVCQUF1QixHQUFHLHFCQUFxQixDQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7Z0JBRW5GLGtCQUFrQixDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ25ELENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRCxPQUFPLENBQUMsTUFBTSxHQUFHLGtCQUFrQixDQUFDO0lBRXBDLE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUVEOzs7Ozs7Ozs7O0VBVUU7QUFDRix3QkFBd0IsWUFBMkIsRUFBRSxRQUFrQjtJQUNyRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsSUFBSSxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQztRQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFFN0UseURBQXlEO0lBQ3pELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLDRFQUE0RTtRQUM1RSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM3QyxJQUFJLFdBQVcsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssS0FBSyxRQUFRLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxTQUFTLEtBQUssUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3pGLE1BQU0sQ0FBQyxXQUFXLENBQUM7WUFDckIsQ0FBQztRQUNILENBQUM7UUFFRCxzRkFBc0Y7UUFDdEYsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0MsSUFBSSxXQUFXLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNuRSxNQUFNLENBQUMsV0FBVyxDQUFDO1lBQ3JCLENBQUM7UUFDSCxDQUFDO1FBRUQseUNBQXlDO1FBQ3pDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELElBQUksQ0FBQyxDQUFDO1FBQ0osR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDN0MsSUFBSSxXQUFXLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxLQUFLLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ3pDLE1BQU0sQ0FBQyxXQUFXLENBQUM7WUFDckIsQ0FBQztRQUNILENBQUM7UUFFRCx5Q0FBeUM7UUFDekMsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQixDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7Ozs7RUFTRTtBQUNGLHFCQUFxQixTQUFxQixFQUFFLFdBQXdCO0lBQ2xFLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDckQsTUFBTSxDQUFDLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRUQsMkRBQTJEO0lBQzNELEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzFDLElBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM1QixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxLQUFLLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUN2QixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxLQUFLLFdBQVcsQ0FBQyxTQUFTLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztvQkFDM0UsTUFBTSxDQUFDLFFBQVEsQ0FBQztnQkFDbEIsQ0FBQztZQUNILENBQUM7WUFDRCxJQUFJLENBQUMsQ0FBQztnQkFDSixNQUFNLENBQUMsUUFBUSxDQUFDO1lBQ2xCLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztJQUVELHlDQUF5QztJQUN6QyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFFRDs7Ozs7O0VBTUU7QUFDRiwrQkFBK0IsV0FBd0IsRUFBRSxRQUFrQixFQUFFLE1BQTRCO0lBQ3ZHLCtCQUErQjtJQUMvQixJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRS9DLHdEQUF3RDtJQUN4RCxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDOUIsT0FBTyxDQUFDLEtBQUssQ0FBQyw2RUFBNkUsQ0FBQyxDQUFDO1FBQzdGLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVELGtGQUFrRjtJQUNsRixFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsSUFBSSxRQUFRLENBQUM7UUFBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQy9DLEVBQUUsQ0FBQyxDQUFDLFdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFFNUMsZ0NBQWdDO0lBQ2hDLElBQUksdUJBQXVCLEdBQTRCLEVBQUUsQ0FBQztJQUUxRCxpRkFBaUY7SUFDakYsc0NBQXNDO0lBQ3RDLHFEQUFxRDtJQUNyRCx1REFBdUQ7SUFDdkQsMEdBQTBHO0lBQzFHLHVCQUF1QixDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSztRQUM1QyxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBRWxELHVGQUF1RjtJQUN2Rix1RkFBdUY7SUFDdkYsOEZBQThGO0lBQzlGLGdCQUFnQjtJQUNoQiw4RkFBOEY7SUFDOUYsd0RBQXdEO0lBQ3hELGtFQUFrRTtJQUNsRSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLGVBQVEsSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNwRCw2REFBNkQ7UUFDN0QsSUFBSSxxQkFBcUIsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDO1FBQzNDLHVCQUF1QixDQUFDLDJCQUEyQixHQUFHLHFCQUFxQixDQUFDO1FBRTVFLHFGQUFxRjtRQUNyRixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMxQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUMxQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxLQUFLLHFCQUFxQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7Z0JBQzNFLHVCQUF1QixDQUFDLDJCQUEyQixHQUFHLFNBQVMsQ0FBQztnQkFDaEUsS0FBSyxDQUFDO1lBQ1IsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQztRQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsNEJBQTRCO0lBQzVHLHVCQUF1QixDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSztRQUMvQyxXQUFXLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUUxRCx3QkFBd0I7SUFDeEIsdUJBQXVCLENBQUMsVUFBVSxHQUFHLFdBQVcsQ0FBQyxVQUFVO1FBQ3pELFdBQVcsQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV4RCxvQkFBb0I7SUFDcEIsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdkIsdUJBQXVCLENBQUMsTUFBTSxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7SUFDdEQsQ0FBQztJQUVELElBQUksQ0FBQyxDQUFDO1FBQ0osTUFBTSxDQUFDLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMzQyxLQUFLLE1BQU07Z0JBQ1QsdUJBQXVCLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRO29CQUNoRCxrRkFBa0Y7b0JBQ2xGLEVBQUUsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztzQkFDdEUsTUFBTSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7Z0JBQzVELEtBQUssQ0FBQztZQUNSLEtBQUssUUFBUTtnQkFDWCx1QkFBdUIsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQztnQkFDckQsS0FBSyxDQUFDO1lBQ1IsS0FBSyxRQUFRLENBQUM7WUFDZCxRQUFRO1FBQ1YsQ0FBQztJQUNILENBQUM7SUFFRCxpRkFBaUY7SUFDakYsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDakIsdUJBQXVCLENBQUMsS0FBSyxHQUFHLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsaUJBQWlCO1FBQzVHLHVCQUF1QixDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7UUFDbkMsdUJBQXVCLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxDQUFDLDRDQUE0QztJQUM3RixDQUFDO0lBRUQsTUFBTSxDQUFDLHVCQUF1QixDQUFDO0FBQ2pDLENBQUM7QUFHRCxrQ0FBa0M7QUFDbEMsY0FBYyxLQUFpQixFQUFFLElBQWdCLEVBQUUsT0FBZTtJQUNoRSwrQkFBK0I7SUFDL0IsSUFBSSxrQkFBa0IsR0FBRyxxQkFBcUIsRUFBRSxDQUFDO0lBRWpELDJCQUEyQjtJQUMzQixJQUFJLFdBQVcsR0FBRyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1FBQUMsTUFBTSxDQUFDO0lBRXJELHdDQUF3QztJQUN4QyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFMUMsY0FBYyxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMvQixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdEQsYUFBYSxHQUFHLElBQUksQ0FBQztJQUVyQixnQ0FBZ0M7SUFDaEMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDckIsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztBQUNILENBQUM7QUFFRCwwQ0FBMEM7QUFDMUMsZ0JBQWdCLEtBQWlCLEVBQUUsSUFBZ0IsRUFBRSxPQUFlO0lBQ2xFLGNBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFL0IsZ0NBQWdDO0lBQ2hDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ25CLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzlCLENBQUM7QUFDSCxDQUFDO0FBRUQsbUJBQW1CO0FBQ25CLGVBQWUsS0FBaUIsRUFBRSxJQUFnQixFQUFFLE9BQWU7SUFDakUsNENBQTRDO0lBQzVDLHdFQUF3RTtJQUN4RSxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFckQsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUN0QixTQUFTLEVBQUUsQ0FBQztJQUNaLGVBQWUsRUFBRSxDQUFDO0lBQ2xCLGFBQWEsRUFBRSxDQUFDO0lBRWhCLGdDQUFnQztJQUNoQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUN4QixPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0FBQ0gsQ0FBQztBQUdELGtEQUFrRDtBQUNsRCwyQkFBMkIsSUFBZ0I7SUFDekMsbUJBQW1CO0lBQ25CLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFFdkMsbUVBQW1FO0lBQ25FLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1FBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUV0QyxrREFBa0Q7SUFDbEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7SUFFbEMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNkLENBQUM7QUFFRDs7O0VBR0U7QUFDRixxQkFBcUI7QUFDckIsd0JBQXdCLElBQWdCLEVBQUUsT0FBZTtJQUN2RCxpREFBaUQ7SUFDakQsSUFBSSxXQUEwQixDQUFDO0lBRS9CLElBQUksUUFBUSxHQUFnQixtQkFBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU5QyxzRUFBc0U7SUFDdEUsSUFBSSxVQUFVLEdBQUc7UUFDZixLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRO1FBQ2pDLGFBQWEsRUFBRSxXQUFXO1FBQzFCLGNBQWMsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxVQUFVLEVBQUUsVUFBVTtLQUNsRixDQUFDO0lBQ0YsWUFBWSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUVuQyx3Q0FBd0M7SUFDeEMseUJBQXlCLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUVwRCw0REFBNEQ7SUFDNUQsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUUzQyx1RkFBdUY7SUFDdkYscUJBQXFCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFFcEQsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsS0FBSyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ3BDLFdBQVcsR0FBRyxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDO1FBQ0osV0FBVyxHQUFHLHVCQUF1QixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUNyQixDQUFDO0FBR0Q7Ozs7Ozs7RUFPRTtBQUNGLGlDQUFpQyxRQUFxQixFQUFFLE9BQWU7SUFDckUsSUFBSSxXQUFXLEdBQWtCLEVBQUUsQ0FBQztJQUVwQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLFdBQVc7UUFDMUMsc0JBQXNCO1FBQ3RCLElBQUksS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBRXRFLHdCQUF3QjtRQUN4QixJQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsRCxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDO1lBQUMsTUFBTSxDQUFDO1FBRWhDLGVBQWU7UUFDZixJQUFJLGNBQWMsR0FBRyxZQUFZLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxRyxvQ0FBb0M7UUFDcEMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7SUFFNUQsQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLENBQUMsV0FBVyxDQUFDO0FBQ3JCLENBQUM7QUFFRDs7Ozs7O0VBTUU7QUFDRixnRkFBZ0Y7QUFDaEYsa0JBQWtCLFFBQXFCLEVBQUUsS0FBYTtJQUNwRCxJQUFJLEtBQWEsQ0FBQztJQUVsQixJQUFJLFNBQVMsR0FBYSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTNDLHNEQUFzRDtJQUN0RCxJQUFJLGFBQWEsR0FBVyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBRWxCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2hDLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRXBDLHdEQUF3RDtRQUN4RCxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztZQUMzQixFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNiLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkIsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsOEJBQThCLEdBQUcsS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1FBQ25FLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDO1FBQ0osTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNmLENBQUM7QUFDSCxDQUFDO0FBR0Q7Ozs7Ozs7Ozs7O0VBV0U7QUFDRiw4QkFBOEIsUUFBcUIsRUFBRSxPQUFlO0lBQ2xFLElBQUksV0FBVyxHQUFrQixFQUFFLENBQUM7SUFFcEMsMkNBQTJDO0lBQzNDLElBQUksWUFBWSxHQUFHLG1CQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTNFLFFBQVEsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFhLEVBQUUsS0FBYTtRQUNsRCxnQkFBZ0I7UUFDaEIsSUFBSSxLQUFLLENBQUM7UUFDVixFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM3RCxLQUFLLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDeEMsQ0FBQztRQUNELElBQUksQ0FBQyxDQUFDO1lBQ0osS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNoQixDQUFDO1FBRUQsZUFBZTtRQUNmLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLElBQUksVUFBVSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsVUFBVSxDQUFDO1lBQ3BELElBQUksTUFBTSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQzlDLENBQUM7UUFDRCxJQUFJLGNBQWMsR0FBRyxZQUFZLENBQUMsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbEYsb0NBQW9DO1FBQ3BDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQzVELENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUNyQixDQUFDO0FBRUQ7Ozs7Ozs7RUFPRTtBQUNGLHNCQUFzQixPQUFvQixFQUFFLFVBQW9CO0lBQzlELFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHO1FBQzlCLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdEIsQ0FBQyxDQUFDLENBQUE7QUFDSixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILG1DQUFtQyxRQUFxQixFQUFFLFNBQW9DO0lBQzVGLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQUMsTUFBTSxDQUFDO0lBRXZCLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBVSxRQUFRO1FBQ2xDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUM7WUFDekMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUM7UUFDakUsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7O0VBT0U7QUFDRiwwQkFBMEIsUUFBcUIsRUFBRSxZQUEyQjtJQUMxRSxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztRQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFFcEMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFVLFdBQVc7UUFDeEMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRTdCLHlCQUF5QjtZQUN6QixJQUFJLGVBQWUsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO1lBQ3hDLElBQUksZUFBZSxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ2xFLElBQUksYUFBYSxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQzlELElBQUksYUFBYSxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRTlELGlEQUFpRDtZQUNqRCw2Q0FBNkM7WUFDN0MsSUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUMvQyxJQUFJLFFBQVEsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzNDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDM0QsSUFBSSxLQUFLLEdBQUcsVUFBVSxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUM7Z0JBQ3hDLFFBQVEsQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQ3ZDLENBQUM7WUFFRCx5RUFBeUU7WUFDekUsSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO1lBQ3ZCLGFBQWEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUNsRSxZQUFZLENBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sQ0FBQyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQUVEOzs7Ozs7Ozs7O0VBVUU7QUFDRiwrQkFBK0IsUUFBZ0IsRUFBRSxRQUFxQjtJQUNwRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEtBQUssTUFBTSxJQUFJLFFBQVEsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQy9DLElBQUksUUFBUSxHQUFhLEVBQUUsQ0FBQztRQUM1QixRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsS0FBSyxFQUFFLEtBQUs7WUFDbEMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZCLEtBQUssUUFBUSxDQUFDO2dCQUNkLEtBQUssTUFBTTtvQkFDVCxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUNyQixLQUFLLENBQUM7Z0JBQ1IsS0FBSyxTQUFTLENBQUM7Z0JBQ2YsS0FBSyxRQUFRLENBQUM7WUFDaEIsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsWUFBWSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNuQyxDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7RUFNRTtBQUNGLHNCQUFzQixLQUFhLEVBQUUsVUFBa0IsRUFBRSxNQUFjO0lBQ3JFLEVBQUUsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQztRQUFDLE1BQU0sQ0FBQztJQUNsRCxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUFDLE1BQU0sQ0FBQztJQUV4QixNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ25CLEtBQUssTUFBTTtZQUNULE1BQU0sQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDL0UsS0FBSyxRQUFRO1lBQ1gsTUFBTSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuRixLQUFLLFFBQVEsQ0FBQztRQUNkO1lBQ0UsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNqQixDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7RUFHRTtBQUNGLG9CQUFvQixLQUFhO0lBQy9CLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLEtBQUssTUFBTTtZQUNULE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0QyxLQUFLLFFBQVE7WUFDWCxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEMsS0FBSyxTQUFTLENBQUM7UUFDZixLQUFLLFFBQVEsQ0FBQztRQUNkO1lBQ0UsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUNqQixDQUFDO0FBQ0gsQ0FBQztBQUdEOzs7O0VBSUU7QUFDRjtJQUNFLElBQUksa0JBQWtCLENBQUM7SUFFdkIsRUFBRSxDQUFDLENBQUMscUJBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkMsa0JBQWtCLEdBQUcscUJBQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO2FBQzlDLElBQUksQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDO2FBQ3pCLElBQUksQ0FBQyxPQUFPLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDO1FBQ0osa0JBQWtCLEdBQUcscUJBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQsTUFBTSxDQUFDLGtCQUFrQixDQUFDO0FBQzVCLENBQUM7QUFFRDs7RUFFRTtBQUNGLGtCQUFrQixrQkFBK0YsRUFBRSxXQUEwQjtJQUMzSSxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDL0MsSUFBSSxXQUFXLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7U0FDM0UsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBRXJCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUU1QixJQUFJLEdBQUcsR0FBRyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztTQUN2QyxJQUFJLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQ2hDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFjLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQWMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlGLENBQUM7QUFFRDs7RUFFRTtBQUNGO0lBQ0UscUJBQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztTQUN0RCxJQUFJLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNyQixDQUFDO0FBRUQ7Ozs7RUFJRTtBQUNGLHdCQUF3QixLQUFpQixFQUFFLE9BQWU7SUFDeEQsK0NBQStDO0lBQy9DLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUNqQixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7SUFDakIsRUFBRSxDQUFDLENBQUMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRyxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUNELEVBQUUsQ0FBQyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakcsT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCwrQkFBK0I7SUFDL0IscUJBQU0sQ0FBQyxjQUFjLENBQUM7U0FDbkIsS0FBSyxDQUFDLEtBQUssRUFBRTtRQUNaLDRDQUE0QztRQUM1QyxpRkFBaUY7UUFDakYsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsTUFBTSxDQUFDO1FBQ3hELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsYUFBYSxHQUFHLE9BQU8sR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUNqRSxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDL0MsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMvRCxDQUFDO0lBQ0gsQ0FBQyxDQUFDO1NBQ0QsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUNiLHNEQUFzRDtRQUN0RCwrRkFBK0Y7UUFDL0YsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxDQUFDO1FBQ3RELEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsWUFBWSxHQUFHLE9BQU8sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUMvRCxNQUFNLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDL0MsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sTUFBTSxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM5RCxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQsNEJBQTRCO0FBQzVCO0lBQ0UscUJBQU0sQ0FBQyxjQUFjLENBQUM7U0FDbkIsS0FBSyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUM7U0FDdkIsS0FBSyxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQztBQUM5QixDQUFDO0FBRUQ7Ozs7O0VBS0U7QUFDRiwwQkFBMEIsT0FBZTtJQUN2QyxlQUFlLEVBQUUsQ0FBQztJQUVsQixFQUFFLENBQUMsQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLFVBQVUsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQzdDLHFCQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBQ0QsSUFBSSxDQUFDLENBQUM7UUFDSixxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEQsQ0FBQztBQUNILENBQUM7QUFFRCx3QkFBd0I7QUFDeEI7SUFDRSxxQkFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyx3QkFBd0IsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNsRSxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sbGVjdGlvbi8gVmVyc2lvbiAxLjAuMy4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWFwLFxuICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXA7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcblxuICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG52YXIgbmVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgc29ydEtleXMgPSBbXSxcbiAgICAgIHNvcnRWYWx1ZXMsXG4gICAgICByb2xsdXAsXG4gICAgICBuZXN0O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcbiAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiByb2xsdXAgIT0gbnVsbFxuICAgICAgICA/IHJvbGx1cChhcnJheSkgOiAoc29ydFZhbHVlcyAhPSBudWxsXG4gICAgICAgID8gYXJyYXkuc29ydChzb3J0VmFsdWVzKVxuICAgICAgICA6IGFycmF5KTtcblxuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAoKSxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAkJDEsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcCQkMTtcbiAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAkJDEuZW50cmllcygpO1xuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwJCQxLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XG4gICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3QgPSB7XG4gICAgb2JqZWN0OiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgIGtleTogZnVuY3Rpb24oZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgcm9sbHVwOiBmdW5jdGlvbihmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gc2V0T2JqZWN0KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gIHJldHVybiBtYXAoKTtcbn1cblxuZnVuY3Rpb24gc2V0TWFwKG1hcCQkMSwga2V5LCB2YWx1ZSkge1xuICBtYXAkJDEuc2V0KGtleSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBTZXQoKSB7fVxuXG52YXIgcHJvdG8gPSBtYXAucHJvdG90eXBlO1xuXG5TZXQucHJvdG90eXBlID0gc2V0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNldCxcbiAgaGFzOiBwcm90by5oYXMsXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSArPSBcIlwiO1xuICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICBlYWNoOiBwcm90by5lYWNoXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBmKSB7XG4gIHZhciBzZXQgPSBuZXcgU2V0O1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlKSB7IHNldC5hZGQodmFsdWUpOyB9KTtcblxuICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdOKAmXMgYW4gYXJyYXkuXG4gIGVsc2UgaWYgKG9iamVjdCkge1xuICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoO1xuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChmKG9iamVjdFtpXSwgaSwgb2JqZWN0KSk7XG4gIH1cblxuICByZXR1cm4gc2V0O1xufVxuXG52YXIga2V5cyA9IGZ1bmN0aW9uKG1hcCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgdmFsdWVzID0gZnVuY3Rpb24obWFwKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICByZXR1cm4gdmFsdWVzO1xufTtcblxudmFyIGVudHJpZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IG1hcFtrZXldfSk7XG4gIHJldHVybiBlbnRyaWVzO1xufTtcblxuZXhwb3J0cy5uZXN0ID0gbmVzdDtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5tYXAgPSBtYXA7XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5leHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zZWxlY3Rpb24vIFZlcnNpb24gMS4wLjUuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbnZhciBuYW1lc3BhY2VzID0ge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcblxudmFyIG5hbWVzcGFjZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbnZhciBjcmVhdG9yID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59O1xuXG52YXIgbmV4dElkID0gMDtcblxuZnVuY3Rpb24gbG9jYWwoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgZ2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fO1xuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlW3RoaXMuX10gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuXyBpbiBub2RlICYmIGRlbGV0ZSBub2RlW3RoaXMuX107XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG52YXIgbWF0Y2hlciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudC5tYXRjaGVzKSB7XG4gICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcbiAgICBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZlbmRvck1hdGNoZXMuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1hdGNoZXIkMSA9IG1hdGNoZXI7XG5cbnZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuZXhwb3J0cy5ldmVudCA9IG51bGw7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQkMSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50JDEpKSB7XG4gICAgZmlsdGVyRXZlbnRzID0ge21vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIn07XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyQ29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgbGlzdGVuZXIgPSBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCk7XG4gIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMpICYgOCkpKSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihldmVudDEpIHtcbiAgICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDsgLy8gRXZlbnRzIGNhbiBiZSByZWVudHJhbnQgKGUuZy4sIGZvY3VzKS5cbiAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQxO1xuICAgIHRyeSB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHRoaXMuX19kYXRhX18sIGluZGV4LCBncm91cCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMpIHtcbiAgcmV0dXJuIHR5cGVuYW1lcy50cmltKCkuc3BsaXQoL158XFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XG4gICAgdmFyIG5hbWUgPSBcIlwiLCBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSBuYW1lID0gdC5zbGljZShpICsgMSksIHQgPSB0LnNsaWNlKDAsIGkpO1xuICAgIHJldHVybiB7dHlwZTogdCwgbmFtZTogbmFtZX07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblJlbW92ZSh0eXBlbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uO1xuICAgIGlmICghb24pIHJldHVybjtcbiAgICBmb3IgKHZhciBqID0gMCwgaSA9IC0xLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAobyA9IG9uW2pdLCAoIXR5cGVuYW1lLnR5cGUgfHwgby50eXBlID09PSB0eXBlbmFtZS50eXBlKSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uWysraV0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKytpKSBvbi5sZW5ndGggPSBpO1xuICAgIGVsc2UgZGVsZXRlIHRoaXMuX19vbjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25BZGQodHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB3cmFwID0gZmlsdGVyRXZlbnRzLmhhc093blByb3BlcnR5KHR5cGVuYW1lLnR5cGUpID8gZmlsdGVyQ29udGV4dExpc3RlbmVyIDogY29udGV4dExpc3RlbmVyO1xuICByZXR1cm4gZnVuY3Rpb24oZCwgaSwgZ3JvdXApIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb24sIG8sIGxpc3RlbmVyID0gd3JhcCh2YWx1ZSwgaSwgZ3JvdXApO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgobyA9IG9uW2pdKS50eXBlID09PSB0eXBlbmFtZS50eXBlICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyID0gbGlzdGVuZXIsIG8uY2FwdHVyZSA9IGNhcHR1cmUpO1xuICAgICAgICBvLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGVuYW1lLnR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICBvID0ge3R5cGU6IHR5cGVuYW1lLnR5cGUsIG5hbWU6IHR5cGVuYW1lLm5hbWUsIHZhbHVlOiB2YWx1ZSwgbGlzdGVuZXI6IGxpc3RlbmVyLCBjYXB0dXJlOiBjYXB0dXJlfTtcbiAgICBpZiAoIW9uKSB0aGlzLl9fb24gPSBbb107XG4gICAgZWxzZSBvbi5wdXNoKG8pO1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX29uID0gZnVuY3Rpb24odHlwZW5hbWUsIHZhbHVlLCBjYXB0dXJlKSB7XG4gIHZhciB0eXBlbmFtZXMgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDtcbiAgZXZlbnQxLnNvdXJjZUV2ZW50ID0gZXhwb3J0cy5ldmVudDtcbiAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgfVxufVxuXG52YXIgc291cmNlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBleHBvcnRzLmV2ZW50LCBzb3VyY2U7XG4gIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xuICByZXR1cm4gY3VycmVudDtcbn07XG5cbnZhciBwb2ludCA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufTtcblxudmFyIG1vdXNlID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHJldHVybiBwb2ludChub2RlLCBldmVudCk7XG59O1xuXG5mdW5jdGlvbiBub25lKCkge31cblxudmFyIHNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgc2VsZWN0aW9uX3NlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxudmFyIHNlbGVjdG9yQWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufTtcblxudmFyIHNlbGVjdGlvbl9zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzdWJncm91cHMucHVzaChzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCBwYXJlbnRzKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZmlsdGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIkMShtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn07XG5cbnZhciBzcGFyc2UgPSBmdW5jdGlvbih1cGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSh1cGRhdGUubGVuZ3RoKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn07XG5cbmZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNlbGVjdGlvbl9kYXRhID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCh2YWx1ZSk7XG5cbiAgZm9yICh2YXIgbSA9IGdyb3Vwcy5sZW5ndGgsIHVwZGF0ZSA9IG5ldyBBcnJheShtKSwgZW50ZXIgPSBuZXcgQXJyYXkobSksIGV4aXQgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgdmFyIHBhcmVudCA9IHBhcmVudHNbal0sXG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2pdLFxuICAgICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgICAgZGF0YSA9IHZhbHVlLmNhbGwocGFyZW50LCBwYXJlbnQgJiYgcGFyZW50Ll9fZGF0YV9fLCBqLCBwYXJlbnRzKSxcbiAgICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBlbnRlckdyb3VwID0gZW50ZXJbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIHVwZGF0ZUdyb3VwID0gdXBkYXRlW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICBleGl0R3JvdXAgPSBleGl0W2pdID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKTtcblxuICAgIGJpbmQocGFyZW50LCBncm91cCwgZW50ZXJHcm91cCwgdXBkYXRlR3JvdXAsIGV4aXRHcm91cCwgZGF0YSwga2V5KTtcblxuICAgIC8vIE5vdyBjb25uZWN0IHRoZSBlbnRlciBub2RlcyB0byB0aGVpciBmb2xsb3dpbmcgdXBkYXRlIG5vZGUsIHN1Y2ggdGhhdFxuICAgIC8vIGFwcGVuZENoaWxkIGNhbiBpbnNlcnQgdGhlIG1hdGVyaWFsaXplZCBlbnRlciBub2RlIGJlZm9yZSB0aGlzIG5vZGUsXG4gICAgLy8gcmF0aGVyIHRoYW4gYXQgdGhlIGVuZCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDAsIHByZXZpb3VzLCBuZXh0OyBpMCA8IGRhdGFMZW5ndGg7ICsraTApIHtcbiAgICAgIGlmIChwcmV2aW91cyA9IGVudGVyR3JvdXBbaTBdKSB7XG4gICAgICAgIGlmIChpMCA+PSBpMSkgaTEgPSBpMCArIDE7XG4gICAgICAgIHdoaWxlICghKG5leHQgPSB1cGRhdGVHcm91cFtpMV0pICYmICsraTEgPCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgcHJldmlvdXMuX25leHQgPSBuZXh0IHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlID0gbmV3IFNlbGVjdGlvbih1cGRhdGUsIHBhcmVudHMpO1xuICB1cGRhdGUuX2VudGVyID0gZW50ZXI7XG4gIHVwZGF0ZS5fZXhpdCA9IGV4aXQ7XG4gIHJldHVybiB1cGRhdGU7XG59O1xuXG52YXIgc2VsZWN0aW9uX2V4aXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufTtcblxudmFyIHNlbGVjdGlvbl9tZXJnZSA9IGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fb3JkZXIgPSBmdW5jdGlvbigpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAtMSwgbSA9IGdyb3Vwcy5sZW5ndGg7ICsraiA8IG07KSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBub2RlLm5leHRTaWJsaW5nKSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBzZWxlY3Rpb25fc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgaWYgKCFjb21wYXJlKSBjb21wYXJlID0gYXNjZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlKGEsIGIpIHtcbiAgICByZXR1cm4gYSAmJiBiID8gY29tcGFyZShhLl9fZGF0YV9fLCBiLl9fZGF0YV9fKSA6ICFhIC0gIWI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzb3J0Z3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzb3J0Z3JvdXAgPSBzb3J0Z3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzb3J0Z3JvdXBbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3J0Z3JvdXAuc29ydChjb21wYXJlTm9kZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzb3J0Z3JvdXBzLCB0aGlzLl9wYXJlbnRzKS5vcmRlcigpO1xufTtcblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG52YXIgc2VsZWN0aW9uX2NhbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBzZWxlY3Rpb25fbm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufTtcblxudmFyIHNlbGVjdGlvbl9ub2RlID0gZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgc2VsZWN0aW9uX3NpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gIHJldHVybiBzaXplO1xufTtcblxudmFyIHNlbGVjdGlvbl9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufTtcblxudmFyIHNlbGVjdGlvbl9lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX2F0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn07XG5cbnZhciBkZWZhdWx0VmlldyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59O1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgbm9kZTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBkZWZhdWx0Vmlldyhub2RlID0gdGhpcy5ub2RlKCkpXG4gICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbClcbiAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn07XG5cbmZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn07XG5cbmZ1bmN0aW9uIGNsYXNzQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KC9efFxccysvKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0IHx8IG5ldyBDbGFzc0xpc3Qobm9kZSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzTGlzdChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xuICB0aGlzLl9uYW1lcyA9IGNsYXNzQXJyYXkobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcbn1cblxuQ2xhc3NMaXN0LnByb3RvdHlwZSA9IHtcbiAgYWRkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgdGhpcy5fbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX25vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgdGhpcy5fbmFtZXMuam9pbihcIiBcIikpO1xuICAgIH1cbiAgfSxcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKSA+PSAwO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjbGFzc2VkQWRkKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LmFkZChuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRSZW1vdmUobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QucmVtb3ZlKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFRydWUobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRBZGQodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRmFsc2UobmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsYXNzZWRSZW1vdmUodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24obmFtZXMsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAodmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IGNsYXNzZWRBZGQgOiBjbGFzc2VkUmVtb3ZlKSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fY2xhc3NlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBuYW1lcyA9IGNsYXNzQXJyYXkobmFtZSArIFwiXCIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBsaXN0ID0gY2xhc3NMaXN0KHRoaXMubm9kZSgpKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWxpc3QuY29udGFpbnMobmFtZXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb24gOiB2YWx1ZVxuICAgICAgPyBjbGFzc2VkVHJ1ZVxuICAgICAgOiBjbGFzc2VkRmFsc2UpKG5hbWVzLCB2YWx1ZSkpO1xufTtcblxuZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fdGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn07XG5cbmZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX2h0bWwgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufTtcblxuZnVuY3Rpb24gcmFpc2UoKSB7XG4gIGlmICh0aGlzLm5leHRTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG59XG5cbnZhciBzZWxlY3Rpb25fcmFpc2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyYWlzZSk7XG59O1xuXG5mdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxudmFyIHNlbGVjdGlvbl9sb3dlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fYXBwZW5kID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0YW50TnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBzZWxlY3Rpb25faW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSksXG4gICAgICBzZWxlY3QgPSBiZWZvcmUgPT0gbnVsbCA/IGNvbnN0YW50TnVsbCA6IHR5cGVvZiBiZWZvcmUgPT09IFwiZnVuY3Rpb25cIiA/IGJlZm9yZSA6IHNlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IG51bGwpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG52YXIgc2VsZWN0aW9uX3JlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59O1xuXG52YXIgc2VsZWN0aW9uX2RhdHVtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQobm9kZSwgdHlwZSwgcGFyYW1zKSB7XG4gIHZhciB3aW5kb3cgPSBkZWZhdWx0Vmlldyhub2RlKSxcbiAgICAgIGV2ZW50ID0gd2luZG93LkN1c3RvbUV2ZW50O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2ZW50ID0gbmV3IGV2ZW50KHR5cGUsIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcbiAgICBpZiAocGFyYW1zKSBldmVudC5pbml0RXZlbnQodHlwZSwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlKSwgZXZlbnQuZGV0YWlsID0gcGFyYW1zLmRldGFpbDtcbiAgICBlbHNlIGV2ZW50LmluaXRFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UpO1xuICB9XG5cbiAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hDb25zdGFudCh0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRnVuY3Rpb24odHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fZGlzcGF0Y2ggPSBmdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGRpc3BhdGNoRnVuY3Rpb25cbiAgICAgIDogZGlzcGF0Y2hDb25zdGFudCkodHlwZSwgcGFyYW1zKSk7XG59O1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG52YXIgc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn07XG5cbnZhciBzZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG59O1xuXG52YXIgdG91Y2ggPSBmdW5jdGlvbihub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciB0b3VjaGVzID0gZnVuY3Rpb24obm9kZSwgdG91Y2hlcykge1xuICBpZiAodG91Y2hlcyA9PSBudWxsKSB0b3VjaGVzID0gc291cmNlRXZlbnQoKS50b3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgcG9pbnRzW2ldID0gcG9pbnQobm9kZSwgdG91Y2hlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxuZXhwb3J0cy5jcmVhdG9yID0gY3JlYXRvcjtcbmV4cG9ydHMubG9jYWwgPSBsb2NhbDtcbmV4cG9ydHMubWF0Y2hlciA9IG1hdGNoZXIkMTtcbmV4cG9ydHMubW91c2UgPSBtb3VzZTtcbmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuZXhwb3J0cy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuZXhwb3J0cy5zZWxlY3RBbGwgPSBzZWxlY3RBbGw7XG5leHBvcnRzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbmV4cG9ydHMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbmV4cG9ydHMuc2VsZWN0b3JBbGwgPSBzZWxlY3RvckFsbDtcbmV4cG9ydHMudG91Y2ggPSB0b3VjaDtcbmV4cG9ydHMudG91Y2hlcyA9IHRvdWNoZXM7XG5leHBvcnRzLndpbmRvdyA9IGRlZmF1bHRWaWV3O1xuZXhwb3J0cy5jdXN0b21FdmVudCA9IGN1c3RvbUV2ZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLmQzX2RzdiA9IHt9KSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gZHN2KGRlbGltaXRlcikge1xuICAgIHJldHVybiBuZXcgRHN2KGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiOiBkW1wiICsgaSArIFwiXVwiO1xuICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3VzdG9tQ29udmVydGVyKGNvbHVtbnMsIGYpIHtcbiAgICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIHJldHVybiBmKG9iamVjdChyb3cpLCBpLCBjb2x1bW5zKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB1bmlxdWUgY29sdW1ucyBpbiBvcmRlciBvZiBkaXNjb3ZlcnkuXG4gIGZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gICAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIGNvbHVtbnMgPSBbXTtcblxuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29sdW1ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIERzdihkZWxpbWl0ZXIpIHtcbiAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXVwiKSxcbiAgICAgICAgZGVsaW1pdGVyQ29kZSA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKHRleHQsIGYpIHtcbiAgICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gdGhpcy5wYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgICAgfSk7XG4gICAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcblxuICAgIHRoaXMucGFyc2VSb3dzID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCAvLyBzZW50aW5lbCB2YWx1ZSBmb3IgZW5kLW9mLWxpbmVcbiAgICAgICAgICBFT0YgPSB7fSwgLy8gc2VudGluZWwgdmFsdWUgZm9yIGVuZC1vZi1maWxlXG4gICAgICAgICAgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgICBuID0gMCwgLy8gdGhlIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgICB0LCAvLyB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgIGVvbDsgLy8gaXMgdGhlIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgaWYgKEkgPj0gTikgcmV0dXJuIEVPRjsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgZmlsZVxuICAgICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDsgLy8gc3BlY2lhbCBjYXNlOiBlbmQgb2YgbGluZVxuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZTogcXVvdGVzXG4gICAgICAgIHZhciBqID0gSSwgYztcbiAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gMzQpIHtcbiAgICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgICAgd2hpbGUgKGkrKyA8IE4pIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDM0KSB7XG4gICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgSSA9IGkgKyAyO1xuICAgICAgICAgIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDIpID09PSAxMCkgKytJO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbW1vbiBjYXNlOiBmaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmVcbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKTtcbiAgICAgICAgICBpZiAoYyA9PT0gMTApIGVvbCA9IHRydWU7IC8vIFxcblxuICAgICAgICAgIGVsc2UgaWYgKGMgPT09IDEzKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IDEwKSArK0ksICsrazsgfSAvLyBcXHJ8XFxyXFxuXG4gICAgICAgICAgZWxzZSBpZiAoYyAhPT0gZGVsaW1pdGVyQ29kZSkgY29udGludWU7XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgSSAtIGspO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBsYXN0IHRva2VuIGJlZm9yZSBFT0ZcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2Uoaik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHtcbiAgICAgICAgICBhLnB1c2godCk7XG4gICAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgJiYgKGEgPSBmKGEsIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICByb3dzLnB1c2goYSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybWF0ID0gZnVuY3Rpb24ocm93cywgY29sdW1ucykge1xuICAgICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcblxuICAgIHRoaXMuZm9ybWF0Um93cyA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgICAgcmV0dXJuIHJlRm9ybWF0LnRlc3QodGV4dCkgPyBcIlxcXCJcIiArIHRleHQucmVwbGFjZSgvXFxcIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCIgOiB0ZXh0O1xuICAgIH1cbiAgfVxuXG4gIGRzdi5wcm90b3R5cGUgPSBEc3YucHJvdG90eXBlO1xuXG4gIHZhciBjc3YgPSBkc3YoXCIsXCIpO1xuICB2YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG4gIHZhciB2ZXJzaW9uID0gXCIwLjEuMTRcIjtcblxuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBleHBvcnRzLmRzdiA9IGRzdjtcbiAgZXhwb3J0cy5jc3YgPSBjc3Y7XG4gIGV4cG9ydHMudHN2ID0gdHN2O1xuXG59KSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnZDMtZm9ybWF0JywgWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgZmFjdG9yeSgoZ2xvYmFsLmQzX2Zvcm1hdCA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4gIC8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbiAgZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XG4gICAgaWYgKChpID0gKHggPSBwID8geC50b0V4cG9uZW50aWFsKHAgLSAxKSA6IHgudG9FeHBvbmVudGlhbCgpKS5pbmRleE9mKFwiZVwiKSkgPCAwKSByZXR1cm4gbnVsbDsgLy8gTmFOLCDCsUluZmluaXR5XG4gICAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAgIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgICAvLyAoZS5nLiwgMS4yZSszKSBvciB0aGUgZm9ybSBcXGRlWy0rXVxcZCsgKGUuZy4sIDFlKzMpLlxuICAgIHJldHVybiBbXG4gICAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICAgK3guc2xpY2UoaSArIDEpXG4gICAgXTtcbiAgfTtcblxuICBmdW5jdGlvbiBleHBvbmVudCh4KSB7XG4gICAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHQgPSBbXSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHByZWZpeEV4cG9uZW50O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeEF1dG8oeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICAgIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgICBleHBvbmVudCA9IGRbMV07XG4gICAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0KHgsIHApIHtcbiAgICB4ID0geC50b1ByZWNpc2lvbihwKTtcblxuICAgIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN3aXRjaCAoeFtpXSkge1xuICAgICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZVwiOiBicmVhayBvdXQ7XG4gICAgICAgIGRlZmF1bHQ6IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGkwID4gMCA/IHguc2xpY2UoMCwgaTApICsgeC5zbGljZShpMSArIDEpIDogeDtcbiAgfTtcblxuICB2YXIgZm9ybWF0VHlwZXMgPSB7XG4gICAgXCJcIjogZm9ybWF0RGVmYXVsdCxcbiAgICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXG4gICAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gICAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICAgIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcbiAgICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICAgIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gICAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXG4gICAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gICAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gICAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gICAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gICAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gICAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XG4gIH07XG5cbiAgLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt0eXBlXVxuICB2YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG5cbiAgICB2YXIgbWF0Y2gsXG4gICAgICAgIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIixcbiAgICAgICAgYWxpZ24gPSBtYXRjaFsyXSB8fCBcIj5cIixcbiAgICAgICAgc2lnbiA9IG1hdGNoWzNdIHx8IFwiLVwiLFxuICAgICAgICBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLFxuICAgICAgICB6ZXJvID0gISFtYXRjaFs1XSxcbiAgICAgICAgd2lkdGggPSBtYXRjaFs2XSAmJiArbWF0Y2hbNl0sXG4gICAgICAgIGNvbW1hID0gISFtYXRjaFs3XSxcbiAgICAgICAgcHJlY2lzaW9uID0gbWF0Y2hbOF0gJiYgK21hdGNoWzhdLnNsaWNlKDEpLFxuICAgICAgICB0eXBlID0gbWF0Y2hbOV0gfHwgXCJcIjtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIE1hcCBpbnZhbGlkIHR5cGVzIHRvIHRoZSBkZWZhdWx0IGZvcm1hdC5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHR5cGUgPSBcIlwiO1xuXG4gICAgLy8gSWYgemVybyBmaWxsIGlzIHNwZWNpZmllZCwgcGFkZGluZyBnb2VzIGFmdGVyIHNpZ24gYW5kIGJlZm9yZSBkaWdpdHMuXG4gICAgaWYgKHplcm8gfHwgKGZpbGwgPT09IFwiMFwiICYmIGFsaWduID09PSBcIj1cIikpIHplcm8gPSB0cnVlLCBmaWxsID0gXCIwXCIsIGFsaWduID0gXCI9XCI7XG5cbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbjtcbiAgICB0aGlzLnNpZ24gPSBzaWduO1xuICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgIHRoaXMuemVybyA9IHplcm87XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY29tbWEgPSBjb21tYTtcbiAgICB0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICAgKyB0aGlzLmFsaWduXG4gICAgICAgICsgdGhpcy5zaWduXG4gICAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLndpZHRoID09IG51bGwgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgICArICh0aGlzLnByZWNpc2lvbiA9PSBudWxsID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICAgKyB0aGlzLnR5cGU7XG4gIH07XG5cbiAgdmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NhbGUobG9jYWxlKSB7XG4gICAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nICYmIGxvY2FsZS50aG91c2FuZHMgPyBmb3JtYXRHcm91cChsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZS50aG91c2FuZHMpIDogaWRlbnRpdHksXG4gICAgICAgIGN1cnJlbmN5ID0gbG9jYWxlLmN1cnJlbmN5LFxuICAgICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWw7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgICAgdmFyIGZpbGwgPSBzcGVjaWZpZXIuZmlsbCxcbiAgICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgICAgc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCxcbiAgICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgICAgY29tbWEgPSBzcGVjaWZpZXIuY29tbWEsXG4gICAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVsxXSA6IC9bJXBdLy50ZXN0KHR5cGUpID8gXCIlXCIgOiBcIlwiO1xuXG4gICAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgICBtYXliZVN1ZmZpeCA9ICF0eXBlIHx8IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAodHlwZSA/IDYgOiAxMilcbiAgICAgICAgICA6IC9bZ3Byc10vLnRlc3QodHlwZSkgPyBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSlcbiAgICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciB2YWx1ZVByZWZpeCA9IHByZWZpeCxcbiAgICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4O1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHRvIHBvc2l0aXZlLCBhbmQgY29tcHV0ZSB0aGUgcHJlZml4LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCAtMCBpcyBub3QgbGVzcyB0aGFuIDAsIGJ1dCAxIC8gLTAgaXMhXG4gICAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSAodmFsdWUgPCAwIHx8IDEgLyB2YWx1ZSA8IDApICYmICh2YWx1ZSAqPSAtMSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBQZXJmb3JtIHRoZSBpbml0aWFsIGZvcm1hdHRpbmcuXG4gICAgICAgICAgdmFsdWUgPSBmb3JtYXRUeXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHZhbHVlIHdhcyBuZWdhdGl2ZSwgaXQgbWF5IGJlIHJvdW5kZWQgdG8gemVybyBkdXJpbmdcbiAgICAgICAgICAvLyBmb3JtYXR0aW5nOyB0cmVhdCB0aGlzIGFzIChwb3NpdGl2ZSkgemVyby5cbiAgICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbiA9IHZhbHVlLmxlbmd0aCwgYztcbiAgICAgICAgICAgIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgKDQ4IDwgYyAmJiBjIDwgNTgpXG4gICAgICAgICAgICAgICAgICB8fCAodHlwZSA9PT0gXCJ4XCIgJiYgOTYgPCBjICYmIGMgPCAxMDMpXG4gICAgICAgICAgICAgICAgICB8fCAodHlwZSA9PT0gXCJYXCIgJiYgNjQgPCBjICYmIGMgPCA3MSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZU5lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogXCItXCIpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcbiAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IHZhbHVlU3VmZml4ICsgKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgICAgLy8gZ3JvdXBlZCwgYW5kIGZyYWN0aW9uYWwgb3IgZXhwb25lbnRpYWwg4oCcc3VmZml44oCdIHBhcnQgdGhhdCBpcyBub3QuXG4gICAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoLCBjO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGMgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpLCA0OCA+IGMgfHwgYyA+IDU3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICAgIGlmIChjb21tYSAmJiAhemVybykgdmFsdWUgPSBncm91cCh2YWx1ZSwgSW5maW5pdHkpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgICBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgZmluYWwgb3V0cHV0IGJhc2VkIG9uIHRoZSBkZXNpcmVkIGFsaWdubWVudC5cbiAgICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nO1xuICAgICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiB2YWx1ZVByZWZpeCArIHBhZGRpbmcgKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBwYWRkaW5nLnNsaWNlKDAsIGxlbmd0aCA9IHBhZGRpbmcubGVuZ3RoID4+IDEpICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZy5zbGljZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWRkaW5nICsgdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgICAgdmFyIGYgPSBmb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgICBlID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxuICB9KTtcblxuICB2YXIgY2FFUyA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMOKCrFwiXVxuICB9KTtcblxuICB2YXIgY3NDWiA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTBLxI1cIl0sXG4gIH0pO1xuXG4gIHZhciBkZUNIID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiJ1wiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEwQ0hGXCJdXG4gIH0pO1xuXG4gIHZhciBkZURFID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH0pO1xuXG4gIHZhciBlbkNBID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbiAgfSk7XG5cbiAgdmFyIGVuR0IgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiwqNcIiwgXCJcIl1cbiAgfSk7XG5cbiAgdmFyIGVzRVMgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTDigqxcIl1cbiAgfSk7XG5cbiAgdmFyIGZpRkkgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH0pO1xuXG4gIHZhciBmckNBID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCIkXCJdXG4gIH0pO1xuXG4gIHZhciBmckZSID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlxceGEw4oKsXCJdXG4gIH0pO1xuXG4gIHZhciBoZUlMID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCqlwiLCBcIlwiXVxuICB9KTtcblxuICB2YXIgaHVIVSA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIlxceGEwXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiXFx4YTBGdFwiXVxuICB9KTtcblxuICB2YXIgaXRJVCA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLigqxcIiwgXCJcIl1cbiAgfSk7XG5cbiAgdmFyIGphSlAgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIHRob3VzYW5kczogXCIsXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwi5YaGXCJdXG4gIH0pO1xuXG4gIHZhciBrb0tSID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIuKCqVwiLCBcIlwiXVxuICB9KTtcblxuICB2YXIgbWtNSyA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIsXCIsXG4gICAgdGhvdXNhbmRzOiBcIi5cIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNC00LXQvS5cIl1cbiAgfSk7XG5cbiAgdmFyIG5sTkwgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wi4oKsXFx4YTBcIiwgXCJcIl1cbiAgfSk7XG5cbiAgdmFyIHBsUEwgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCIuXCIsXG4gICAgZ3JvdXBpbmc6IFszXSxcbiAgICBjdXJyZW5jeTogW1wiXCIsIFwiesWCXCJdXG4gIH0pO1xuXG4gIHZhciBwdEJSID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiLlwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlIkXCIsIFwiXCJdXG4gIH0pO1xuXG4gIHZhciBydVJVID0gbG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIixcIixcbiAgICB0aG91c2FuZHM6IFwiXFx4YTBcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCJcIiwgXCJcXHhhMNGA0YPQsS5cIl1cbiAgfSk7XG5cbiAgdmFyIHN2U0UgPSBsb2NhbGUoe1xuICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIHRob3VzYW5kczogXCJcXHhhMFwiLFxuICAgIGdyb3VwaW5nOiBbM10sXG4gICAgY3VycmVuY3k6IFtcIlwiLCBcIlNFS1wiXVxuICB9KTtcblxuICB2YXIgemhDTiA9IGxvY2FsZSh7XG4gICAgZGVjaW1hbDogXCIuXCIsXG4gICAgdGhvdXNhbmRzOiBcIixcIixcbiAgICBncm91cGluZzogWzNdLFxuICAgIGN1cnJlbmN5OiBbXCLCpVwiLCBcIlwiXVxuICB9KTtcblxuICBmdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gICAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG4gIH07XG5cbiAgdmFyIGZvcm1hdCA9IGRlZmF1bHRMb2NhbGUuZm9ybWF0O1xuICB2YXIgZm9ybWF0UHJlZml4ID0gZGVmYXVsdExvY2FsZS5mb3JtYXRQcmVmaXg7XG5cbiAgdmFyIHZlcnNpb24gPSBcIjAuNC4yXCI7XG5cbiAgZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0UHJlZml4ID0gZm9ybWF0UHJlZml4O1xuICBleHBvcnRzLmxvY2FsZSA9IGxvY2FsZTtcbiAgZXhwb3J0cy5sb2NhbGVDYUVzID0gY2FFUztcbiAgZXhwb3J0cy5sb2NhbGVDc0N6ID0gY3NDWjtcbiAgZXhwb3J0cy5sb2NhbGVEZUNoID0gZGVDSDtcbiAgZXhwb3J0cy5sb2NhbGVEZURlID0gZGVERTtcbiAgZXhwb3J0cy5sb2NhbGVFbkNhID0gZW5DQTtcbiAgZXhwb3J0cy5sb2NhbGVFbkdiID0gZW5HQjtcbiAgZXhwb3J0cy5sb2NhbGVFblVzID0gZGVmYXVsdExvY2FsZTtcbiAgZXhwb3J0cy5sb2NhbGVFc0VzID0gZXNFUztcbiAgZXhwb3J0cy5sb2NhbGVGaUZpID0gZmlGSTtcbiAgZXhwb3J0cy5sb2NhbGVGckNhID0gZnJDQTtcbiAgZXhwb3J0cy5sb2NhbGVGckZyID0gZnJGUjtcbiAgZXhwb3J0cy5sb2NhbGVIZUlsID0gaGVJTDtcbiAgZXhwb3J0cy5sb2NhbGVIdUh1ID0gaHVIVTtcbiAgZXhwb3J0cy5sb2NhbGVJdEl0ID0gaXRJVDtcbiAgZXhwb3J0cy5sb2NhbGVKYUpwID0gamFKUDtcbiAgZXhwb3J0cy5sb2NhbGVLb0tyID0ga29LUjtcbiAgZXhwb3J0cy5sb2NhbGVNa01rID0gbWtNSztcbiAgZXhwb3J0cy5sb2NhbGVObE5sID0gbmxOTDtcbiAgZXhwb3J0cy5sb2NhbGVQbFBsID0gcGxQTDtcbiAgZXhwb3J0cy5sb2NhbGVQdEJyID0gcHRCUjtcbiAgZXhwb3J0cy5sb2NhbGVSdVJ1ID0gcnVSVTtcbiAgZXhwb3J0cy5sb2NhbGVTdlNlID0gc3ZTRTtcbiAgZXhwb3J0cy5sb2NhbGVaaENuID0gemhDTjtcbiAgZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG4gIGV4cG9ydHMucHJlY2lzaW9uRml4ZWQgPSBwcmVjaXNpb25GaXhlZDtcbiAgZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG4gIGV4cG9ydHMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtdGltZScpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnZDMtdGltZS1mb3JtYXQnLCBbJ2V4cG9ydHMnLCAnZDMtdGltZSddLCBmYWN0b3J5KSA6XG4gIGZhY3RvcnkoKGdsb2JhbC5kM190aW1lX2Zvcm1hdCA9IHt9KSxnbG9iYWwuZDNfdGltZSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICAgIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXdZZWFyKHkpIHtcbiAgICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxlJDEobG9jYWxlKSB7XG4gICAgdmFyIGxvY2FsZV9kYXRlVGltZSA9IGxvY2FsZS5kYXRlVGltZSxcbiAgICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgICAgbG9jYWxlX3BlcmlvZHMgPSBsb2NhbGUucGVyaW9kcyxcbiAgICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgICAgbG9jYWxlX21vbnRocyA9IGxvY2FsZS5tb250aHMsXG4gICAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICAgIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgICAgcGVyaW9kTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgICBzaG9ydFdlZWtkYXlSZSA9IGZvcm1hdFJlKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgICBtb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfbW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgICBcImJcIjogZm9ybWF0U2hvcnRNb250aCxcbiAgICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICAgIFwiY1wiOiBudWxsLFxuICAgICAgXCJkXCI6IGZvcm1hdERheU9mTW9udGgsXG4gICAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgICBcIlNcIjogZm9ybWF0U2Vjb25kcyxcbiAgICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogZm9ybWF0V2Vla051bWJlck1vbmRheSxcbiAgICAgIFwieFwiOiBudWxsLFxuICAgICAgXCJYXCI6IG51bGwsXG4gICAgICBcInlcIjogZm9ybWF0WWVhcixcbiAgICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gICAgfTtcblxuICAgIHZhciB1dGNGb3JtYXRzID0ge1xuICAgICAgXCJhXCI6IGZvcm1hdFVUQ1Nob3J0V2Vla2RheSxcbiAgICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgICBcIkJcIjogZm9ybWF0VVRDTW9udGgsXG4gICAgICBcImNcIjogbnVsbCxcbiAgICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgICAgXCJlXCI6IGZvcm1hdFVUQ0RheU9mTW9udGgsXG4gICAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyLFxuICAgICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgICBcInhcIjogbnVsbCxcbiAgICAgIFwiWFwiOiBudWxsLFxuICAgICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgICBcIllcIjogZm9ybWF0VVRDRnVsbFllYXIsXG4gICAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICAgIH07XG5cbiAgICB2YXIgcGFyc2VzID0ge1xuICAgICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgICAgXCJBXCI6IHBhcnNlV2Vla2RheSxcbiAgICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICAgIFwiY1wiOiBwYXJzZUxvY2FsZURhdGVUaW1lLFxuICAgICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgICBcImpcIjogcGFyc2VEYXlPZlllYXIsXG4gICAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICAgIFwiTVwiOiBwYXJzZU1pbnV0ZXMsXG4gICAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgICAgXCJVXCI6IHBhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIFwid1wiOiBwYXJzZVdlZWtkYXlOdW1iZXIsXG4gICAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFwiWFwiOiBwYXJzZUxvY2FsZVRpbWUsXG4gICAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgICBcIlpcIjogcGFyc2Vab25lLFxuICAgICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuXG4gICAgLy8gVGhlc2UgcmVjdXJzaXZlIGRpcmVjdGl2ZSBkZWZpbml0aW9ucyBtdXN0IGJlIGRlZmVycmVkLlxuICAgIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gICAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgICBmb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCBmb3JtYXRzKTtcbiAgICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICAgIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gICAgdXRjRm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgdXRjRm9ybWF0cyk7XG5cbiAgICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gW10sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBqID0gMCxcbiAgICAgICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIHBhZCxcbiAgICAgICAgICAgIGZvcm1hdDtcblxuICAgICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgICAgZWxzZSBwYWQgPSBjID09PSBcImVcIiA/IFwiIFwiIDogXCIwXCI7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgICBqID0gaSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyaW5nLnB1c2goc3BlY2lmaWVyLnNsaWNlKGosIGkpKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSBuZXdZZWFyKDE5MDApLFxuICAgICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICAgIGlmIChcIldcIiBpbiBkIHx8IFwiVVwiIGluIGQpIHtcbiAgICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICAgIHZhciBkYXkgPSBcIlpcIiBpbiBkID8gdXRjRGF0ZShuZXdZZWFyKGQueSkpLmdldFVUQ0RheSgpIDogbmV3RGF0ZShuZXdZZWFyKGQueSkpLmdldERheSgpO1xuICAgICAgICAgIGQubSA9IDA7XG4gICAgICAgICAgZC5kID0gXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRheSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgICByZXR1cm4gbmV3RGF0ZShkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhcnNlO1xuXG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGo7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHBlcmlvZFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgICBmLnBhcnNlID0gbmV3UGFyc2Uoc3BlY2lmaWVyLCBsb2NhbERhdGUpO1xuICAgICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfSxcbiAgICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgICAgZi5wYXJzZSA9IG5ld1BhcnNlKHNwZWNpZmllciwgdXRjRGF0ZSk7XG4gICAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9O1xuICB2YXIgbnVtYmVyUmUgPSAvXlxccypcXGQrLztcbiAgdmFyIHBlcmNlbnRSZSA9IC9eJS87XG4gIHZhciByZXF1b3RlUmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG4gIGZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgICAgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLFxuICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cblxuICBmdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBtYXBbbmFtZXNbaV0udG9Mb3dlckNhc2UoKV0gPSBpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86XFw6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgcmV0dXJuIG4gPyAoZC5aID0gblsxXSA/IDAgOiAtKG5bMl0gKyAoblszXSB8fCBcIjAwXCIpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoMSArIGQzVGltZS5kYXkuY291bnQoZDNUaW1lLnllYXIoZCksIGQpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZDNUaW1lLnN1bmRheS5jb3VudChkM1RpbWUueWVhcihkKSwgZCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlcihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQzVGltZS5tb25kYXkuY291bnQoZDNUaW1lLnllYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICAgIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHJldHVybiAoeiA+IDAgPyBcIi1cIiA6ICh6ICo9IC0xLCBcIitcIikpXG4gICAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICAgIHJldHVybiBwYWQoZC5nZXRVVENNaW51dGVzKCksIHAsIDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2Vjb25kcyhkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ1NlY29uZHMoKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQzVGltZS51dGNTdW5kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXIoZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkM1RpbWUudXRjTW9uZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gICAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICAgIHJldHVybiBcIiswMDAwXCI7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgICByZXR1cm4gXCIlXCI7XG4gIH1cblxuICB2YXIgbG9jYWxlID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9KTtcblxuICB2YXIgY2FFUyA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRpdW1lbmdlXCIsIFwiZGlsbHVuc1wiLCBcImRpbWFydHNcIiwgXCJkaW1lY3Jlc1wiLCBcImRpam91c1wiLCBcImRpdmVuZHJlc1wiLCBcImRpc3NhYnRlXCJdLFxuICAgIHNob3J0RGF5czogW1wiZGcuXCIsIFwiZGwuXCIsIFwiZHQuXCIsIFwiZGMuXCIsIFwiZGouXCIsIFwiZHYuXCIsIFwiZHMuXCJdLFxuICAgIG1vbnRoczogW1wiZ2VuZXJcIiwgXCJmZWJyZXJcIiwgXCJtYXLDp1wiLCBcImFicmlsXCIsIFwibWFpZ1wiLCBcImp1bnlcIiwgXCJqdWxpb2xcIiwgXCJhZ29zdFwiLCBcInNldGVtYnJlXCIsIFwib2N0dWJyZVwiLCBcIm5vdmVtYnJlXCIsIFwiZGVzZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImdlbi5cIiwgXCJmZWJyLlwiLCBcIm1hcsOnXCIsIFwiYWJyLlwiLCBcIm1haWdcIiwgXCJqdW55XCIsIFwianVsLlwiLCBcImFnLlwiLCBcInNldC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImRlcy5cIl1cbiAgfSk7XG5cbiAgdmFyIGRlQ0ggPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGRlciAlZS4gJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJTb25udGFnXCIsIFwiTW9udGFnXCIsIFwiRGllbnN0YWdcIiwgXCJNaXR0d29jaFwiLCBcIkRvbm5lcnN0YWdcIiwgXCJGcmVpdGFnXCIsIFwiU2Ftc3RhZ1wiXSxcbiAgICBzaG9ydERheXM6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyXCIsIFwiRmVicnVhclwiLCBcIk3DpHJ6XCIsIFwiQXByaWxcIiwgXCJNYWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlemVtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNcnpcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfSk7XG5cbiAgdmFyIGRlREUgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJUEsIGRlciAlZS4gJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJTb25udGFnXCIsIFwiTW9udGFnXCIsIFwiRGllbnN0YWdcIiwgXCJNaXR0d29jaFwiLCBcIkRvbm5lcnN0YWdcIiwgXCJGcmVpdGFnXCIsIFwiU2Ftc3RhZ1wiXSxcbiAgICBzaG9ydERheXM6IFtcIlNvXCIsIFwiTW9cIiwgXCJEaVwiLCBcIk1pXCIsIFwiRG9cIiwgXCJGclwiLCBcIlNhXCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyXCIsIFwiRmVicnVhclwiLCBcIk3DpHJ6XCIsIFwiQXByaWxcIiwgXCJNYWlcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9rdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlemVtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNcnpcIiwgXCJBcHJcIiwgXCJNYWlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPa3RcIiwgXCJOb3ZcIiwgXCJEZXpcIl1cbiAgfSk7XG5cbiAgdmFyIGVuQ0EgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJWEgJWIgJWUgJVggJVlcIixcbiAgICBkYXRlOiBcIiVZLSVtLSVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH0pO1xuXG4gIHZhciBlbkdCID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICViICVYICVZXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICAgIHNob3J0RGF5czogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxuICB9KTtcblxuICB2YXIgZXNFUyA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgZGUgJUIgZGUgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcImRvbWluZ29cIiwgXCJsdW5lc1wiLCBcIm1hcnRlc1wiLCBcIm1pw6lyY29sZXNcIiwgXCJqdWV2ZXNcIiwgXCJ2aWVybmVzXCIsIFwic8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcImRvbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1pw6lcIiwgXCJqdWVcIiwgXCJ2aWVcIiwgXCJzw6FiXCJdLFxuICAgIG1vbnRoczogW1wiZW5lcm9cIiwgXCJmZWJyZXJvXCIsIFwibWFyem9cIiwgXCJhYnJpbFwiLCBcIm1heW9cIiwgXCJqdW5pb1wiLCBcImp1bGlvXCIsIFwiYWdvc3RvXCIsIFwic2VwdGllbWJyZVwiLCBcIm9jdHVicmVcIiwgXCJub3ZpZW1icmVcIiwgXCJkaWNpZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImVuZVwiLCBcImZlYlwiLCBcIm1hclwiLCBcImFiclwiLCBcIm1heVwiLCBcImp1blwiLCBcImp1bFwiLCBcImFnb1wiLCBcInNlcFwiLCBcIm9jdFwiLCBcIm5vdlwiLCBcImRpY1wiXVxuICB9KTtcblxuICB2YXIgZmlGSSA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgJS1kLiAlQnRhICVZIGtsbyAlWFwiLFxuICAgIGRhdGU6IFwiJS1kLiUtbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJhLm0uXCIsIFwicC5tLlwiXSxcbiAgICBkYXlzOiBbXCJzdW5udW50YWlcIiwgXCJtYWFuYW50YWlcIiwgXCJ0aWlzdGFpXCIsIFwia2Vza2l2aWlra29cIiwgXCJ0b3JzdGFpXCIsIFwicGVyamFudGFpXCIsIFwibGF1YW50YWlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTdVwiLCBcIk1hXCIsIFwiVGlcIiwgXCJLZVwiLCBcIlRvXCIsIFwiUGVcIiwgXCJMYVwiXSxcbiAgICBtb250aHM6IFtcInRhbW1pa3V1XCIsIFwiaGVsbWlrdXVcIiwgXCJtYWFsaXNrdXVcIiwgXCJodWh0aWt1dVwiLCBcInRvdWtva3V1XCIsIFwia2Vzw6RrdXVcIiwgXCJoZWluw6RrdXVcIiwgXCJlbG9rdXVcIiwgXCJzeXlza3V1XCIsIFwibG9rYWt1dVwiLCBcIm1hcnJhc2t1dVwiLCBcImpvdWx1a3V1XCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJUYW1taVwiLCBcIkhlbG1pXCIsIFwiTWFhbGlzXCIsIFwiSHVodGlcIiwgXCJUb3Vrb1wiLCBcIktlc8OkXCIsIFwiSGVpbsOkXCIsIFwiRWxvXCIsIFwiU3l5c1wiLCBcIkxva2FcIiwgXCJNYXJyYXNcIiwgXCJKb3VsdVwiXVxuICB9KTtcblxuICB2YXIgZnJDQSA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlYSAlZSAlYiAlWSAlWFwiLFxuICAgIGRhdGU6IFwiJVktJW0tJWRcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiXCIsIFwiXCJdLFxuICAgIGRheXM6IFtcImRpbWFuY2hlXCIsIFwibHVuZGlcIiwgXCJtYXJkaVwiLCBcIm1lcmNyZWRpXCIsIFwiamV1ZGlcIiwgXCJ2ZW5kcmVkaVwiLCBcInNhbWVkaVwiXSxcbiAgICBzaG9ydERheXM6IFtcImRpbVwiLCBcImx1blwiLCBcIm1hclwiLCBcIm1lclwiLCBcImpldVwiLCBcInZlblwiLCBcInNhbVwiXSxcbiAgICBtb250aHM6IFtcImphbnZpZXJcIiwgXCJmw6l2cmllclwiLCBcIm1hcnNcIiwgXCJhdnJpbFwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsbGV0XCIsIFwiYW/Du3RcIiwgXCJzZXB0ZW1icmVcIiwgXCJvY3RvYnJlXCIsIFwibm92ZW1icmVcIiwgXCJkw6ljZW1icmVcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcImphblwiLCBcImbDqXZcIiwgXCJtYXJcIiwgXCJhdnJcIiwgXCJtYWlcIiwgXCJqdWlcIiwgXCJqdWxcIiwgXCJhb8O7XCIsIFwic2VwXCIsIFwib2N0XCIsIFwibm92XCIsIFwiZMOpY1wiXVxuICB9KTtcblxuICB2YXIgZnJGUiA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgbGUgJWUgJUIgJVksICVYXCIsXG4gICAgZGF0ZTogXCIlZC8lbS8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJkaW1hbmNoZVwiLCBcImx1bmRpXCIsIFwibWFyZGlcIiwgXCJtZXJjcmVkaVwiLCBcImpldWRpXCIsIFwidmVuZHJlZGlcIiwgXCJzYW1lZGlcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJkaW0uXCIsIFwibHVuLlwiLCBcIm1hci5cIiwgXCJtZXIuXCIsIFwiamV1LlwiLCBcInZlbi5cIiwgXCJzYW0uXCJdLFxuICAgIG1vbnRoczogW1wiamFudmllclwiLCBcImbDqXZyaWVyXCIsIFwibWFyc1wiLCBcImF2cmlsXCIsIFwibWFpXCIsIFwianVpblwiLCBcImp1aWxsZXRcIiwgXCJhb8O7dFwiLCBcInNlcHRlbWJyZVwiLCBcIm9jdG9icmVcIiwgXCJub3ZlbWJyZVwiLCBcImTDqWNlbWJyZVwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFudi5cIiwgXCJmw6l2ci5cIiwgXCJtYXJzXCIsIFwiYXZyLlwiLCBcIm1haVwiLCBcImp1aW5cIiwgXCJqdWlsLlwiLCBcImFvw7t0XCIsIFwic2VwdC5cIiwgXCJvY3QuXCIsIFwibm92LlwiLCBcImTDqWMuXCJdXG4gIH0pO1xuXG4gIHZhciBoZUlMID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVBLCAlZSDXkSVCICVZICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcIteo15DXqdeV159cIiwgXCLXqdeg15lcIiwgXCLXqdec15nXqdeZXCIsIFwi16jXkdeZ16LXmVwiLCBcIteX157Xmdep15lcIiwgXCLXqdeZ16nXmVwiLCBcItep15HXqlwiXSxcbiAgICBzaG9ydERheXM6IFtcIteQ17NcIiwgXCLXkdezXCIsIFwi15LXs1wiLCBcIteT17NcIiwgXCLXlNezXCIsIFwi15XXs1wiLCBcItep17NcIl0sXG4gICAgbW9udGhzOiBbXCLXmdeg15XXkNeoXCIsIFwi16TXkdeo15XXkNeoXCIsIFwi157XqNelXCIsIFwi15DXpNeo15nXnFwiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXldeh15hcIiwgXCLXodek15jXnteR16hcIiwgXCLXkNeV16fXmNeV15HXqFwiLCBcIteg15XXkdee15HXqFwiLCBcIteT16bXnteR16hcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIteZ16DXldezXCIsIFwi16TXkdeo17NcIiwgXCLXnteo16VcIiwgXCLXkNek16jXs1wiLCBcItee15DXmVwiLCBcIteZ15XXoNeZXCIsIFwi15nXldec15lcIiwgXCLXkNeV15LXs1wiLCBcIteh16TXmNezXCIsIFwi15DXlden17NcIiwgXCLXoNeV15HXs1wiLCBcIteT16bXntezXCJdXG4gIH0pO1xuXG4gIHZhciBodUhVID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVZLiAlQiAlLWUuLCAlQSAlWFwiLFxuICAgIGRhdGU6IFwiJVkuICVtLiAlZC5cIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiZGUuXCIsIFwiZHUuXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJ2YXPDoXJuYXBcIiwgXCJow6l0ZsWRXCIsIFwia2VkZFwiLCBcInN6ZXJkYVwiLCBcImNzw7x0w7ZydMO2a1wiLCBcInDDqW50ZWtcIiwgXCJzem9tYmF0XCJdLFxuICAgIHNob3J0RGF5czogW1wiVlwiLCBcIkhcIiwgXCJLXCIsIFwiU3plXCIsIFwiQ3NcIiwgXCJQXCIsIFwiU3pvXCJdLFxuICAgIG1vbnRoczogW1wiamFudcOhclwiLCBcImZlYnJ1w6FyXCIsIFwibcOhcmNpdXNcIiwgXCLDoXByaWxpc1wiLCBcIm3DoWp1c1wiLCBcImrDum5pdXNcIiwgXCJqw7psaXVzXCIsIFwiYXVndXN6dHVzXCIsIFwic3plcHRlbWJlclwiLCBcIm9rdMOzYmVyXCIsIFwibm92ZW1iZXJcIiwgXCJkZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiamFuLlwiLCBcImZlYi5cIiwgXCJtw6FyLlwiLCBcIsOhcHIuXCIsIFwibcOhai5cIiwgXCJqw7puLlwiLCBcImrDumwuXCIsIFwiYXVnLlwiLCBcInN6ZXB0LlwiLCBcIm9rdC5cIiwgXCJub3YuXCIsIFwiZGVjLlwiXVxuICB9KTtcblxuICB2YXIgaXRJVCA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSAlZSAlQiAlWSwgJVhcIixcbiAgICBkYXRlOiBcIiVkLyVtLyVZXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sIC8vIHVudXNlZFxuICAgIGRheXM6IFtcIkRvbWVuaWNhXCIsIFwiTHVuZWTDrFwiLCBcIk1hcnRlZMOsXCIsIFwiTWVyY29sZWTDrFwiLCBcIkdpb3ZlZMOsXCIsIFwiVmVuZXJkw6xcIiwgXCJTYWJhdG9cIl0sXG4gICAgc2hvcnREYXlzOiBbXCJEb21cIiwgXCJMdW5cIiwgXCJNYXJcIiwgXCJNZXJcIiwgXCJHaW9cIiwgXCJWZW5cIiwgXCJTYWJcIl0sXG4gICAgbW9udGhzOiBbXCJHZW5uYWlvXCIsIFwiRmViYnJhaW9cIiwgXCJNYXJ6b1wiLCBcIkFwcmlsZVwiLCBcIk1hZ2dpb1wiLCBcIkdpdWdub1wiLCBcIkx1Z2xpb1wiLCBcIkFnb3N0b1wiLCBcIlNldHRlbWJyZVwiLCBcIk90dG9icmVcIiwgXCJOb3ZlbWJyZVwiLCBcIkRpY2VtYnJlXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJHZW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYWdcIiwgXCJHaXVcIiwgXCJMdWdcIiwgXCJBZ29cIiwgXCJTZXRcIiwgXCJPdHRcIiwgXCJOb3ZcIiwgXCJEaWNcIl1cbiAgfSk7XG5cbiAgdmFyIGphSlAgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJVkgJWIgJWUgJWEgJVhcIixcbiAgICBkYXRlOiBcIiVZLyVtLyVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgZGF5czogW1wi5pel5puc5pelXCIsIFwi5pyI5puc5pelXCIsIFwi54Gr5puc5pelXCIsIFwi5rC05puc5pelXCIsIFwi5pyo5puc5pelXCIsIFwi6YeR5puc5pelXCIsIFwi5Zyf5puc5pelXCJdLFxuICAgIHNob3J0RGF5czogW1wi5pelXCIsIFwi5pyIXCIsIFwi54GrXCIsIFwi5rC0XCIsIFwi5pyoXCIsIFwi6YeRXCIsIFwi5ZyfXCJdLFxuICAgIG1vbnRoczogW1wi552m5pyIXCIsIFwi5aaC5pyIXCIsIFwi5byl55SfXCIsIFwi5Y2v5pyIXCIsIFwi55qQ5pyIXCIsIFwi5rC054Sh5pyIXCIsIFwi5paH5pyIXCIsIFwi6JGJ5pyIXCIsIFwi6ZW35pyIXCIsIFwi56We54Sh5pyIXCIsIFwi6Zyc5pyIXCIsIFwi5bir6LWwXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCIx5pyIXCIsIFwiMuaciFwiLCBcIjPmnIhcIiwgXCI05pyIXCIsIFwiNeaciFwiLCBcIjbmnIhcIiwgXCI35pyIXCIsIFwiOOaciFwiLCBcIjnmnIhcIiwgXCIxMOaciFwiLCBcIjEx5pyIXCIsIFwiMTLmnIhcIl1cbiAgfSk7XG5cbiAgdmFyIGtvS1IgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJVkvJW0vJWQgJWEgJVhcIixcbiAgICBkYXRlOiBcIiVZLyVtLyVkXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIuyYpOyghFwiLCBcIuyYpO2bhFwiXSxcbiAgICBkYXlzOiBbXCLsnbzsmpTsnbxcIiwgXCLsm5TsmpTsnbxcIiwgXCLtmZTsmpTsnbxcIiwgXCLsiJjsmpTsnbxcIiwgXCLrqqnsmpTsnbxcIiwgXCLquIjsmpTsnbxcIiwgXCLthqDsmpTsnbxcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLsnbxcIiwgXCLsm5RcIiwgXCLtmZRcIiwgXCLsiJhcIiwgXCLrqqlcIiwgXCLquIhcIiwgXCLthqBcIl0sXG4gICAgbW9udGhzOiBbXCIx7JuUXCIsIFwiMuyblFwiLCBcIjPsm5RcIiwgXCI07JuUXCIsIFwiNeyblFwiLCBcIjbsm5RcIiwgXCI37JuUXCIsIFwiOOyblFwiLCBcIjnsm5RcIiwgXCIxMOyblFwiLCBcIjEx7JuUXCIsIFwiMTLsm5RcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIjHsm5RcIiwgXCIy7JuUXCIsIFwiM+yblFwiLCBcIjTsm5RcIiwgXCI17JuUXCIsIFwiNuyblFwiLCBcIjfsm5RcIiwgXCI47JuUXCIsIFwiOeyblFwiLCBcIjEw7JuUXCIsIFwiMTHsm5RcIiwgXCIxMuyblFwiXVxuICB9KTtcblxuICB2YXIgbWtNSyA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItC90LXQtNC10LvQsFwiLCBcItC/0L7QvdC10LTQtdC70L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLRgNGC0L7QulwiLCBcItC/0LXRgtC+0LpcIiwgXCLRgdCw0LHQvtGC0LBcIl0sXG4gICAgc2hvcnREYXlzOiBbXCLQvdC10LRcIiwgXCLQv9C+0L1cIiwgXCLQstGC0L5cIiwgXCLRgdGA0LVcIiwgXCLRh9C10YJcIiwgXCLQv9C10YJcIiwgXCLRgdCw0LFcIl0sXG4gICAgbW9udGhzOiBbXCLRmNCw0L3Rg9Cw0YDQuFwiLCBcItGE0LXQstGA0YPQsNGA0LhcIiwgXCLQvNCw0YDRglwiLCBcItCw0L/RgNC40LtcIiwgXCLQvNCw0ZhcIiwgXCLRmNGD0L3QuFwiLCBcItGY0YPQu9C4XCIsIFwi0LDQstCz0YPRgdGCXCIsIFwi0YHQtdC/0YLQtdC80LLRgNC4XCIsIFwi0L7QutGC0L7QvNCy0YDQuFwiLCBcItC90L7QtdC80LLRgNC4XCIsIFwi0LTQtdC60LXQvNCy0YDQuFwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wi0ZjQsNC9XCIsIFwi0YTQtdCyXCIsIFwi0LzQsNGAXCIsIFwi0LDQv9GAXCIsIFwi0LzQsNGYXCIsIFwi0ZjRg9C9XCIsIFwi0ZjRg9C7XCIsIFwi0LDQstCzXCIsIFwi0YHQtdC/XCIsIFwi0L7QutGCXCIsIFwi0L3QvtC1XCIsIFwi0LTQtdC6XCJdXG4gIH0pO1xuXG4gIHZhciBubE5MID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVhICVlICVCICVZICVUXCIsXG4gICAgZGF0ZTogXCIlZC0lbS0lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLCAvLyB1bnVzZWRcbiAgICBkYXlzOiBbXCJ6b25kYWdcIiwgXCJtYWFuZGFnXCIsIFwiZGluc2RhZ1wiLCBcIndvZW5zZGFnXCIsIFwiZG9uZGVyZGFnXCIsIFwidnJpamRhZ1wiLCBcInphdGVyZGFnXCJdLFxuICAgIHNob3J0RGF5czogW1wiem9cIiwgXCJtYVwiLCBcImRpXCIsIFwid29cIiwgXCJkb1wiLCBcInZyXCIsIFwiemFcIl0sXG4gICAgbW9udGhzOiBbXCJqYW51YXJpXCIsIFwiZmVicnVhcmlcIiwgXCJtYWFydFwiLCBcImFwcmlsXCIsIFwibWVpXCIsIFwianVuaVwiLCBcImp1bGlcIiwgXCJhdWd1c3R1c1wiLCBcInNlcHRlbWJlclwiLCBcIm9rdG9iZXJcIiwgXCJub3ZlbWJlclwiLCBcImRlY2VtYmVyXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJqYW5cIiwgXCJmZWJcIiwgXCJtcnRcIiwgXCJhcHJcIiwgXCJtZWlcIiwgXCJqdW5cIiwgXCJqdWxcIiwgXCJhdWdcIiwgXCJzZXBcIiwgXCJva3RcIiwgXCJub3ZcIiwgXCJkZWNcIl1cbiAgfSk7XG5cbiAgdmFyIHBsUEwgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlICVCICVZLCAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSwgLy8gdW51c2VkXG4gICAgZGF5czogW1wiTmllZHppZWxhXCIsIFwiUG9uaWVkemlhxYJla1wiLCBcIld0b3Jla1wiLCBcIsWacm9kYVwiLCBcIkN6d2FydGVrXCIsIFwiUGnEhXRla1wiLCBcIlNvYm90YVwiXSxcbiAgICBzaG9ydERheXM6IFtcIk5pZWR6LlwiLCBcIlBvbi5cIiwgXCJXdC5cIiwgXCLFmnIuXCIsIFwiQ3p3LlwiLCBcIlB0LlwiLCBcIlNvYi5cIl0sXG4gICAgbW9udGhzOiBbXCJTdHljemXFhFwiLCBcIkx1dHlcIiwgXCJNYXJ6ZWNcIiwgXCJLd2llY2llxYRcIiwgXCJNYWpcIiwgXCJDemVyd2llY1wiLCBcIkxpcGllY1wiLCBcIlNpZXJwaWXFhFwiLCBcIldyemVzaWXFhFwiLCBcIlBhxbpkemllcm5pa1wiLCBcIkxpc3RvcGFkXCIsIFwiR3J1ZHppZcWEXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCJTdHljei5cIiwgXCJMdXR5XCIsIFwiTWFyei5cIiwgXCJLd2llLlwiLCBcIk1halwiLCBcIkN6ZXJ3LlwiLCBcIkxpcGMuXCIsIFwiU2llcnAuXCIsIFwiV3J6LlwiLCBcIlBhxbpkei5cIiwgXCJMaXN0b3AuXCIsIFwiR3J1ZHouXCJdLyogSW4gUG9saXNoIGxhbmd1YWdlIGFiYnJhdmlhdGVkIG1vbnRocyBhcmUgbm90IGNvbW1vbmx5IHVzZWQgc28gdGhlcmUgaXMgYSBkaXNwdXRlIGFib3V0IHRoZSBwcm9wZXIgYWJicmF2aWF0aW9ucy4gKi9cbiAgfSk7XG5cbiAgdmFyIHB0QlIgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJUEsICVlIGRlICVCIGRlICVZLiAlWFwiLFxuICAgIGRhdGU6IFwiJWQvJW0vJVlcIixcbiAgICB0aW1lOiBcIiVIOiVNOiVTXCIsXG4gICAgcGVyaW9kczogW1wiQU1cIiwgXCJQTVwiXSxcbiAgICBkYXlzOiBbXCJEb21pbmdvXCIsIFwiU2VndW5kYVwiLCBcIlRlcsOnYVwiLCBcIlF1YXJ0YVwiLCBcIlF1aW50YVwiLCBcIlNleHRhXCIsIFwiU8OhYmFkb1wiXSxcbiAgICBzaG9ydERheXM6IFtcIkRvbVwiLCBcIlNlZ1wiLCBcIlRlclwiLCBcIlF1YVwiLCBcIlF1aVwiLCBcIlNleFwiLCBcIlPDoWJcIl0sXG4gICAgbW9udGhzOiBbXCJKYW5laXJvXCIsIFwiRmV2ZXJlaXJvXCIsIFwiTWFyw6dvXCIsIFwiQWJyaWxcIiwgXCJNYWlvXCIsIFwiSnVuaG9cIiwgXCJKdWxob1wiLCBcIkFnb3N0b1wiLCBcIlNldGVtYnJvXCIsIFwiT3V0dWJyb1wiLCBcIk5vdmVtYnJvXCIsIFwiRGV6ZW1icm9cIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZldlwiLCBcIk1hclwiLCBcIkFiclwiLCBcIk1haVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkFnb1wiLCBcIlNldFwiLCBcIk91dFwiLCBcIk5vdlwiLCBcIkRlelwiXVxuICB9KTtcblxuICB2YXIgcnVSVSA9IGxvY2FsZSQxKHtcbiAgICBkYXRlVGltZTogXCIlQSwgJWUgJUIgJVkg0LMuICVYXCIsXG4gICAgZGF0ZTogXCIlZC4lbS4lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgIGRheXM6IFtcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVcIiwgXCLQv9C+0L3QtdC00LXQu9GM0L3QuNC6XCIsIFwi0LLRgtC+0YDQvdC40LpcIiwgXCLRgdGA0LXQtNCwXCIsIFwi0YfQtdGC0LLQtdGA0LNcIiwgXCLQv9GP0YLQvdC40YbQsFwiLCBcItGB0YPQsdCx0L7RgtCwXCJdLFxuICAgIHNob3J0RGF5czogW1wi0LLRgVwiLCBcItC/0L1cIiwgXCLQstGCXCIsIFwi0YHRgFwiLCBcItGH0YJcIiwgXCLQv9GCXCIsIFwi0YHQsVwiXSxcbiAgICBtb250aHM6IFtcItGP0L3QstCw0YDRj1wiLCBcItGE0LXQstGA0LDQu9GPXCIsIFwi0LzQsNGA0YLQsFwiLCBcItCw0L/RgNC10LvRj1wiLCBcItC80LDRj1wiLCBcItC40Y7QvdGPXCIsIFwi0LjRjtC70Y9cIiwgXCLQsNCy0LPRg9GB0YLQsFwiLCBcItGB0LXQvdGC0Y/QsdGA0Y9cIiwgXCLQvtC60YLRj9Cx0YDRj1wiLCBcItC90L7Rj9Cx0YDRj1wiLCBcItC00LXQutCw0LHRgNGPXCJdLFxuICAgIHNob3J0TW9udGhzOiBbXCLRj9C90LJcIiwgXCLRhNC10LJcIiwgXCLQvNCw0YBcIiwgXCLQsNC/0YBcIiwgXCLQvNCw0LlcIiwgXCLQuNGO0L1cIiwgXCLQuNGO0LtcIiwgXCLQsNCy0LNcIiwgXCLRgdC10L1cIiwgXCLQvtC60YJcIiwgXCLQvdC+0Y9cIiwgXCLQtNC10LpcIl1cbiAgfSk7XG5cbiAgdmFyIHN2U0UgPSBsb2NhbGUkMSh7XG4gICAgZGF0ZVRpbWU6IFwiJUEgZGVuICVkICVCICVZICVYXCIsXG4gICAgZGF0ZTogXCIlWS0lbS0lZFwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbXCJmbVwiLCBcImVtXCJdLFxuICAgIGRheXM6IFtcIlPDtm5kYWdcIiwgXCJNw6VuZGFnXCIsIFwiVGlzZGFnXCIsIFwiT25zZGFnXCIsIFwiVG9yc2RhZ1wiLCBcIkZyZWRhZ1wiLCBcIkzDtnJkYWdcIl0sXG4gICAgc2hvcnREYXlzOiBbXCJTw7ZuXCIsIFwiTcOlblwiLCBcIlRpc1wiLCBcIk9uc1wiLCBcIlRvclwiLCBcIkZyZVwiLCBcIkzDtnJcIl0sXG4gICAgbW9udGhzOiBbXCJKYW51YXJpXCIsIFwiRmVicnVhcmlcIiwgXCJNYXJzXCIsIFwiQXByaWxcIiwgXCJNYWpcIiwgXCJKdW5pXCIsIFwiSnVsaVwiLCBcIkF1Z3VzdGlcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPa3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgICBzaG9ydE1vbnRoczogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWFqXCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2t0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG4gIH0pO1xuXG4gIHZhciB6aENOID0gbG9jYWxlJDEoe1xuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlWS8lLW0vJS1kXCIsXG4gICAgdGltZTogXCIlSDolTTolU1wiLFxuICAgIHBlcmlvZHM6IFtcIuS4iuWNiFwiLCBcIuS4i+WNiFwiXSxcbiAgICBkYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgc2hvcnREYXlzOiBbXCLmmJ/mnJ/ml6VcIiwgXCLmmJ/mnJ/kuIBcIiwgXCLmmJ/mnJ/kuoxcIiwgXCLmmJ/mnJ/kuIlcIiwgXCLmmJ/mnJ/lm5tcIiwgXCLmmJ/mnJ/kupRcIiwgXCLmmJ/mnJ/lha1cIl0sXG4gICAgbW9udGhzOiBbXCLkuIDmnIhcIiwgXCLkuozmnIhcIiwgXCLkuInmnIhcIiwgXCLlm5vmnIhcIiwgXCLkupTmnIhcIiwgXCLlha3mnIhcIiwgXCLkuIPmnIhcIiwgXCLlhavmnIhcIiwgXCLkuZ3mnIhcIiwgXCLljYHmnIhcIiwgXCLljYHkuIDmnIhcIiwgXCLljYHkuozmnIhcIl0sXG4gICAgc2hvcnRNb250aHM6IFtcIuS4gOaciFwiLCBcIuS6jOaciFwiLCBcIuS4ieaciFwiLCBcIuWbm+aciFwiLCBcIuS6lOaciFwiLCBcIuWFreaciFwiLCBcIuS4g+aciFwiLCBcIuWFq+aciFwiLCBcIuS5neaciFwiLCBcIuWNgeaciFwiLCBcIuWNgeS4gOaciFwiLCBcIuWNgeS6jOaciFwiXVxuICB9KTtcblxuICB2YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuICBmdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cblxuICBmb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG5cbiAgZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzb1NwZWNpZmllcjtcbiAgfTtcblxuICB2YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgICAgOiBsb2NhbGUudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbiAgdmFyIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIHZhciB1dGNGb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0O1xuXG4gIHZhciB2ZXJzaW9uID0gXCIwLjIuMVwiO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gIGV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuICBleHBvcnRzLnV0Y0Zvcm1hdCA9IHV0Y0Zvcm1hdDtcbiAgZXhwb3J0cy5sb2NhbGUgPSBsb2NhbGUkMTtcbiAgZXhwb3J0cy5sb2NhbGVDYUVzID0gY2FFUztcbiAgZXhwb3J0cy5sb2NhbGVEZUNoID0gZGVDSDtcbiAgZXhwb3J0cy5sb2NhbGVEZURlID0gZGVERTtcbiAgZXhwb3J0cy5sb2NhbGVFbkNhID0gZW5DQTtcbiAgZXhwb3J0cy5sb2NhbGVFbkdiID0gZW5HQjtcbiAgZXhwb3J0cy5sb2NhbGVFblVzID0gbG9jYWxlO1xuICBleHBvcnRzLmxvY2FsZUVzRXMgPSBlc0VTO1xuICBleHBvcnRzLmxvY2FsZUZpRmkgPSBmaUZJO1xuICBleHBvcnRzLmxvY2FsZUZyQ2EgPSBmckNBO1xuICBleHBvcnRzLmxvY2FsZUZyRnIgPSBmckZSO1xuICBleHBvcnRzLmxvY2FsZUhlSWwgPSBoZUlMO1xuICBleHBvcnRzLmxvY2FsZUh1SHUgPSBodUhVO1xuICBleHBvcnRzLmxvY2FsZUl0SXQgPSBpdElUO1xuICBleHBvcnRzLmxvY2FsZUphSnAgPSBqYUpQO1xuICBleHBvcnRzLmxvY2FsZUtvS3IgPSBrb0tSO1xuICBleHBvcnRzLmxvY2FsZU1rTWsgPSBta01LO1xuICBleHBvcnRzLmxvY2FsZU5sTmwgPSBubE5MO1xuICBleHBvcnRzLmxvY2FsZVBsUGwgPSBwbFBMO1xuICBleHBvcnRzLmxvY2FsZVB0QnIgPSBwdEJSO1xuICBleHBvcnRzLmxvY2FsZVJ1UnUgPSBydVJVO1xuICBleHBvcnRzLmxvY2FsZVN2U2UgPSBzdlNFO1xuICBleHBvcnRzLmxvY2FsZVpoQ24gPSB6aENOO1xuICBleHBvcnRzLmlzb0Zvcm1hdCA9IGZvcm1hdElzbztcblxufSkpOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2QzLXRpbWUnLCBbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICBmYWN0b3J5KChnbG9iYWwuZDNfdGltZSA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdDAgPSBuZXcgRGF0ZTtcbiAgdmFyIHQxID0gbmV3IERhdGU7XG4gIGZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICAgIH1cblxuICAgIGludGVydmFsLmZsb29yID0gaW50ZXJ2YWw7XG5cbiAgICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkMCA9IG5ldyBEYXRlKCtkYXRlKSxcbiAgICAgICAgICBkMSA9IG5ldyBEYXRlKGRhdGUgLSAxKTtcbiAgICAgIGZsb29yaShkMCksIGZsb29yaShkMSksIG9mZnNldGkoZDEsIDEpO1xuICAgICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gICAgfTtcblxuICAgIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBkYXRlO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gICAgfTtcblxuICAgIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIHZhciByYW5nZSA9IFtdO1xuICAgICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCAtIDEpO1xuICAgICAgc3RvcCA9IG5ldyBEYXRlKCtzdG9wKTtcbiAgICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIGlmICghKHN0YXJ0IDwgc3RvcCkgfHwgIShzdGVwID4gMCkpIHJldHVybiByYW5nZTsgLy8gYWxzbyBoYW5kbGVzIEludmFsaWQgRGF0ZVxuICAgICAgb2Zmc2V0aShzdGFydCwgMSksIGZsb29yaShzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCBzdG9wKSByYW5nZS5wdXNoKG5ldyBEYXRlKCtzdGFydCkpO1xuICAgICAgd2hpbGUgKG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpLCBzdGFydCA8IHN0b3ApIHJhbmdlLnB1c2gobmV3IERhdGUoK3N0YXJ0KSk7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcblxuICAgIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgICB3aGlsZSAoLS1zdGVwID49IDApIHdoaWxlIChvZmZzZXRpKGRhdGUsIDEpLCAhdGVzdChkYXRlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgICBmbG9vcmkodDApLCBmbG9vcmkodDEpO1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICAgIH07XG5cbiAgICAgIGludGVydmFsLmV2ZXJ5ID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgICAgcmV0dXJuICFpc0Zpbml0ZShzdGVwKSB8fCAhKHN0ZXAgPiAwKSA/IG51bGxcbiAgICAgICAgICAgIDogIShzdGVwID4gMSkgPyBpbnRlcnZhbFxuICAgICAgICAgICAgOiBpbnRlcnZhbC5maWx0ZXIoZmllbGRcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpZWxkKGQpICUgc3RlcCA9PT0gMDsgfVxuICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oZCkgeyByZXR1cm4gaW50ZXJ2YWwuY291bnQoMCwgZCkgJSBzdGVwID09PSAwOyB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVydmFsO1xuICB9O1xuXG4gIHZhciBtaWxsaXNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgIC8vIG5vb3BcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xuICB9KTtcblxuICAvLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG4gIG1pbGxpc2Vjb25kLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLmZsb29yKGspO1xuICAgIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICAgIGlmICghKGsgPiAxKSkgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBrO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0U2Vjb25kcygpO1xuICB9KTtcblxuICB2YXIgbWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIH0pO1xuXG4gIHZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0TWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG4gIH0pO1xuXG4gIHZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1O1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2ZTQpIC8gNjA0OGU1O1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG4gIHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuICB2YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG4gIHZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xuICB2YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xuICB2YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbiAgdmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxuICB2YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICBkYXRlLnNldERhdGUoMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICB9KTtcblxuICB2YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNTZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMWUzO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICB9KTtcblxuICB2YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2ZTQ7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gMzZlNTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA4NjRlNTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSAtIDE7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHV0Y1dlZWtkYXkoaSkge1xuICAgIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gICAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyA2MDQ4ZTU7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbiAgdmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG4gIHZhciB1dGNUdWVzZGF5ID0gdXRjV2Vla2RheSgyKTtcbiAgdmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG4gIHZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG4gIHZhciB1dGNGcmlkYXkgPSB1dGNXZWVrZGF5KDUpO1xuICB2YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG4gIHZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICAgIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG4gIH0pO1xuXG4gIHZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpICsgc3RlcCk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgfSk7XG5cbiAgdmFyIG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kLnJhbmdlO1xuICB2YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcbiAgdmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG4gIHZhciBob3VycyA9IGhvdXIucmFuZ2U7XG4gIHZhciBkYXlzID0gZGF5LnJhbmdlO1xuICB2YXIgc3VuZGF5cyA9IHN1bmRheS5yYW5nZTtcbiAgdmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG4gIHZhciB0dWVzZGF5cyA9IHR1ZXNkYXkucmFuZ2U7XG4gIHZhciB3ZWRuZXNkYXlzID0gd2VkbmVzZGF5LnJhbmdlO1xuICB2YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG4gIHZhciBmcmlkYXlzID0gZnJpZGF5LnJhbmdlO1xuICB2YXIgc2F0dXJkYXlzID0gc2F0dXJkYXkucmFuZ2U7XG4gIHZhciB3ZWVrcyA9IHN1bmRheS5yYW5nZTtcbiAgdmFyIG1vbnRocyA9IG1vbnRoLnJhbmdlO1xuICB2YXIgeWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG4gIHZhciB1dGNNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICB2YXIgdXRjTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICB2YXIgdXRjU2Vjb25kcyA9IHV0Y1NlY29uZC5yYW5nZTtcbiAgdmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG4gIHZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG4gIHZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuICB2YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcbiAgdmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG4gIHZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG4gIHZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xuICB2YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG4gIHZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xuICB2YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XG4gIHZhciB1dGNXZWVrcyA9IHV0Y1N1bmRheS5yYW5nZTtcbiAgdmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuICB2YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG4gIHZhciB2ZXJzaW9uID0gXCIwLjEuMVwiO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4gIGV4cG9ydHMubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICBleHBvcnRzLnNlY29uZHMgPSBzZWNvbmRzO1xuICBleHBvcnRzLm1pbnV0ZXMgPSBtaW51dGVzO1xuICBleHBvcnRzLmhvdXJzID0gaG91cnM7XG4gIGV4cG9ydHMuZGF5cyA9IGRheXM7XG4gIGV4cG9ydHMuc3VuZGF5cyA9IHN1bmRheXM7XG4gIGV4cG9ydHMubW9uZGF5cyA9IG1vbmRheXM7XG4gIGV4cG9ydHMudHVlc2RheXMgPSB0dWVzZGF5cztcbiAgZXhwb3J0cy53ZWRuZXNkYXlzID0gd2VkbmVzZGF5cztcbiAgZXhwb3J0cy50aHVyc2RheXMgPSB0aHVyc2RheXM7XG4gIGV4cG9ydHMuZnJpZGF5cyA9IGZyaWRheXM7XG4gIGV4cG9ydHMuc2F0dXJkYXlzID0gc2F0dXJkYXlzO1xuICBleHBvcnRzLndlZWtzID0gd2Vla3M7XG4gIGV4cG9ydHMubW9udGhzID0gbW9udGhzO1xuICBleHBvcnRzLnllYXJzID0geWVhcnM7XG4gIGV4cG9ydHMudXRjTWlsbGlzZWNvbmQgPSB1dGNNaWxsaXNlY29uZDtcbiAgZXhwb3J0cy51dGNNaWxsaXNlY29uZHMgPSB1dGNNaWxsaXNlY29uZHM7XG4gIGV4cG9ydHMudXRjU2Vjb25kcyA9IHV0Y1NlY29uZHM7XG4gIGV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZXM7XG4gIGV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VycztcbiAgZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5cztcbiAgZXhwb3J0cy51dGNTdW5kYXlzID0gdXRjU3VuZGF5cztcbiAgZXhwb3J0cy51dGNNb25kYXlzID0gdXRjTW9uZGF5cztcbiAgZXhwb3J0cy51dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXlzO1xuICBleHBvcnRzLnV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXlzO1xuICBleHBvcnRzLnV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5cztcbiAgZXhwb3J0cy51dGNGcmlkYXlzID0gdXRjRnJpZGF5cztcbiAgZXhwb3J0cy51dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheXM7XG4gIGV4cG9ydHMudXRjV2Vla3MgPSB1dGNXZWVrcztcbiAgZXhwb3J0cy51dGNNb250aHMgPSB1dGNNb250aHM7XG4gIGV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFycztcbiAgZXhwb3J0cy5taWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICBleHBvcnRzLnNlY29uZCA9IHNlY29uZDtcbiAgZXhwb3J0cy5taW51dGUgPSBtaW51dGU7XG4gIGV4cG9ydHMuaG91ciA9IGhvdXI7XG4gIGV4cG9ydHMuZGF5ID0gZGF5O1xuICBleHBvcnRzLnN1bmRheSA9IHN1bmRheTtcbiAgZXhwb3J0cy5tb25kYXkgPSBtb25kYXk7XG4gIGV4cG9ydHMudHVlc2RheSA9IHR1ZXNkYXk7XG4gIGV4cG9ydHMud2VkbmVzZGF5ID0gd2VkbmVzZGF5O1xuICBleHBvcnRzLnRodXJzZGF5ID0gdGh1cnNkYXk7XG4gIGV4cG9ydHMuZnJpZGF5ID0gZnJpZGF5O1xuICBleHBvcnRzLnNhdHVyZGF5ID0gc2F0dXJkYXk7XG4gIGV4cG9ydHMud2VlayA9IHN1bmRheTtcbiAgZXhwb3J0cy5tb250aCA9IG1vbnRoO1xuICBleHBvcnRzLnllYXIgPSB5ZWFyO1xuICBleHBvcnRzLnV0Y1NlY29uZCA9IHV0Y1NlY29uZDtcbiAgZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG4gIGV4cG9ydHMudXRjSG91ciA9IHV0Y0hvdXI7XG4gIGV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuICBleHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1N1bmRheTtcbiAgZXhwb3J0cy51dGNNb25kYXkgPSB1dGNNb25kYXk7XG4gIGV4cG9ydHMudXRjVHVlc2RheSA9IHV0Y1R1ZXNkYXk7XG4gIGV4cG9ydHMudXRjV2VkbmVzZGF5ID0gdXRjV2VkbmVzZGF5O1xuICBleHBvcnRzLnV0Y1RodXJzZGF5ID0gdXRjVGh1cnNkYXk7XG4gIGV4cG9ydHMudXRjRnJpZGF5ID0gdXRjRnJpZGF5O1xuICBleHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjU2F0dXJkYXk7XG4gIGV4cG9ydHMudXRjV2VlayA9IHV0Y1N1bmRheTtcbiAgZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuICBleHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuICBleHBvcnRzLmludGVydmFsID0gbmV3SW50ZXJ2YWw7XG5cbn0pKTsiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImRhdGFsaWJcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMS43LjNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkphdmFTY3JpcHQgdXRpbGl0ZXMgZm9yIGxvYWRpbmcsIHN1bW1hcml6aW5nIGFuZCB3b3JraW5nIHdpdGggZGF0YS5cIixcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJkYXRhXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwic3RhdGlzdGljc1wiLFxuICAgIFwicGFyc2VcIixcbiAgICBcImNzdlwiLFxuICAgIFwidHN2XCIsXG4gICAgXCJqc29uXCIsXG4gICAgXCJ1dGlsaXR5XCJcbiAgXSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHA6Ly9naXRodWIuY29tL3ZlZ2EvZGF0YWxpYi5naXRcIlxuICB9LFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiSmVmZnJleSBIZWVyXCIsXG4gICAgXCJ1cmxcIjogXCJodHRwOi8vaWRsLmNzLndhc2hpbmd0b24uZWR1XCJcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIk1pY2hhZWwgQ29ycmVsbFwiLFxuICAgICAgXCJ1cmxcIjogXCJodHRwOi8vcGFnZXMuY3Mud2lzYy5lZHUvfm1jb3JyZWxsL1wiXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJSeWFuIFJ1c3NlbGxcIixcbiAgICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL1J1c3NlbGxTcHJvdXRzXCJcbiAgICB9XG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJkMy1kc3ZcIjogXCIwLjFcIixcbiAgICBcImQzLWZvcm1hdFwiOiBcIjAuNFwiLFxuICAgIFwiZDMtdGltZVwiOiBcIjAuMVwiLFxuICAgIFwiZDMtdGltZS1mb3JtYXRcIjogXCIwLjJcIixcbiAgICBcInRvcG9qc29uXCI6IFwiXjEuNi4xOVwiLFxuICAgIFwicmVxdWVzdFwiOiBcIl4yLjY3LjBcIixcbiAgICBcInN5bmMtcmVxdWVzdFwiOiBcIl4yLjEuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTIuMC4xXCIsXG4gICAgXCJjaGFpXCI6IFwiXjMuNC4xXCIsXG4gICAgXCJpc3RhbmJ1bFwiOiBcImxhdGVzdFwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuOS4xLXJjMVwiLFxuICAgIFwibW9jaGFcIjogXCJeMi4zLjRcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcIl4yLjYuMVwiXG4gIH0sXG4gIFwibWFpblwiOiBcInNyYy9pbmRleC5qc1wiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiZGVwbG95XCI6IFwibnBtIHJ1biB0ZXN0ICYmIHNjcmlwdHMvZGVwbG95LnNoXCIsXG4gICAgXCJsaW50XCI6IFwianNoaW50IHNyYy9cIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgVFo9QW1lcmljYS9Mb3NfQW5nZWxlcyBtb2NoYSAtLXJlY3Vyc2l2ZSB0ZXN0L1wiLFxuICAgIFwiY292ZXJcIjogXCJUWj1BbWVyaWNhL0xvc19BbmdlbGVzIGlzdGFuYnVsIGNvdmVyIF9tb2NoYSAtLSAtLXJlY3Vyc2l2ZSB0ZXN0L1wiLFxuICAgIFwiYnVpbGRcIjogXCJicm93c2VyaWZ5IHNyYy9pbmRleC5qcyAtZCAtcyBkbCAtbyBkYXRhbGliLmpzXCIsXG4gICAgXCJwb3N0YnVpbGRcIjogXCJ1Z2xpZnlqcyBkYXRhbGliLmpzIC1jIC1tIC1vIGRhdGFsaWIubWluLmpzXCJcbiAgfSxcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcImJ1ZmZlclwiOiBmYWxzZSxcbiAgICBcImZzXCI6IGZhbHNlLFxuICAgIFwiaHR0cFwiOiBmYWxzZSxcbiAgICBcInJlcXVlc3RcIjogZmFsc2UsXG4gICAgXCJzeW5jLXJlcXVlc3RcIjogZmFsc2UsXG4gICAgXCJ1cmxcIjogZmFsc2VcbiAgfVxufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyksXG4gICAgdXRjID0gdGltZS51dGM7XG5cbnZhciB1ID0gbW9kdWxlLmV4cG9ydHM7XG5cbnUuJHllYXIgICA9IHV0aWwuJGZ1bmMoJ3llYXInLCB0aW1lLnllYXIudW5pdCk7XG51LiRtb250aCAgPSB1dGlsLiRmdW5jKCdtb250aCcsIHRpbWUubW9udGhzLnVuaXQpO1xudS4kZGF0ZSAgID0gdXRpbC4kZnVuYygnZGF0ZScsIHRpbWUuZGF0ZXMudW5pdCk7XG51LiRkYXkgICAgPSB1dGlsLiRmdW5jKCdkYXknLCB0aW1lLndlZWtkYXlzLnVuaXQpO1xudS4kaG91ciAgID0gdXRpbC4kZnVuYygnaG91cicsIHRpbWUuaG91cnMudW5pdCk7XG51LiRtaW51dGUgPSB1dGlsLiRmdW5jKCdtaW51dGUnLCB0aW1lLm1pbnV0ZXMudW5pdCk7XG51LiRzZWNvbmQgPSB1dGlsLiRmdW5jKCdzZWNvbmQnLCB0aW1lLnNlY29uZHMudW5pdCk7XG5cbnUuJHV0Y1llYXIgICA9IHV0aWwuJGZ1bmMoJ3V0Y1llYXInLCB1dGMueWVhci51bml0KTtcbnUuJHV0Y01vbnRoICA9IHV0aWwuJGZ1bmMoJ3V0Y01vbnRoJywgdXRjLm1vbnRocy51bml0KTtcbnUuJHV0Y0RhdGUgICA9IHV0aWwuJGZ1bmMoJ3V0Y0RhdGUnLCB1dGMuZGF0ZXMudW5pdCk7XG51LiR1dGNEYXkgICAgPSB1dGlsLiRmdW5jKCd1dGNEYXknLCB1dGMud2Vla2RheXMudW5pdCk7XG51LiR1dGNIb3VyICAgPSB1dGlsLiRmdW5jKCd1dGNIb3VyJywgdXRjLmhvdXJzLnVuaXQpO1xudS4kdXRjTWludXRlID0gdXRpbC4kZnVuYygndXRjTWludXRlJywgdXRjLm1pbnV0ZXMudW5pdCk7XG51LiR1dGNTZWNvbmQgPSB1dGlsLiRmdW5jKCd1dGNTZWNvbmQnLCB1dGMuc2Vjb25kcy51bml0KTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIE1lYXN1cmVzID0gcmVxdWlyZSgnLi9tZWFzdXJlcycpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4vY29sbGVjdG9yJyk7XG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0b3IoKSB7XG4gIHRoaXMuX2NlbGxzID0ge307XG4gIHRoaXMuX2FnZ3IgPSBbXTtcbiAgdGhpcy5fc3RyZWFtID0gZmFsc2U7XG59XG5cbnZhciBGbGFncyA9IEFnZ3JlZ2F0b3IuRmxhZ3MgPSB7XG4gIEFERF9DRUxMOiAxLFxuICBNT0RfQ0VMTDogMlxufTtcblxudmFyIHByb3RvID0gQWdncmVnYXRvci5wcm90b3R5cGU7XG5cbi8vIFBhcmFtZXRlcnNcblxucHJvdG8uc3RyZWFtID0gZnVuY3Rpb24odikge1xuICBpZiAodiA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3RyZWFtO1xuICB0aGlzLl9zdHJlYW0gPSAhIXY7XG4gIHRoaXMuX2FnZ3IgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBrZXkgYWNjZXNzb3IgdG8gdXNlIGZvciBzdHJlYW1pbmcgcmVtb3Zlc1xucHJvdG8ua2V5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX2tleTtcbiAgdGhpcy5fa2V5ID0gdXRpbC4kKGtleSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gSW5wdXQ6IGFycmF5IG9mIG9iamVjdHMgb2YgdGhlIGZvcm1cbi8vIHtuYW1lOiBzdHJpbmcsIGdldDogZnVuY3Rpb259XG5wcm90by5ncm91cGJ5ID0gZnVuY3Rpb24oZGltcykge1xuICB0aGlzLl9kaW1zID0gdXRpbC5hcnJheShkaW1zKS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgIGQgPSB1dGlsLmlzU3RyaW5nKGQpID8ge25hbWU6IGQsIGdldDogdXRpbC4kKGQpfVxuICAgICAgOiB1dGlsLmlzRnVuY3Rpb24oZCkgPyB7bmFtZTogdXRpbC5uYW1lKGQpIHx8IGQubmFtZSB8fCAoJ18nICsgaSksIGdldDogZH1cbiAgICAgIDogKGQubmFtZSAmJiB1dGlsLmlzRnVuY3Rpb24oZC5nZXQpKSA/IGQgOiBudWxsO1xuICAgIGlmIChkID09IG51bGwpIHRocm93ICdJbnZhbGlkIGdyb3VwYnkgYXJndW1lbnQ6ICcgKyBkO1xuICAgIHJldHVybiBkO1xuICB9KTtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbn07XG5cbi8vIElucHV0OiBhcnJheSBvZiBvYmplY3RzIG9mIHRoZSBmb3JtXG4vLyB7bmFtZTogc3RyaW5nLCBvcHM6IFtzdHJpbmcsIC4uLl19XG5wcm90by5zdW1tYXJpemUgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgZmllbGRzID0gc3VtbWFyaXplX2FyZ3MoZmllbGRzKTtcbiAgdGhpcy5fY291bnQgPSB0cnVlO1xuICB2YXIgYWdnciA9ICh0aGlzLl9hZ2dyID0gW10pLFxuICAgICAgbSwgZiwgaSwgaiwgb3AsIGFzLCBnZXQ7XG5cbiAgZm9yIChpPTA7IGk8ZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgZm9yIChqPTAsIG09W10sIGY9ZmllbGRzW2ldOyBqPGYub3BzLmxlbmd0aDsgKytqKSB7XG4gICAgICBvcCA9IGYub3BzW2pdO1xuICAgICAgaWYgKG9wICE9PSAnY291bnQnKSB0aGlzLl9jb3VudCA9IGZhbHNlO1xuICAgICAgYXMgPSAoZi5hcyAmJiBmLmFzW2pdKSB8fCAob3AgKyAoZi5uYW1lPT09JyonID8gJycgOiAnXycrZi5uYW1lKSk7XG4gICAgICBtLnB1c2goTWVhc3VyZXNbb3BdKGFzKSk7XG4gICAgfVxuICAgIGdldCA9IGYuZ2V0ICYmIHV0aWwuJChmLmdldCkgfHxcbiAgICAgIChmLm5hbWUgPT09ICcqJyA/IHV0aWwuaWRlbnRpdHkgOiB1dGlsLiQoZi5uYW1lKSk7XG4gICAgYWdnci5wdXNoKHtcbiAgICAgIG5hbWU6IGYubmFtZSxcbiAgICAgIG1lYXN1cmVzOiBNZWFzdXJlcy5jcmVhdGUoXG4gICAgICAgIG0sXG4gICAgICAgIHRoaXMuX3N0cmVhbSwgLy8gc3RyZWFtaW5nIHJlbW92ZSBmbGFnXG4gICAgICAgIGdldCwgICAgICAgICAgLy8gaW5wdXQgdHVwbGUgZ2V0dGVyXG4gICAgICAgIHRoaXMuX2Fzc2lnbikgLy8gb3V0cHV0IHR1cGxlIHNldHRlclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLmNsZWFyKCk7XG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gc3VtbWFyaXplIGJ5IGNvdW50XG5wcm90by5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdW1tYXJpemUoeycqJzonY291bnQnfSk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSB2YWx1ZSBhc3NpZ25tZW50XG5wcm90by5fYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICBvYmplY3RbbmFtZV0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHN1bW1hcml6ZV9hcmdzKGZpZWxkcykge1xuICBpZiAodXRpbC5pc0FycmF5KGZpZWxkcykpIHsgcmV0dXJuIGZpZWxkczsgfVxuICBpZiAoZmllbGRzID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIHZhciBhID0gW10sIG5hbWUsIG9wcztcbiAgZm9yIChuYW1lIGluIGZpZWxkcykge1xuICAgIG9wcyA9IHV0aWwuYXJyYXkoZmllbGRzW25hbWVdKTtcbiAgICBhLnB1c2goe25hbWU6IG5hbWUsIG9wczogb3BzfSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vIENlbGwgTWFuYWdlbWVudFxuXG5wcm90by5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2NlbGxzID0ge30sIHRoaXMpO1xufTtcblxucHJvdG8uX2NlbGxrZXkgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBkID0gdGhpcy5fZGltcyxcbiAgICAgIG4gPSBkLmxlbmd0aCwgaSxcbiAgICAgIGsgPSBTdHJpbmcoZFswXS5nZXQoeCkpO1xuICBmb3IgKGk9MTsgaTxuOyArK2kpIHtcbiAgICBrICs9ICd8JyArIGRbaV0uZ2V0KHgpO1xuICB9XG4gIHJldHVybiBrO1xufTtcblxucHJvdG8uX2NlbGwgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXkgPSB0aGlzLl9kaW1zLmxlbmd0aCA/IHRoaXMuX2NlbGxrZXkoeCkgOiAnJztcbiAgcmV0dXJuIHRoaXMuX2NlbGxzW2tleV0gfHwgKHRoaXMuX2NlbGxzW2tleV0gPSB0aGlzLl9uZXdjZWxsKHgsIGtleSkpO1xufTtcblxucHJvdG8uX25ld2NlbGwgPSBmdW5jdGlvbih4LCBrZXkpIHtcbiAgdmFyIGNlbGwgPSB7XG4gICAgbnVtOiAgIDAsXG4gICAgdHVwbGU6IHRoaXMuX25ld3R1cGxlKHgsIGtleSksXG4gICAgZmxhZzogIEZsYWdzLkFERF9DRUxMLFxuICAgIGFnZ3M6ICB7fVxuICB9O1xuXG4gIHZhciBhZ2dyID0gdGhpcy5fYWdnciwgaTtcbiAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdID0gbmV3IGFnZ3JbaV0ubWVhc3VyZXMoY2VsbCwgY2VsbC50dXBsZSk7XG4gIH1cbiAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgIGNlbGwuZGF0YSA9IG5ldyBDb2xsZWN0b3IodGhpcy5fa2V5KTtcbiAgfVxuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9uZXd0dXBsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgdCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj1kaW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB0W2RpbXNbaV0ubmFtZV0gPSBkaW1zW2ldLmdldCh4KTtcbiAgfVxuICByZXR1cm4gdGhpcy5faW5nZXN0KHQpO1xufTtcblxuLy8gT3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gdHVwbGUgaW5nZXN0aW9uXG5wcm90by5faW5nZXN0ID0gdXRpbC5pZGVudGl0eTtcblxuLy8gUHJvY2VzcyBUdXBsZXNcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgY2VsbC5udW0gKz0gMTtcbiAgaWYgKCF0aGlzLl9jb3VudCkgeyAvLyBza2lwIGlmIGNvdW50LW9ubHlcbiAgICBpZiAoY2VsbC5jb2xsZWN0KSBjZWxsLmRhdGEuYWRkKHgpO1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLmFkZCh4KTtcbiAgICB9XG4gIH1cbiAgY2VsbC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBpZiAodGhpcy5fb25fYWRkKSB0aGlzLl9vbl9hZGQoeCwgY2VsbCk7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSAtPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5yZW0oeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0ucmVtKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG4gIGlmICh0aGlzLl9vbl9yZW0pIHRoaXMuX29uX3JlbSh4LCBjZWxsKTtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbihjdXJyLCBwcmV2KSB7XG4gIHZhciBjZWxsMCA9IHRoaXMuX2NlbGwocHJldiksXG4gICAgICBjZWxsMSA9IHRoaXMuX2NlbGwoY3VyciksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBpZiAoY2VsbDAgIT09IGNlbGwxKSB7XG4gICAgY2VsbDAubnVtIC09IDE7XG4gICAgY2VsbDEubnVtICs9IDE7XG4gICAgaWYgKGNlbGwwLmNvbGxlY3QpIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGlmIChjZWxsMS5jb2xsZWN0KSBjZWxsMS5kYXRhLmFkZChjdXJyKTtcbiAgfSBlbHNlIGlmIChjZWxsMC5jb2xsZWN0ICYmICF1dGlsLmlzT2JqZWN0KGN1cnIpKSB7XG4gICAgY2VsbDAuZGF0YS5yZW0ocHJldik7XG4gICAgY2VsbDAuZGF0YS5hZGQoY3Vycik7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbDAuYWdnc1thZ2dyW2ldLm5hbWVdLnJlbShwcmV2KTtcbiAgICBjZWxsMS5hZ2dzW2FnZ3JbaV0ubmFtZV0uYWRkKGN1cnIpO1xuICB9XG4gIGNlbGwwLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG4gIGNlbGwxLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG4gIGlmICh0aGlzLl9vbl9tb2QpIHRoaXMuX29uX21vZChjdXJyLCBwcmV2LCBjZWxsMCwgY2VsbDEpO1xufTtcblxucHJvdG8uX21hcmtNb2QgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsMCA9IHRoaXMuX2NlbGwoeCk7XG4gIGNlbGwwLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZiAoY2VsbC5udW0gPiAwKSB7XG4gICAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgICAgfVxuICAgICAgLy8gYWRkIG91dHB1dCB0dXBsZVxuICAgICAgcmVzdWx0LnB1c2goY2VsbC50dXBsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trXTtcbiAgICB9XG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnByb3RvLmNoYW5nZXMgPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgdmFyIGNoYW5nZXMgPSBvdXRwdXQgfHwge2FkZDpbXSwgcmVtOltdLCBtb2Q6W119LFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBmbGFnLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBmbGFnID0gY2VsbC5mbGFnO1xuXG4gICAgLy8gY29uc29saWRhdGUgY29sbGVjdG9yIHZhbHVlc1xuICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgIH1cblxuICAgIC8vIG9yZ2FuaXplIG91dHB1dCB0dXBsZXNcbiAgICBpZiAoY2VsbC5udW0gPD0gMCkge1xuICAgICAgY2hhbmdlcy5yZW0ucHVzaChjZWxsLnR1cGxlKTsgLy8gaWYgKGZsYWcgPT09IEZsYWdzLk1PRF9DRUxMKSB7ID8/XG4gICAgICBkZWxldGUgdGhpcy5fY2VsbHNba107XG4gICAgICBpZiAodGhpcy5fb25fZHJvcCkgdGhpcy5fb25fZHJvcChjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX29uX2tlZXApIHRoaXMuX29uX2tlZXAoY2VsbCk7XG4gICAgICBpZiAoZmxhZyAmIEZsYWdzLkFERF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMuYWRkLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWcgJiBGbGFncy5NT0RfQ0VMTCkge1xuICAgICAgICBjaGFuZ2VzLm1vZC5wdXNoKGNlbGwudHVwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNlbGwuZmxhZyA9IDA7XG4gIH1cblxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG4gIHJldHVybiBjaGFuZ2VzO1xufTtcblxucHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiB0aGlzLmNsZWFyKCkuaW5zZXJ0KGlucHV0KS5yZXN1bHQoKTtcbn07XG5cbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHRoaXMuX2NvbnNvbGlkYXRlKCk7XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX2FkZChpbnB1dFtpXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZiAoIXRoaXMuX3N0cmVhbSkge1xuICAgIHRocm93ICdBZ2dyZWdhdG9yIG5vdCBjb25maWd1cmVkIGZvciBzdHJlYW1pbmcgcmVtb3Zlcy4nICtcbiAgICAgICcgQ2FsbCBzdHJlYW0odHJ1ZSkgcHJpb3IgdG8gY2FsbGluZyBzdW1tYXJpemUuJztcbiAgfVxuICBmb3IgKHZhciBpPTA7IGk8aW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9yZW0oaW5wdXRbaV0pO1xuICB9XG4gIHRoaXMuX3JlbXMgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGNvbnNvbGlkYXRlIHJlbW92YWxzXG5wcm90by5fY29uc29saWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLl9yZW1zKSByZXR1cm47XG4gIGZvciAodmFyIGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBpZiAodGhpcy5fY2VsbHNba10uY29sbGVjdCkge1xuICAgICAgdGhpcy5fY2VsbHNba10uZGF0YS52YWx1ZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgUkVNID0gJ19fZGxfcmVtX18nO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3Ioa2V5KSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fa2V5ID0ga2V5IHx8IG51bGw7XG4gIHRoaXMuX2xhc3QgPSBudWxsO1xufVxuXG52YXIgcHJvdG8gPSBDb2xsZWN0b3IucHJvdG90eXBlO1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2FkZDtcblxuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgeCA9IEFycmF5KGEubGVuZ3RoIC0gci5sZW5ndGgpLFxuICAgICAgaSwgaiwgbiwgbTtcblxuICBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzaW5nIHJhdyB2YWx1ZXNcbiAgICBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaykge1xuICAgIC8vIGhhcyB1bmlxdWUga2V5IGZpZWxkLCBzbyB1c2UgdGhhdFxuICAgIG0gPSB1dGlsLnRvTWFwKHIsIGspO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoayhhW2ldKSkpIHsgeFtqKytdID0gYVtpXTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyB1bmlxdWUga2V5LCBtYXJrIHR1cGxlcyBkaXJlY3RseVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgcltpXVtSRU1dID0gMTtcbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghYVtpXVtSRU1dKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZWxldGUgcltpXVtSRU1dO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG4gIHJldHVybiB0aGlzLl9leHQ7XG59O1xuXG5wcm90by5hcmdtaW4gPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50KGdldClbMF07XG59O1xuXG5wcm90by5hcmdtYXggPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50KGdldClbMV07XG59O1xuXG5wcm90by5taW4gPSBmdW5jdGlvbihnZXQpIHtcbiAgdmFyIG0gPSB0aGlzLmV4dGVudChnZXQpWzBdO1xuICByZXR1cm4gbSAhPSBudWxsID8gZ2V0KG0pIDogK0luZmluaXR5O1xufTtcblxucHJvdG8ubWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbiAgcmV0dXJuIG0gIT0gbnVsbCA/IGdldChtKSA6IC1JbmZpbml0eTtcbn07XG5cbnByb3RvLnF1YXJ0aWxlID0gZnVuY3Rpb24oZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fcSkge1xuICAgIHRoaXMuX3EgPSBzdGF0cy5xdWFydGlsZSh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuICByZXR1cm4gdGhpcy5fcTtcbn07XG5cbnByb3RvLnExID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMF07XG59O1xuXG5wcm90by5xMiA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzFdO1xufTtcblxucHJvdG8ucTMgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsyXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdG9yO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vYWdncmVnYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBmbGF0dGVuIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gIHZhciBhcmdzID0gW10ucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCB4KSB7XG4gICAgcmV0dXJuIGEuY29uY2F0KHV0aWwuYXJyYXkoeCkpO1xuICB9LCBbXSk7XG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFuIGFnZ3JlZ2F0b3JcbiAgcmV0dXJuIG5ldyBBZ2dyZWdhdG9yKClcbiAgICAuZ3JvdXBieShhcmdzKVxuICAgIC5zdW1tYXJpemUoeycqJzondmFsdWVzJ30pO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgdHlwZXMgPSB7XG4gICd2YWx1ZXMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsdWVzJyxcbiAgICBpbml0OiAnY2VsbC5jb2xsZWN0ID0gdHJ1ZTsnLFxuICAgIHNldDogICdjZWxsLmRhdGEudmFsdWVzKCknLCBpZHg6IC0xXG4gIH0pLFxuICAnY291bnQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnY291bnQnLFxuICAgIHNldDogICdjZWxsLm51bSdcbiAgfSksXG4gICdtaXNzaW5nJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21pc3NpbmcnLFxuICAgIHNldDogICd0aGlzLm1pc3NpbmcnXG4gIH0pLFxuICAndmFsaWQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsaWQnLFxuICAgIHNldDogICd0aGlzLnZhbGlkJ1xuICB9KSxcbiAgJ3N1bSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdW0nLFxuICAgIGluaXQ6ICd0aGlzLnN1bSA9IDA7JyxcbiAgICBhZGQ6ICAndGhpcy5zdW0gKz0gdjsnLFxuICAgIHJlbTogICd0aGlzLnN1bSAtPSB2OycsXG4gICAgc2V0OiAgJ3RoaXMuc3VtJ1xuICB9KSxcbiAgJ21lYW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWVhbicsXG4gICAgaW5pdDogJ3RoaXMubWVhbiA9IDA7JyxcbiAgICBhZGQ6ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gKz0gZCAvIHRoaXMudmFsaWQ7JyxcbiAgICByZW06ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gLT0gdGhpcy52YWxpZCA/IGQgLyB0aGlzLnZhbGlkIDogdGhpcy5tZWFuOycsXG4gICAgc2V0OiAgJ3RoaXMubWVhbidcbiAgfSksXG4gICdhdmVyYWdlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2F2ZXJhZ2UnLFxuICAgIHNldDogICd0aGlzLm1lYW4nLFxuICAgIHJlcTogIFsnbWVhbiddLCBpZHg6IDFcbiAgfSksXG4gICd2YXJpYW5jZSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZScsXG4gICAgaW5pdDogJ3RoaXMuZGV2ID0gMDsnLFxuICAgIGFkZDogICd0aGlzLmRldiArPSBkICogKHYgLSB0aGlzLm1lYW4pOycsXG4gICAgcmVtOiAgJ3RoaXMuZGV2IC09IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCA+IDEgPyB0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpIDogMCcsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlcCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZXAnLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IHRoaXMuZGV2IC8gdGhpcy52YWxpZCA6IDAnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXYnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXYnLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IE1hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpKSA6IDAnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXZwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N0ZGV2cCcsXG4gICAgc2V0OiAgJ3RoaXMudmFsaWQgPiAxID8gTWF0aC5zcXJ0KHRoaXMuZGV2IC8gdGhpcy52YWxpZCkgOiAwJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ3N0ZGVycic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRlcnInLFxuICAgIHNldDogICd0aGlzLnZhbGlkID4gMSA/IE1hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLnZhbGlkICogKHRoaXMudmFsaWQtMSkpKSA6IDAnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnbWVkaWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lZGlhbicsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMih0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3ExJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ExJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnExKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTMnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTModGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdkaXN0aW5jdCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdkaXN0aW5jdCcsXG4gICAgc2V0OiAgJ3RoaXMuZGlzdGluY3QoY2VsbC5kYXRhLnZhbHVlcygpLCB0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtaW4nLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLmFyZ21pbiA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMuYXJnbWluID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21pbiA9IHRoaXMuYXJnbWluIHx8IGNlbGwuZGF0YS5hcmdtaW4odGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21pbiddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtYXgnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLmFyZ21heCA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21heCA9IHRoaXMuYXJnbWF4IHx8IGNlbGwuZGF0YS5hcmdtYXgodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21heCddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaW4nLFxuICAgIGluaXQ6ICd0aGlzLm1pbiA9ICtJbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLm1pbiA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMubWluID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWluID0gKGlzTmFOKHRoaXMubWluKSA/IGNlbGwuZGF0YS5taW4odGhpcy5nZXQpIDogdGhpcy5taW4pJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWF4JyxcbiAgICBpbml0OiAndGhpcy5tYXggPSAtSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5tYXggPSB2OycsXG4gICAgcmVtOiAgJ2lmICh2ID49IHRoaXMubWF4KSB0aGlzLm1heCA9IE5hTjsnLFxuICAgIHNldDogICd0aGlzLm1heCA9IChpc05hTih0aGlzLm1heCkgPyBjZWxsLmRhdGEubWF4KHRoaXMuZ2V0KSA6IHRoaXMubWF4KScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbW9kZXNrZXcnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbW9kZXNrZXcnLFxuICAgIHNldDogICd0aGlzLmRldj09PTAgPyAwIDogKHRoaXMubWVhbiAtIGNlbGwuZGF0YS5xMih0aGlzLmdldCkpIC8gTWF0aC5zcXJ0KHRoaXMuZGV2Lyh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWydtZWFuJywgJ3ZhcmlhbmNlJywgJ21lZGlhbiddLCBpZHg6IDVcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIG1lYXN1cmUoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG0gPSB1dGlsLmV4dGVuZCh7aW5pdDonJywgYWRkOicnLCByZW06JycsIGlkeDowfSwgYmFzZSk7XG4gICAgbS5vdXQgPSBvdXQgfHwgYmFzZS5uYW1lO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZywgc3RyZWFtKSB7XG4gIGZ1bmN0aW9uIGNvbGxlY3QobSwgYSkge1xuICAgIGZ1bmN0aW9uIGhlbHBlcihyKSB7IGlmICghbVtyXSkgY29sbGVjdChtLCBtW3JdID0gdHlwZXNbcl0oKSk7IH1cbiAgICBpZiAoYS5yZXEpIGEucmVxLmZvckVhY2goaGVscGVyKTtcbiAgICBpZiAoc3RyZWFtICYmIGEuc3RyKSBhLnN0ci5mb3JFYWNoKGhlbHBlcik7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgdmFyIG1hcCA9IGFnZy5yZWR1Y2UoXG4gICAgY29sbGVjdCxcbiAgICBhZ2cucmVkdWNlKGZ1bmN0aW9uKG0sIGEpIHsgcmV0dXJuIChtW2EubmFtZV0gPSBhLCBtKTsgfSwge30pXG4gICk7XG4gIHJldHVybiB1dGlsLnZhbHMobWFwKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoYWdnLCBzdHJlYW0sIGFjY2Vzc29yLCBtdXRhdG9yKSB7XG4gIHZhciBhbGwgPSByZXNvbHZlKGFnZywgc3RyZWFtKSxcbiAgICAgIGN0ciA9ICd0aGlzLmNlbGwgPSBjZWxsOyB0aGlzLnR1cGxlID0gdDsgdGhpcy52YWxpZCA9IDA7IHRoaXMubWlzc2luZyA9IDA7JyxcbiAgICAgIGFkZCA9ICdpZiAodj09bnVsbCkgdGhpcy5taXNzaW5nKys7IGlmICghdGhpcy5pc1ZhbGlkKHYpKSByZXR1cm47ICsrdGhpcy52YWxpZDsnLFxuICAgICAgcmVtID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmctLTsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgLS10aGlzLnZhbGlkOycsXG4gICAgICBzZXQgPSAndmFyIHQgPSB0aGlzLnR1cGxlOyB2YXIgY2VsbCA9IHRoaXMuY2VsbDsnO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYS5pZHggPCAwKSB7XG4gICAgICBjdHIgPSBhLmluaXQgKyBjdHI7XG4gICAgICBhZGQgPSBhLmFkZCArIGFkZDtcbiAgICAgIHJlbSA9IGEucmVtICsgcmVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHIgKz0gYS5pbml0O1xuICAgICAgYWRkICs9IGEuYWRkO1xuICAgICAgcmVtICs9IGEucmVtO1xuICAgIH1cbiAgfSk7XG4gIGFnZy5zbGljZSgpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBzZXQgKz0gJ3RoaXMuYXNzaWduKHQsXFwnJythLm91dCsnXFwnLCcrYS5zZXQrJyk7JztcbiAgICB9KTtcbiAgc2V0ICs9ICdyZXR1cm4gdDsnO1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIGN0ciA9IEZ1bmN0aW9uKCdjZWxsJywgJ3QnLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFzc2lnbiA9IG11dGF0b3I7XG4gIGN0ci5wcm90b3R5cGUuYWRkID0gRnVuY3Rpb24oJ3QnLCAndmFyIHYgPSB0aGlzLmdldCh0KTsnICsgYWRkKTtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKHNldCk7XG4gIGN0ci5wcm90b3R5cGUuZ2V0ID0gYWNjZXNzb3I7XG4gIGN0ci5wcm90b3R5cGUuZGlzdGluY3QgPSByZXF1aXJlKCcuLi9zdGF0cycpLmNvdW50LmRpc3RpbmN0O1xuICBjdHIucHJvdG90eXBlLmlzVmFsaWQgPSB1dGlsLmlzVmFsaWQ7XG4gIGN0ci5maWVsZHMgPSBhZ2cubWFwKHV0aWwuJCgnb3V0JykpO1xuICByZXR1cm4gY3RyO1xufVxuXG50eXBlcy5jcmVhdGUgPSBjcmVhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgdGltZSA9IHJlcXVpcmUoJy4uL3RpbWUnKSxcbiAgICBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIGlmICghb3B0KSB7IHRocm93IEVycm9yKFwiTWlzc2luZyBiaW5uaW5nIG9wdGlvbnMuXCIpOyB9XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSxcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcblxuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgd2hpbGUgKE1hdGguY2VpbChzcGFuL3N0ZXApID4gbWF4YikgeyBzdGVwICo9IGJhc2U7IH1cblxuICAgIC8vIGRlY3JlYXNlIHN0ZXAgc2l6ZSBpZiBhbGxvd2VkXG4gICAgZm9yIChpPTA7IGk8ZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcCk7XG4gIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbWluLFxuICAgIHN0b3A6ICBtYXgsXG4gICAgc3RlcDogIHN0ZXAsXG4gICAgdW5pdDogIHtwcmVjaXNpb246IHByZWNpc2lvbn0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGluZGV4OiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdmFsdWUodikge1xuICByZXR1cm4gdGhpcy5zdGVwICogTWF0aC5mbG9vcih2IC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHYpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHYgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBkYXRlX3ZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMudW5pdC5kYXRlKHZhbHVlLmNhbGwodGhpcywgdikpO1xufVxuXG5mdW5jdGlvbiBkYXRlX2luZGV4KHYpIHtcbiAgcmV0dXJuIGluZGV4LmNhbGwodGhpcywgdGhpcy51bml0LnVuaXQodikpO1xufVxuXG5iaW5zLmRhdGUgPSBmdW5jdGlvbihvcHQpIHtcbiAgaWYgKCFvcHQpIHsgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIGRhdGUgYmlubmluZyBvcHRpb25zLlwiKTsgfVxuXG4gIC8vIGZpbmQgdGltZSBzdGVwLCB0aGVuIGJpblxuICB2YXIgdW5pdHMgPSBvcHQudXRjID8gdGltZS51dGMgOiB0aW1lLFxuICAgICAgZG1pbiA9IG9wdC5taW4sXG4gICAgICBkbWF4ID0gb3B0Lm1heCxcbiAgICAgIG1heGIgPSBvcHQubWF4YmlucyB8fCAyMCxcbiAgICAgIG1pbmIgPSBvcHQubWluYmlucyB8fCA0LFxuICAgICAgc3BhbiA9ICgrZG1heCkgLSAoK2RtaW4pLFxuICAgICAgdW5pdCA9IG9wdC51bml0ID8gdW5pdHNbb3B0LnVuaXRdIDogdW5pdHMuZmluZChzcGFuLCBtaW5iLCBtYXhiKSxcbiAgICAgIHNwZWMgPSBiaW5zKHtcbiAgICAgICAgbWluOiAgICAgdW5pdC5taW4gIT0gbnVsbCA/IHVuaXQubWluIDogdW5pdC51bml0KGRtaW4pLFxuICAgICAgICBtYXg6ICAgICB1bml0Lm1heCAhPSBudWxsID8gdW5pdC5tYXggOiB1bml0LnVuaXQoZG1heCksXG4gICAgICAgIG1heGJpbnM6IG1heGIsXG4gICAgICAgIG1pbnN0ZXA6IHVuaXQubWluc3RlcCxcbiAgICAgICAgc3RlcHM6ICAgdW5pdC5zdGVwXG4gICAgICB9KTtcblxuICBzcGVjLnVuaXQgPSB1bml0O1xuICBzcGVjLmluZGV4ID0gZGF0ZV9pbmRleDtcbiAgaWYgKCFvcHQucmF3KSBzcGVjLnZhbHVlID0gZGF0ZV92YWx1ZTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbnM7XG4iLCJ2YXIgYmlucyA9IHJlcXVpcmUoJy4vYmlucycpLFxuICAgIGdlbiAgPSByZXF1aXJlKCcuLi9nZW5lcmF0ZScpLFxuICAgIHR5cGUgPSByZXF1aXJlKCcuLi9pbXBvcnQvdHlwZScpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgcXR5cGUgPSB7XG4gICdpbnRlZ2VyJzogMSxcbiAgJ251bWJlcic6IDEsXG4gICdkYXRlJzogMVxufTtcblxuZnVuY3Rpb24gJGJpbih2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiAhYiA/IChvcHQuYWNjZXNzb3IgfHwgdXRpbC5pZGVudGl0eSkgOlxuICAgIHV0aWwuJGZ1bmMoJ2JpbicsIGIudW5pdC51bml0ID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoYi51bml0LnVuaXQoeCkpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoeCk7IH1cbiAgICApKG9wdC5hY2Nlc3Nvcik7XG59XG5cbmZ1bmN0aW9uIGhpc3RvZ3JhbSh2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiBiID9cbiAgICBudW1lcmljYWwodmFsdWVzLCBvcHQuYWNjZXNzb3IsIGIpIDpcbiAgICBjYXRlZ29yaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3Nvciwgb3B0ICYmIG9wdC5zb3J0KTtcbn1cblxuZnVuY3Rpb24gc3BlYyhvcHQpIHtcbiAgdmFyIHQgPSBvcHQudHlwZSwgYiA9IG51bGw7XG4gIGlmICh0ID09IG51bGwgfHwgcXR5cGVbdF0pIHtcbiAgICBpZiAodCA9PT0gJ2ludGVnZXInICYmIG9wdC5taW5zdGVwID09IG51bGwpIG9wdC5taW5zdGVwID0gMTtcbiAgICBiID0gKHQgPT09ICdkYXRlJykgPyBiaW5zLmRhdGUob3B0KSA6IGJpbnMob3B0KTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICBpID0gMCxcbiAgICAgIHZhbHVlcyA9IHV0aWwuaXNBcnJheShhW2ldKSA/IGFbaSsrXSA6IG51bGwsXG4gICAgICBmID0gdXRpbC5pc0Z1bmN0aW9uKGFbaV0pIHx8IHV0aWwuaXNTdHJpbmcoYVtpXSkgPyB1dGlsLiQoYVtpKytdKSA6IG51bGwsXG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7fSwgYVtpXSk7XG5cbiAgaWYgKHZhbHVlcykge1xuICAgIG9wdC50eXBlID0gb3B0LnR5cGUgfHwgdHlwZSh2YWx1ZXMsIGYpO1xuICAgIGlmIChxdHlwZVtvcHQudHlwZV0pIHtcbiAgICAgIHZhciBleHQgPSBzdGF0cy5leHRlbnQodmFsdWVzLCBmKTtcbiAgICAgIG9wdCA9IHV0aWwuZXh0ZW5kKHttaW46IGV4dFswXSwgbWF4OiBleHRbMV19LCBvcHQpO1xuICAgIH1cbiAgfVxuICBpZiAoZikgeyBvcHQuYWNjZXNzb3IgPSBmOyB9XG4gIHJldHVybiBvcHQ7XG59XG5cbmZ1bmN0aW9uIG51bWVyaWNhbCh2YWx1ZXMsIGYsIGIpIHtcbiAgdmFyIGggPSBnZW4ucmFuZ2UoYi5zdGFydCwgYi5zdG9wICsgYi5zdGVwLzIsIGIuc3RlcClcbiAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHt2YWx1ZTogYi52YWx1ZSh2KSwgY291bnQ6IDB9OyB9KTtcblxuICBmb3IgKHZhciBpPTAsIHYsIGo7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaiA9IGIuaW5kZXgodik7XG4gICAgICBpZiAoaiA8IDAgfHwgaiA+PSBoLmxlbmd0aCB8fCAhaXNGaW5pdGUoaikpIGNvbnRpbnVlO1xuICAgICAgaFtqXS5jb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICBoLmJpbnMgPSBiO1xuICByZXR1cm4gaDtcbn1cblxuZnVuY3Rpb24gY2F0ZWdvcmljYWwodmFsdWVzLCBmLCBzb3J0KSB7XG4gIHZhciB1ID0gc3RhdHMudW5pcXVlKHZhbHVlcywgZiksXG4gICAgICBjID0gc3RhdHMuY291bnQubWFwKHZhbHVlcywgZik7XG4gIHJldHVybiB1Lm1hcChmdW5jdGlvbihrKSB7IHJldHVybiB7dmFsdWU6IGssIGNvdW50OiBjW2tdfTsgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3Ioc29ydCA/ICctY291bnQnIDogJyt2YWx1ZScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICRiaW46ICRiaW4sXG4gIGhpc3RvZ3JhbTogaGlzdG9ncmFtXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICB0eXBlID0gcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpLFxuICAgIHN0YXRzID0gcmVxdWlyZSgnLi9zdGF0cycpLFxuICAgIHRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdGFibGU6ICAgZm9ybWF0VGFibGUsICAvLyBmb3JtYXQgYSBkYXRhIHRhYmxlXG4gIHN1bW1hcnk6IGZvcm1hdFN1bW1hcnkgLy8gZm9ybWF0IGEgZGF0YSB0YWJsZSBzdW1tYXJ5XG59O1xuXG52YXIgRk1UID0ge1xuICAnZGF0ZSc6ICAgICd8dGltZTpcIiVtLyVkLyVZICVIOiVNOiVTXCInLFxuICAnbnVtYmVyJzogICd8bnVtYmVyOlwiLjRmXCInLFxuICAnaW50ZWdlcic6ICd8bnVtYmVyOlwiZFwiJ1xufTtcblxudmFyIFBPUyA9IHtcbiAgJ251bWJlcic6ICAnbGVmdCcsXG4gICdpbnRlZ2VyJzogJ2xlZnQnXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRUYWJsZShkYXRhLCBvcHQpIHtcbiAgb3B0ID0gdXRpbC5leHRlbmQoe3NlcGFyYXRvcjonICcsIG1pbndpZHRoOiA4LCBtYXh3aWR0aDogMTV9LCBvcHQpO1xuICB2YXIgZmllbGRzID0gb3B0LmZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSksXG4gICAgICB0eXBlcyA9IHR5cGUuYWxsKGRhdGEpO1xuXG4gIGlmIChvcHQuc3RhcnQgfHwgb3B0LmxpbWl0KSB7XG4gICAgdmFyIGEgPSBvcHQuc3RhcnQgfHwgMCxcbiAgICAgICAgYiA9IG9wdC5saW1pdCA/IGEgKyBvcHQubGltaXQgOiBkYXRhLmxlbmd0aDtcbiAgICBkYXRhID0gZGF0YS5zbGljZShhLCBiKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBjaGFyIHdpZHRoIG9mIGZpZWxkc1xuICB2YXIgbGVucyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmb3JtYXQgPSBGTVRbdHlwZXNbbmFtZV1dIHx8ICcnLFxuICAgICAgICB0ID0gdGVtcGxhdGUoJ3t7JyArIG5hbWUgKyBmb3JtYXQgKyAnfX0nKSxcbiAgICAgICAgbCA9IHN0YXRzLm1heChkYXRhLCBmdW5jdGlvbih4KSB7IHJldHVybiB0KHgpLmxlbmd0aDsgfSk7XG4gICAgbCA9IE1hdGgubWF4KE1hdGgubWluKG5hbWUubGVuZ3RoLCBvcHQubWlud2lkdGgpLCBsKTtcbiAgICByZXR1cm4gb3B0Lm1heHdpZHRoID4gMCA/IE1hdGgubWluKGwsIG9wdC5tYXh3aWR0aCkgOiBsO1xuICB9KTtcblxuICAvLyBwcmludCBoZWFkZXIgcm93XG4gIHZhciBoZWFkID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIHV0aWwudHJ1bmNhdGUodXRpbC5wYWQobmFtZSwgbGVuc1tpXSwgJ2NlbnRlcicpLCBsZW5zW2ldKTtcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKTtcblxuICAvLyBidWlsZCB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgZWFjaCByb3dcbiAgdmFyIHRtcGwgPSB0ZW1wbGF0ZShmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gJ3t7JyArXG4gICAgICBuYW1lICtcbiAgICAgIChGTVRbdHlwZXNbbmFtZV1dIHx8ICcnKSArXG4gICAgICAoJ3xwYWQ6JyArIGxlbnNbaV0gKyAnLCcgKyAoUE9TW3R5cGVzW25hbWVdXSB8fCAncmlnaHQnKSkgK1xuICAgICAgKCd8dHJ1bmNhdGU6JyArIGxlbnNbaV0pICtcbiAgICAnfX0nO1xuICB9KS5qb2luKG9wdC5zZXBhcmF0b3IpKTtcblxuICAvLyBwcmludCB0YWJsZVxuICByZXR1cm4gaGVhZCArIFwiXFxuXCIgKyBkYXRhLm1hcCh0bXBsKS5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U3VtbWFyeShzKSB7XG4gIHMgPSBzID8gcy5fX3N1bW1hcnlfXyA/IHMgOiBzdGF0cy5zdW1tYXJ5KHMpIDogdGhpcztcbiAgdmFyIHN0ciA9IFtdLCBpLCBuO1xuICBmb3IgKGk9MCwgbj1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBzdHIucHVzaCgnLS0gJyArIHNbaV0uZmllbGQgKyAnIC0tJyk7XG4gICAgaWYgKHNbaV0udHlwZSA9PT0gJ3N0cmluZycgfHwgc1tpXS5kaXN0aW5jdCA8IDEwKSB7XG4gICAgICBzdHIucHVzaChwcmludENhdGVnb3JpY2FsUHJvZmlsZShzW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ci5wdXNoKHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShzW2ldKSk7XG4gICAgfVxuICAgIHN0ci5wdXNoKCcnKTtcbiAgfVxuICByZXR1cm4gc3RyLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ21pbjogICAgICAnICsgcC5taW4sXG4gICAgJ21heDogICAgICAnICsgcC5tYXgsXG4gICAgJ21lZGlhbjogICAnICsgcC5tZWRpYW4sXG4gICAgJ21lYW46ICAgICAnICsgcC5tZWFuLFxuICAgICdzdGRldjogICAgJyArIHAuc3RkZXYsXG4gICAgJ21vZGVza2V3OiAnICsgcC5tb2Rlc2tld1xuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSB7XG4gIHZhciBsaXN0ID0gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ3RvcCB2YWx1ZXM6ICdcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnIFxcJycgKyB2ICsgJ1xcJyAoJyArIHVbdl0gKyAnKSc7IH0pO1xuICByZXR1cm4gbGlzdC5jb25jYXQodG9wKS5qb2luKCdcXG4nKTtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIGQzX3RpbWUgPSByZXF1aXJlKCdkMy10aW1lJyksXG4gICAgZDNfdGltZUYgPSByZXF1aXJlKCdkMy10aW1lLWZvcm1hdCcpLFxuICAgIGQzX251bWJlckYgPSByZXF1aXJlKCdkMy1mb3JtYXQnKSxcbiAgICBudW1iZXJGID0gZDNfbnVtYmVyRiwgLy8gZGVmYXVsdHMgdG8gRU4tVVNcbiAgICB0aW1lRiA9IGQzX3RpbWVGLCAgICAgLy8gZGVmYXVsdHMgdG8gRU4tVVNcbiAgICB0bXBEYXRlID0gbmV3IERhdGUoMjAwMCwgMCwgMSksXG4gICAgbW9udGhGdWxsLCBtb250aEFiYnIsIGRheUZ1bGwsIGRheUFiYnI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFVwZGF0ZSBudW1iZXIgZm9ybWF0dGVyIHRvIHVzZSBwcm92aWRlZCBsb2NhbGUgY29uZmlndXJhdGlvbi5cbiAgLy8gRm9yIG1vcmUgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1mb3JtYXRcbiAgbnVtYmVyTG9jYWxlOiBudW1iZXJMb2NhbGUsXG4gIG51bWJlcjogICAgICAgZnVuY3Rpb24oZikgeyByZXR1cm4gbnVtYmVyRi5mb3JtYXQoZik7IH0sXG4gIG51bWJlclByZWZpeDogZnVuY3Rpb24oZiwgdikgeyByZXR1cm4gbnVtYmVyRi5mb3JtYXRQcmVmaXgoZiwgdik7IH0sXG5cbiAgLy8gVXBkYXRlIHRpbWUgZm9ybWF0dGVyIHRvIHVzZSBwcm92aWRlZCBsb2NhbGUgY29uZmlndXJhdGlvbi5cbiAgLy8gRm9yIG1vcmUgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdFxuICB0aW1lTG9jYWxlOiAgIHRpbWVMb2NhbGUsXG4gIHRpbWU6ICAgICAgICAgZnVuY3Rpb24oZikgeyByZXR1cm4gdGltZUYuZm9ybWF0KGYpOyB9LFxuICB1dGM6ICAgICAgICAgIGZ1bmN0aW9uKGYpIHsgcmV0dXJuIHRpbWVGLnV0Y0Zvcm1hdChmKTsgfSxcblxuICAvLyBTZXQgbnVtYmVyIGFuZCB0aW1lIGxvY2FsZSBzaW11bHRhbmVvdXNseS5cbiAgbG9jYWxlOiAgICAgICBmdW5jdGlvbihsKSB7IG51bWJlckxvY2FsZShsKTsgdGltZUxvY2FsZShsKTsgfSxcblxuICAvLyBhdXRvbWF0aWMgZm9ybWF0dGluZyBmdW5jdGlvbnNcbiAgYXV0bzoge1xuICAgIG51bWJlcjogICBhdXRvTnVtYmVyRm9ybWF0LFxuICAgIGxpbmVhcjogICBsaW5lYXJOdW1iZXJGb3JtYXQsXG4gICAgdGltZTogICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gdGltZUF1dG9Gb3JtYXQoKTsgfSxcbiAgICB1dGM6ICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiB1dGNBdXRvRm9ybWF0KCk7IH1cbiAgfSxcblxuICBtb250aDogICAgICBtb250aEZvcm1hdCwgICAgICAvLyBmb3JtYXQgbW9udGggbmFtZSBmcm9tIGludGVnZXIgY29kZVxuICBkYXk6ICAgICAgICBkYXlGb3JtYXQsICAgICAgICAvLyBmb3JtYXQgd2VlayBkYXkgbmFtZSBmcm9tIGludGVnZXIgY29kZVxuICBxdWFydGVyOiAgICBxdWFydGVyRm9ybWF0LCAgICAvLyBmb3JtYXQgcXVhcnRlciBuYW1lIGZyb20gdGltZXN0YW1wXG4gIHV0Y1F1YXJ0ZXI6IHV0Y1F1YXJ0ZXJGb3JtYXQgIC8vIGZvcm1hdCBxdWFydGVyIG5hbWUgZnJvbSB1dGMgdGltZXN0YW1wXG59O1xuXG4vLyAtLSBMb2NhbGVzIC0tLS1cblxuLy8gdHJhbnNmb3JtICdlbi1VUycgc3R5bGUgbG9jYWxlIHN0cmluZyB0byBtYXRjaCBkMy1mb3JtYXQgdjAuNCsgY29udmVudGlvblxuZnVuY3Rpb24gbG9jYWxlUmVmKGwpIHtcbiAgcmV0dXJuIGwubGVuZ3RoID4gNCAmJiAnbG9jYWxlJyArIChcbiAgICBsWzBdLnRvVXBwZXJDYXNlKCkgKyBsWzFdLnRvTG93ZXJDYXNlKCkgK1xuICAgIGxbM10udG9VcHBlckNhc2UoKSArIGxbNF0udG9Mb3dlckNhc2UoKVxuICApO1xufVxuXG5mdW5jdGlvbiBudW1iZXJMb2NhbGUobCkge1xuICB2YXIgZiA9IHV0aWwuaXNTdHJpbmcobCkgPyBkM19udW1iZXJGW2xvY2FsZVJlZihsKV0gOiBkM19udW1iZXJGLmxvY2FsZShsKTtcbiAgaWYgKGYgPT0gbnVsbCkgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCBsb2NhbGU6ICcgKyBsKTtcbiAgbnVtYmVyRiA9IGY7XG59XG5cbmZ1bmN0aW9uIHRpbWVMb2NhbGUobCkge1xuICB2YXIgZiA9IHV0aWwuaXNTdHJpbmcobCkgPyBkM190aW1lRltsb2NhbGVSZWYobCldIDogZDNfdGltZUYubG9jYWxlKGwpO1xuICBpZiAoZiA9PSBudWxsKSB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIGxvY2FsZTogJyArIGwpO1xuICB0aW1lRiA9IGY7XG4gIG1vbnRoRnVsbCA9IG1vbnRoQWJiciA9IGRheUZ1bGwgPSBkYXlBYmJyID0gbnVsbDtcbn1cblxuLy8gLS0gTnVtYmVyIEZvcm1hdHRpbmcgLS0tLVxuXG52YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIGxpbmVhclJhbmdlKGRvbWFpbiwgY291bnQpIHtcbiAgaWYgKCFkb21haW4ubGVuZ3RoKSBkb21haW4gPSBbMF07XG4gIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gIHZhciBzdGFydCA9IGRvbWFpblswXSxcbiAgICAgIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzdG9wIDwgc3RhcnQpIHsgZXJyb3IgPSBzdG9wOyBzdG9wID0gc3RhcnQ7IHN0YXJ0ID0gZXJyb3I7IH1cblxuICB2YXIgc3BhbiA9IChzdG9wIC0gc3RhcnQpIHx8IChjb3VudCA9IDEsIHN0YXJ0IHx8IHN0b3AgfHwgMSksXG4gICAgICBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIGNvdW50KSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzcGFuIC8gY291bnQgLyBzdGVwO1xuXG4gIC8vIEZpbHRlciB0aWNrcyB0byBnZXQgY2xvc2VyIHRvIHRoZSBkZXNpcmVkIGNvdW50LlxuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcCAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcCAqPSAyO1xuXG4gIC8vIFJvdW5kIHN0YXJ0IGFuZCBzdG9wIHZhbHVlcyB0byBzdGVwIGludGVydmFsLlxuICByZXR1cm4gW1xuICAgIE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcCxcbiAgICBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKSAqIHN0ZXAgKyBzdGVwIC8gMiwgLy8gaW5jbHVzaXZlXG4gICAgc3RlcFxuICBdO1xufVxuXG5mdW5jdGlvbiB0cmltWmVybyhmLCBkZWNpbWFsKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIHMgPSBmKHgpLFxuICAgICAgICBuID0gcy5pbmRleE9mKGRlY2ltYWwpO1xuICAgIGlmIChuIDwgMCkgcmV0dXJuIHM7XG5cbiAgICB2YXIgaWR4ID0gcmlnaHRtb3N0RGlnaXQocywgbiksXG4gICAgICAgIGVuZCA9IGlkeCA8IHMubGVuZ3RoID8gcy5zbGljZShpZHgpIDogJyc7XG5cbiAgICB3aGlsZSAoLS1pZHggPiBuKSB7XG4gICAgICBpZiAoc1tpZHhdICE9PSAnMCcpIHsgKytpZHg7IGJyZWFrOyB9XG4gICAgfVxuICAgIHJldHVybiBzLnNsaWNlKDAsIGlkeCkgKyBlbmQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJpZ2h0bW9zdERpZ2l0KHMsIG4pIHtcbiAgdmFyIGkgPSBzLmxhc3RJbmRleE9mKCdlJyksIGM7XG4gIGlmIChpID4gMCkgcmV0dXJuIGk7XG4gIGZvciAoaT1zLmxlbmd0aDsgLS1pID4gbjspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHJldHVybiBpKzE7IC8vIGlzIGRpZ2l0XG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0b051bWJlckZvcm1hdChmKSB7XG4gIHZhciBkZWNpbWFsID0gbnVtYmVyRi5mb3JtYXQoJy4xZicpKDEpWzFdOyAvLyBnZXQgZGVjaW1hbCBjaGFyXG4gIGlmIChmID09IG51bGwpIGYgPSAnLCc7XG4gIGYgPSBkM19udW1iZXJGLmZvcm1hdFNwZWNpZmllcihmKTtcbiAgaWYgKGYucHJlY2lzaW9uID09IG51bGwpIGYucHJlY2lzaW9uID0gMTI7XG4gIHN3aXRjaCAoZi50eXBlKSB7XG4gICAgY2FzZSAnJSc6IGYucHJlY2lzaW9uIC09IDI7IGJyZWFrO1xuICAgIGNhc2UgJ2UnOiBmLnByZWNpc2lvbiAtPSAxOyBicmVhaztcbiAgfVxuICByZXR1cm4gdHJpbVplcm8obnVtYmVyRi5mb3JtYXQoZiksIGRlY2ltYWwpO1xufVxuXG5mdW5jdGlvbiBsaW5lYXJOdW1iZXJGb3JtYXQoZG9tYWluLCBjb3VudCwgZikge1xuICB2YXIgcmFuZ2UgPSBsaW5lYXJSYW5nZShkb21haW4sIGNvdW50KTtcblxuICBpZiAoZiA9PSBudWxsKSBmID0gJyxmJztcblxuICBzd2l0Y2ggKGYgPSBkM19udW1iZXJGLmZvcm1hdFNwZWNpZmllcihmKSwgZi50eXBlKSB7XG4gICAgY2FzZSAncyc6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHJhbmdlWzBdKSwgTWF0aC5hYnMocmFuZ2VbMV0pKTtcbiAgICAgIGlmIChmLnByZWNpc2lvbiA9PSBudWxsKSBmLnByZWNpc2lvbiA9IGQzX251bWJlckYucHJlY2lzaW9uUHJlZml4KHJhbmdlWzJdLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gbnVtYmVyRi5mb3JtYXRQcmVmaXgoZiwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlICcnOlxuICAgIGNhc2UgJ2UnOlxuICAgIGNhc2UgJ2cnOlxuICAgIGNhc2UgJ3AnOlxuICAgIGNhc2UgJ3InOiB7XG4gICAgICBpZiAoZi5wcmVjaXNpb24gPT0gbnVsbCkgZi5wcmVjaXNpb24gPSBkM19udW1iZXJGLnByZWNpc2lvblJvdW5kKHJhbmdlWzJdLCBNYXRoLm1heChNYXRoLmFicyhyYW5nZVswXSksIE1hdGguYWJzKHJhbmdlWzFdKSkpIC0gKGYudHlwZSA9PT0gJ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlICdmJzpcbiAgICBjYXNlICclJzoge1xuICAgICAgaWYgKGYucHJlY2lzaW9uID09IG51bGwpIGYucHJlY2lzaW9uID0gZDNfbnVtYmVyRi5wcmVjaXNpb25GaXhlZChyYW5nZVsyXSkgLSAyICogKGYudHlwZSA9PT0gJyUnKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyRi5mb3JtYXQoZik7XG59XG5cbi8vIC0tIERhdGV0aW1lIEZvcm1hdHRpbmcgLS0tLVxuXG5mdW5jdGlvbiB0aW1lQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi5mb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnNlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUubWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUuaG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLmRheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS5tb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLndlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnllYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXRjQXV0b0Zvcm1hdCgpIHtcbiAgdmFyIGYgPSB0aW1lRi51dGNGb3JtYXQsXG4gICAgICBmb3JtYXRNaWxsaXNlY29uZCA9IGYoJy4lTCcpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZignOiVTJyksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmKCclSTolTScpLFxuICAgICAgZm9ybWF0SG91ciA9IGYoJyVJICVwJyksXG4gICAgICBmb3JtYXREYXkgPSBmKCclYSAlZCcpLFxuICAgICAgZm9ybWF0V2VlayA9IGYoJyViICVkJyksXG4gICAgICBmb3JtYXRNb250aCA9IGYoJyVCJyksXG4gICAgICBmb3JtYXRZZWFyID0gZignJVknKTtcblxuICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkID0gK2RhdGU7XG4gICAgcmV0dXJuIChkM190aW1lLnV0Y1NlY29uZChkYXRlKSA8IGQgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjTWludXRlKGRhdGUpIDwgZCA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGQzX3RpbWUudXRjSG91cihkYXRlKSA8IGQgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkM190aW1lLnV0Y0RheShkYXRlKSA8IGQgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogZDNfdGltZS51dGNNb250aChkYXRlKSA8IGQgP1xuICAgICAgICAgIChkM190aW1lLnV0Y1dlZWsoZGF0ZSkgPCBkID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiBkM190aW1lLnV0Y1llYXIoZGF0ZSkgPCBkID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9udGhGb3JtYXQobW9udGgsIGFiYnJldmlhdGUpIHtcbiAgdmFyIGYgPSBhYmJyZXZpYXRlID9cbiAgICAobW9udGhBYmJyIHx8IChtb250aEFiYnIgPSB0aW1lRi5mb3JtYXQoJyViJykpKSA6XG4gICAgKG1vbnRoRnVsbCB8fCAobW9udGhGdWxsID0gdGltZUYuZm9ybWF0KCclQicpKSk7XG4gIHJldHVybiAodG1wRGF0ZS5zZXRNb250aChtb250aCksIGYodG1wRGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBkYXlGb3JtYXQoZGF5LCBhYmJyZXZpYXRlKSB7XG4gIHZhciBmID0gYWJicmV2aWF0ZSA/XG4gICAgKGRheUFiYnIgfHwgKGRheUFiYnIgPSB0aW1lRi5mb3JtYXQoJyVhJykpKSA6XG4gICAgKGRheUZ1bGwgfHwgKGRheUZ1bGwgPSB0aW1lRi5mb3JtYXQoJyVBJykpKTtcbiAgcmV0dXJuICh0bXBEYXRlLnNldE1vbnRoKDApLCB0bXBEYXRlLnNldERhdGUoMiArIGRheSksIGYodG1wRGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBxdWFydGVyRm9ybWF0KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRNb250aCgpIC8gMykgKyAxO1xufVxuXG5mdW5jdGlvbiB1dGNRdWFydGVyRm9ybWF0KGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRVVENNb250aCgpIC8gMykgKyAxO1xufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBnZW4gPSBtb2R1bGUuZXhwb3J0cztcblxuZ2VuLnJlcGVhdCA9IGZ1bmN0aW9uKHZhbCwgbikge1xuICB2YXIgYSA9IEFycmF5KG4pLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIGFbaV0gPSB2YWw7XG4gIHJldHVybiBhO1xufTtcblxuZ2VuLnplcm9zID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gZ2VuLnJlcGVhdCgwLCBuKTtcbn07XG5cbmdlbi5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHN0ZXAgPSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHJhbmdlJyk7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbmdlbi5yYW5kb20gPSB7fTtcblxuZ2VuLnJhbmRvbS51bmlmb3JtID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWF4ID0gbWluID09PSB1bmRlZmluZWQgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgdmFyIGQgPSBtYXggLSBtaW47XG4gIHZhciBmID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1pbiArIGQgKiBNYXRoLnJhbmRvbSgpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7XG4gIH07XG4gIGYucGRmID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCA+PSBtaW4gJiYgeCA8PSBtYXgpID8gMS9kIDogMDtcbiAgfTtcbiAgZi5jZGYgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCBtaW4gPyAwIDogeCA+IG1heCA/IDEgOiAoeCAtIG1pbikgLyBkO1xuICB9O1xuICBmLmljZGYgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIChwID49IDAgJiYgcCA8PSAxKSA/IG1pbiArIHAqZCA6IE5hTjtcbiAgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICBiID0gYTtcbiAgICBhID0gMDtcbiAgfVxuICB2YXIgZCA9IGIgLSBhO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhICsgTWF0aC5mbG9vcihkICogTWF0aC5yYW5kb20oKSk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTtcbiAgfTtcbiAgZi5wZGYgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4ID09PSBNYXRoLmZsb29yKHgpICYmIHggPj0gYSAmJiB4IDwgYikgPyAxL2QgOiAwO1xuICB9O1xuICBmLmNkZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgdiA9IE1hdGguZmxvb3IoeCk7XG4gICAgcmV0dXJuIHYgPCBhID8gMCA6IHYgPj0gYiA/IDEgOiAodiAtIGEgKyAxKSAvIGQ7XG4gIH07XG4gIGYuaWNkZiA9IGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gKHAgPj0gMCAmJiBwIDw9IDEpID8gYSAtIDEgKyBNYXRoLmZsb29yKHAqZCkgOiBOYU47XG4gIH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5ub3JtYWwgPSBmdW5jdGlvbihtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2IHx8IDE7XG4gIHZhciBuZXh0O1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gMCwgeSA9IDAsIHJkcywgYztcbiAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gbmV4dDtcbiAgICAgIG5leHQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgeCA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgeSA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgcmRzID0geCp4ICsgeSp5O1xuICAgIH0gd2hpbGUgKHJkcyA9PT0gMCB8fCByZHMgPiAxKTtcbiAgICBjID0gTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHJkcykvcmRzKTsgLy8gQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICBuZXh0ID0gbWVhbiArIHkqYypzdGRldjtcbiAgICByZXR1cm4gbWVhbiArIHgqYypzdGRldjtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBnZW4uemVyb3MobikubWFwKGYpO1xuICB9O1xuICBmLnBkZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgZXhwID0gTWF0aC5leHAoTWF0aC5wb3coeC1tZWFuLCAyKSAvICgtMiAqIE1hdGgucG93KHN0ZGV2LCAyKSkpO1xuICAgIHJldHVybiAoMSAvIChzdGRldiAqIE1hdGguc3FydCgyKk1hdGguUEkpKSkgKiBleHA7XG4gIH07XG4gIGYuY2RmID0gZnVuY3Rpb24oeCkge1xuICAgIC8vIEFwcHJveGltYXRpb24gZnJvbSBXZXN0ICgyMDA5KVxuICAgIC8vIEJldHRlciBBcHByb3hpbWF0aW9ucyB0byBDdW11bGF0aXZlIE5vcm1hbCBGdW5jdGlvbnNcbiAgICB2YXIgY2QsXG4gICAgICAgIHogPSAoeCAtIG1lYW4pIC8gc3RkZXYsXG4gICAgICAgIFogPSBNYXRoLmFicyh6KTtcbiAgICBpZiAoWiA+IDM3KSB7XG4gICAgICBjZCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdW0sIGV4cCA9IE1hdGguZXhwKC1aKlovMik7XG4gICAgICBpZiAoWiA8IDcuMDcxMDY3ODExODY1NDcpIHtcbiAgICAgICAgc3VtID0gMy41MjYyNDk2NTk5ODkxMWUtMDIgKiBaICsgMC43MDAzODMwNjQ0NDM2ODg7XG4gICAgICAgIHN1bSA9IHN1bSAqIFogKyA2LjM3Mzk2MjIwMzUzMTY1O1xuICAgICAgICBzdW0gPSBzdW0gKiBaICsgMzMuOTEyODY2MDc4MzgzO1xuICAgICAgICBzdW0gPSBzdW0gKiBaICsgMTEyLjA3OTI5MTQ5Nzg3MTtcbiAgICAgICAgc3VtID0gc3VtICogWiArIDIyMS4yMTM1OTYxNjk5MzE7XG4gICAgICAgIHN1bSA9IHN1bSAqIFogKyAyMjAuMjA2ODY3OTEyMzc2O1xuICAgICAgICBjZCA9IGV4cCAqIHN1bTtcbiAgICAgICAgc3VtID0gOC44Mzg4MzQ3NjQ4MzE4NGUtMDIgKiBaICsgMS43NTU2NjcxNjMxODI2NDtcbiAgICAgICAgc3VtID0gc3VtICogWiArIDE2LjA2NDE3NzU3OTIwNztcbiAgICAgICAgc3VtID0gc3VtICogWiArIDg2Ljc4MDczMjIwMjk0NjE7XG4gICAgICAgIHN1bSA9IHN1bSAqIFogKyAyOTYuNTY0MjQ4Nzc5Njc0O1xuICAgICAgICBzdW0gPSBzdW0gKiBaICsgNjM3LjMzMzYzMzM3ODgzMTtcbiAgICAgICAgc3VtID0gc3VtICogWiArIDc5My44MjY1MTI1MTk5NDg7XG4gICAgICAgIHN1bSA9IHN1bSAqIFogKyA0NDAuNDEzNzM1ODI0NzUyO1xuICAgICAgICBjZCA9IGNkIC8gc3VtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VtID0gWiArIDAuNjU7XG4gICAgICAgIHN1bSA9IFogKyA0IC8gc3VtO1xuICAgICAgICBzdW0gPSBaICsgMyAvIHN1bTtcbiAgICAgICAgc3VtID0gWiArIDIgLyBzdW07XG4gICAgICAgIHN1bSA9IFogKyAxIC8gc3VtO1xuICAgICAgICBjZCA9IGV4cCAvIHN1bSAvIDIuNTA2NjI4Mjc0NjMxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geiA+IDAgPyAxIC0gY2QgOiBjZDtcbiAgfTtcbiAgZi5pY2RmID0gZnVuY3Rpb24ocCkge1xuICAgIC8vIEFwcHJveGltYXRpb24gb2YgUHJvYml0IGZ1bmN0aW9uIHVzaW5nIGludmVyc2UgZXJyb3IgZnVuY3Rpb24uXG4gICAgaWYgKHAgPD0gMCB8fCBwID49IDEpIHJldHVybiBOYU47XG4gICAgdmFyIHggPSAyKnAgLSAxLFxuICAgICAgICB2ID0gKDggKiAoTWF0aC5QSSAtIDMpKSAvICgzICogTWF0aC5QSSAqICg0LU1hdGguUEkpKSxcbiAgICAgICAgYSA9ICgyIC8gKE1hdGguUEkqdikpICsgKE1hdGgubG9nKDEgLSBNYXRoLnBvdyh4LDIpKSAvIDIpLFxuICAgICAgICBiID0gTWF0aC5sb2coMSAtICh4KngpKSAvIHYsXG4gICAgICAgIHMgPSAoeCA+IDAgPyAxIDogLTEpICogTWF0aC5zcXJ0KE1hdGguc3FydCgoYSphKSAtIGIpIC0gYSk7XG4gICAgcmV0dXJuIG1lYW4gKyBzdGRldiAqIE1hdGguU1FSVDIgKiBzO1xuICB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20uYm9vdHN0cmFwID0gZnVuY3Rpb24oZG9tYWluLCBzbW9vdGgpIHtcbiAgLy8gR2VuZXJhdGVzIGEgYm9vdHN0cmFwIHNhbXBsZSBmcm9tIGEgc2V0IG9mIG9ic2VydmF0aW9ucy5cbiAgLy8gU21vb3RoIGJvb3RzdHJhcHBpbmcgYWRkcyByYW5kb20gemVyby1jZW50ZXJlZCBub2lzZSB0byB0aGUgc2FtcGxlcy5cbiAgdmFyIHZhbCA9IGRvbWFpbi5maWx0ZXIodXRpbC5pc1ZhbGlkKSxcbiAgICAgIGxlbiA9IHZhbC5sZW5ndGgsXG4gICAgICBlcnIgPSBzbW9vdGggPyBnZW4ucmFuZG9tLm5vcm1hbCgwLCBzbW9vdGgpIDogbnVsbDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsW35+KE1hdGgucmFuZG9tKCkqbGVuKV0gKyAoZXJyID8gZXJyKCkgOiAwKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBnZW4uemVyb3MobikubWFwKGYpO1xuICB9O1xuICByZXR1cm4gZjtcbn07IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgZDNfZHN2ID0gcmVxdWlyZSgnZDMtZHN2Jyk7XG5cbmZ1bmN0aW9uIGRzdihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICB2YXIgaCA9IGZvcm1hdC5oZWFkZXI7XG4gICAgZGF0YSA9IChoID8gaC5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgOiAnJykgKyBkYXRhO1xuICB9XG4gIHJldHVybiBkM19kc3YuZHN2KGZvcm1hdC5kZWxpbWl0ZXIpLnBhcnNlKGRhdGEpO1xufVxuXG5kc3YuZGVsaW1pdGVyID0gZnVuY3Rpb24oZGVsaW0pIHtcbiAgdmFyIGZtdCA9IHtkZWxpbWl0ZXI6IGRlbGltfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gdXRpbC5leHRlbmQoZm9ybWF0LCBmbXQpIDogZm10KTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZHN2O1xuIiwidmFyIGRzdiA9IHJlcXVpcmUoJy4vZHN2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKSxcbiAgZHN2OiBkc3YsXG4gIGNzdjogZHN2LmRlbGltaXRlcignLCcpLFxuICB0c3Y6IGRzdi5kZWxpbWl0ZXIoJ1xcdCcpXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIHZhciBkID0gdXRpbC5pc09iamVjdChkYXRhKSAmJiAhdXRpbC5pc0J1ZmZlcihkYXRhKSA/XG4gICAgZGF0YSA6IEpTT04ucGFyc2UoZGF0YSk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnByb3BlcnR5KSB7XG4gICAgZCA9IHV0aWwuYWNjZXNzb3IoZm9ybWF0LnByb3BlcnR5KShkKTtcbiAgfVxuICByZXR1cm4gZDtcbn07XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG52YXIgcmVhZGVyID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIHZhciB0b3BvanNvbiA9IHJlYWRlci50b3BvanNvbjtcbiAgaWYgKHRvcG9qc29uID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ1RvcG9KU09OIGxpYnJhcnkgbm90IGxvYWRlZC4nKTsgfVxuXG4gIHZhciB0ID0ganNvbihkYXRhLCBmb3JtYXQpLCBvYmo7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5mZWF0dXJlXSkpIHtcbiAgICAgIHJldHVybiB0b3BvanNvbi5mZWF0dXJlKHQsIG9iaikuZmVhdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIGZvcm1hdC5mZWF0dXJlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKSkge1xuICAgICAgcmV0dXJuIFt0b3BvanNvbi5tZXNoKHQsIHQub2JqZWN0c1tmb3JtYXQubWVzaF0pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnICsgZm9ybWF0Lm1lc2gpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLicpO1xuICB9XG59O1xuXG5yZWFkZXIudG9wb2pzb24gPSByZXF1aXJlKCd0b3BvanNvbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZWFkZXI7XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyZWUsIGZvcm1hdCkge1xuICByZXR1cm4gdG9UYWJsZShqc29uKHRyZWUsIGZvcm1hdCksIGZvcm1hdCk7XG59O1xuXG5mdW5jdGlvbiB0b1RhYmxlKHJvb3QsIGZpZWxkcykge1xuICB2YXIgY2hpbGRyZW5GaWVsZCA9IGZpZWxkcyAmJiBmaWVsZHMuY2hpbGRyZW4gfHwgJ2NoaWxkcmVuJyxcbiAgICAgIHBhcmVudEZpZWxkID0gZmllbGRzICYmIGZpZWxkcy5wYXJlbnQgfHwgJ3BhcmVudCcsXG4gICAgICB0YWJsZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGVbcGFyZW50RmllbGRdID0gcGFyZW50O1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmlzaXQocm9vdCwgbnVsbCk7XG4gIHJldHVybiAodGFibGUucm9vdCA9IHJvb3QsIHRhYmxlKTtcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG52YXIgcHJvdG9jb2xfcmUgPSAvXihbQS1aYS16XSs6KT9cXC9cXC8vO1xuXG4vLyBTcGVjaWFsIHRyZWF0bWVudCBpbiBub2RlLmpzIGZvciB0aGUgZmlsZTogcHJvdG9jb2xcbnZhciBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8vIFZhbGlkYXRlIGFuZCBjbGVhbnVwIFVSTCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGJlIGFjY2Vzc2VkXG4vLyBSZXR1cm5zIGNsZWFuZWQgdXAgVVJMLCBvciBmYWxzZSBpZiBhY2Nlc3MgaXMgbm90IGFsbG93ZWRcbmZ1bmN0aW9uIHNhbml0aXplVXJsKG9wdCkge1xuICB2YXIgdXJsID0gb3B0LnVybDtcbiAgaWYgKCF1cmwgJiYgb3B0LmZpbGUpIHsgcmV0dXJuIGZpbGVQcm90b2NvbCArIG9wdC5maWxlOyB9XG5cbiAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVsYXRpdmUgdXJsIChoYXMgbm8gaG9zdCksIHByZXBlbmQgb3B0LmJhc2VVUkxcbiAgaWYgKG9wdC5iYXNlVVJMICYmICFwcm90b2NvbF9yZS50ZXN0KHVybCkpIHtcbiAgICBpZiAoIXN0YXJ0c1dpdGgodXJsLCAnLycpICYmIG9wdC5iYXNlVVJMW29wdC5iYXNlVVJMLmxlbmd0aC0xXSAhPT0gJy8nKSB7XG4gICAgICB1cmwgPSAnLycgKyB1cmw7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIH1cbiAgICB1cmwgPSBvcHQuYmFzZVVSTCArIHVybDtcbiAgfVxuICAvLyByZWxhdGl2ZSBwcm90b2NvbCwgc3RhcnRzIHdpdGggJy8vJ1xuICBpZiAoIWxvYWQudXNlWEhSICYmIHN0YXJ0c1dpdGgodXJsLCAnLy8nKSkge1xuICAgIHVybCA9IChvcHQuZGVmYXVsdFByb3RvY29sIHx8ICdodHRwJykgKyAnOicgKyB1cmw7XG4gIH1cbiAgLy8gSWYgb3B0LmRvbWFpbldoaXRlTGlzdCBpcyBzZXQsIG9ubHkgYWxsb3dzIHVybCwgd2hvc2UgaG9zdG5hbWVcbiAgLy8gKiBJcyB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpXG4gIC8vICogRXF1YWxzIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgLy8gKiBJcyBhIHByb3BlciBzdWJkb21haW4gb2Ygb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICBpZiAob3B0LmRvbWFpbldoaXRlTGlzdCkge1xuICAgIHZhciBkb21haW4sIG9yaWdpbjtcbiAgICBpZiAobG9hZC51c2VYSFIpIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNjUxMy9ob3ctZG8taS1wYXJzZS1hLXVybC1pbnRvLWhvc3RuYW1lLWFuZC1wYXRoLWluLWphdmFzY3JpcHRcbiAgICAgIC8vIElFIGRvZXNuJ3QgcG9wdWxhdGUgYWxsIGxpbmsgcHJvcGVydGllcyB3aGVuIHNldHRpbmcgLmhyZWYgd2l0aCBhIHJlbGF0aXZlIFVSTCxcbiAgICAgIC8vIGhvd2V2ZXIgLmhyZWYgd2lsbCByZXR1cm4gYW4gYWJzb2x1dGUgVVJMIHdoaWNoIHRoZW4gY2FuIGJlIHVzZWQgb24gaXRzZWxmXG4gICAgICAvLyB0byBwb3B1bGF0ZSB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICAgIGlmIChhLmhvc3QgPT09ICcnKSB7XG4gICAgICAgIGEuaHJlZiA9IGEuaHJlZjtcbiAgICAgIH1cbiAgICAgIGRvbWFpbiA9IGEuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVsYXRpdmUgcHJvdG9jb2wgaXMgYnJva2VuOiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXVybC9pc3N1ZXMvNVxuICAgICAgdmFyIHBhcnRzID0gcmVxdWlyZSgndXJsJykucGFyc2UodXJsKTtcbiAgICAgIGRvbWFpbiA9IHBhcnRzLmhvc3RuYW1lO1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3JpZ2luICE9PSBkb21haW4pIHtcbiAgICAgIHZhciB3aGl0ZUxpc3RlZCA9IG9wdC5kb21haW5XaGl0ZUxpc3Quc29tZShmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGxvYWQubG9hZGVyKG9wdCwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBsb2FkZXIob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH0sIHVybDtcblxuICB0cnkge1xuICAgIHVybCA9IGxvYWQuc2FuaXRpemVVcmwob3B0KTsgLy8gZW5hYmxlIG92ZXJyaWRlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBlcnJvcignSW52YWxpZCBVUkw6ICcgKyBvcHQudXJsKTtcbiAgfSBlbHNlIGlmIChsb2FkLnVzZVhIUikge1xuICAgIC8vIG9uIGNsaWVudCwgdXNlIHhoclxuICAgIHJldHVybiBsb2FkLnhocih1cmwsIG9wdCwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHN0YXJ0c1dpdGgodXJsLCBmaWxlUHJvdG9jb2wpKSB7XG4gICAgLy8gb24gc2VydmVyLCBpZiB1cmwgc3RhcnRzIHdpdGggJ2ZpbGU6Ly8nLCBzdHJpcCBpdCBhbmQgbG9hZCBmcm9tIGZpbGVcbiAgICByZXR1cm4gbG9hZC5maWxlKHVybC5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKSwgb3B0LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJzovLycpIDwgMCkgeyAvLyBUT0RPIGJldHRlciBwcm90b2NvbCBjaGVjaz9cbiAgICAvLyBvbiBzZXJ2ZXIsIGlmIG5vIHByb3RvY29sIGFzc3VtZSBmaWxlXG4gICAgcmV0dXJuIGxvYWQuZmlsZSh1cmwsIG9wdCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgb24gc2VydmVyXG4gICAgcmV0dXJuIGxvYWQuaHR0cCh1cmwsIG9wdCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gJ3RleHQnID9cbiAgICByZXF1ZXN0LnJlc3BvbnNlIDogLy8gbnVsbCBvbiBlcnJvclxuICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyAnJyBvbiBlcnJvclxufVxuXG5mdW5jdGlvbiB4aHIodXJsLCBvcHQsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgaWYgKCdvbmxvYWQnIGluIHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMpIHJlc3BvbmQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikge1xuICAgIHZhciBoZWFkZXJzID0gdXRpbC5leHRlbmQoe30sIGxvYWQuaGVhZGVycywgb3B0LmhlYWRlcnMpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gaGVhZGVycykge1xuICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgIH1cbiAgfVxuICByZXF1ZXN0LnNlbmQoKTtcblxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZW5hbWUsIG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIH1cbiAgZnMucmVhZEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlcnMgPSB1dGlsLmV4dGVuZCh7fSwgbG9hZC5oZWFkZXJzLCBvcHQuaGVhZGVycyk7XG5cbiAgdmFyIG9wdGlvbnMgPSB7dXJsOiB1cmwsIGVuY29kaW5nOiBudWxsLCBnemlwOiB0cnVlLCBoZWFkZXJzOiBoZWFkZXJzfTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiByZXF1aXJlKCdzeW5jLXJlcXVlc3QnKSgnR0VUJywgdXJsLCBvcHRpb25zKS5nZXRCb2R5KCk7XG4gIH1cbiAgcmVxdWlyZSgncmVxdWVzdCcpKG9wdGlvbnMsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBlcnJvciB8fFxuICAgICAgICAnTG9hZCBmYWlsZWQgd2l0aCByZXNwb25zZSBjb2RlICcgKyByZXNwb25zZS5zdGF0dXNDb2RlICsgJy4nO1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZyA9PSBudWxsID8gZmFsc2UgOiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbn1cblxuLy8gQWxsb3cgdGhlc2UgZnVuY3Rpb25zIHRvIGJlIG92ZXJyaWRlbiBieSB0aGUgdXNlciBvZiB0aGUgbGlicmFyeVxubG9hZC5sb2FkZXIgPSBsb2FkZXI7XG5sb2FkLnNhbml0aXplVXJsID0gc2FuaXRpemVVcmw7XG5sb2FkLnhociA9IHhocjtcbmxvYWQuZmlsZSA9IGZpbGU7XG5sb2FkLmh0dHAgPSBodHRwO1xuXG4vLyBEZWZhdWx0IHNldHRpbmdzXG5sb2FkLnVzZVhIUiA9ICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKTtcbmxvYWQuaGVhZGVycyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpLFxuICBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyksXG4gIHRpbWVGID0gcmVxdWlyZSgnLi4vZm9ybWF0JykudGltZTtcblxuZnVuY3Rpb24gcmVhZChkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHR5cGUgPSAoZm9ybWF0ICYmIGZvcm1hdC50eXBlKSB8fCAnanNvbic7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIHR5cGVzID0gKHR5cGVzPT09J2F1dG8nKSA/IHR5cGUuaW5mZXJBbGwoZGF0YSkgOiB1dGlsLmR1cGxpY2F0ZSh0eXBlcyk7XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykge1xuICAgIHZhciB0ID0gdHlwZXNbY107XG4gICAgaWYgKHQgJiYgdC5pbmRleE9mKCdkYXRlOicpID09PSAwKSB7XG4gICAgICB2YXIgcGFydHMgPSB0LnNwbGl0KC86KC4rKT8vLCAyKSwgIC8vIHNwbGl0IG9uIGZpcnN0IDpcbiAgICAgICAgICBwYXR0ZXJuID0gcGFydHNbMV07XG4gICAgICBpZiAoKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcXCcnKSB8fFxuICAgICAgICAgIChwYXR0ZXJuWzBdID09PSAnXCInICAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXCInKSkge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxLCAtMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignRm9ybWF0IHBhdHRlcm4gbXVzdCBiZSBxdW90ZWQ6ICcgKyBwYXR0ZXJuKTtcbiAgICAgIH1cbiAgICAgIHBhdHRlcm4gPSB0aW1lRihwYXR0ZXJuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7IHJldHVybiBwYXR0ZXJuLnBhcnNlKHYpOyB9O1xuICAgIH1cbiAgICBpZiAoIXR5cGUucGFyc2Vyc1t0XSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lsbGVnYWwgZm9ybWF0IHBhdHRlcm46ICcgKyBjICsgJzonICsgdCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlLnBhcnNlcnNbdF07XG4gIH0pO1xuXG4gIGZvciAoaT0wLCBjbGVuPWNvbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZCA9IGRhdGFbaV07XG4gICAgZm9yIChqPTA7IGo8Y2xlbjsgKytqKSB7XG4gICAgICBkW2NvbHNbal1dID0gcGFyc2Vyc1tqXShkW2NvbHNbal1dKTtcbiAgICB9XG4gIH1cbiAgdHlwZS5hbm5vdGF0aW9uKGRhdGEsIHR5cGVzKTtcbn1cblxucmVhZC5mb3JtYXRzID0gZm9ybWF0cztcbm1vZHVsZS5leHBvcnRzID0gcmVhZDtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGxvYWQgPSByZXF1aXJlKCcuL2xvYWQnKTtcbnZhciByZWFkID0gcmVxdWlyZSgnLi9yZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbFxuICAua2V5cyhyZWFkLmZvcm1hdHMpXG4gIC5yZWR1Y2UoZnVuY3Rpb24ob3V0LCB0eXBlKSB7XG4gICAgb3V0W3R5cGVdID0gZnVuY3Rpb24ob3B0LCBmb3JtYXQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBwcm9jZXNzIGFyZ3VtZW50c1xuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcob3B0KSkgeyBvcHQgPSB7dXJsOiBvcHR9OyB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB1dGlsLmlzRnVuY3Rpb24oZm9ybWF0KSkge1xuICAgICAgICBjYWxsYmFjayA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdXAgcmVhZCBmb3JtYXRcbiAgICAgIGZvcm1hdCA9IHV0aWwuZXh0ZW5kKHtwYXJzZTogJ2F1dG8nfSwgZm9ybWF0KTtcbiAgICAgIGZvcm1hdC50eXBlID0gdHlwZTtcblxuICAgICAgLy8gbG9hZCBkYXRhXG4gICAgICB2YXIgZGF0YSA9IGxvYWQob3B0LCBjYWxsYmFjayA/IGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICAgIGlmIChlcnJvcikgeyBjYWxsYmFjayhlcnJvciwgbnVsbCk7IHJldHVybjsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIGRhdGEgbG9hZGVkLCBub3cgcGFyc2UgaXQgKGFzeW5jKVxuICAgICAgICAgIGRhdGEgPSByZWFkKGRhdGEsIGZvcm1hdCk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgIC8vIGRhdGEgbG9hZGVkLCBub3cgcGFyc2UgaXQgKHN5bmMpXG4gICAgICBpZiAoIWNhbGxiYWNrKSByZXR1cm4gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBUWVBFUyA9ICdfX3R5cGVzX18nO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgYm9vbGVhbjogdXRpbC5ib29sZWFuLFxuICBpbnRlZ2VyOiB1dGlsLm51bWJlcixcbiAgbnVtYmVyOiAgdXRpbC5udW1iZXIsXG4gIGRhdGU6ICAgIHV0aWwuZGF0ZSxcbiAgc3RyaW5nOiAgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA9PSBudWxsIHx8IHggPT09ICcnID8gbnVsbCA6IHggKyAnJzsgfVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09J3RydWUnIHx8IHg9PT0nZmFsc2UnIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBpbnRlZ2VyOiBmdW5jdGlvbih4KSB7IHJldHVybiBURVNUUy5udW1iZXIoeCkgJiYgKHg9K3gpID09PSB+fng7IH0sXG4gIG51bWJlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH0sXG4gIGRhdGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTihEYXRlLnBhcnNlKHgpKTsgfVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGlvbihkYXRhLCB0eXBlcykge1xuICBpZiAoIXR5cGVzKSByZXR1cm4gZGF0YSAmJiBkYXRhW1RZUEVTXSB8fCBudWxsO1xuICBkYXRhW1RZUEVTXSA9IHR5cGVzO1xufVxuXG5mdW5jdGlvbiBmaWVsZE5hbWVzKGRhdHVtKSB7XG4gIHJldHVybiB1dGlsLmtleXMoZGF0dW0pO1xufVxuXG5mdW5jdGlvbiBicmFja2V0KGZpZWxkTmFtZSkge1xuICByZXR1cm4gJ1snICsgZmllbGROYW1lICsgJ10nO1xufVxuXG5mdW5jdGlvbiB0eXBlKHZhbHVlcywgZikge1xuICB2YWx1ZXMgPSB1dGlsLmFycmF5KHZhbHVlcyk7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGdldCA9IGZpZWxkcyA/IHV0aWwuaWRlbnRpdHkgOiAoZmllbGRzID0gZmllbGROYW1lcyhkYXRhWzBdKSwgYnJhY2tldCk7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKGZ1bmN0aW9uKHR5cGVzLCBmKSB7XG4gICAgcmV0dXJuICh0eXBlc1tmXSA9IHR5cGUoZGF0YSwgZ2V0KGYpKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICB2YWx1ZXMgPSB1dGlsLmFycmF5KHZhbHVlcyk7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBqLCB2O1xuXG4gIC8vIHR5cGVzIHRvIHRlc3QgZm9yLCBpbiBwcmVjZWRlbmNlIG9yZGVyXG4gIHZhciB0eXBlcyA9IFsnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlcicsICdkYXRlJ107XG5cbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IG5leHQgdmFsdWUgdG8gdGVzdFxuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIC8vIHRlc3QgdmFsdWUgYWdhaW5zdCByZW1haW5pbmcgdHlwZXNcbiAgICBmb3IgKGo9MDsgajx0eXBlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZCh2KSAmJiAhVEVTVFNbdHlwZXNbal1dKHYpKSB7XG4gICAgICAgIHR5cGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgaiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyB0eXBlcyBsZWZ0LCByZXR1cm4gJ3N0cmluZydcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbMF07XG59XG5cbmZ1bmN0aW9uIGluZmVyQWxsKGRhdGEsIGZpZWxkcykge1xuICB2YXIgZ2V0ID0gZmllbGRzID8gdXRpbC5pZGVudGl0eSA6IChmaWVsZHMgPSBmaWVsZE5hbWVzKGRhdGFbMF0pLCBicmFja2V0KTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB0eXBlc1tmXSA9IGluZmVyKGRhdGEsIGdldChmKSk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbnR5cGUuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG50eXBlLmFsbCA9IHR5cGVBbGw7XG50eXBlLmluZmVyID0gaW5mZXI7XG50eXBlLmluZmVyQWxsID0gaW5mZXJBbGw7XG50eXBlLnBhcnNlcnMgPSBQQVJTRVJTO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRsID0ge1xuICB2ZXJzaW9uOiAgICByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuICBsb2FkOiAgICAgICByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyksXG4gIHJlYWQ6ICAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L3JlYWQnKSxcbiAgdHlwZTogICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpLFxuICBBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yJyksXG4gIGdyb3VwYnk6ICAgIHJlcXVpcmUoJy4vYWdncmVnYXRlL2dyb3VwYnknKSxcbiAgYmluczogICAgICAgcmVxdWlyZSgnLi9iaW5zL2JpbnMnKSxcbiAgJGJpbjogICAgICAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLiRiaW4sXG4gIGhpc3RvZ3JhbTogIHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS5oaXN0b2dyYW0sXG4gIGZvcm1hdDogICAgIHJlcXVpcmUoJy4vZm9ybWF0JyksXG4gIHRlbXBsYXRlOiAgIHJlcXVpcmUoJy4vdGVtcGxhdGUnKSxcbiAgdGltZTogICAgICAgcmVxdWlyZSgnLi90aW1lJylcbn07XG5cbnV0aWwuZXh0ZW5kKGRsLCB1dGlsKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2FjY2Vzc29yJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9zdGF0cycpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2ltcG9ydC9yZWFkZXJzJykpO1xudXRpbC5leHRlbmQoZGwuZm9ybWF0LCByZXF1aXJlKCcuL2Zvcm1hdC10YWJsZXMnKSk7XG5cbi8vIGJhY2t3YXJkcy1jb21wYXRpYmxlLCBkZXByZWNhdGVkIEFQSVxuLy8gd2lsbCByZW1vdmUgaW4gdGhlIGZ1dHVyZVxuZGwucHJpbnQgPSB7XG4gIHRhYmxlOiAgIGRsLmZvcm1hdC50YWJsZSxcbiAgc3VtbWFyeTogZGwuZm9ybWF0LnN1bW1hcnlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGw7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xuXG52YXIgc3RhdHMgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gQ29sbGVjdCB1bmlxdWUgdmFsdWVzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBmaXJzdC1vYnNlcnZlZCBvcmRlclxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBhcnJheS5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCB8fCAwO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBub24tbnVsbCwgbm9uLXVuZGVmaW5lZCwgbm9uLU5hTiB2YWx1ZXMuXG5zdGF0cy5jb3VudC52YWxpZCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgdmFsaWQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHZhbGlkICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5taXNzaW5nID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgPT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbi8vIE51bGwsIHVuZGVmaW5lZCBhbmQgTmFOIGFyZSBlYWNoIGNvbnNpZGVyZWQgZGlzdGluY3QgdmFsdWVzLlxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZGlzdGluY3QgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMuY291bnQubWFwID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtYXAgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBtYXBbdl0gPSAodiBpbiBtYXApID8gbWFwW3ZdICsgMSA6IDE7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgcmV0dXJuIHN0YXRzLnF1YW50aWxlKHZhbHVlcywgMC41KTtcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBxdWFydGlsZSBib3VuZGFyaWVzIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5xdWFydGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBxID0gc3RhdHMucXVhbnRpbGU7XG4gIHJldHVybiBbcSh2YWx1ZXMsIDAuMjUpLCBxKHZhbHVlcywgMC41MCksIHEodmFsdWVzLCAwLjc1KV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBxdWFudGlsZSBvZiBhIHNvcnRlZCBhcnJheSBvZiBudW1iZXJzLlxuLy8gQWRhcHRlZCBmcm9tIHRoZSBEMy5qcyBpbXBsZW1lbnRhdGlvbi5cbnN0YXRzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmLCBwKSB7XG4gIGlmIChwID09PSB1bmRlZmluZWQpIHsgcCA9IGY7IGYgPSB1dGlsLmlkZW50aXR5OyB9XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLFxuICAgICAgaCA9IE1hdGguZmxvb3IoSCksXG4gICAgICB2ID0gK2YodmFsdWVzW2ggLSAxXSksXG4gICAgICBlID0gSCAtIGg7XG4gIHJldHVybiBlID8gdiArIGUgKiAoZih2YWx1ZXNbaF0pIC0gdikgOiB2O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc3VtIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdW0gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgZm9yICh2YXIgc3VtPTAsIGk9MCwgbj12YWx1ZXMubGVuZ3RoLCB2OyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHN1bSArPSB2O1xuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWVhbiA9IDAsIGRlbHRhLCBpLCBuLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBnZW9tZXRyaWMgbWVhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbi5nZW9tZXRyaWMgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAxLCBjLCBuLCB2LCBpO1xuICBmb3IgKGk9MCwgYz0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPD0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdlb21ldHJpYyBtZWFuIG9ubHkgZGVmaW5lZCBmb3IgcG9zaXRpdmUgdmFsdWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIG1lYW4gKj0gdjtcbiAgICAgICsrYztcbiAgICB9XG4gIH1cbiAgbWVhbiA9IGMgPiAwID8gTWF0aC5wb3cobWVhbiwgMS9jKSA6IDA7XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgaGFybW9uaWMgbWVhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbi5oYXJtb25pYyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWVhbiA9IDAsIGMsIG4sIHYsIGk7XG4gIGZvciAoaT0wLCBjPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBtZWFuICs9IDEvdjtcbiAgICAgICsrYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGMgLyBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGggPCAyKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICh2ID09PSB2KSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHZlY3RvciBkaXN0YW5jZSBiZXR3ZWVuIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIERlZmF1bHQgaXMgRXVjbGlkZWFuIChleHA9MikgZGlzdGFuY2UsIGNvbmZpZ3VyYWJsZSB2aWEgZXhwIGFyZ3VtZW50Llxuc3RhdHMuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgZXhwKSB7XG4gIHZhciBmID0gdXRpbC5pc0Z1bmN0aW9uKGIpIHx8IHV0aWwuaXNTdHJpbmcoYiksXG4gICAgICBYID0gdmFsdWVzLFxuICAgICAgWSA9IGYgPyB2YWx1ZXMgOiBhLFxuICAgICAgZSA9IGYgPyBleHAgOiBiLFxuICAgICAgTDIgPSBlID09PSAyIHx8IGUgPT0gbnVsbCxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBzID0gMCwgZCwgaTtcbiAgaWYgKGYpIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gIH1cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IGYgPyAoYShYW2ldKS1iKFlbaV0pKSA6IChYW2ldLVlbaV0pO1xuICAgIHMgKz0gTDIgPyBkKmQgOiBNYXRoLnBvdyhNYXRoLmFicyhkKSwgZSk7XG4gIH1cbiAgcmV0dXJuIEwyID8gTWF0aC5zcXJ0KHMpIDogTWF0aC5wb3cocywgMS9lKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIENvaGVuJ3MgZCBlZmZlY3Qgc2l6ZSBiZXR3ZWVuIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvaGVuc2QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgeDEgPSBzdGF0cy5tZWFuKFgpLFxuICAgICAgeDIgPSBzdGF0cy5tZWFuKFkpLFxuICAgICAgbjEgPSBzdGF0cy5jb3VudC52YWxpZChYKSxcbiAgICAgIG4yID0gc3RhdHMuY291bnQudmFsaWQoWSk7XG5cbiAgaWYgKChuMStuMi0yKSA8PSAwKSB7XG4gICAgLy8gaWYgYm90aCBhcnJheXMgYXJlIHNpemUgMSwgb3Igb25lIGlzIGVtcHR5LCB0aGVyZSdzIG5vIGVmZmVjdCBzaXplXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gcG9vbCBzdGFuZGFyZCBkZXZpYXRpb25cbiAgdmFyIHMxID0gc3RhdHMudmFyaWFuY2UoWCksXG4gICAgICBzMiA9IHN0YXRzLnZhcmlhbmNlKFkpLFxuICAgICAgcyA9IE1hdGguc3FydCgoKChuMS0xKSpzMSkgKyAoKG4yLTEpKnMyKSkgLyAobjErbjItMikpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB2YXJpYW5jZSwgdGhlcmUncyBubyBlZmZlY3Qgc2l6ZVxuICByZXR1cm4gcz09PTAgPyAwIDogKHgxIC0geDIpIC8gcztcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBjb3ZhcmlhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzXG5zdGF0cy5jb3ZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIG4gPSBYLmxlbmd0aCxcbiAgICAgIHhtID0gc3RhdHMubWVhbihYKSxcbiAgICAgIHltID0gc3RhdHMubWVhbihZKSxcbiAgICAgIHN1bSA9IDAsIGMgPSAwLCBpLCB4LCB5LCB2eCwgdnk7XG5cbiAgaWYgKG4gIT09IFkubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0lucHV0IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHggPSBYW2ldOyB2eCA9IHV0aWwuaXNWYWxpZCh4KTtcbiAgICB5ID0gWVtpXTsgdnkgPSB1dGlsLmlzVmFsaWQoeSk7XG4gICAgaWYgKHZ4ICYmIHZ5KSB7XG4gICAgICBzdW0gKz0gKHgteG0pICogKHkteW0pO1xuICAgICAgKytjO1xuICAgIH0gZWxzZSBpZiAodnggfHwgdnkpIHtcbiAgICAgIHRocm93IEVycm9yKCdWYWxpZCB2YWx1ZXMgbXVzdCBhbGlnbi4nKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bSAvIChjLTEpO1xufTtcblxuLy8gQ29tcHV0ZSBhc2NlbmRpbmcgcmFuayBzY29yZXMgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbi8vIFRpZXMgYXJlIGFzc2lnbmVkIHRoZWlyIGNvbGxlY3RpdmUgbWVhbiByYW5rLlxuc3RhdHMucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpIHx8IHV0aWwuaWRlbnRpdHk7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge2lkeDogaSwgdmFsOiBmKHYpfTtcbiAgICB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcigndmFsJykpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG4gIGEgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcztcblxuICB2YXIgZG90ID0gc3RhdHMuZG90KGEsIGIpLFxuICAgICAgbXVhID0gc3RhdHMubWVhbihhKSxcbiAgICAgIG11YiA9IHN0YXRzLm1lYW4oYiksXG4gICAgICBzZGEgPSBzdGF0cy5zdGRldihhKSxcbiAgICAgIHNkYiA9IHN0YXRzLnN0ZGV2KGIpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgcmV0dXJuIChkb3QgLSBuKm11YSptdWIpIC8gKChuLTEpICogc2RhICogc2RiKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNwZWFybWFuIHJhbmsgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiB2YWx1ZXMuXG5zdGF0cy5jb3IucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgcmEgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIGEpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIGIpIDogc3RhdHMucmFuayhhKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLCBpLCBzLCBkO1xuXG4gIGZvciAoaT0wLCBzPTA7IGk8bjsgKytpKSB7XG4gICAgZCA9IHJhW2ldIC0gcmJbaV07XG4gICAgcyArPSBkICogZDtcbiAgfVxuXG4gIHJldHVybiAxIC0gNipzIC8gKG4gKiAobipuLTEpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRpc3RhbmNlIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfY29ycmVsYXRpb25cbnN0YXRzLmNvci5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYTtcblxuICB2YXIgQSA9IHN0YXRzLmRpc3QubWF0KFgpLFxuICAgICAgQiA9IHN0YXRzLmRpc3QubWF0KFkpLFxuICAgICAgbiA9IEEubGVuZ3RoLFxuICAgICAgaSwgYWEsIGJiLCBhYjtcblxuICBmb3IgKGk9MCwgYWE9MCwgYmI9MCwgYWI9MDsgaTxuOyArK2kpIHtcbiAgICBhYSArPSBBW2ldKkFbaV07XG4gICAgYmIgKz0gQltpXSpCW2ldO1xuICAgIGFiICs9IEFbaV0qQltpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoYWIgLyBNYXRoLnNxcnQoYWEqYmIpKTtcbn07XG5cbi8vIFNpbXBsZSBsaW5lYXIgcmVncmVzc2lvbi5cbi8vIFJldHVybnMgYSBcImZpdFwiIG9iamVjdCB3aXRoIHNsb3BlIChtKSwgaW50ZXJjZXB0IChiKSxcbi8vIHIgdmFsdWUgKFIpLCBhbmQgc3VtLXNxdWFyZWQgcmVzaWR1YWwgZXJyb3IgKHJzcykuXG5zdGF0cy5saW5lYXJSZWdyZXNzaW9uID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIG4gPSBYLmxlbmd0aCxcbiAgICAgIHh5ID0gc3RhdHMuY292YXJpYW5jZShYLCBZKSwgLy8gd2lsbCB0aHJvdyBlcnIgaWYgdmFsaWQgdmFscyBkb24ndCBhbGlnblxuICAgICAgc3ggPSBzdGF0cy5zdGRldihYKSxcbiAgICAgIHN5ID0gc3RhdHMuc3RkZXYoWSksXG4gICAgICBzbG9wZSA9IHh5IC8gKHN4KnN4KSxcbiAgICAgIGljZXB0ID0gc3RhdHMubWVhbihZKSAtIHNsb3BlICogc3RhdHMubWVhbihYKSxcbiAgICAgIGZpdCA9IHtzbG9wZTogc2xvcGUsIGludGVyY2VwdDogaWNlcHQsIFI6IHh5IC8gKHN4KnN5KSwgcnNzOiAwfSxcbiAgICAgIHJlcywgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKFhbaV0pICYmIHV0aWwuaXNWYWxpZChZW2ldKSkge1xuICAgICAgcmVzID0gKHNsb3BlKlhbaV0gKyBpY2VwdCkgLSBZW2ldO1xuICAgICAgZml0LnJzcyArPSByZXMgKiByZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpdDtcbn07XG5cbi8vIE5hbWVzcGFjZSBmb3IgYm9vdHN0cmFwXG5zdGF0cy5ib290c3RyYXAgPSB7fTtcblxuLy8gQ29uc3RydWN0IGEgYm9vdHN0cmFwcGVkIGNvbmZpZGVuY2UgaW50ZXJ2YWwgYXQgYSBnaXZlbiBwZXJjZW50aWxlIGxldmVsXG4vLyBBcmd1bWVudHMgYXJlIGFuIGFycmF5LCBhbiBvcHRpb25hbCBuIChkZWZhdWx0cyB0byAxMDAwKSxcbi8vICBhbiBvcHRpb25hbCBhbHBoYSAoZGVmYXVsdHMgdG8gMC4wNSksIGFuZCBhbiBvcHRpb25hbCBzbW9vdGhpbmcgcGFyYW1ldGVyXG5zdGF0cy5ib290c3RyYXAuY2kgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGMsIGQpIHtcbiAgdmFyIFgsIE4sIGFscGhhLCBzbW9vdGgsIGJzLCBtZWFucywgaTtcbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihhKSB8fCB1dGlsLmlzU3RyaW5nKGEpKSB7XG4gICAgWCA9IHZhbHVlcy5tYXAodXRpbC4kKGEpKTtcbiAgICBOID0gYjtcbiAgICBhbHBoYSA9IGM7XG4gICAgc21vb3RoID0gZDtcbiAgfSBlbHNlIHtcbiAgICBYID0gdmFsdWVzO1xuICAgIE4gPSBhO1xuICAgIGFscGhhID0gYjtcbiAgICBzbW9vdGggPSBjO1xuICB9XG4gIE4gPSBOID8gK04gOiAxMDAwO1xuICBhbHBoYSA9IGFscGhhIHx8IDAuMDU7XG5cbiAgYnMgPSBnZW4ucmFuZG9tLmJvb3RzdHJhcChYLCBzbW9vdGgpO1xuICBmb3IgKGk9MCwgbWVhbnMgPSBBcnJheShOKTsgaTxOOyArK2kpIHtcbiAgICBtZWFuc1tpXSA9IHN0YXRzLm1lYW4oYnMuc2FtcGxlcyhYLmxlbmd0aCkpO1xuICB9XG4gIG1lYW5zLnNvcnQodXRpbC5udW1jbXApO1xuICByZXR1cm4gW1xuICAgIHN0YXRzLnF1YW50aWxlKG1lYW5zLCBhbHBoYS8yKSxcbiAgICBzdGF0cy5xdWFudGlsZShtZWFucywgMS0oYWxwaGEvMikpXG4gIF07XG59O1xuXG4vLyBOYW1lc3BhY2UgZm9yIHotdGVzdHNcbnN0YXRzLnogPSB7fTtcblxuLy8gQ29uc3RydWN0IGEgei1jb25maWRlbmNlIGludGVydmFsIGF0IGEgZ2l2ZW4gc2lnbmlmaWNhbmNlIGxldmVsXG4vLyBBcmd1bWVudHMgYXJlIGFuIGFycmF5IGFuZCBhbiBvcHRpb25hbCBhbHBoYSAoZGVmYXVsdHMgdG8gMC4wNSkuXG5zdGF0cy56LmNpID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBYID0gdmFsdWVzLCBhbHBoYSA9IGE7XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oYSkgfHwgdXRpbC5pc1N0cmluZyhhKSkge1xuICAgIFggPSB2YWx1ZXMubWFwKHV0aWwuJChhKSk7XG4gICAgYWxwaGEgPSBiO1xuICB9XG4gIGFscGhhID0gYWxwaGEgfHwgMC4wNTtcblxuICB2YXIgeiA9IGFscGhhPT09MC4wNSA/IDEuOTYgOiBnZW4ucmFuZG9tLm5vcm1hbCgwLCAxKS5pY2RmKDEtKGFscGhhLzIpKSxcbiAgICAgIG11ID0gc3RhdHMubWVhbihYKSxcbiAgICAgIFNFID0gc3RhdHMuc3RkZXYoWCkgLyBNYXRoLnNxcnQoc3RhdHMuY291bnQudmFsaWQoWCkpO1xuICByZXR1cm4gW211IC0gKHoqU0UpLCBtdSArICh6KlNFKV07XG59O1xuXG4vLyBQZXJmb3JtIGEgei10ZXN0IG9mIG1lYW5zLiBSZXR1cm5zIHRoZSBwLXZhbHVlLlxuLy8gSWYgYSBzaW5nbGUgYXJyYXkgaXMgcHJvdmlkZWQsIHBlcmZvcm1zIGEgb25lLXNhbXBsZSBsb2NhdGlvbiB0ZXN0LlxuLy8gSWYgdHdvIGFycmF5cyBvciBhIHRhYmxlIGFuZCB0d28gYWNjZXNzb3JzIGFyZSBwcm92aWRlZCwgcGVyZm9ybXNcbi8vIGEgdHdvLXNhbXBsZSBsb2NhdGlvbiB0ZXN0LiBBIHBhaXJlZCB0ZXN0IGlzIHBlcmZvcm1lZCBpZiBzcGVjaWZpZWRcbi8vIGJ5IHRoZSBvcHRpb25zIGhhc2guXG4vLyBUaGUgb3B0aW9ucyBoYXNoIGZvcm1hdCBpczoge3BhaXJlZDogYm9vbGVhbiwgbnVsbGg6IG51bWJlcn0uXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1otdGVzdFxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYWlyZWRfZGlmZmVyZW5jZV90ZXN0XG5zdGF0cy56LnRlc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIG9wdCkge1xuICBpZiAodXRpbC5pc0Z1bmN0aW9uKGIpIHx8IHV0aWwuaXNTdHJpbmcoYikpIHsgLy8gdGFibGUgYW5kIGFjY2Vzc29yc1xuICAgIHJldHVybiAob3B0ICYmIG9wdC5wYWlyZWQgPyB6dGVzdFAgOiB6dGVzdDIpKG9wdCwgdmFsdWVzLCBhLCBiKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzQXJyYXkoYSkpIHsgLy8gdHdvIGFycmF5c1xuICAgIHJldHVybiAoYiAmJiBiLnBhaXJlZCA/IHp0ZXN0UCA6IHp0ZXN0MikoYiwgdmFsdWVzLCBhKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzRnVuY3Rpb24oYSkgfHwgdXRpbC5pc1N0cmluZyhhKSkge1xuICAgIHJldHVybiB6dGVzdDEoYiwgdmFsdWVzLCBhKTsgLy8gdGFibGUgYW5kIGFjY2Vzc29yXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHp0ZXN0MShhLCB2YWx1ZXMpOyAvLyBvbmUgYXJyYXlcbiAgfVxufTtcblxuLy8gUGVyZm9ybSBhIHotdGVzdCBvZiBtZWFucy4gUmV0dXJucyB0aGUgcC12YWx1ZS5cbi8vIEFzc3VtaW5nIHdlIGhhdmUgYSBsaXN0IG9mIHZhbHVlcywgYW5kIGEgbnVsbCBoeXBvdGhlc2lzLiBJZiBubyBudWxsXG4vLyBoeXBvdGhlc2lzLCBhc3N1bWUgb3VyIG51bGwgaHlwb3RoZXNpcyBpcyBtdT0wLlxuZnVuY3Rpb24genRlc3QxKG9wdCwgWCwgZikge1xuICB2YXIgbnVsbEggPSBvcHQgJiYgb3B0Lm51bGxoIHx8IDAsXG4gICAgICBnYXVzc2lhbiA9IGdlbi5yYW5kb20ubm9ybWFsKDAsIDEpLFxuICAgICAgbXUgPSBzdGF0cy5tZWFuKFgsZiksXG4gICAgICBTRSA9IHN0YXRzLnN0ZGV2KFgsZikgLyBNYXRoLnNxcnQoc3RhdHMuY291bnQudmFsaWQoWCxmKSk7XG5cbiAgaWYgKFNFPT09MCkge1xuICAgIC8vIFRlc3Qgbm90IHdlbGwgZGVmaW5lZCB3aGVuIHN0YW5kYXJkIGVycm9yIGlzIDAuXG4gICAgcmV0dXJuIChtdSAtIG51bGxIKSA9PT0gMCA/IDEgOiAwO1xuICB9XG4gIC8vIFR3by1zaWRlZCwgc28gdHdpY2UgdGhlIG9uZS1zaWRlZCBjZGYuXG4gIHZhciB6ID0gKG11IC0gbnVsbEgpIC8gU0U7XG4gIHJldHVybiAyICogZ2F1c3NpYW4uY2RmKC1NYXRoLmFicyh6KSk7XG59XG5cbi8vIFBlcmZvcm0gYSB0d28gc2FtcGxlIHBhaXJlZCB6LXRlc3Qgb2YgbWVhbnMuIFJldHVybnMgdGhlIHAtdmFsdWUuXG5mdW5jdGlvbiB6dGVzdFAob3B0LCB2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgbjEgPSBzdGF0cy5jb3VudChYKSxcbiAgICAgIG4yID0gc3RhdHMuY291bnQoWSksXG4gICAgICBkaWZmcyA9IEFycmF5KCksIGk7XG5cbiAgaWYgKG4xICE9PSBuMikge1xuICAgIHRocm93IEVycm9yKCdBcnJheSBsZW5ndGhzIG11c3QgbWF0Y2guJyk7XG4gIH1cbiAgZm9yIChpPTA7IGk8bjE7ICsraSkge1xuICAgIC8vIE9ubHkgdmFsaWQgZGlmZmVyZW5jZXMgc2hvdWxkIGNvbnRyaWJ1dGUgdG8gdGhlIHRlc3Qgc3RhdGlzdGljXG4gICAgaWYgKHV0aWwuaXNWYWxpZChYW2ldKSAmJiB1dGlsLmlzVmFsaWQoWVtpXSkpIHtcbiAgICAgIGRpZmZzLnB1c2goWFtpXSAtIFlbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdHMuei50ZXN0KGRpZmZzLCBvcHQgJiYgb3B0Lm51bGxoIHx8IDApO1xufVxuXG4vLyBQZXJmb3JtIGEgdHdvIHNhbXBsZSB6LXRlc3Qgb2YgbWVhbnMuIFJldHVybnMgdGhlIHAtdmFsdWUuXG5mdW5jdGlvbiB6dGVzdDIob3B0LCB2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgbjEgPSBzdGF0cy5jb3VudC52YWxpZChYKSxcbiAgICAgIG4yID0gc3RhdHMuY291bnQudmFsaWQoWSksXG4gICAgICBnYXVzc2lhbiA9IGdlbi5yYW5kb20ubm9ybWFsKDAsIDEpLFxuICAgICAgbWVhbkRpZmYgPSBzdGF0cy5tZWFuKFgpIC0gc3RhdHMubWVhbihZKSAtIChvcHQgJiYgb3B0Lm51bGxoIHx8IDApLFxuICAgICAgU0UgPSBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UoWCkvbjEgKyBzdGF0cy52YXJpYW5jZShZKS9uMik7XG5cbiAgaWYgKFNFPT09MCkge1xuICAgIC8vIE5vdCB3ZWxsIGRlZmluZWQgd2hlbiBwb29sZWQgc3RhbmRhcmQgZXJyb3IgaXMgMC5cbiAgICByZXR1cm4gbWVhbkRpZmY9PT0wID8gMSA6IDA7XG4gIH1cbiAgLy8gVHdvLXRhaWxlZCwgc28gdHdpY2UgdGhlIG9uZS1zaWRlZCBjZGYuXG4gIHZhciB6ID0gbWVhbkRpZmYgLyBTRTtcbiAgcmV0dXJuIDIgKiBnYXVzc2lhbi5jZGYoLU1hdGguYWJzKHopKTtcbn1cblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV1cbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXV0dWFsX2luZm9ybWF0aW9uXG5zdGF0cy5tdXR1YWwgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICB2YXIgeCA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIHkgPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGNvdW50cykpIDogYjtcblxuICB2YXIgcHggPSB7fSxcbiAgICAgIHB5ID0ge30sXG4gICAgICBuID0gei5sZW5ndGgsXG4gICAgICBzID0gMCwgSSA9IDAsIEggPSAwLCBwLCB0LCBpO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dID0gMDtcbiAgICBweVt5W2ldXSA9IDA7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSArPSB6W2ldO1xuICAgIHB5W3lbaV1dICs9IHpbaV07XG4gICAgcyArPSB6W2ldO1xuICB9XG5cbiAgdCA9IDEgLyAocyAqIE1hdGguTE4yKTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYgKHpbaV0gPT09IDApIGNvbnRpbnVlO1xuICAgIHAgPSAocyAqIHpbaV0pIC8gKHB4W3hbaV1dICogcHlbeVtpXV0pO1xuICAgIEkgKz0geltpXSAqIHQgKiBNYXRoLmxvZyhwKTtcbiAgICBIICs9IHpbaV0gKiB0ICogTWF0aC5sb2coeltpXS9zKTtcbiAgfVxuXG4gIHJldHVybiBbSSwgMSArIEkvSF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuc3RhdHMubXV0dWFsLmluZm8gPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVswXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG5zdGF0cy5tdXR1YWwuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzFdO1xufTtcblxuLy8gQ29tcHV0ZSBhIHByb2ZpbGUgb2Ygc3VtbWFyeSBzdGF0aXN0aWNzIGZvciBhIHZhcmlhYmxlLlxuc3RhdHMucHJvZmlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgbWVhbiA9IDAsXG4gICAgICB2YWxpZCA9IDAsXG4gICAgICBtaXNzaW5nID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHg7XG5cbiAgLy8gY29tcHV0ZSBzdW1tYXJ5IHN0YXRzXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICsrbWlzc2luZztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBpZiAobWluPT09bnVsbCB8fCB4IDwgbWluKSBtaW4gPSB4O1xuICAgICAgaWYgKG1heD09PW51bGwgfHwgeCA+IG1heCkgbWF4ID0geDtcbiAgICAgIGRlbHRhID0geCAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrdmFsaWQpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHggLSBtZWFuKTtcbiAgICAgIHZhbHMucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvICh2YWxpZCAtIDEpO1xuICBzZCA9IE1hdGguc3FydChNMik7XG5cbiAgLy8gc29ydCB2YWx1ZXMgZm9yIG1lZGlhbiBhbmQgaXFyXG4gIHZhbHMuc29ydCh1dGlsLmNtcCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAgICAgdHlwZSh2YWx1ZXMsIGYpLFxuICAgIHVuaXF1ZTogICB1LFxuICAgIGNvdW50OiAgICB2YWx1ZXMubGVuZ3RoLFxuICAgIHZhbGlkOiAgICB2YWxpZCxcbiAgICBtaXNzaW5nOiAgbWlzc2luZyxcbiAgICBkaXN0aW5jdDogZGlzdGluY3QsXG4gICAgbWluOiAgICAgIG1pbixcbiAgICBtYXg6ICAgICAgbWF4LFxuICAgIG1lYW46ICAgICBtZWFuLFxuICAgIHN0ZGV2OiAgICBzZCxcbiAgICBtZWRpYW46ICAgKHYgPSBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjUpKSxcbiAgICBxMTogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC4yNSksXG4gICAgcTM6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNzUpLFxuICAgIG1vZGVza2V3OiBzZCA9PT0gMCA/IDAgOiAobWVhbiAtIHYpIC8gc2RcbiAgfTtcbn07XG5cbi8vIENvbXB1dGUgcHJvZmlsZXMgZm9yIGFsbCB2YXJpYWJsZXMgaW4gYSBkYXRhIHNldC5cbnN0YXRzLnN1bW1hcnkgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgdmFyIHMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcCA9IHN0YXRzLnByb2ZpbGUoZGF0YSwgdXRpbC4kKGYpKTtcbiAgICByZXR1cm4gKHAuZmllbGQgPSBmLCBwKTtcbiAgfSk7XG4gIHJldHVybiAocy5fX3N1bW1hcnlfXyA9IHRydWUsIHMpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcblxudmFyIGNvbnRleHQgPSB7XG4gIGZvcm1hdHM6ICAgIFtdLFxuICBmb3JtYXRfbWFwOiB7fSxcbiAgdHJ1bmNhdGU6ICAgdXRpbC50cnVuY2F0ZSxcbiAgcGFkOiAgICAgICAgdXRpbC5wYWQsXG4gIGRheTogICAgICAgIGZvcm1hdC5kYXksXG4gIG1vbnRoOiAgICAgIGZvcm1hdC5tb250aCxcbiAgcXVhcnRlcjogICAgZm9ybWF0LnF1YXJ0ZXIsXG4gIHV0Y1F1YXJ0ZXI6IGZvcm1hdC51dGNRdWFydGVyXG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0KSB7XG4gIHZhciBzcmMgPSBzb3VyY2UodGV4dCwgJ2QnKTtcbiAgc3JjID0gJ3ZhciBfX3Q7IHJldHVybiAnICsgc3JjICsgJzsnO1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIHJldHVybiAobmV3IEZ1bmN0aW9uKCdkJywgc3JjKSkuYmluZChjb250ZXh0KTtcbn1cblxudGVtcGxhdGUuc291cmNlID0gc291cmNlO1xudGVtcGxhdGUuY29udGV4dCA9IGNvbnRleHQ7XG50ZW1wbGF0ZS5mb3JtYXQgPSBnZXRfZm9ybWF0O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuLy8gQ2xlYXIgY2FjaGUgb2YgZm9ybWF0IG9iamVjdHMuXG4vLyBUaGlzIGNhbiAqYnJlYWsqIHByaW9yIHRlbXBsYXRlIGZ1bmN0aW9ucywgc28gaW52b2tlIHdpdGggY2FyZSFcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuLy8gR2VuZXJhdGUgcHJvcGVydHkgYWNjZXNzIGNvZGUgZm9yIHVzZSB3aXRoaW4gdGVtcGxhdGUgc291cmNlLlxuLy8gb2JqZWN0OiB0aGUgbmFtZSBvZiB0aGUgb2JqZWN0ICh2YXJpYWJsZSkgY29udGFpbmluZyB0ZW1wbGF0ZSBkYXRhXG4vLyBwcm9wZXJ0eTogdGhlIHByb3BlcnR5IGFjY2VzcyBzdHJpbmcsIHZlcmJhdGltIGZyb20gdGVtcGxhdGUgdGFnXG50ZW1wbGF0ZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdmFyIHNyYyA9IHV0aWwuZmllbGQocHJvcGVydHkpLm1hcCh1dGlsLnN0cikuam9pbignXVsnKTtcbiAgcmV0dXJuIG9iamVjdCArICdbJyArIHNyYyArICddJztcbn07XG5cbi8vIEdlbmVyYXRlIHNvdXJjZSBjb2RlIGZvciBhIHRlbXBsYXRlIGZ1bmN0aW9uLlxuLy8gdGV4dDogdGhlIHRlbXBsYXRlIHRleHRcbi8vIHZhcmlhYmxlOiB0aGUgbmFtZSBvZiB0aGUgZGF0YSBvYmplY3QgdmFyaWFibGUgKCdvYmonIGJ5IGRlZmF1bHQpXG4vLyBwcm9wZXJ0aWVzOiBvcHRpb25hbCBoYXNoIGZvciBjb2xsZWN0aW5nIGFsbCBhY2Nlc3NlZCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBzb3VyY2UodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyaWFibGUgPSB2YXJpYWJsZSB8fCAnb2JqJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHNyYyA9ICdcXCcnO1xuICB2YXIgcmVnZXggPSB0ZW1wbGF0ZV9yZTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBpbnRlcnBvbGF0ZSwgb2Zmc2V0KSB7XG4gICAgc3JjICs9IHRleHRcbiAgICAgIC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UodGVtcGxhdGVfZXNjYXBlciwgdGVtcGxhdGVfZXNjYXBlQ2hhcik7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgIHNyYyArPSAnXFwnXFxuKygoX190PSgnICtcbiAgICAgICAgdGVtcGxhdGVfdmFyKGludGVycG9sYXRlLCB2YXJpYWJsZSwgcHJvcGVydGllcykgK1xuICAgICAgICAnKSk9PW51bGw/XFwnXFwnOl9fdCkrXFxuXFwnJztcbiAgICB9XG5cbiAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcbiAgcmV0dXJuIHNyYyArICdcXCcnO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZV92YXIodGV4dCwgdmFyaWFibGUsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGZpbHRlcnMgPSB0ZXh0Lm1hdGNoKGZpbHRlcl9yZSk7XG4gIHZhciBwcm9wID0gZmlsdGVycy5zaGlmdCgpLnRyaW0oKTtcbiAgdmFyIHN0cmluZ0Nhc3QgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8ICcnO1xuICAgIGlmIChzdHJpbmdDYXN0KSB7XG4gICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICBzcmMgPSAnU3RyaW5nKCcgKyBzcmMgKyAnKScgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG5cbiAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gJyh0eXBlb2YgJyArIHNyYyArICc9PT1cIm51bWJlclwiP25ldyBEYXRlKCcrc3JjKycpOicrc3JjKycpJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdHRlcih0eXBlKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBhcmdzWzBdO1xuICAgIGlmICgocGF0dGVyblswXSA9PT0gJ1xcJycgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aC0xXSA9PT0gJ1xcJycpIHx8XG4gICAgICAgIChwYXR0ZXJuWzBdID09PSAnXCInICAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXCInKSkge1xuICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignRm9ybWF0IHBhdHRlcm4gbXVzdCBiZSBxdW90ZWQ6ICcgKyBwYXR0ZXJuKTtcbiAgICB9XG4gICAgYSA9IHRlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCB0eXBlKTtcbiAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgdmFyIGFyZyA9IHR5cGUgPT09ICdudW1iZXInID8gc3JjIDogZGF0ZSgpO1xuICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrYXJnKycpJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0aWVzKSBwcm9wZXJ0aWVzW3Byb3BdID0gMTtcbiAgdmFyIHNyYyA9IHRlbXBsYXRlLnByb3BlcnR5KHZhcmlhYmxlLCBwcm9wKTtcblxuICBmb3IgKHZhciBpPTA7IGk8ZmlsdGVycy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmID0gZmlsdGVyc1tpXSwgYXJncyA9IG51bGwsIHBpZHgsIGEsIGI7XG5cbiAgICBpZiAoKHBpZHg9Zi5pbmRleE9mKCc6JykpID4gMCkge1xuICAgICAgZiA9IGYuc2xpY2UoMCwgcGlkeCk7XG4gICAgICBhcmdzID0gZmlsdGVyc1tpXS5zbGljZShwaWR4KzEpXG4gICAgICAgIC5tYXRjaChhcmdzX3JlKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9KTtcbiAgICB9XG4gICAgZiA9IGYudHJpbSgpO1xuXG4gICAgc3dpdGNoIChmKSB7XG4gICAgICBjYXNlICdsZW5ndGgnOlxuICAgICAgICBzdHJjYWxsKCcubGVuZ3RoJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVMb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZVVwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJpbSc6XG4gICAgICAgIHN0cmNhbGwoJy50cmltKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoMCwnICsgYSArICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgtJyArIGEgKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYSArIHV0aWwubnVtYmVyKGFyZ3NbMV0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoKycrYSsnLCcrYisnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NsaWNlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoJysgYSArXG4gICAgICAgICAgKGFyZ3MubGVuZ3RoID4gMSA/ICcsJyArIHV0aWwubnVtYmVyKGFyZ3NbMV0pIDogJycpICtcbiAgICAgICAgICAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYXJnc1sxXTtcbiAgICAgICAgYiA9IChiIT09J2xlZnQnICYmIGIhPT0nbWlkZGxlJyAmJiBiIT09J2NlbnRlcicpID8gJ3JpZ2h0JyA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnRydW5jYXRlKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMucGFkKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBmb3JtYXR0ZXIoJ251bWJlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICBmb3JtYXR0ZXIoJ3RpbWUnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aW1lLXV0Yyc6XG4gICAgICAgIGZvcm1hdHRlcigndXRjJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBzcmMgPSAndGhpcy5tb250aCgnICsgc3JjICsgJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vbnRoLWFiYnJldic6XG4gICAgICAgIHNyYyA9ICd0aGlzLm1vbnRoKCcgKyBzcmMgKyAnLHRydWUpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXknOlxuICAgICAgICBzcmMgPSAndGhpcy5kYXkoJyArIHNyYyArICcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXktYWJicmV2JzpcbiAgICAgICAgc3JjID0gJ3RoaXMuZGF5KCcgKyBzcmMgKyAnLHRydWUpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgc3JjID0gJ3RoaXMucXVhcnRlcignICsgc3JjICsgJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3F1YXJ0ZXItdXRjJzpcbiAgICAgICAgc3JjID0gJ3RoaXMudXRjUXVhcnRlcignICsgc3JjICsgJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKCdVbnJlY29nbml6ZWQgdGVtcGxhdGUgZmlsdGVyOiAnICsgZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNyYztcbn1cblxudmFyIHRlbXBsYXRlX3JlID0gL1xce1xceyguKz8pXFx9XFx9fCQvZyxcbiAgICBmaWx0ZXJfcmUgPSAvKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFteXFx8XCJdK3xbXlxcfFxcJ10rKSsvZyxcbiAgICBhcmdzX3JlID0gLyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xbXixcIl0rfFteLFxcJ10rKSsvZztcblxuLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbi8vIHN0cmluZyBsaXRlcmFsLlxudmFyIHRlbXBsYXRlX2VzY2FwZXMgPSB7XG4gICdcXCcnOiAgICAgJ1xcJycsXG4gICdcXFxcJzogICAgICdcXFxcJyxcbiAgJ1xccic6ICAgICAncicsXG4gICdcXG4nOiAgICAgJ24nLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxudmFyIHRlbXBsYXRlX2VzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2VzY2FwZUNoYXIobWF0Y2gpIHtcbiAgcmV0dXJuICdcXFxcJyArIHRlbXBsYXRlX2VzY2FwZXNbbWF0Y2hdO1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9mb3JtYXQocGF0dGVybiwgdHlwZSkge1xuICB2YXIga2V5ID0gdHlwZSArICc6JyArIHBhdHRlcm47XG4gIGlmIChjb250ZXh0LmZvcm1hdF9tYXBba2V5XSA9PSBudWxsKSB7XG4gICAgdmFyIGYgPSBmb3JtYXRbdHlwZV0ocGF0dGVybik7XG4gICAgdmFyIGkgPSBjb250ZXh0LmZvcm1hdHMubGVuZ3RoO1xuICAgIGNvbnRleHQuZm9ybWF0cy5wdXNoKGYpO1xuICAgIGNvbnRleHQuZm9ybWF0X21hcFtrZXldID0gaTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5mb3JtYXRfbWFwW2tleV07XG59XG5cbmZ1bmN0aW9uIGdldF9mb3JtYXQocGF0dGVybiwgdHlwZSkge1xuICByZXR1cm4gY29udGV4dC5mb3JtYXRzW3RlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCB0eXBlKV07XG59XG4iLCJ2YXIgZDNfdGltZSA9IHJlcXVpcmUoJ2QzLXRpbWUnKTtcblxudmFyIHRlbXBEYXRlID0gbmV3IERhdGUoKSxcbiAgICBiYXNlRGF0ZSA9IG5ldyBEYXRlKDAsIDAsIDEpLnNldEZ1bGxZZWFyKDApLCAvLyBKYW4gMSwgMCBBRFxuICAgIHV0Y0Jhc2VEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMCwgMCwgMSkpLnNldFVUQ0Z1bGxZZWFyKDApO1xuXG5mdW5jdGlvbiBkYXRlKGQpIHtcbiAgcmV0dXJuICh0ZW1wRGF0ZS5zZXRUaW1lKCtkKSwgdGVtcERhdGUpO1xufVxuXG4vLyBjcmVhdGUgYSB0aW1lIHVuaXQgZW50cnlcbmZ1bmN0aW9uIGVudHJ5KHR5cGUsIGRhdGUsIHVuaXQsIHN0ZXAsIG1pbiwgbWF4KSB7XG4gIHZhciBlID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgZGF0ZTogZGF0ZSxcbiAgICB1bml0OiB1bml0XG4gIH07XG4gIGlmIChzdGVwKSB7XG4gICAgZS5zdGVwID0gc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBlLm1pbnN0ZXAgPSAxO1xuICB9XG4gIGlmIChtaW4gIT0gbnVsbCkgZS5taW4gPSBtaW47XG4gIGlmIChtYXggIT0gbnVsbCkgZS5tYXggPSBtYXg7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgdW5pdCwgYmFzZSwgc3RlcCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIGVudHJ5KHR5cGUsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5vZmZzZXQoYmFzZSwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gdW5pdC5jb3VudChiYXNlLCBkKTsgfSxcbiAgICBzdGVwLCBtaW4sIG1heCk7XG59XG5cbnZhciBsb2NhbGUgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS5zZWNvbmQsIGJhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLm1pbnV0ZSwgYmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUuaG91ciwgICBiYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS5kYXksICAgIGJhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUubW9udGgsICBiYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnllYXIsICAgYmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCAwLCAwLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFNlY29uZHMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnbWludXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRNaW51dGVzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ2hvdXJzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCAxLCBkKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldEhvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCAwLCA0K2QpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0RGF5KCk7IH0sXG4gICAgWzFdLCAwLCA2XG4gICksXG4gIGVudHJ5KCdkYXRlcycsXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgZCk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXREYXRlKCk7IH0sXG4gICAgWzFdLCAxLCAzMVxuICApLFxuICBlbnRyeSgnbW9udGhzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZSgxOTcwLCBkICUgMTIsIDEpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0TW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciB1dGMgPSBbXG4gIGNyZWF0ZSgnc2Vjb25kJywgZDNfdGltZS51dGNTZWNvbmQsIHV0Y0Jhc2VEYXRlKSxcbiAgY3JlYXRlKCdtaW51dGUnLCBkM190aW1lLnV0Y01pbnV0ZSwgdXRjQmFzZURhdGUpLFxuICBjcmVhdGUoJ2hvdXInLCAgIGQzX3RpbWUudXRjSG91ciwgICB1dGNCYXNlRGF0ZSksXG4gIGNyZWF0ZSgnZGF5JywgICAgZDNfdGltZS51dGNEYXksICAgIHV0Y0Jhc2VEYXRlLCBbMSwgN10pLFxuICBjcmVhdGUoJ21vbnRoJywgIGQzX3RpbWUudXRjTW9udGgsICB1dGNCYXNlRGF0ZSwgWzEsIDMsIDZdKSxcbiAgY3JlYXRlKCd5ZWFyJywgICBkM190aW1lLnV0Y1llYXIsICAgdXRjQmFzZURhdGUpLFxuXG4gIC8vIHBlcmlvZGljIHVuaXRzXG4gIGVudHJ5KCdzZWNvbmRzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCAwLCBkKSk7IH0sXG4gICAgZnVuY3Rpb24oZCkgeyByZXR1cm4gZGF0ZShkKS5nZXRVVENTZWNvbmRzKCk7IH0sXG4gICAgbnVsbCwgMCwgNTlcbiAgKSxcbiAgZW50cnkoJ21pbnV0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ01pbnV0ZXMoKTsgfSxcbiAgICBudWxsLCAwLCA1OVxuICApLFxuICBlbnRyeSgnaG91cnMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0hvdXJzKCk7IH0sXG4gICAgbnVsbCwgMCwgMjNcbiAgKSxcbiAgZW50cnkoJ3dlZWtkYXlzJyxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0K2QpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RheSgpOyB9LFxuICAgIFsxXSwgMCwgNlxuICApLFxuICBlbnRyeSgnZGF0ZXMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTsgfSxcbiAgICBmdW5jdGlvbihkKSB7IHJldHVybiBkYXRlKGQpLmdldFVUQ0RhdGUoKTsgfSxcbiAgICBbMV0sIDEsIDMxXG4gICksXG4gIGVudHJ5KCdtb250aHMnLFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpOyB9LFxuICAgIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRhdGUoZCkuZ2V0VVRDTW9udGgoKTsgfSxcbiAgICBbMV0sIDAsIDExXG4gIClcbl07XG5cbnZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG5mdW5jdGlvbiBmaW5kKHVuaXRzLCBzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBzdGVwID0gU1RFUFNbMF0sIGksIG4sIGJpbnM7XG5cbiAgZm9yIChpPTEsIG49U1RFUFMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gdW5pdHNbU1RFUFNbaS0xXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiB1bml0c1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuaXRzW1NURVBTW24tMV1bMV1dO1xufVxuXG5mdW5jdGlvbiB0b1VuaXRNYXAodW5pdHMpIHtcbiAgdmFyIG1hcCA9IHt9LCBpLCBuO1xuICBmb3IgKGk9MCwgbj11bml0cy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgbWFwW3VuaXRzW2ldLnR5cGVdID0gdW5pdHNbaV07XG4gIH1cbiAgbWFwLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gICAgcmV0dXJuIGZpbmQodW5pdHMsIHNwYW4sIG1pbmIsIG1heGIpO1xuICB9O1xuICByZXR1cm4gbWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvVW5pdE1hcChsb2NhbGUpO1xubW9kdWxlLmV4cG9ydHMudXRjID0gdG9Vbml0TWFwKHV0Yyk7IiwidmFyIHUgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudmFyIEZOQU1FID0gJ19fbmFtZV9fJztcblxudS5uYW1lZGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBmKSB7IHJldHVybiAoZltGTkFNRV0gPSBuYW1lLCBmKTsgfTtcblxudS5uYW1lID0gZnVuY3Rpb24oZikgeyByZXR1cm4gZj09bnVsbCA/IG51bGwgOiBmW0ZOQU1FXTsgfTtcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IHUubmFtZWRmdW5jKCd0cnVlJywgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9KTtcblxudS5mYWxzZSA9IHUubmFtZWRmdW5jKCdmYWxzZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0pO1xuXG51LmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnUuZXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG59O1xuXG51LmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICBmb3IgKHZhciB4LCBuYW1lLCBpPTEsIGxlbj1hcmd1bWVudHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKG5hbWUgaW4geCkgeyBvYmpbbmFtZV0gPSB4W25hbWVdOyB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbnUubGVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHgubGVuZ3RoICE9IG51bGwgPyB4Lmxlbmd0aCA6IG51bGw7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0LCBmKSB7XG4gIHJldHVybiAoZiA9IHUuJChmKSkgP1xuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialtmKHgpXSA9IDEsIG9iaik7IH0sIHt9KSA6XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW3hdID0gMSwgb2JqKTsgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmo7XG59O1xuXG51LmlzQnVmZmVyID0gKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKSB8fCB1LmZhbHNlO1xuXG4vLyB0eXBlIGNvZXJjaW9uIGZ1bmN0aW9uc1xuXG51Lm51bWJlciA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiArcztcbn07XG5cbnUuYm9vbGVhbiA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBzPT09J2ZhbHNlJyA/IGZhbHNlIDogISFzO1xufTtcblxuLy8gcGFyc2UgYSBkYXRlIHdpdGggb3B0aW9uYWwgZDMudGltZS1mb3JtYXQgZm9ybWF0XG51LmRhdGUgPSBmdW5jdGlvbihzLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSBmb3JtYXQgPyBmb3JtYXQgOiBEYXRlO1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IGQucGFyc2Uocyk7XG59O1xuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107XG59O1xuXG51LnN0ciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHUuaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKHUuc3RyKSArICddJ1xuICAgIDogdS5pc09iamVjdCh4KSB8fCB1LmlzU3RyaW5nKHgpID9cbiAgICAgIC8vIE91dHB1dCB2YWxpZCBKU09OIGFuZCBKUyBzb3VyY2Ugc3RyaW5ncy5cbiAgICAgIC8vIFNlZSBodHRwOi8vdGltZWxlc3NyZXBvLmNvbS9qc29uLWlzbnQtYS1qYXZhc2NyaXB0LXN1YnNldFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeCkucmVwbGFjZSgnXFx1MjAyOCcsJ1xcXFx1MjAyOCcpLnJlcGxhY2UoJ1xcdTIwMjknLCAnXFxcXHUyMDI5JylcbiAgICA6IHg7XG59O1xuXG4vLyBkYXRhIGFjY2VzcyBmdW5jdGlvbnNcblxudmFyIGZpZWxkX3JlID0gL1xcWyguKj8pXFxdfFteLlxcW10rL2c7XG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikubWF0Y2goZmllbGRfcmUpLm1hcChmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGRbMF0gIT09ICdbJyA/IGQgOlxuICAgICAgZFsxXSAhPT0gXCInXCIgJiYgZFsxXSAhPT0gJ1wiJyA/IGQuc2xpY2UoMSwgLTEpIDpcbiAgICAgIGQuc2xpY2UoMiwgLTIpLnJlcGxhY2UoL1xcXFwoW1wiJ10pL2csICckMScpO1xuICB9KTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIEZ1bmN0aW9uKCd4JywgJ3JldHVybiB4WycgKyB1LmZpZWxkKGYpLm1hcCh1LnN0cikuam9pbignXVsnKSArICddOycpKTtcbn07XG5cbi8vIHNob3J0LWN1dCBmb3IgYWNjZXNzb3JcbnUuJCA9IHUuYWNjZXNzb3I7XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgeFtzW2ldXSA9IHY7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxudS4kZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgZiA9IHUuJChmKSB8fCB1LmlkZW50aXR5O1xuICAgIHZhciBuID0gbmFtZSArICh1Lm5hbWUoZikgPyAnXycrdS5uYW1lKGYpIDogJycpO1xuICAgIHJldHVybiB1Lm5hbWVkZnVuYyhuLCBmdW5jdGlvbihkKSB7IHJldHVybiBvcChmKGQpKTsgfSk7XG4gIH07XG59O1xuXG51LiR2YWxpZCAgPSB1LiRmdW5jKCd2YWxpZCcsIHUuaXNWYWxpZCk7XG51LiRsZW5ndGggPSB1LiRmdW5jKCdsZW5ndGgnLCB1Lmxlbmd0aCk7XG5cbnUuJGluID0gZnVuY3Rpb24oZiwgdmFsdWVzKSB7XG4gIGYgPSB1LiQoZik7XG4gIHZhciBtYXAgPSB1LmlzQXJyYXkodmFsdWVzKSA/IHUudG9NYXAodmFsdWVzKSA6IHZhbHVlcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhbWFwW2YoZCldOyB9O1xufTtcblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSAnLScpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09ICcrJykgeyBzID0gKzE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgc2lnbi5wdXNoKHMpO1xuICAgIHJldHVybiB1LmFjY2Vzc29yKGYpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgYztcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldO1xuICAgICAgYyA9IHUuY21wKGYoYSksIGYoYikpO1xuICAgICAgaWYgKGMpIHJldHVybiBjICogc2lnbltpXTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59O1xuXG51LmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIChhIDwgYiB8fCBhID09IG51bGwpICYmIGIgIT0gbnVsbCA/IC0xIDpcbiAgICAoYSA+IGIgfHwgYiA9PSBudWxsKSAmJiBhICE9IG51bGwgPyAxIDpcbiAgICAoKGIgPSBiIGluc3RhbmNlb2YgRGF0ZSA/ICtiIDogYiksXG4gICAgIChhID0gYSBpbnN0YW5jZW9mIERhdGUgPyArYSA6IGEpKSAhPT0gYSAmJiBiID09PSBiID8gLTEgOlxuICAgIGIgIT09IGIgJiYgYSA9PT0gYSA/IDEgOiAwO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLy8gcGVybXV0ZXMgYW4gYXJyYXkgdXNpbmcgYSBLbnV0aCBzaHVmZmxlXG51LnBlcm11dGUgPSBmdW5jdGlvbihhKSB7XG4gIHZhciBtID0gYS5sZW5ndGgsXG4gICAgICBzd2FwLFxuICAgICAgaTtcblxuICB3aGlsZSAobSkge1xuICAgIGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtLS0pO1xuICAgIHN3YXAgPSBhW21dO1xuICAgIGFbbV0gPSBhW2ldO1xuICAgIGFbaV0gPSBzd2FwO1xuICB9XG59O1xuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbnUucGFkID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHBhZGNoYXIpIHtcbiAgcGFkY2hhciA9IHBhZGNoYXIgfHwgXCIgXCI7XG4gIHZhciBkID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIGlmIChkIDw9IDApIHJldHVybiBzO1xuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIHN0cnJlcChkLCBwYWRjaGFyKSArIHM7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgcmV0dXJuIHN0cnJlcChNYXRoLmZsb29yKGQvMiksIHBhZGNoYXIpICtcbiAgICAgICAgIHMgKyBzdHJyZXAoTWF0aC5jZWlsKGQvMiksIHBhZGNoYXIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcyArIHN0cnJlcChkLCBwYWRjaGFyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RycmVwKG4sIHN0cikge1xuICB2YXIgcyA9IFwiXCIsIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG51LnRydW5jYXRlID0gZnVuY3Rpb24ocywgbGVuZ3RoLCBwb3MsIHdvcmQsIGVsbGlwc2lzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgaWYgKGxlbiA8PSBsZW5ndGgpIHJldHVybiBzO1xuICBlbGxpcHNpcyA9IGVsbGlwc2lzICE9PSB1bmRlZmluZWQgPyBTdHJpbmcoZWxsaXBzaXMpIDogJ1xcdTIwMjYnO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgK1xuICAgICAgICBlbGxpcHNpcyArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKCcnKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHRydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcbiIsInZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSBzcGFjZSA9IEFycmF5KHNwYWNlKzEpLmpvaW4oJyAnKTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKHBhcmVudCwga2V5LCBub2RlLCBsZXZlbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJztcbiAgICAgICAgdmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0cmluZ2lmeShub2RlLCBpLCBub2RlW2ldLCBsZXZlbCsxKSB8fCBqc29uLnN0cmluZ2lmeShudWxsKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBqc29uLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCsxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgICAgICAgICsgY29sb25TZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBrZXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcbiIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcbiIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgoZ2xvYmFsLnRvcG9qc29uID0gZ2xvYmFsLnRvcG9qc29uIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhbnNmb3JtQWJzb2x1dGUodHJhbnNmb3JtKSB7XG4gIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgdmFyIHgwLFxuICAgICAgeTAsXG4gICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcbiAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgIHBvaW50WzBdID0gKHgwICs9IHBvaW50WzBdKSAqIGt4ICsgZHg7XG4gICAgcG9pbnRbMV0gPSAoeTAgKz0gcG9pbnRbMV0pICoga3kgKyBkeTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUmVsYXRpdmUodHJhbnNmb3JtKSB7XG4gIGlmICghdHJhbnNmb3JtKSByZXR1cm4gbm9vcDtcbiAgdmFyIHgwLFxuICAgICAgeTAsXG4gICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24ocG9pbnQsIGkpIHtcbiAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgIHZhciB4MSA9IE1hdGgucm91bmQoKHBvaW50WzBdIC0gZHgpIC8ga3gpLFxuICAgICAgICB5MSA9IE1hdGgucm91bmQoKHBvaW50WzFdIC0gZHkpIC8ga3kpO1xuICAgIHBvaW50WzBdID0geDEgLSB4MDtcbiAgICBwb2ludFsxXSA9IHkxIC0geTA7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXZlcnNlKGFycmF5LCBuKSB7XG4gIHZhciB0LCBqID0gYXJyYXkubGVuZ3RoLCBpID0gaiAtIG47XG4gIHdoaWxlIChpIDwgLS1qKSB0ID0gYXJyYXlbaV0sIGFycmF5W2krK10gPSBhcnJheVtqXSwgYXJyYXlbal0gPSB0O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUodG9wb2xvZ3ksIG8pIHtcbiAgcmV0dXJuIG8udHlwZSA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gICAgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSQxKHRvcG9sb2d5LCBvKTsgfSlcbiAgfSA6IGZlYXR1cmUkMSh0b3BvbG9neSwgbyk7XG59XG5cbmZ1bmN0aW9uIGZlYXR1cmUkMSh0b3BvbG9neSwgbykge1xuICB2YXIgZiA9IHtcbiAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICBpZDogby5pZCxcbiAgICBwcm9wZXJ0aWVzOiBvLnByb3BlcnRpZXMgfHwge30sXG4gICAgZ2VvbWV0cnk6IG9iamVjdCh0b3BvbG9neSwgbylcbiAgfTtcbiAgaWYgKG8uaWQgPT0gbnVsbCkgZGVsZXRlIGYuaWQ7XG4gIHJldHVybiBmO1xufVxuXG5mdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGFic29sdXRlID0gdHJhbnNmb3JtQWJzb2x1dGUodG9wb2xvZ3kudHJhbnNmb3JtKSxcbiAgICAgIGFyY3MgPSB0b3BvbG9neS5hcmNzO1xuXG4gIGZ1bmN0aW9uIGFyYyhpLCBwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCkgcG9pbnRzLnBvcCgpO1xuICAgIGZvciAodmFyIGEgPSBhcmNzW2kgPCAwID8gfmkgOiBpXSwgayA9IDAsIG4gPSBhLmxlbmd0aCwgcDsgayA8IG47ICsraykge1xuICAgICAgcG9pbnRzLnB1c2gocCA9IGFba10uc2xpY2UoKSk7XG4gICAgICBhYnNvbHV0ZShwLCBrKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcCA9IHAuc2xpY2UoKTtcbiAgICBhYnNvbHV0ZShwLCAwKTtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGFyY3MubGVuZ3RoOyBpIDwgbjsgKytpKSBhcmMoYXJjc1tpXSwgcG9pbnRzKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDIpIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0uc2xpY2UoKSk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdCA9IG8udHlwZTtcbiAgICByZXR1cm4gdCA9PT0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiA/IHt0eXBlOiB0LCBnZW9tZXRyaWVzOiBvLmdlb21ldHJpZXMubWFwKGdlb21ldHJ5KX1cbiAgICAgICAgOiB0IGluIGdlb21ldHJ5VHlwZSA/IHt0eXBlOiB0LCBjb29yZGluYXRlczogZ2VvbWV0cnlUeXBlW3RdKG8pfVxuICAgICAgICA6IG51bGw7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIFBvaW50OiBmdW5jdGlvbihvKSB7IHJldHVybiBwb2ludChvLmNvb3JkaW5hdGVzKTsgfSxcbiAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IH0sXG4gICAgTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gbGluZShvLmFyY3MpOyB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24obykgeyByZXR1cm4gby5hcmNzLm1hcChsaW5lKTsgfSxcbiAgICBQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBwb2x5Z29uKG8uYXJjcyk7IH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFyY3MubWFwKHBvbHlnb24pOyB9XG4gIH07XG5cbiAgcmV0dXJuIGdlb21ldHJ5KG8pO1xufVxuXG5mdW5jdGlvbiBzdGl0Y2hBcmNzKHRvcG9sb2d5LCBhcmNzKSB7XG4gIHZhciBzdGl0Y2hlZEFyY3MgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgZnJhZ21lbnRCeUVuZCA9IHt9LFxuICAgICAgZnJhZ21lbnRzID0gW10sXG4gICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgLy8gU3RpdGNoIGVtcHR5IGFyY3MgZmlyc3QsIHNpbmNlIHRoZXkgbWF5IGJlIHN1YnN1bWVkIGJ5IG90aGVyIGFyY3MuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpLCBqKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgIGlmIChhcmMubGVuZ3RoIDwgMyAmJiAhYXJjWzFdWzBdICYmICFhcmNbMV1bMV0pIHtcbiAgICAgIHQgPSBhcmNzWysrZW1wdHlJbmRleF0sIGFyY3NbZW1wdHlJbmRleF0gPSBpLCBhcmNzW2pdID0gdDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICBzdGFydCA9IGVbMF0sXG4gICAgICAgIGVuZCA9IGVbMV0sXG4gICAgICAgIGYsIGc7XG5cbiAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICBmLnB1c2goaSk7XG4gICAgICBmLmVuZCA9IGVuZDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgdmFyIGZnID0gZyA9PT0gZiA/IGYgOiBmLmNvbmNhdChnKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2ZnLnN0YXJ0ID0gZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2ZnLmVuZCA9IGcuZW5kXSA9IGZnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZi51bnNoaWZ0KGkpO1xuICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG4gICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtnZi5zdGFydCA9IGcuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnZi5lbmQgPSBmLmVuZF0gPSBnZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZiA9IFtpXTtcbiAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0ID0gc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZF0gPSBmO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5kcyhpKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCBwMCA9IGFyY1swXSwgcDE7XG4gICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgZWxzZSBwMSA9IGFyY1thcmMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGkgPCAwID8gW3AxLCBwMF0gOiBbcDAsIHAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCkge1xuICAgIGZvciAodmFyIGsgaW4gZnJhZ21lbnRCeUVuZCkge1xuICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGRlbGV0ZSBmLnN0YXJ0O1xuICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSA9IDE7IH0pO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZik7XG4gICAgfVxuICB9XG5cbiAgZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KTtcbiAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgaWYgKCFzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldKSBmcmFnbWVudHMucHVzaChbaV0pOyB9KTtcblxuICByZXR1cm4gZnJhZ21lbnRzO1xufVxuXG5mdW5jdGlvbiBtZXNoKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5mdW5jdGlvbiBtZXNoQXJjcyh0b3BvbG9neSwgbywgZmlsdGVyKSB7XG4gIHZhciBhcmNzID0gW107XG5cbiAgZnVuY3Rpb24gYXJjKGkpIHtcbiAgICB2YXIgaiA9IGkgPCAwID8gfmkgOiBpO1xuICAgIChnZW9tc0J5QXJjW2pdIHx8IChnZW9tc0J5QXJjW2pdID0gW10pKS5wdXNoKHtpOiBpLCBnOiBnZW9tfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goYXJjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChsaW5lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7XG4gICAgZWxzZSBpZiAoby50eXBlIGluIGdlb21ldHJ5VHlwZSkgZ2VvbSA9IG8sIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcyk7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgICBnZW9tO1xuXG4gICAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgICBNdWx0aUxpbmVTdHJpbmc6IHBvbHlnb24sXG4gICAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzKSB7IGFyY3MuZm9yRWFjaChwb2x5Z29uKTsgfVxuICAgIH07XG5cbiAgICBnZW9tZXRyeShvKTtcblxuICAgIGdlb21zQnlBcmMuZm9yRWFjaChhcmd1bWVudHMubGVuZ3RoIDwgM1xuICAgICAgICA/IGZ1bmN0aW9uKGdlb21zKSB7IGFyY3MucHVzaChnZW9tc1swXS5pKTsgfVxuICAgICAgICA6IGZ1bmN0aW9uKGdlb21zKSB7IGlmIChmaWx0ZXIoZ2VvbXNbMF0uZywgZ2VvbXNbZ2VvbXMubGVuZ3RoIC0gMV0uZykpIGFyY3MucHVzaChnZW9tc1swXS5pKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3BvbG9neS5hcmNzLmxlbmd0aDsgaSA8IG47ICsraSkgYXJjcy5wdXNoKGkpO1xuICB9XG5cbiAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBhcmNzOiBzdGl0Y2hBcmNzKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhblRyaWFuZ2xlQXJlYSh0cmlhbmdsZSkge1xuICB2YXIgYSA9IHRyaWFuZ2xlWzBdLCBiID0gdHJpYW5nbGVbMV0sIGMgPSB0cmlhbmdsZVsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGFbMV0pIC0gKGFbMF0gLSBiWzBdKSAqIChjWzFdIC0gYVsxXSkpO1xufVxuXG5mdW5jdGlvbiByaW5nKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICAgIGEsXG4gICAgICBiID0gcmluZ1tuIC0gMV0sXG4gICAgICBhcmVhID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEgPSBiO1xuICAgIGIgPSByaW5nW2ldO1xuICAgIGFyZWEgKz0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXTtcbiAgfVxuXG4gIHJldHVybiBhcmVhIC8gMjtcbn1cblxuZnVuY3Rpb24gbWVyZ2UodG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBjb21wb25lbnRzID0gW107XG5cbiAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoby50eXBlID09PSBcIlBvbHlnb25cIikgcmVnaXN0ZXIoby5hcmNzKTtcbiAgICBlbHNlIGlmIChvLnR5cGUgPT09IFwiTXVsdGlQb2x5Z29uXCIpIG8uYXJjcy5mb3JFYWNoKHJlZ2lzdGVyKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nJCQpIHtcbiAgICAgIHJpbmckJC5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAocG9seWdvbnNCeUFyY1thcmMgPSBhcmMgPCAwID8gfmFyYyA6IGFyY10gfHwgKHBvbHlnb25zQnlBcmNbYXJjXSA9IFtdKSkucHVzaChwb2x5Z29uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBvbHlnb25zLnB1c2gocG9seWdvbik7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhKHJpbmckJCkge1xuICAgIHJldHVybiBNYXRoLmFicyhyaW5nKG9iamVjdCh0b3BvbG9neSwge3R5cGU6IFwiUG9seWdvblwiLCBhcmNzOiBbcmluZyQkXX0pLmNvb3JkaW5hdGVzWzBdKSk7XG4gIH1cblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgIHdoaWxlIChwb2x5Z29uID0gbmVpZ2hib3JzLnBvcCgpKSB7XG4gICAgICAgIGNvbXBvbmVudC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZyQkKSB7XG4gICAgICAgICAgcmluZyQkLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgICAgICBwb2x5Z29uc0J5QXJjW2FyYyA8IDAgPyB+YXJjIDogYXJjXS5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLl8gPSAxO1xuICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHBvbHlnb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICBkZWxldGUgcG9seWdvbi5fO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgYXJjczogY29tcG9uZW50cy5tYXAoZnVuY3Rpb24ocG9seWdvbnMpIHtcbiAgICAgIHZhciBhcmNzID0gW10sIG47XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIGV4dGVyaW9yICh1bmlxdWUpIGFyY3MuXG4gICAgICBwb2x5Z29ucy5mb3JFYWNoKGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgICAgICAgcG9seWdvbi5mb3JFYWNoKGZ1bmN0aW9uKHJpbmckJCkge1xuICAgICAgICAgIHJpbmckJC5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaEFyY3ModG9wb2xvZ3ksIGFyY3MpO1xuXG4gICAgICAvLyBJZiBtb3JlIHRoYW4gb25lIHJpbmcgaXMgcmV0dXJuZWQsXG4gICAgICAvLyBhdCBtb3N0IG9uZSBvZiB0aGVzZSByaW5ncyBjYW4gYmUgdGhlIGV4dGVyaW9yO1xuICAgICAgLy8gY2hvb3NlIHRoZSBvbmUgd2l0aCB0aGUgZ3JlYXRlc3QgYWJzb2x1dGUgYXJlYS5cbiAgICAgIGlmICgobiA9IGFyY3MubGVuZ3RoKSA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGsgPSBhcmVhKGFyY3NbMF0pLCBraSwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGlmICgoa2kgPSBhcmVhKGFyY3NbaV0pKSA+IGspIHtcbiAgICAgICAgICAgIHQgPSBhcmNzWzBdLCBhcmNzWzBdID0gYXJjc1tpXSwgYXJjc1tpXSA9IHQsIGsgPSBraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyY3M7XG4gICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmVpZ2hib3JzKG9iamVjdHMpIHtcbiAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICB9O1xuXG4gIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQXJlYShhLCBiKSB7XG4gIHJldHVybiBhWzFdWzJdIC0gYlsxXVsyXTtcbn1cblxuZnVuY3Rpb24gbWluQXJlYUhlYXAoKSB7XG4gIHZhciBoZWFwID0ge30sXG4gICAgICBhcnJheSA9IFtdLFxuICAgICAgc2l6ZSA9IDA7XG5cbiAgaGVhcC5wdXNoID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdXAoYXJyYXlbb2JqZWN0Ll8gPSBzaXplXSA9IG9iamVjdCwgc2l6ZSsrKTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfTtcblxuICBoZWFwLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzaXplIDw9IDApIHJldHVybjtcbiAgICB2YXIgcmVtb3ZlZCA9IGFycmF5WzBdLCBvYmplY3Q7XG4gICAgaWYgKC0tc2l6ZSA+IDApIG9iamVjdCA9IGFycmF5W3NpemVdLCBkb3duKGFycmF5W29iamVjdC5fID0gMF0gPSBvYmplY3QsIDApO1xuICAgIHJldHVybiByZW1vdmVkO1xuICB9O1xuXG4gIGhlYXAucmVtb3ZlID0gZnVuY3Rpb24ocmVtb3ZlZCkge1xuICAgIHZhciBpID0gcmVtb3ZlZC5fLCBvYmplY3Q7XG4gICAgaWYgKGFycmF5W2ldICE9PSByZW1vdmVkKSByZXR1cm47IC8vIGludmFsaWQgcmVxdWVzdFxuICAgIGlmIChpICE9PSAtLXNpemUpIG9iamVjdCA9IGFycmF5W3NpemVdLCAoY29tcGFyZUFyZWEob2JqZWN0LCByZW1vdmVkKSA8IDAgPyB1cCA6IGRvd24pKGFycmF5W29iamVjdC5fID0gaV0gPSBvYmplY3QsIGkpO1xuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHVwKG9iamVjdCwgaSkge1xuICAgIHdoaWxlIChpID4gMCkge1xuICAgICAgdmFyIGogPSAoKGkgKyAxKSA+PiAxKSAtIDEsXG4gICAgICAgICAgcGFyZW50ID0gYXJyYXlbal07XG4gICAgICBpZiAoY29tcGFyZUFyZWEob2JqZWN0LCBwYXJlbnQpID49IDApIGJyZWFrO1xuICAgICAgYXJyYXlbcGFyZW50Ll8gPSBpXSA9IHBhcmVudDtcbiAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvd24ob2JqZWN0LCBpKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByID0gKGkgKyAxKSA8PCAxLFxuICAgICAgICAgIGwgPSByIC0gMSxcbiAgICAgICAgICBqID0gaSxcbiAgICAgICAgICBjaGlsZCA9IGFycmF5W2pdO1xuICAgICAgaWYgKGwgPCBzaXplICYmIGNvbXBhcmVBcmVhKGFycmF5W2xdLCBjaGlsZCkgPCAwKSBjaGlsZCA9IGFycmF5W2ogPSBsXTtcbiAgICAgIGlmIChyIDwgc2l6ZSAmJiBjb21wYXJlQXJlYShhcnJheVtyXSwgY2hpbGQpIDwgMCkgY2hpbGQgPSBhcnJheVtqID0gcl07XG4gICAgICBpZiAoaiA9PT0gaSkgYnJlYWs7XG4gICAgICBhcnJheVtjaGlsZC5fID0gaV0gPSBjaGlsZDtcbiAgICAgIGFycmF5W29iamVjdC5fID0gaSA9IGpdID0gb2JqZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoZWFwO1xufVxuXG5mdW5jdGlvbiBwcmVzaW1wbGlmeSh0b3BvbG9neSwgdHJpYW5nbGVBcmVhKSB7XG4gIHZhciBhYnNvbHV0ZSA9IHRyYW5zZm9ybUFic29sdXRlKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICByZWxhdGl2ZSA9IHRyYW5zZm9ybVJlbGF0aXZlKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBoZWFwID0gbWluQXJlYUhlYXAoKTtcblxuICBpZiAoIXRyaWFuZ2xlQXJlYSkgdHJpYW5nbGVBcmVhID0gY2FydGVzaWFuVHJpYW5nbGVBcmVhO1xuXG4gIHRvcG9sb2d5LmFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICB2YXIgdHJpYW5nbGVzID0gW10sXG4gICAgICAgIG1heEFyZWEgPSAwLFxuICAgICAgICB0cmlhbmdsZSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgcDtcblxuICAgIC8vIFRvIHN0b3JlIGVhY2ggcG9pbnTigJlzIGVmZmVjdGl2ZSBhcmVhLCB3ZSBjcmVhdGUgYSBuZXcgYXJyYXkgcmF0aGVyIHRoYW5cbiAgICAvLyBleHRlbmRpbmcgdGhlIHBhc3NlZC1pbiBwb2ludCB0byB3b3JrYXJvdW5kIGEgQ2hyb21lL1Y4IGJ1ZyAoZ2V0dGluZ1xuICAgIC8vIHN0dWNrIGluIHNtaSBtb2RlKS4gRm9yIG1pZHBvaW50cywgdGhlIGluaXRpYWwgZWZmZWN0aXZlIGFyZWEgb2ZcbiAgICAvLyBJbmZpbml0eSB3aWxsIGJlIGNvbXB1dGVkIGluIHRoZSBuZXh0IHN0ZXAuXG4gICAgZm9yIChpID0gMCwgbiA9IGFyYy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHAgPSBhcmNbaV07XG4gICAgICBhYnNvbHV0ZShhcmNbaV0gPSBbcFswXSwgcFsxXSwgSW5maW5pdHldLCBpKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBuID0gYXJjLmxlbmd0aCAtIDE7IGkgPCBuOyArK2kpIHtcbiAgICAgIHRyaWFuZ2xlID0gYXJjLnNsaWNlKGkgLSAxLCBpICsgMik7XG4gICAgICB0cmlhbmdsZVsxXVsyXSA9IHRyaWFuZ2xlQXJlYSh0cmlhbmdsZSk7XG4gICAgICB0cmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XG4gICAgICBoZWFwLnB1c2godHJpYW5nbGUpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlc1tpXTtcbiAgICAgIHRyaWFuZ2xlLnByZXZpb3VzID0gdHJpYW5nbGVzW2kgLSAxXTtcbiAgICAgIHRyaWFuZ2xlLm5leHQgPSB0cmlhbmdsZXNbaSArIDFdO1xuICAgIH1cblxuICAgIHdoaWxlICh0cmlhbmdsZSA9IGhlYXAucG9wKCkpIHtcbiAgICAgIHZhciBwcmV2aW91cyA9IHRyaWFuZ2xlLnByZXZpb3VzLFxuICAgICAgICAgIG5leHQgPSB0cmlhbmdsZS5uZXh0O1xuXG4gICAgICAvLyBJZiB0aGUgYXJlYSBvZiB0aGUgY3VycmVudCBwb2ludCBpcyBsZXNzIHRoYW4gdGhhdCBvZiB0aGUgcHJldmlvdXMgcG9pbnRcbiAgICAgIC8vIHRvIGJlIGVsaW1pbmF0ZWQsIHVzZSB0aGUgbGF0dGVyJ3MgYXJlYSBpbnN0ZWFkLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgcG9pbnQgY2Fubm90IGJlIGVsaW1pbmF0ZWQgd2l0aG91dCBlbGltaW5hdGluZyBwcmV2aW91c2x5LVxuICAgICAgLy8gZWxpbWluYXRlZCBwb2ludHMuXG4gICAgICBpZiAodHJpYW5nbGVbMV1bMl0gPCBtYXhBcmVhKSB0cmlhbmdsZVsxXVsyXSA9IG1heEFyZWE7XG4gICAgICBlbHNlIG1heEFyZWEgPSB0cmlhbmdsZVsxXVsyXTtcblxuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICBwcmV2aW91c1syXSA9IHRyaWFuZ2xlWzJdO1xuICAgICAgICB1cGRhdGUocHJldmlvdXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgIG5leHRbMF0gPSB0cmlhbmdsZVswXTtcbiAgICAgICAgdXBkYXRlKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFyYy5mb3JFYWNoKHJlbGF0aXZlKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHRyaWFuZ2xlKSB7XG4gICAgaGVhcC5yZW1vdmUodHJpYW5nbGUpO1xuICAgIHRyaWFuZ2xlWzFdWzJdID0gdHJpYW5nbGVBcmVhKHRyaWFuZ2xlKTtcbiAgICBoZWFwLnB1c2godHJpYW5nbGUpO1xuICB9XG5cbiAgcmV0dXJuIHRvcG9sb2d5O1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS42LjI3XCI7XG5cbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLm1lc2ggPSBtZXNoO1xuZXhwb3J0cy5tZXNoQXJjcyA9IG1lc2hBcmNzO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFyY3MgPSBtZXJnZUFyY3M7XG5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuZXhwb3J0cy5uZWlnaGJvcnMgPSBuZWlnaGJvcnM7XG5leHBvcnRzLnByZXNpbXBsaWZ5ID0gcHJlc2ltcGxpZnk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7IiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIGdsb2JhbCwgZGVmaW5lLCBTeXN0ZW0sIFJlZmxlY3QsIFByb21pc2UgKi9cclxudmFyIF9fZXh0ZW5kcztcclxudmFyIF9fYXNzaWduO1xyXG52YXIgX19yZXN0O1xyXG52YXIgX19kZWNvcmF0ZTtcclxudmFyIF9fcGFyYW07XHJcbnZhciBfX21ldGFkYXRhO1xyXG52YXIgX19hd2FpdGVyO1xyXG52YXIgX19nZW5lcmF0b3I7XHJcbnZhciBfX2V4cG9ydFN0YXI7XHJcbnZhciBfX3ZhbHVlcztcclxudmFyIF9fcmVhZDtcclxudmFyIF9fc3ByZWFkO1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIHEgPSBbXSwgYywgaTtcclxuICAgICAgICByZXR1cm4gaSA9IHsgbmV4dDogdmVyYihcIm5leHRcIiksIFwidGhyb3dcIjogdmVyYihcInRocm93XCIpLCBcInJldHVyblwiOiB2ZXJiKFwicmV0dXJuXCIpIH0sIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSwgbmV4dCgpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG5leHQoKSB7IGlmICghYyAmJiBxLmxlbmd0aCkgcmVzdW1lKChjID0gcS5zaGlmdCgpKVswXSwgY1sxXSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShjWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIuZG9uZSA/IHNldHRsZShjWzJdLCByKSA6IHIudmFsdWVbMF0gPT09IFwieWllbGRcIiA/IHNldHRsZShjWzJdLCB7IHZhbHVlOiByLnZhbHVlWzFdLCBkb25lOiBmYWxzZSB9KSA6IFByb21pc2UucmVzb2x2ZShyLnZhbHVlWzFdKS50aGVuKHIudmFsdWVbMF0gPT09IFwiZGVsZWdhdGVcIiA/IGRlbGVnYXRlIDogZnVsZmlsbCwgcmVqZWN0KTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGRlbGVnYXRlKHIpIHsgc3RlcChyLmRvbmUgPyByIDogeyB2YWx1ZTogW1wieWllbGRcIiwgci52YWx1ZV0sIGRvbmU6IGZhbHNlIH0pOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBjID0gdm9pZCAwLCBmKHYpLCBuZXh0KCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGkgPSB7IG5leHQ6IHZlcmIoXCJuZXh0XCIpLCBcInRocm93XCI6IHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgXCJyZXR1cm5cIjogdmVyYihcInJldHVyblwiLCBmdW5jdGlvbiAodikgeyByZXR1cm4geyB2YWx1ZTogdiwgZG9uZTogdHJ1ZSB9OyB9KSB9O1xyXG4gICAgICAgIHJldHVybiBvID0gX19hc3luY1ZhbHVlcyhvKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiB7IHZhbHVlOiBbXCJkZWxlZ2F0ZVwiLCAob1tuXSB8fCBmKS5jYWxsKG8sIHYpXSwgZG9uZTogZmFsc2UgfTsgfTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbn0pOyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC52ZWdhID0gZ2xvYmFsLnZlZ2EgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUGFyc2UgYW4gZXZlbnQgc2VsZWN0b3Igc3RyaW5nLlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBldmVudCBzdHJlYW0gZGVmaW5pdGlvbnMuXG4gKi9cbnZhciBldmVudFNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IsIHNvdXJjZSwgbWFya3MpIHtcbiAgREVGQVVMVF9TT1VSQ0UgPSBzb3VyY2UgfHwgVklFVztcbiAgTUFSS1MgPSBtYXJrcyB8fCBERUZBVUxUX01BUktTO1xuICByZXR1cm4gcGFyc2VNZXJnZShzZWxlY3Rvci50cmltKCkpLm1hcChwYXJzZVNlbGVjdG9yKTtcbn07XG5cbnZhciBWSUVXICAgID0gJ3ZpZXcnO1xudmFyIExCUkFDSyAgPSAnWyc7XG52YXIgUkJSQUNLICA9ICddJztcbnZhciBMQlJBQ0UgID0gJ3snO1xudmFyIFJCUkFDRSAgPSAnfSc7XG52YXIgQ09MT04gICA9ICc6JztcbnZhciBDT01NQSAgID0gJywnO1xudmFyIE5BTUUgICAgPSAnQCc7XG52YXIgR1QgICAgICA9ICc+JztcbnZhciBJTExFR0FMID0gL1tcXFtcXF1cXHtcXH1dLztcbnZhciBERUZBVUxUX1NPVVJDRTtcbnZhciBNQVJLUztcbnZhciBERUZBVUxUX01BUktTID0ge1xuICAgICAgJyonOiAxLFxuICAgICAgYXJjOiAxLFxuICAgICAgYXJlYTogMSxcbiAgICAgIGdyb3VwOiAxLFxuICAgICAgaW1hZ2U6IDEsXG4gICAgICBsaW5lOiAxLFxuICAgICAgcGF0aDogMSxcbiAgICAgIHJlY3Q6IDEsXG4gICAgICBydWxlOiAxLFxuICAgICAgc2hhcGU6IDEsXG4gICAgICBzeW1ib2w6IDEsXG4gICAgICB0ZXh0OiAxLFxuICAgICAgdHJhaWw6IDFcbiAgICB9O1xuXG5mdW5jdGlvbiBpc01hcmtUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIE1BUktTLmhhc093blByb3BlcnR5KHR5cGUpO1xufVxuXG5mdW5jdGlvbiBmaW5kKHMsIGksIGVuZENoYXIsIHB1c2hDaGFyLCBwb3BDaGFyKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBuID0gcy5sZW5ndGgsXG4gICAgICBjO1xuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICBjID0gc1tpXTtcbiAgICBpZiAoIWNvdW50ICYmIGMgPT09IGVuZENoYXIpIHJldHVybiBpO1xuICAgIGVsc2UgaWYgKHBvcENoYXIgJiYgcG9wQ2hhci5pbmRleE9mKGMpID49IDApIC0tY291bnQ7XG4gICAgZWxzZSBpZiAocHVzaENoYXIgJiYgcHVzaENoYXIuaW5kZXhPZihjKSA+PSAwKSArK2NvdW50O1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1lcmdlKHMpIHtcbiAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgc3RhcnQgPSAwLFxuICAgICAgbiA9IHMubGVuZ3RoLFxuICAgICAgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgQ09NTUEsIExCUkFDSyArIExCUkFDRSwgUkJSQUNLICsgUkJSQUNFKTtcbiAgICBvdXRwdXQucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBzdGFydCA9ICsraTtcbiAgfVxuXG4gIGlmIChvdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgJ0VtcHR5IGV2ZW50IHNlbGVjdG9yOiAnICsgcztcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlbGVjdG9yKHMpIHtcbiAgcmV0dXJuIHNbMF0gPT09ICdbJ1xuICAgID8gcGFyc2VCZXR3ZWVuKHMpXG4gICAgOiBwYXJzZVN0cmVhbShzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHMpIHtcbiAgdmFyIG4gPSBzLmxlbmd0aCxcbiAgICAgIGkgPSAxLFxuICAgICAgYiwgc3RyZWFtO1xuXG4gIGkgPSBmaW5kKHMsIGksIFJCUkFDSywgTEJSQUNLLCBSQlJBQ0spO1xuICBpZiAoaSA9PT0gbikge1xuICAgIHRocm93ICdFbXB0eSBiZXR3ZWVuIHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIGIgPSBwYXJzZU1lcmdlKHMuc3Vic3RyaW5nKDEsIGkpKTtcbiAgaWYgKGIubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgJ0JldHdlZW4gc2VsZWN0b3IgbXVzdCBoYXZlIHR3byBlbGVtZW50czogJyArIHM7XG4gIH1cblxuICBzID0gcy5zbGljZShpICsgMSkudHJpbSgpO1xuICBpZiAoc1swXSAhPT0gR1QpIHtcbiAgICB0aHJvdyAnRXhwZWN0ZWQgXFwnPlxcJyBhZnRlciBiZXR3ZWVuIHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIGIgPSBiLm1hcChwYXJzZVNlbGVjdG9yKTtcblxuICBzdHJlYW0gPSBwYXJzZVNlbGVjdG9yKHMuc2xpY2UoMSkudHJpbSgpKTtcbiAgaWYgKHN0cmVhbS5iZXR3ZWVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IGIsXG4gICAgICBzdHJlYW06IHN0cmVhbVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmJldHdlZW4gPSBiO1xuICB9XG5cbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJlYW0ocykge1xuICB2YXIgc3RyZWFtID0ge3NvdXJjZTogREVGQVVMVF9TT1VSQ0V9LFxuICAgICAgc291cmNlID0gW10sXG4gICAgICB0aHJvdHRsZSA9IFswLCAwXSxcbiAgICAgIG1hcmtuYW1lID0gMCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIG4gPSBzLmxlbmd0aCxcbiAgICAgIGkgPSAwLCBqLFxuICAgICAgZmlsdGVyO1xuXG4gIC8vIGV4dHJhY3QgdGhyb3R0bGUgZnJvbSBlbmRcbiAgaWYgKHNbbi0xXSA9PT0gUkJSQUNFKSB7XG4gICAgaSA9IHMubGFzdEluZGV4T2YoTEJSQUNFKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdHRsZSA9IHBhcnNlVGhyb3R0bGUocy5zdWJzdHJpbmcoaSsxLCBuLTEpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgdGhyb3R0bGUgc3BlY2lmaWNhdGlvbjogJyArIHM7XG4gICAgICB9XG4gICAgICBzID0gcy5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICBuID0gcy5sZW5ndGg7XG4gICAgfSBlbHNlIHRocm93ICdVbm1hdGNoZWQgcmlnaHQgYnJhY2U6ICcgKyBzO1xuICAgIGkgPSAwO1xuICB9XG5cbiAgaWYgKCFuKSB0aHJvdyBzO1xuXG4gIC8vIHNldCBuYW1lIGZsYWcgYmFzZWQgb24gZmlyc3QgY2hhclxuICBpZiAoc1swXSA9PT0gTkFNRSkgbWFya25hbWUgPSArK2k7XG5cbiAgLy8gZXh0cmFjdCBmaXJzdCBwYXJ0IG9mIG11bHRpLXBhcnQgc3RyZWFtIHNlbGVjdG9yXG4gIGogPSBmaW5kKHMsIGksIENPTE9OKTtcbiAgaWYgKGogPCBuKSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGopLnRyaW0oKSk7XG4gICAgc3RhcnQgPSBpID0gKytqO1xuICB9XG5cbiAgLy8gZXh0cmFjdCByZW1haW5pbmcgcGFydCBvZiBzdHJlYW0gc2VsZWN0b3JcbiAgaSA9IGZpbmQocywgaSwgTEJSQUNLKTtcbiAgaWYgKGkgPT09IG4pIHtcbiAgICBzb3VyY2UucHVzaChzLnN1YnN0cmluZyhzdGFydCwgbikudHJpbSgpKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBmaWx0ZXIgPSBbXTtcbiAgICBzdGFydCA9ICsraTtcbiAgICBpZiAoc3RhcnQgPT09IG4pIHRocm93ICdVbm1hdGNoZWQgbGVmdCBicmFja2V0OiAnICsgcztcbiAgfVxuXG4gIC8vIGV4dHJhY3QgZmlsdGVyc1xuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBSQlJBQ0spO1xuICAgIGlmIChpID09PSBuKSB0aHJvdyAnVW5tYXRjaGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgZmlsdGVyLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGkpLnRyaW0oKSk7XG4gICAgaWYgKGkgPCBuLTEgJiYgc1srK2ldICE9PSBMQlJBQ0spIHRocm93ICdFeHBlY3RlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9XG5cbiAgLy8gbWFyc2hhbGwgZXZlbnQgc3RyZWFtIHNwZWNpZmljYXRpb25cbiAgaWYgKCEobiA9IHNvdXJjZS5sZW5ndGgpIHx8IElMTEVHQUwudGVzdChzb3VyY2Vbbi0xXSkpIHtcbiAgICB0aHJvdyAnSW52YWxpZCBldmVudCBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBpZiAobiA+IDEpIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVsxXTtcbiAgICBpZiAobWFya25hbWUpIHtcbiAgICAgIHN0cmVhbS5tYXJrbmFtZSA9IHNvdXJjZVswXS5zbGljZSgxKTtcbiAgICB9IGVsc2UgaWYgKGlzTWFya1R5cGUoc291cmNlWzBdKSkge1xuICAgICAgc3RyZWFtLm1hcmt0eXBlID0gc291cmNlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc291cmNlID0gc291cmNlWzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVswXTtcbiAgfVxuICBpZiAoc3RyZWFtLnR5cGUuc2xpY2UoLTEpID09PSAnIScpIHtcbiAgICBzdHJlYW0uY29uc3VtZSA9IHRydWU7XG4gICAgc3RyZWFtLnR5cGUgPSBzdHJlYW0udHlwZS5zbGljZSgwLCAtMSk7XG4gIH1cbiAgaWYgKGZpbHRlciAhPSBudWxsKSBzdHJlYW0uZmlsdGVyID0gZmlsdGVyO1xuICBpZiAodGhyb3R0bGVbMF0pIHN0cmVhbS50aHJvdHRsZSA9IHRocm90dGxlWzBdO1xuICBpZiAodGhyb3R0bGVbMV0pIHN0cmVhbS5kZWJvdW5jZSA9IHRocm90dGxlWzFdO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGhyb3R0bGUocykge1xuICB2YXIgYSA9IHMuc3BsaXQoQ09NTUEpO1xuICBpZiAoIXMubGVuZ3RoIHx8IGEubGVuZ3RoID4gMikgdGhyb3cgcztcbiAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uKF8pIHtcbiAgICB2YXIgeCA9ICtfO1xuICAgIGlmICh4ICE9PSB4KSB0aHJvdyBzO1xuICAgIHJldHVybiB4O1xuICB9KTtcbn1cblxuZXhwb3J0cy5zZWxlY3RvciA9IGV2ZW50U2VsZWN0b3I7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcInZlZ2EtbGl0ZVwiLFxuICBcImF1dGhvclwiOiBcIkplZmZyZXkgSGVlciwgRG9taW5payBNb3JpdHosIEthbml0IFxcXCJIYW1cXFwiIFdvbmdzdXBoYXNhd2F0XCIsXG4gIFwidmVyc2lvblwiOiBcIjIuMC4wLWFscGhhLjlcIixcbiAgXCJjb2xsYWJvcmF0b3JzXCI6IFtcbiAgICBcIkthbml0IFdvbmdzdXBoYXNhd2F0IDxrYW5pdHdAZ21haWwuY29tPiAoaHR0cDovL2thbml0dy55ZWxsb3dwaWd6LmNvbSlcIixcbiAgICBcIkRvbWluaWsgTW9yaXR6IDxkb21vcml0ekBjcy53YXNoaW5ndG9uLmVkdT4gKGh0dHBzOi8vd3d3LmRvbW9yaXR6LmRlKVwiLFxuICAgIFwiSmVmZnJleSBIZWVyIDxqaGVlckB1dy5lZHU+IChodHRwOi8vamhlZXIub3JnKVwiXG4gIF0sXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL3ZlZ2EuZ2l0aHViLmlvL3ZlZ2EtbGl0ZS9cIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlZlZ2EtbGl0ZSBwcm92aWRlcyBhIGhpZ2hlci1sZXZlbCBncmFtbWFyIGZvciB2aXN1YWwgYW5hbHlzaXMsIGNvbXBhcmFibGUgdG8gZ2dwbG90IG9yIFRhYmxlYXUsIHRoYXQgZ2VuZXJhdGVzIGNvbXBsZXRlIFZlZ2Egc3BlY2lmaWNhdGlvbnMuXCIsXG4gIFwibWFpblwiOiBcImJ1aWxkL3NyYy92bC5qc1wiLFxuICBcInR5cGVzXCI6IFwiYnVpbGQvc3JjL3ZsLmQudHNcIixcbiAgXCJiaW5cIjoge1xuICAgIFwidmwycG5nXCI6IFwiLi9iaW4vdmwycG5nXCIsXG4gICAgXCJ2bDJzdmdcIjogXCIuL2Jpbi92bDJzdmdcIixcbiAgICBcInZsMnZnXCI6IFwiLi9iaW4vdmwydmdcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHtcbiAgICBcInRlc3RcIjogXCJ0ZXN0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRzY1wiOiBcInJtIC1yZiBidWlsZC8qLyoqICYmIHRzY1wiLFxuICAgIFwicHJlYnVpbGRcIjogXCJta2RpciAtcCBidWlsZC9zaXRlIGJ1aWxkL2V4YW1wbGVzL2ltYWdlcyBidWlsZC90ZXN0LWdhbGxlcnlcIixcbiAgICBcImJ1aWxkXCI6IFwibnBtIHJ1biB0c2MgJiYgY3AgcGFja2FnZS5qc29uIGJ1aWxkICYmIGJyb3dzZXJpZnkgc3JjL3ZsLnRzIC1wIHRzaWZ5IC1kIC1zIHZsIHwgZXhvcmNpc3QgYnVpbGQvdmVnYS1saXRlLmpzLm1hcCA+IGJ1aWxkL3ZlZ2EtbGl0ZS5qc1wiLFxuICAgIFwicG9zdGJ1aWxkXCI6IFwidWdsaWZ5anMgYnVpbGQvdmVnYS1saXRlLmpzIC1jbSAtLWluLXNvdXJjZS1tYXAgYnVpbGQvdmVnYS1saXRlLmpzLm1hcCAtLXNvdXJjZS1tYXAgYnVpbGQvdmVnYS1saXRlLm1pbi5qcy5tYXAgPiBidWlsZC92ZWdhLWxpdGUubWluLmpzICYmIG5wbSBydW4gc2NoZW1hXCIsXG4gICAgXCJidWlsZDpleGFtcGxlc1wiOiBcIi4vc2NyaXB0cy9idWlsZC1leGFtcGxlcy5zaFwiLFxuICAgIFwiYnVpbGQ6aW1hZ2VzXCI6IFwibnBtIHJ1biBkYXRhICYmIHNjcmlwdHMvZ2VuZXJhdGUtaW1hZ2VzLnNoXCIsXG4gICAgXCJidWlsZDp0b2NcIjogXCJidW5kbGUgZXhlYyBqZWt5bGwgYnVpbGQgLXEgJiYgc2NyaXB0cy9nZW5lcmF0ZS10b2NcIixcbiAgICBcImJ1aWxkOnNpdGVcIjogXCJucG0gcnVuIGxpbmsgJiYgYnJvd3NlcmlmeSBzaXRlL3N0YXRpYy9tYWluLnRzIC1wIFt0c2lmeSAtcCBzaXRlXSAtZCB8IGV4b3JjaXN0IGJ1aWxkL3NpdGUvbWFpbi5qcy5tYXAgPiBidWlsZC9zaXRlL21haW4uanNcIixcbiAgICBcImJ1aWxkOnZlcnNpb25zXCI6IFwic2NyaXB0cy91cGRhdGUtdmVyc2lvbi5zaFwiLFxuICAgIFwiYnVpbGQ6dGVzdC1nYWxsZXJ5XCI6IFwiYnJvd3NlcmlmeSB0ZXN0LWdhbGxlcnkvbWFpbi50cyAtcCBbdHNpZnkgLXAgdGVzdC1nYWxsZXJ5XSAtZCA+IGJ1aWxkL3Rlc3QtZ2FsbGVyeS9tYWluLmpzXCIsXG4gICAgXCJjaGVjazpleGFtcGxlc1wiOiBcInNjcmlwdHMvY2hlY2stZXhhbXBsZXMuc2hcIixcbiAgICBcImNoZWNrOnNjaGVtYVwiOiBcInNjcmlwdHMvY2hlY2stc2NoZW1hLnNoXCIsXG4gICAgXCJjbGVhblwiOiBcInJtIC1yZiBidWlsZCAmJiBybSAtZiB2ZWdhLWxpdGUuKiAmIGZpbmQgLUUgc3JjIHRlc3Qgc2l0ZSBleGFtcGxlcyAtcmVnZXggJy4qXFxcXC4oanN8anMubWFwfGQudHN8dmcuanNvbiknIC1kZWxldGUgJiBybSAtcmYgZGF0YVwiLFxuICAgIFwiZGF0YVwiOiBcInJzeW5jIC1yIG5vZGVfbW9kdWxlcy92ZWdhLWRhdGFzZXRzL2RhdGEvKiBkYXRhXCIsXG4gICAgXCJsaW5rXCI6IFwibnBtIGxpbmsgJiYgbnBtIGxpbmsgdmVnYS1saXRlXCIsXG5cbiAgICBcImRlcGxveVwiOiBcInNjcmlwdHMvZGVwbG95LnNoXCIsXG4gICAgXCJkZXBsb3k6Z2hcIjogXCJzY3JpcHRzL2RlcGxveS1naC5zaFwiLFxuICAgIFwiZGVwbG95OnNjaGVtYVwiOiBcInNjcmlwdHMvZGVwbG95LXNjaGVtYS5zaFwiLFxuXG4gICAgXCJwcmVzdGFydFwiOiBcIm5wbSBydW4gZGF0YSAmJiBucG0gcnVuIGJ1aWxkICYmIHNjcmlwdHMvaW5kZXgtZXhhbXBsZXNcIixcbiAgICBcInN0YXJ0XCI6IFwibm9kZW1vbiAteCAnbnBtIHJ1biBidWlsZDp0ZXN0LWdhbGxlcnknICYgYnJvd3Nlci1zeW5jIHN0YXJ0IC0tc2VydmVyIC0tZmlsZXMgJ2J1aWxkL3Rlc3QtZ2FsbGVyeS9tYWluLmpzJyAtLWluZGV4ICd0ZXN0LWdhbGxlcnkvaW5kZXguaHRtbCdcIixcbiAgICBcInBvc3RzdGFydFwiOiBcInJtIGV4YW1wbGVzL2FsbC1leGFtcGxlcy5qc29uXCIsXG5cbiAgICBcInByZXNjaGVtYVwiOiBcIm5wbSBydW4gcHJlYnVpbGRcIixcbiAgICBcInNjaGVtYVwiOiBcInR5cGVzY3JpcHQtanNvbi1zY2hlbWEgLS1yZXF1aXJlZCB0cnVlIC0tbm9FeHRyYVByb3BzIHRydWUgc3JjL3NwZWMudHMgVG9wTGV2ZWxFeHRlbmRlZFNwZWMgPiBidWlsZC92ZWdhLWxpdGUtc2NoZW1hLmpzb24gJiYgcm0gLWYgX2RhdGEvdmVnYS1saXRlLXNjaGVtYS5qc29uICYmIGNwIGJ1aWxkL3ZlZ2EtbGl0ZS1zY2hlbWEuanNvbiBfZGF0YS9cIixcblxuICAgIFwicHJlc2l0ZVwiOiBcIm5wbSBydW4gYnVpbGQgJiYgbnBtIHJ1biBkYXRhICYmIG5wbSBydW4gYnVpbGQ6c2l0ZSAmJiBucG0gcnVuIGJ1aWxkOnRvYyAmJiBucG0gcnVuIGJ1aWxkOnZlcnNpb25zXCIsXG4gICAgXCJzaXRlXCI6IFwiYnVuZGxlIGV4ZWMgamVreWxsIHNlcnZlXCIsXG5cbiAgICBcImxpbnRcIjogXCJ0c2xpbnQgLS1wcm9qZWN0IHRzY29uZmlnLmpzb24gLWMgdHNsaW50Lmpzb24gLS10eXBlLWNoZWNrXCIsXG4gICAgXCJwcmV0ZXN0XCI6IFwibnBtIHJ1biB0c2MgJiYgbnBtIHJ1biBzY2hlbWEgJiYgbnBtIHJ1biBkYXRhXCIsXG4gICAgXCJ0ZXN0XCI6IFwibnBtIHJ1biB0ZXN0Om5vY29tcGlsZVwiLFxuICAgIFwidGVzdDpub2NvbXBpbGVcIjogXCJucG0gcnVuIHRlc3Q6b25seSAmJiBucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biBtb2NoYTpleGFtcGxlc1wiLFxuICAgIFwidGVzdDpvbmx5XCI6IFwibnljIC0tcmVwb3J0ZXI9aHRtbCAtLXJlcG9ydGVyPXRleHQtc3VtbWFyeSBucG0gcnVuIG1vY2hhOnRlc3RcIixcbiAgICBcInRlc3Q6ZGVidWdcIjogXCJucG0gcnVuIHByZXRlc3QgJiYgbW9jaGEgLS1yZWN1cnNpdmUgLS1kZWJ1Zy1icmsgYnVpbGQvdGVzdCBidWlsZC9leGFtcGxlc1wiLFxuICAgIFwibW9jaGE6dGVzdFwiOiBcIm1vY2hhIC0tcmVxdWlyZSBzb3VyY2UtbWFwLXN1cHBvcnQvcmVnaXN0ZXIgLS1yZXBvcnRlciBkb3QgLS1yZWN1cnNpdmUgYnVpbGQvdGVzdFwiLFxuICAgIFwibW9jaGE6ZXhhbXBsZXNcIjogXCJtb2NoYSAtLXJlcXVpcmUgc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyIC0tcmVwb3J0ZXIgZG90IC0tcmVjdXJzaXZlIGJ1aWxkL2V4YW1wbGVzXCIsXG5cbiAgICBcImNvZGVjb3ZcIjogXCJueWMgcmVwb3J0IC0tcmVwb3J0ZXI9anNvbiAmJiBjb2RlY292IC1mIGNvdmVyYWdlLyouanNvblwiLFxuICAgIFwid2F0Y2g6YnVpbGRcIjogXCJ3YXRjaGlmeSBzcmMvdmwudHMgLXAgdHNpZnkgLXYgLWQgLXMgdmwgLW8gJ2V4b3JjaXN0IGJ1aWxkL3ZlZ2EtbGl0ZS5qcy5tYXAgPiBidWlsZC92ZWdhLWxpdGUuanMnXCIsXG4gICAgXCJ3YXRjaDp0ZXN0XCI6IFwibm9kZW1vbiAteCAnbnBtIHRlc3QnXCIsXG4gICAgXCJ3YXRjaFwiOiBcIm5vZGVtb24gLXggJ25wbSBydW4gYnVpbGQgJiYgbnBtIHJ1biB0ZXN0Om5vY29tcGlsZScgIyBhbHJlYWR5IHJhbiBzY2hlbWEgaW4gYnVpbGRcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlLmdpdFwiXG4gIH0sXG4gIFwibGljZW5zZVwiOiBcIkJTRC0zLUNsYXVzZVwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkB0eXBlcy9jaGFpXCI6IFwiXjMuNS4wXCIsXG4gICAgXCJAdHlwZXMvZDNcIjogXCJeNC43LjBcIixcbiAgICBcIkB0eXBlcy9oaWdobGlnaHQuanNcIjogXCJeOS4xLjlcIixcbiAgICBcIkB0eXBlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnlcIjogXCJeMS4wLjMxXCIsXG4gICAgXCJAdHlwZXMvbW9jaGFcIjogXCJeMi4yLjQwXCIsXG4gICAgXCJAdHlwZXMvbm9kZVwiOiBcIl43LjAuMTJcIixcbiAgICBcImFqdlwiOiBcIjUuMC4xLWJldGEuMVwiLFxuICAgIFwiYnJvd3Nlci1zeW5jXCI6IFwifjIuMTguOFwiLFxuICAgIFwiYnJvd3NlcmlmeVwiOiBcIn4xNC4zLjBcIixcbiAgICBcImJyb3dzZXJpZnktc2hpbVwiOiBcIl4zLjguMTRcIixcbiAgICBcImNoYWlcIjogXCJ+My41LjBcIixcbiAgICBcImNoZWVyaW9cIjogXCJ+MC4yMi4wXCIsXG4gICAgXCJjb2RlY292XCI6IFwifjIuMS4wXCIsXG4gICAgXCJkM1wiOiBcIl40LjcuNFwiLFxuICAgIFwiZXhvcmNpc3RcIjogXCJ+MC40LjBcIixcbiAgICBcImhpZ2hsaWdodC5qc1wiOiBcIl45LjEwLjBcIixcbiAgICBcIm1vY2hhXCI6IFwifjMuMi4wXCIsXG4gICAgXCJub2RlbW9uXCI6IFwifjEuMTEuMFwiLFxuICAgIFwibnljXCI6IFwifjEwLjIuMFwiLFxuICAgIFwic291cmNlLW1hcC1zdXBwb3J0XCI6IFwifjAuNC4xNFwiLFxuICAgIFwidHNpZnlcIjogXCJ+My4wLjFcIixcbiAgICBcInRzbGludFwiOiBcIn41LjEuMFwiLFxuICAgIFwidHNsaW50LWVzbGludC1ydWxlc1wiOiBcIl40LjAuMFwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl4yLjIuMlwiLFxuICAgIFwidHlwZXNjcmlwdC1qc29uLXNjaGVtYVwiOiBcIl4wLjExLjBcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcIn4yLjguMjJcIixcbiAgICBcInZlZ2FcIjogXCIzLjAuMC1iZXRhLjI4XCIsXG4gICAgXCJ2ZWdhLWRhdGFzZXRzXCI6IFwidmVnYS92ZWdhLWRhdGFzZXRzI2doLXBhZ2VzXCIsXG4gICAgXCJ2ZWdhLWVtYmVkXCI6IFwiMy4wLjAtYmV0YS4xMFwiLFxuICAgIFwid2F0Y2hpZnlcIjogXCJ+My45LjBcIixcbiAgICBcInlhbWwtZnJvbnQtbWF0dGVyXCI6IFwifjMuNC4wXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCI6IFwifjEuMC4xXCIsXG4gICAgXCJ0c2xpYlwiOiBcIl4xLjYuMFwiLFxuICAgIFwidmVnYS1ldmVudC1zZWxlY3RvclwiOiBcIl4yLjAuMC1iZXRhXCIsXG4gICAgXCJ2ZWdhLXV0aWxcIjogXCJ+MS4xLjRcIixcbiAgICBcInlhcmdzXCI6IFwifjcuMC4yXCJcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuQUdHUkVHQVRFX09QUyA9IFtcbiAgICAndmFsdWVzJyxcbiAgICAnY291bnQnLFxuICAgICd2YWxpZCcsXG4gICAgJ21pc3NpbmcnLFxuICAgICdkaXN0aW5jdCcsXG4gICAgJ3N1bScsXG4gICAgJ21lYW4nLFxuICAgICdhdmVyYWdlJyxcbiAgICAndmFyaWFuY2UnLFxuICAgICd2YXJpYW5jZXAnLFxuICAgICdzdGRldicsXG4gICAgJ3N0ZGV2cCcsXG4gICAgJ21lZGlhbicsXG4gICAgJ3ExJyxcbiAgICAncTMnLFxuICAgICdjaTAnLFxuICAgICdjaTEnLFxuICAgICdtb2Rlc2tldycsXG4gICAgJ21pbicsXG4gICAgJ21heCcsXG4gICAgJ2FyZ21pbicsXG4gICAgJ2FyZ21heCcsXG5dO1xuZXhwb3J0cy5BR0dSRUdBVEVfT1BfSU5ERVggPSB1dGlsXzEudG9TZXQoZXhwb3J0cy5BR0dSRUdBVEVfT1BTKTtcbi8qKiBBZGRpdGl2ZS1iYXNlZCBhZ2dyZWdhdGlvbiBvcGVyYXRpb25zLiAgVGhlc2UgY2FuIGJlIGFwcGxpZWQgdG8gc3RhY2suICovXG5leHBvcnRzLlNVTV9PUFMgPSBbXG4gICAgJ2NvdW50JyxcbiAgICAnc3VtJyxcbiAgICAnZGlzdGluY3QnLFxuICAgICd2YWxpZCcsXG4gICAgJ21pc3NpbmcnXG5dO1xuLyoqXG4gKiBBZ2dyZWdhdGlvbiBvcGVyYXRvcnMgdGhhdCBhbHdheXMgcHJvZHVjZSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbZG9tYWluTWluLCBkb21haW5NYXhdLlxuICovXG5leHBvcnRzLlNIQVJFRF9ET01BSU5fT1BTID0gW1xuICAgICdtZWFuJyxcbiAgICAnYXZlcmFnZScsXG4gICAgJ21lZGlhbicsXG4gICAgJ3ExJyxcbiAgICAncTMnLFxuICAgICdtaW4nLFxuICAgICdtYXgnLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlXZG5jbVZuWVhSbExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJGblozSmxaMkYwWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEN0Q1FVRTJRanRCUVUxb1FpeFJRVUZCTEdGQlFXRXNSMEZCYTBJN1NVRkRlRU1zVVVGQlVUdEpRVU5TTEU5QlFVODdTVUZEVUN4UFFVRlBPMGxCUTFBc1UwRkJVenRKUVVOVUxGVkJRVlU3U1VGRFZpeExRVUZMTzBsQlEwd3NUVUZCVFR0SlFVTk9MRk5CUVZNN1NVRkRWQ3hWUVVGVk8wbEJRMVlzVjBGQlZ6dEpRVU5ZTEU5QlFVODdTVUZEVUN4UlFVRlJPMGxCUTFJc1VVRkJVVHRKUVVOU0xFbEJRVWs3U1VGRFNpeEpRVUZKTzBsQlEwb3NTMEZCU3p0SlFVTk1MRXRCUVVzN1NVRkRUQ3hWUVVGVk8wbEJRMVlzUzBGQlN6dEpRVU5NTEV0QlFVczdTVUZEVEN4UlFVRlJPMGxCUTFJc1VVRkJVVHREUVVOWUxFTkJRVU03UVVGRlZ5eFJRVUZCTEd0Q1FVRnJRaXhIUVVGSExGbEJRVXNzUTBGQlF5eHhRa0ZCWVN4RFFVRkRMRU5CUVVNN1FVRkZka1FzTmtWQlFUWkZPMEZCUTJoRkxGRkJRVUVzVDBGQlR5eEhRVUZyUWp0SlFVTnNReXhQUVVGUE8wbEJRMUFzUzBGQlN6dEpRVU5NTEZWQlFWVTdTVUZEVml4UFFVRlBPMGxCUTFBc1UwRkJVenREUVVOYUxFTkJRVU03UVVGRlJqczdSMEZGUnp0QlFVTlZMRkZCUVVFc2FVSkJRV2xDTEVkQlFXdENPMGxCUXpWRExFMUJRVTA3U1VGRFRpeFRRVUZUTzBsQlExUXNVVUZCVVR0SlFVTlNMRWxCUVVrN1NVRkRTaXhKUVVGSk8wbEJRMG9zUzBGQlN6dEpRVU5NTEV0QlFVczdRMEZEVWl4RFFVRkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFYSVNfUFJPUEVSVElFUyA9IFtcbiAgICAnZG9tYWluJywgJ2Zvcm1hdCcsICdncmlkJywgJ2xhYmVsUGFkZGluZycsICdsYWJlbHMnLCAnbWF4RXh0ZW50JywgJ21pbkV4dGVudCcsICdvZmZzZXQnLCAnb3JpZW50JywgJ3Bvc2l0aW9uJywgJ3RpY2tDb3VudCcsICd0aWNrcycsICd0aWNrU2l6ZScsICd0aXRsZScsICd0aXRsZVBhZGRpbmcnLCAndmFsdWVzJywgJ3ppbmRleCdcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZWGhwY3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTloZUdsekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCY1VaaExGRkJRVUVzWlVGQlpTeEhRVUZyUWp0SlFVTTFReXhSUVVGUkxFVkJRVVVzVVVGQlVTeEZRVUZGTEUxQlFVMHNSVUZCUlN4alFVRmpMRVZCUVVVc1VVRkJVU3hGUVVGRkxGZEJRVmNzUlVGQlJTeFhRVUZYTEVWQlFVVXNVVUZCVVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hWUVVGVkxFVkJRVVVzVjBGQlZ5eEZRVUZGTEU5QlFVOHNSVUZCUlN4VlFVRlZMRVZCUVVVc1QwRkJUeXhGUVVGRkxHTkJRV01zUlVGQlJTeFJRVUZSTEVWQlFVVXNVVUZCVVR0RFFVTTVUQ3hEUVVGREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBiaW5Ub1N0cmluZyhiaW4pIHtcbiAgICBpZiAodXRpbF8xLmlzQm9vbGVhbihiaW4pKSB7XG4gICAgICAgIHJldHVybiAnYmluJztcbiAgICB9XG4gICAgcmV0dXJuICdiaW4nICsgT2JqZWN0LmtleXMoYmluKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIFwiX1wiICsgcCArIFwiX1wiICsgYmluW3BdOyB9KS5qb2luKCcnKTtcbn1cbmV4cG9ydHMuYmluVG9TdHJpbmcgPSBiaW5Ub1N0cmluZztcbmZ1bmN0aW9uIGF1dG9NYXhCaW5zKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuUk9XOlxuICAgICAgICBjYXNlIGNoYW5uZWxfMS5DT0xVTU46XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNJWkU6XG4gICAgICAgIC8vIEZhY2V0cyBhbmQgU2l6ZSBzaG91bGRuJ3QgaGF2ZSB0b28gbWFueSBiaW5zXG4gICAgICAgIC8vIFdlIGNob29zZSA2IGxpa2Ugc2hhcGUgdG8gc2ltcGxpZnkgdGhlIHJ1bGVcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4gNjsgLy8gVmVnYSdzIFwic2hhcGVcIiBoYXMgNiBkaXN0aW5jdCB2YWx1ZXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAxMDtcbiAgICB9XG59XG5leHBvcnRzLmF1dG9NYXhCaW5zID0gYXV0b01heEJpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZbWx1TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dmMzSmpMMkpwYmk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhGRFFVRTBSRHRCUVVNMVJDd3JRa0ZCYVVNN1FVRXlSR3BETEhGQ1FVRTBRaXhIUVVGclFqdEpRVU0xUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVFpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hOUVVGSkxFTkJRVU1zVTBGQlNTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkhMRVZCUVdwQ0xFTkJRV2xDTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU03UVVGRGRrVXNRMEZCUXp0QlFVeEVMR3REUVV0RE8wRkJSVVFzY1VKQlFUUkNMRTlCUVdkQ08wbEJRekZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFSXNTMEZCU3l4aFFVRkhMRU5CUVVNN1VVRkRWQ3hMUVVGTExHZENRVUZOTEVOQlFVTTdVVUZEV2l4TFFVRkxMR05CUVVrc1EwRkJRenRSUVVOU0xDdERRVUVyUXp0UlFVTXZReXc0UTBGQk9FTTdVVUZEYUVRc1MwRkJTeXhsUVVGTE8xbEJRMUlzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMSFZEUVVGMVF6dFJRVU51UkR0WlFVTkZMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFpDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFWcEVMR3REUVZsREluMD0iLCIvKlxuICogQ29uc3RhbnRzIGFuZCB1dGlsaXRpZXMgZm9yIGVuY29kaW5nIGNoYW5uZWxzIChWaXN1YWwgdmFyaWFibGVzKVxuICogc3VjaCBhcyAneCcsICd5JywgJ2NvbG9yJy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgQ2hhbm5lbDtcbihmdW5jdGlvbiAoQ2hhbm5lbCkge1xuICAgIC8vIEZhY2V0XG4gICAgQ2hhbm5lbC5ST1cgPSAncm93JztcbiAgICBDaGFubmVsLkNPTFVNTiA9ICdjb2x1bW4nO1xuICAgIC8vIFBvc2l0aW9uXG4gICAgQ2hhbm5lbC5YID0gJ3gnO1xuICAgIENoYW5uZWwuWSA9ICd5JztcbiAgICBDaGFubmVsLlgyID0gJ3gyJztcbiAgICBDaGFubmVsLlkyID0gJ3kyJztcbiAgICAvLyBNYXJrIHByb3BlcnR5IHdpdGggc2NhbGVcbiAgICBDaGFubmVsLkNPTE9SID0gJ2NvbG9yJztcbiAgICBDaGFubmVsLlNIQVBFID0gJ3NoYXBlJztcbiAgICBDaGFubmVsLlNJWkUgPSAnc2l6ZSc7XG4gICAgQ2hhbm5lbC5PUEFDSVRZID0gJ29wYWNpdHknO1xuICAgIC8vIE5vbi1zY2FsZSBjaGFubmVsXG4gICAgQ2hhbm5lbC5URVhUID0gJ3RleHQnO1xuICAgIENoYW5uZWwuT1JERVIgPSAnb3JkZXInO1xuICAgIENoYW5uZWwuREVUQUlMID0gJ2RldGFpbCc7XG59KShDaGFubmVsID0gZXhwb3J0cy5DaGFubmVsIHx8IChleHBvcnRzLkNoYW5uZWwgPSB7fSkpO1xuZXhwb3J0cy5YID0gQ2hhbm5lbC5YO1xuZXhwb3J0cy5ZID0gQ2hhbm5lbC5ZO1xuZXhwb3J0cy5YMiA9IENoYW5uZWwuWDI7XG5leHBvcnRzLlkyID0gQ2hhbm5lbC5ZMjtcbmV4cG9ydHMuUk9XID0gQ2hhbm5lbC5ST1c7XG5leHBvcnRzLkNPTFVNTiA9IENoYW5uZWwuQ09MVU1OO1xuZXhwb3J0cy5TSEFQRSA9IENoYW5uZWwuU0hBUEU7XG5leHBvcnRzLlNJWkUgPSBDaGFubmVsLlNJWkU7XG5leHBvcnRzLkNPTE9SID0gQ2hhbm5lbC5DT0xPUjtcbmV4cG9ydHMuVEVYVCA9IENoYW5uZWwuVEVYVDtcbmV4cG9ydHMuREVUQUlMID0gQ2hhbm5lbC5ERVRBSUw7XG5leHBvcnRzLk9SREVSID0gQ2hhbm5lbC5PUkRFUjtcbmV4cG9ydHMuT1BBQ0lUWSA9IENoYW5uZWwuT1BBQ0lUWTtcbmV4cG9ydHMuQ0hBTk5FTFMgPSBbZXhwb3J0cy5YLCBleHBvcnRzLlksIGV4cG9ydHMuWDIsIGV4cG9ydHMuWTIsIGV4cG9ydHMuUk9XLCBleHBvcnRzLkNPTFVNTiwgZXhwb3J0cy5TSVpFLCBleHBvcnRzLlNIQVBFLCBleHBvcnRzLkNPTE9SLCBleHBvcnRzLk9SREVSLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuVEVYVCwgZXhwb3J0cy5ERVRBSUxdO1xuLy8gQ0hBTk5FTFMgd2l0aG91dCBDT0xVTU4sIFJPV1xuZXhwb3J0cy5VTklUX0NIQU5ORUxTID0gW2V4cG9ydHMuWCwgZXhwb3J0cy5ZLCBleHBvcnRzLlgyLCBleHBvcnRzLlkyLCBleHBvcnRzLlNJWkUsIGV4cG9ydHMuU0hBUEUsIGV4cG9ydHMuQ09MT1IsIGV4cG9ydHMuT1JERVIsIGV4cG9ydHMuT1BBQ0lUWSwgZXhwb3J0cy5URVhULCBleHBvcnRzLkRFVEFJTF07XG4vLyBVTklUX0NIQU5ORUxTIHdpdGhvdXQgWDIsIFkyLCBPUkRFUiwgREVUQUlMLCBURVhUXG5leHBvcnRzLlVOSVRfU0NBTEVfQ0hBTk5FTFMgPSBbZXhwb3J0cy5YLCBleHBvcnRzLlksIGV4cG9ydHMuU0laRSwgZXhwb3J0cy5TSEFQRSwgZXhwb3J0cy5DT0xPUiwgZXhwb3J0cy5PUEFDSVRZXTtcbi8vIFVOSVRfU0NBTEVfQ0hBTk5FTFMgd2l0aCBST1csIENPTFVNTlxuZXhwb3J0cy5TQ0FMRV9DSEFOTkVMUyA9IFtleHBvcnRzLlgsIGV4cG9ydHMuWSwgZXhwb3J0cy5TSVpFLCBleHBvcnRzLlNIQVBFLCBleHBvcnRzLkNPTE9SLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuUk9XLCBleHBvcnRzLkNPTFVNTl07XG4vLyBVTklUX0NIQU5ORUxTIHdpdGhvdXQgWCwgWSwgWDIsIFkyO1xuZXhwb3J0cy5OT05TUEFUSUFMX0NIQU5ORUxTID0gW2V4cG9ydHMuU0laRSwgZXhwb3J0cy5TSEFQRSwgZXhwb3J0cy5DT0xPUiwgZXhwb3J0cy5PUkRFUiwgZXhwb3J0cy5PUEFDSVRZLCBleHBvcnRzLlRFWFQsIGV4cG9ydHMuREVUQUlMXTtcbi8vIFVOSVRfU0NBTEVfQ0hBTk5FTFMgd2l0aG91dCBYLCBZO1xuZXhwb3J0cy5OT05TUEFUSUFMX1NDQUxFX0NIQU5ORUxTID0gW2V4cG9ydHMuU0laRSwgZXhwb3J0cy5TSEFQRSwgZXhwb3J0cy5DT0xPUiwgZXhwb3J0cy5PUEFDSVRZXTtcbmV4cG9ydHMuTEVWRUxfT0ZfREVUQUlMX0NIQU5ORUxTID0gdXRpbF8xLndpdGhvdXQoZXhwb3J0cy5OT05TUEFUSUFMX0NIQU5ORUxTLCBbJ29yZGVyJ10pO1xuLyoqIENoYW5uZWxzIHRoYXQgY2FuIHNlcnZlIGFzIGdyb3VwaW5ncyBmb3Igc3RhY2tlZCBjaGFydHMuICovXG5leHBvcnRzLlNUQUNLX0dST1VQX0NIQU5ORUxTID0gW2V4cG9ydHMuQ09MT1IsIGV4cG9ydHMuREVUQUlMLCBleHBvcnRzLk9SREVSLCBleHBvcnRzLk9QQUNJVFksIGV4cG9ydHMuU0laRV07XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgY2hhbm5lbCBzdXBwb3J0cyBhIHBhcnRpY3VsYXIgbWFyayB0eXBlLlxuICogQHBhcmFtIGNoYW5uZWwgIGNoYW5uZWwgbmFtZVxuICogQHBhcmFtIG1hcmsgdGhlIG1hcmsgdHlwZVxuICogQHJldHVybiB3aGV0aGVyIHRoZSBtYXJrIHN1cHBvcnRzIHRoZSBjaGFubmVsXG4gKi9cbmZ1bmN0aW9uIHN1cHBvcnRNYXJrKGNoYW5uZWwsIG1hcmspIHtcbiAgICByZXR1cm4gbWFyayBpbiBnZXRTdXBwb3J0ZWRNYXJrKGNoYW5uZWwpO1xufVxuZXhwb3J0cy5zdXBwb3J0TWFyayA9IHN1cHBvcnRNYXJrO1xuLyoqXG4gKiBSZXR1cm4gYSBkaWN0aW9uYXJ5IHNob3dpbmcgd2hldGhlciBhIGNoYW5uZWwgc3VwcG9ydHMgbWFyayB0eXBlLlxuICogQHBhcmFtIGNoYW5uZWxcbiAqIEByZXR1cm4gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgbWFyayB0eXBlcyB0byBib29sZWFuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkTWFyayhjaGFubmVsKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5YOlxuICAgICAgICBjYXNlIGV4cG9ydHMuWTpcbiAgICAgICAgY2FzZSBleHBvcnRzLkNPTE9SOlxuICAgICAgICBjYXNlIGV4cG9ydHMuREVUQUlMOlxuICAgICAgICBjYXNlIGV4cG9ydHMuT1JERVI6IC8vIFRPRE86IHJldmlzZSAob3JkZXIgbWlnaHQgbm90IHN1cHBvcnQgcmVjdCwgd2hpY2ggaXMgbm90IHN0YWNrYWJsZT8pXG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUEFDSVRZOlxuICAgICAgICBjYXNlIGV4cG9ydHMuUk9XOlxuICAgICAgICBjYXNlIGV4cG9ydHMuQ09MVU1OOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgcnVsZTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgYmFyOiB0cnVlLCByZWN0OiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCB0ZXh0OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGV4cG9ydHMuWDI6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ZMjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcnVsZTogdHJ1ZSwgYmFyOiB0cnVlLCByZWN0OiB0cnVlLCBhcmVhOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGV4cG9ydHMuU0laRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIHJ1bGU6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGJhcjogdHJ1ZSwgdGV4dDogdHJ1ZSwgbGluZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBleHBvcnRzLlNIQVBFOlxuICAgICAgICAgICAgcmV0dXJuIHsgcG9pbnQ6IHRydWUgfTtcbiAgICAgICAgY2FzZSBleHBvcnRzLlRFWFQ6XG4gICAgICAgICAgICByZXR1cm4geyB0ZXh0OiB0cnVlIH07XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuZ2V0U3VwcG9ydGVkTWFyayA9IGdldFN1cHBvcnRlZE1hcms7XG5mdW5jdGlvbiBoYXNTY2FsZShjaGFubmVsKSB7XG4gICAgcmV0dXJuICF1dGlsXzEuY29udGFpbnMoW2V4cG9ydHMuREVUQUlMLCBleHBvcnRzLlRFWFQsIGV4cG9ydHMuT1JERVJdLCBjaGFubmVsKTtcbn1cbmV4cG9ydHMuaGFzU2NhbGUgPSBoYXNTY2FsZTtcbi8vIFBvc2l0aW9uIGRvZXMgbm90IHdvcmsgd2l0aCBvcmRpbmFsIChsb29rdXApIHNjYWxlIGFuZCBzZXF1ZW50aWFsICh3aGljaCBpcyBvbmx5IGZvciBjb2xvcilcbnZhciBQT1NJVElPTl9TQ0FMRV9UWVBFX0lOREVYID0gdXRpbF8xLnRvU2V0KHV0aWxfMS53aXRob3V0KHNjYWxlXzEuU0NBTEVfVFlQRVMsIFsnb3JkaW5hbCcsICdzZXF1ZW50aWFsJ10pKTtcbmZ1bmN0aW9uIHN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc2NhbGVUeXBlKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ST1c6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5DT0xVTU46XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlID09PSAnYmFuZCc7IC8vIHJvdyAvIGNvbHVtbiBjdXJyZW50bHkgc3VwcG9ydHMgYmFuZCBvbmx5XG4gICAgICAgIGNhc2UgZXhwb3J0cy5YOlxuICAgICAgICBjYXNlIGV4cG9ydHMuWTpcbiAgICAgICAgY2FzZSBleHBvcnRzLlNJWkU6IC8vIFRPRE86IHNpemUgYW5kIG9wYWNpdHkgY2FuIHN1cHBvcnQgb3JkaW5hbCB3aXRoIG1vcmUgbW9kaWZpY2F0aW9uXG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUEFDSVRZOlxuICAgICAgICAgICAgLy8gQWx0aG91Z2ggaXQgZ2VuZXJhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byB1c2UgYmFuZCB3aXRoIHNpemUgYW5kIG9wYWNpdHksXG4gICAgICAgICAgICAvLyBpdCBjYW4gYWxzbyB3b3JrIHNpbmNlIHdlIHVzZSBiYW5kOiAwLjUgdG8gZ2V0IG1pZHBvaW50LlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSBpbiBQT1NJVElPTl9TQ0FMRV9UWVBFX0lOREVYO1xuICAgICAgICBjYXNlIGV4cG9ydHMuQ09MT1I6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlICE9PSAnYmFuZCc7IC8vIGJhbmQgZG9lcyBub3QgbWFrZSBzZW5zZSB3aXRoIGNvbG9yXG4gICAgICAgIGNhc2UgZXhwb3J0cy5TSEFQRTpcbiAgICAgICAgICAgIHJldHVybiBzY2FsZVR5cGUgPT09ICdvcmRpbmFsJzsgLy8gc2hhcGUgPSBsb29rdXAgb25seVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogaXQgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnN1cHBvcnRTY2FsZVR5cGUgPSBzdXBwb3J0U2NhbGVUeXBlO1xuZnVuY3Rpb24gcmFuZ2VUeXBlKGNoYW5uZWwpIHtcbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLlg6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ZOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU0laRTpcbiAgICAgICAgY2FzZSBleHBvcnRzLk9QQUNJVFk6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVvdXMnO1xuICAgICAgICBjYXNlIGV4cG9ydHMuUk9XOlxuICAgICAgICBjYXNlIGV4cG9ydHMuQ09MVU1OOlxuICAgICAgICBjYXNlIGV4cG9ydHMuU0hBUEU6XG4gICAgICAgICAgICByZXR1cm4gJ2Rpc2NyZXRlJztcbiAgICAgICAgLy8gQ29sb3IgY2FuIGJlIGVpdGhlciBjb250aW51b3VzIG9yIGRpc2NyZXRlLCBkZXBlbmRpbmcgb24gc2NhbGUgdHlwZS5cbiAgICAgICAgY2FzZSBleHBvcnRzLkNPTE9SOlxuICAgICAgICAgICAgcmV0dXJuICdmbGV4aWJsZSc7XG4gICAgICAgIC8vIE5vIHNjYWxlLCBubyByYW5nZSB0eXBlLlxuICAgICAgICBjYXNlIGV4cG9ydHMuWDI6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5ZMjpcbiAgICAgICAgY2FzZSBleHBvcnRzLkRFVEFJTDpcbiAgICAgICAgY2FzZSBleHBvcnRzLlRFWFQ6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5PUkRFUjpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS4gKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFN1cHBvcnRlZFJvbGUgbm90IGltcGxlbWVudGVkIGZvciAnICsgY2hhbm5lbCk7XG59XG5leHBvcnRzLnJhbmdlVHlwZSA9IHJhbmdlVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyaGhibTVsYkM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTlqYUdGdWJtVnNMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQk96czdSMEZIUnpzN08wRkJUVWdzYVVOQlFTdERPMEZCUXk5RExDdENRVUZuUkR0QlFVVm9SQ3hKUVVGcFFpeFBRVUZQTEVOQmNVSjJRanRCUVhKQ1JDeFhRVUZwUWl4UFFVRlBPMGxCUTNSQ0xGRkJRVkU3U1VGRFN5eFhRVUZITEVkQlFWVXNTMEZCU3l4RFFVRkRPMGxCUTI1Q0xHTkJRVTBzUjBGQllTeFJRVUZSTEVOQlFVTTdTVUZGZWtNc1YwRkJWenRKUVVORkxGTkJRVU1zUjBGQlVTeEhRVUZITEVOQlFVTTdTVUZEWWl4VFFVRkRMRWRCUVZFc1IwRkJSeXhEUVVGRE8wbEJRMklzVlVGQlJTeEhRVUZUTEVsQlFVa3NRMEZCUXp0SlFVTm9RaXhWUVVGRkxFZEJRVk1zU1VGQlNTeERRVUZETzBsQlJUZENMREpDUVVFeVFqdEpRVU5rTEdGQlFVc3NSMEZCV1N4UFFVRlBMRU5CUVVNN1NVRkRla0lzWVVGQlN5eEhRVUZaTEU5QlFVOHNRMEZCUXp0SlFVTjZRaXhaUVVGSkxFZEJRVmNzVFVGQlRTeERRVUZETzBsQlEzUkNMR1ZCUVU4c1IwRkJZeXhUUVVGVExFTkJRVU03U1VGRk5VTXNiMEpCUVc5Q08wbEJRMUFzV1VGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0SlFVTjBRaXhoUVVGTExFZEJRVmtzVDBGQlR5eERRVUZETzBsQlEzcENMR05CUVUwc1IwRkJZU3hSUVVGUkxFTkJRVU03UVVGRE0wTXNRMEZCUXl4RlFYSkNaMElzVDBGQlR5eEhRVUZRTEdWQlFVOHNTMEZCVUN4bFFVRlBMRkZCY1VKMlFqdEJRVWxaTEZGQlFVRXNRMEZCUXl4SFFVRkhMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03UVVGRFpDeFJRVUZCTEVOQlFVTXNSMEZCUnl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMlFzVVVGQlFTeEZRVUZGTEVkQlFVY3NUMEZCVHl4RFFVRkRMRVZCUVVVc1EwRkJRenRCUVVOb1FpeFJRVUZCTEVWQlFVVXNSMEZCUnl4UFFVRlBMRU5CUVVNc1JVRkJSU3hEUVVGRE8wRkJRMmhDTEZGQlFVRXNSMEZCUnl4SFFVRkhMRTlCUVU4c1EwRkJReXhIUVVGSExFTkJRVU03UVVGRGJFSXNVVUZCUVN4TlFVRk5MRWRCUVVjc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF6dEJRVU40UWl4UlFVRkJMRXRCUVVzc1IwRkJSeXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzBGQlEzUkNMRkZCUVVFc1NVRkJTU3hIUVVGSExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEY0VJc1VVRkJRU3hMUVVGTExFZEJRVWNzVDBGQlR5eERRVUZETEV0QlFVc3NRMEZCUXp0QlFVTjBRaXhSUVVGQkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTNCQ0xGRkJRVUVzVFVGQlRTeEhRVUZITEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNN1FVRkRlRUlzVVVGQlFTeExRVUZMTEVkQlFVY3NUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJRenRCUVVOMFFpeFJRVUZCTEU5QlFVOHNSMEZCUnl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRE8wRkJSekZDTEZGQlFVRXNVVUZCVVN4SFFVRkhMRU5CUVVNc1UwRkJReXhGUVVGRkxGTkJRVU1zUlVGQlJTeFZRVUZGTEVWQlFVVXNWVUZCUlN4RlFVRkZMRmRCUVVjc1JVRkJSU3hqUVVGTkxFVkJRVVVzV1VGQlNTeEZRVUZGTEdGQlFVc3NSVUZCUlN4aFFVRkxMRVZCUVVVc1lVRkJTeXhGUVVGRkxHVkJRVThzUlVGQlJTeFpRVUZKTEVWQlFVVXNZMEZCVFN4RFFVRkRMRU5CUVVNN1FVRkZkRWNzSzBKQlFTdENPMEZCUTJ4Q0xGRkJRVUVzWVVGQllTeEhRVUZITEVOQlFVTXNVMEZCUXl4RlFVRkZMRk5CUVVNc1JVRkJSU3hWUVVGRkxFVkJRVVVzVlVGQlJTeEZRVUZGTEZsQlFVa3NSVUZCUlN4aFFVRkxMRVZCUVVVc1lVRkJTeXhGUVVGRkxHRkJRVXNzUlVGQlJTeGxRVUZQTEVWQlFVVXNXVUZCU1N4RlFVRkZMR05CUVUwc1EwRkJReXhEUVVGRE8wRkJSVGxHTEc5RVFVRnZSRHRCUVVOMlF5eFJRVUZCTEcxQ1FVRnRRaXhIUVVGSExFTkJRVU1zVTBGQlF5eEZRVUZGTEZOQlFVTXNSVUZCUlN4WlFVRkpMRVZCUVVVc1lVRkJTeXhGUVVGRkxHRkJRVXNzUlVGQlJTeGxRVUZQTEVOQlFVTXNRMEZCUXp0QlFVVjJSU3gxUTBGQmRVTTdRVUZETVVJc1VVRkJRU3hqUVVGakxFZEJRVWNzUTBGQlF5eFRRVUZETEVWQlFVVXNVMEZCUXl4RlFVRkZMRmxCUVVrc1JVRkJSU3hoUVVGTExFVkJRVVVzWVVGQlN5eEZRVUZGTEdWQlFVOHNSVUZCUlN4WFFVRkhMRVZCUVVVc1kwRkJUU3hEUVVGRExFTkJRVU03UVVGRkwwVXNjME5CUVhORE8wRkJRM3BDTEZGQlFVRXNiVUpCUVcxQ0xFZEJRVWNzUTBGQlF5eFpRVUZKTEVWQlFVVXNZVUZCU3l4RlFVRkZMR0ZCUVVzc1JVRkJSU3hoUVVGTExFVkJRVVVzWlVGQlR5eEZRVUZGTEZsQlFVa3NSVUZCUlN4alFVRk5MRU5CUVVNc1EwRkJRenRCUVVWMFJpeHZRMEZCYjBNN1FVRkRka0lzVVVGQlFTeDVRa0ZCZVVJc1IwRkJSeXhEUVVGRExGbEJRVWtzUlVGQlJTeGhRVUZMTEVWQlFVVXNZVUZCU3l4RlFVRkZMR1ZCUVU4c1EwRkJReXhEUVVGRE8wRkJSVEZFTEZGQlFVRXNkMEpCUVhkQ0xFZEJRVWNzWTBGQlR5eERRVUZETERKQ1FVRnRRaXhGUVVGRkxFTkJRVU1zVDBGQlR5eERRVUZqTEVOQlFVTXNRMEZCUXp0QlFVVTNSaXdyUkVGQkswUTdRVUZEYkVRc1VVRkJRU3h2UWtGQmIwSXNSMEZCUnl4RFFVRkRMR0ZCUVVzc1JVRkJSU3hqUVVGTkxFVkJRVVVzWVVGQlN5eEZRVUZGTEdWQlFVOHNSVUZCUlN4WlFVRkpMRU5CUVVNc1EwRkJRenRCUVdVeFJUczdPenM3UjBGTFJ6dEJRVU5JTEhGQ1FVRTBRaXhQUVVGblFpeEZRVUZGTEVsQlFWVTdTVUZEZEVRc1RVRkJUU3hEUVVGRExFbEJRVWtzU1VGQlNTeG5Ra0ZCWjBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEJRVU16UXl4RFFVRkRPMEZCUmtRc2EwTkJSVU03UVVGRlJEczdPenRIUVVsSE8wRkJRMGdzTUVKQlFXbERMRTlCUVdkQ08wbEJReTlETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFSXNTMEZCU3l4VFFVRkRMRU5CUVVNN1VVRkRVQ3hMUVVGTExGTkJRVU1zUTBGQlF6dFJRVU5RTEV0QlFVc3NZVUZCU3l4RFFVRkRPMUZCUTFnc1MwRkJTeXhqUVVGTkxFTkJRVU03VVVGRFdpeExRVUZMTEdGQlFVc3NRMEZCUXl4RFFVRkpMSFZGUVVGMVJUdFJRVU4wUml4TFFVRkxMR1ZCUVU4c1EwRkJRenRSUVVOaUxFdEJRVXNzVjBGQlJ5eERRVUZETzFGQlExUXNTMEZCU3l4alFVRk5PMWxCUTFRc1RVRkJUU3hEUVVGRE8yZENRVU5NTEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hKUVVGSkxFVkJRVVVzVFVGQlRTeEZRVUZGTEVsQlFVazdaMEpCUXk5RUxFZEJRVWNzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWs3WVVGRE1VUXNRMEZCUXp0UlFVTktMRXRCUVVzc1ZVRkJSU3hEUVVGRE8xRkJRMUlzUzBGQlN5eFZRVUZGTzFsQlEwd3NUVUZCVFN4RFFVRkRPMmRDUVVOTUxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNSMEZCUnl4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVVVzU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpPMkZCUXpsRExFTkJRVU03VVVGRFNpeExRVUZMTEZsQlFVazdXVUZEVUN4TlFVRk5MRU5CUVVNN1owSkJRMHdzUzBGQlN5eEZRVUZGTEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNUVUZCVFN4RlFVRkZMRWxCUVVrc1JVRkJSU3hOUVVGTkxFVkJRVVVzU1VGQlNUdG5Ra0ZETDBRc1IwRkJSeXhGUVVGRkxFbEJRVWtzUlVGQlJTeEpRVUZKTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSk8yRkJRMnhETEVOQlFVTTdVVUZEU2l4TFFVRkxMR0ZCUVVzN1dVRkRVaXhOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNTVUZCU1N4RlFVRkRMRU5CUVVNN1VVRkRka0lzUzBGQlN5eFpRVUZKTzFsQlExQXNUVUZCVFN4RFFVRkRMRVZCUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlF5eERRVUZETzBsQlEzaENMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETzBGQlExb3NRMEZCUXp0QlFUbENSQ3cwUTBFNFFrTTdRVUZGUkN4clFrRkJlVUlzVDBGQlowSTdTVUZEZGtNc1RVRkJUU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNZMEZCVFN4RlFVRkZMRmxCUVVrc1JVRkJSU3hoUVVGTExFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0QlFVTnVSQ3hEUVVGRE8wRkJSa1FzTkVKQlJVTTdRVUZGUkN3NFJrRkJPRVk3UVVGRE9VWXNTVUZCVFN4NVFrRkJlVUlzUjBGQlJ5eFpRVUZMTEVOQlFVTXNZMEZCVHl4RFFVRkRMRzFDUVVGWExFVkJRVVVzUTBGQlF5eFRRVUZUTEVWQlFVVXNXVUZCV1N4RFFVRm5RaXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVVY0Unl3d1FrRkJhVU1zVDBGQlowSXNSVUZCUlN4VFFVRnZRanRKUVVOeVJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NWMEZCUnl4RFFVRkRPMUZCUTFRc1MwRkJTeXhqUVVGTk8xbEJRMVFzVFVGQlRTeERRVUZETEZOQlFWTXNTMEZCU3l4TlFVRk5MRU5CUVVNc1EwRkJReXcwUTBGQk5FTTdVVUZETTBVc1MwRkJTeXhUUVVGRExFTkJRVU03VVVGRFVDeExRVUZMTEZOQlFVTXNRMEZCUXp0UlFVTlFMRXRCUVVzc1dVRkJTU3hEUVVGRExFTkJRVU1zYjBWQlFXOUZPMUZCUXk5RkxFdEJRVXNzWlVGQlR6dFpRVU5XTERoRlFVRTRSVHRaUVVNNVJTd3lSRUZCTWtRN1dVRkRNMFFzVFVGQlRTeERRVUZETEZOQlFWTXNTVUZCU1N4NVFrRkJlVUlzUTBGQlF6dFJRVU5vUkN4TFFVRkxMR0ZCUVVzN1dVRkRVaXhOUVVGTkxFTkJRVU1zVTBGQlV5eExRVUZMTEUxQlFVMHNRMEZCUXl4RFFVRkpMSE5EUVVGelF6dFJRVU40UlN4TFFVRkxMR0ZCUVVzN1dVRkRVaXhOUVVGTkxFTkJRVU1zVTBGQlV5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMSE5DUVVGelFqdEpRVU14UkN4RFFVRkRPMGxCUTBRc2MwUkJRWE5FTzBsQlEzUkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQmJrSkVMRFJEUVcxQ1F6dEJRVVZFTEcxQ1FVRXdRaXhQUVVGblFqdEpRVU40UXl4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRXRCUVVzc1UwRkJReXhEUVVGRE8xRkJRMUFzUzBGQlN5eFRRVUZETEVOQlFVTTdVVUZEVUN4TFFVRkxMRmxCUVVrc1EwRkJRenRSUVVOV0xFdEJRVXNzWlVGQlR6dFpRVU5XTEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNN1VVRkZkRUlzUzBGQlN5eFhRVUZITEVOQlFVTTdVVUZEVkN4TFFVRkxMR05CUVUwc1EwRkJRenRSUVVOYUxFdEJRVXNzWVVGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1VVRkZjRUlzZFVWQlFYVkZPMUZCUTNaRkxFdEJRVXNzWVVGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1VVRkZjRUlzTWtKQlFUSkNPMUZCUXpOQ0xFdEJRVXNzVlVGQlJTeERRVUZETzFGQlExSXNTMEZCU3l4VlFVRkZMRU5CUVVNN1VVRkRVaXhMUVVGTExHTkJRVTBzUTBGQlF6dFJRVU5hTEV0QlFVc3NXVUZCU1N4RFFVRkRPMUZCUTFZc1MwRkJTeXhoUVVGTE8xbEJRMUlzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnlRaXhEUVVGRE8wbEJRMFFzYjBSQlFXOUVPMGxCUTNCRUxFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNkVU5CUVhWRExFZEJRVWNzVDBGQlR5eERRVUZETEVOQlFVTTdRVUZEY2tVc1EwRkJRenRCUVROQ1JDdzRRa0V5UWtNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBsYWJlbHMobW9kZWwsIGNoYW5uZWwsIGxhYmVsc1NwZWMsIGRlZikge1xuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgIHZhciBheGlzID0gbW9kZWwuYXhpcyhjaGFubmVsKTtcbiAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnO1xuICAgIC8vIFRleHRcbiAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlRFTVBPUkFMKSB7XG4gICAgICAgIGxhYmVsc1NwZWMgPSB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICBzaWduYWw6IGNvbW1vbl8xLnRpbWVGb3JtYXRFeHByZXNzaW9uKCdkYXR1bS52YWx1ZScsIGZpZWxkRGVmLnRpbWVVbml0LCBheGlzLmZvcm1hdCwgY29uZmlnLmF4aXMuc2hvcnRUaW1lTGFiZWxzLCBjb25maWcudGltZUZvcm1hdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbGFiZWxzU3BlYyk7XG4gICAgfVxuICAgIC8vIExhYmVsIEFuZ2xlXG4gICAgaWYgKGF4aXMubGFiZWxBbmdsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhYmVsc1NwZWMuYW5nbGUgPSB7IHZhbHVlOiBheGlzLmxhYmVsQW5nbGUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGF1dG8gcm90YXRlIGZvciBYXG4gICAgICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiAodXRpbF8xLmNvbnRhaW5zKFt0eXBlXzEuTk9NSU5BTCwgdHlwZV8xLk9SRElOQUxdLCBmaWVsZERlZi50eXBlKSB8fCAhIWZpZWxkRGVmLmJpbiB8fCBmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwpKSB7XG4gICAgICAgICAgICBsYWJlbHNTcGVjLmFuZ2xlID0geyB2YWx1ZTogMjcwIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXV0byBzZXQgYWxpZ24gaWYgcm90YXRlZFxuICAgIC8vIFRPRE86IGNvbnNpZGVyIG90aGVyIHZhbHVlIGJlc2lkZXMgMjcwLCA5MFxuICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlKSB7XG4gICAgICAgIGlmIChsYWJlbHNTcGVjLmFuZ2xlLnZhbHVlID09PSAyNzApIHtcbiAgICAgICAgICAgIGxhYmVsc1NwZWMuYWxpZ24gPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZi5vcmllbnQgPT09ICd0b3AnID8gJ2xlZnQnIDpcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5DT0xVTU4pID8gJ3JpZ2h0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2VudGVyJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYWJlbHNTcGVjLmFuZ2xlLnZhbHVlID09PSA5MCkge1xuICAgICAgICAgICAgbGFiZWxzU3BlYy5hbGlnbiA9IHsgdmFsdWU6ICdjZW50ZXInIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxhYmVsc1NwZWMuYW5nbGUpIHtcbiAgICAgICAgLy8gQXV0byBzZXQgYmFzZWxpbmUgaWYgcm90YXRlZFxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBvdGhlciB2YWx1ZSBiZXNpZGVzIDI3MCwgOTBcbiAgICAgICAgaWYgKGxhYmVsc1NwZWMuYW5nbGUudmFsdWUgPT09IDI3MCkge1xuICAgICAgICAgICAgbGFiZWxzU3BlYy5iYXNlbGluZSA9IHsgdmFsdWU6IChjaGFubmVsID09PSBjaGFubmVsXzEuWCB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuQ09MVU1OKSA/ICdtaWRkbGUnIDogJ2JvdHRvbScgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYWJlbHNTcGVjLmFuZ2xlLnZhbHVlID09PSA5MCkge1xuICAgICAgICAgICAgbGFiZWxzU3BlYy5iYXNlbGluZSA9IHsgdmFsdWU6ICdib3R0b20nIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHV0aWxfMS5rZXlzKGxhYmVsc1NwZWMpLmxlbmd0aCA9PT0gMCA/IHVuZGVmaW5lZCA6IGxhYmVsc1NwZWM7XG59XG5leHBvcnRzLmxhYmVscyA9IGxhYmVscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpXNWpiMlJsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdllYaHBjeTlsYm1OdlpHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeDVRMEZCYVVRN1FVRkRha1FzYlVOQlFYTkVPMEZCUTNSRUxHMURRVUZyUkR0QlFVZHNSQ3h2UTBGQkswTTdRVUZITDBNc1owSkJRWFZDTEV0QlFWa3NSVUZCUlN4UFFVRm5RaXhGUVVGRkxGVkJRV1VzUlVGQlJTeEhRVUZYTzBsQlEycEdMRWxCUVUwc1VVRkJVU3hIUVVGSExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRla01zU1VGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU5xUXl4SlFVRk5MRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETzBsQlJUVkNMRTlCUVU4N1NVRkRVQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4TFFVRkxMR1ZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGREwwSXNWVUZCVlN4SFFVRkhMR0ZCUVUwc1EwRkJRenRaUVVOc1FpeEpRVUZKTEVWQlFVVTdaMEpCUTBvc1RVRkJUU3hGUVVGRkxEWkNRVUZ2UWl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hSUVVGUkxFTkJRVU1zVVVGQlVTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eGxRVUZsTEVWQlFVVXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRoUVVNMVNEdFRRVU5HTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1NVRkRha0lzUTBGQlF6dEpRVVZFTEdOQlFXTTdTVUZEWkN4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVlVGQlZTeExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRiRU1zVlVGQlZTeERRVUZETEV0QlFVc3NSMEZCUnl4RlFVRkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZETEVOQlFVTTdTVUZET1VNc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNiMEpCUVc5Q08xRkJRM0JDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFbEJRVWtzUTBGQlF5eGxRVUZSTEVOQlFVTXNRMEZCUXl4alFVRlBMRVZCUVVVc1kwRkJUeXhEUVVGRExFVkJRVVVzVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEZGQlFWRXNRMEZCUXl4SlFVRkpMRXRCUVVzc1pVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNUlMRlZCUVZVc1EwRkJReXhMUVVGTExFZEJRVWNzUlVGQlF5eExRVUZMTEVWQlFVVXNSMEZCUnl4RlFVRkRMRU5CUVVNN1VVRkRiRU1zUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN3MFFrRkJORUk3U1VGRE5VSXNOa05CUVRaRE8wbEJRemRETEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkNMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJrTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1IwRkJSenRuUWtGRGFrSXNTMEZCU3l4RlFVRkZMRWRCUVVjc1EwRkJReXhOUVVGTkxFdEJRVXNzUzBGQlN5eEhRVUZITEUxQlFVMDdiMEpCUXpWQ0xFTkJRVU1zVDBGQlR5eExRVUZMTEZkQlFVTXNTVUZCU1N4UFFVRlBMRXRCUVVzc1owSkJRVTBzUTBGQlF5eEhRVUZITEU5QlFVODdkMEpCUXk5RExGRkJRVkU3WVVGRGFrSXNRMEZCUXp0UlFVTktMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZReXhWUVVGVkxFTkJRVU1zUzBGQlN5eEhRVUZITEVWQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJReXhEUVVGRE8xRkJRM1pETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRja0lzSzBKQlFTdENPMUZCUXk5Q0xEWkRRVUUyUXp0UlFVTTNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1MwRkJTeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRlZCUVZVc1EwRkJReXhSUVVGUkxFZEJRVWNzUlVGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhKUVVGSkxFOUJRVThzUzBGQlN5eG5Ra0ZCVFN4RFFVRkRMRWRCUVVjc1VVRkJVU3hIUVVGSExGRkJRVkVzUlVGQlF5eERRVUZETzFGQlF6ZEdMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZReXhWUVVGVkxFTkJRVU1zVVVGQlVTeEhRVUZITEVWQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJReXhEUVVGRE8xRkJRekZETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlVRc1RVRkJUU3hEUVVGRExGZEJRVWtzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhIUVVGSExGTkJRVk1zUjBGQlJ5eFZRVUZWTEVOQlFVTTdRVUZEYUVVc1EwRkJRenRCUVdwRVJDeDNRa0ZwUkVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBheGlzXzEgPSByZXF1aXJlKFwiLi4vLi4vYXhpc1wiKTtcbnZhciBlbmNvZGUgPSByZXF1aXJlKFwiLi9lbmNvZGVcIik7XG52YXIgcnVsZXMgPSByZXF1aXJlKFwiLi9ydWxlc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBBWElTX1BBUlRTID0gWydkb21haW4nLCAnZ3JpZCcsICdsYWJlbHMnLCAndGlja3MnLCAndGl0bGUnXTtcbmZ1bmN0aW9uIHBhcnNlQXhpc0NvbXBvbmVudChtb2RlbCwgYXhpc0NoYW5uZWxzKSB7XG4gICAgcmV0dXJuIGF4aXNDaGFubmVscy5yZWR1Y2UoZnVuY3Rpb24gKGF4aXMsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIHZnQXhlcyA9IFtdO1xuICAgICAgICBpZiAobW9kZWwuYXhpcyhjaGFubmVsKSkge1xuICAgICAgICAgICAgdmFyIG1haW4gPSBwYXJzZU1haW5BeGlzKGNoYW5uZWwsIG1vZGVsKTtcbiAgICAgICAgICAgIGlmIChtYWluICYmIGlzVmlzaWJsZUF4aXMobWFpbikpIHtcbiAgICAgICAgICAgICAgICB2Z0F4ZXMucHVzaChtYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmlkID0gcGFyc2VHcmlkQXhpcyhjaGFubmVsLCBtb2RlbCk7XG4gICAgICAgICAgICBpZiAoZ3JpZCAmJiBpc1Zpc2libGVBeGlzKGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgdmdBeGVzLnB1c2goZ3JpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmdBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBheGlzW2NoYW5uZWxdID0gdmdBeGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBheGlzO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucGFyc2VBeGlzQ29tcG9uZW50ID0gcGFyc2VBeGlzQ29tcG9uZW50O1xuZnVuY3Rpb24gaXNGYWxzZU9yTnVsbCh2KSB7XG4gICAgcmV0dXJuIHYgPT09IGZhbHNlIHx8IHYgPT09IG51bGw7XG59XG4vKipcbiAqIFJldHVybiBpZiBhbiBheGlzIGlzIHZpc2libGUgKHNob3dzIGF0IGxlYXN0IG9uZSBwYXJ0IG9mIHRoZSBheGlzKS5cbiAqL1xuZnVuY3Rpb24gaXNWaXNpYmxlQXhpcyhheGlzKSB7XG4gICAgcmV0dXJuIHV0aWxfMS5zb21lKEFYSVNfUEFSVFMsIGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBoYXNBeGlzUGFydChheGlzLCBwYXJ0KTsgfSk7XG59XG5mdW5jdGlvbiBoYXNBeGlzUGFydChheGlzLCBwYXJ0KSB7XG4gICAgLy8gRklYTUUgdGhpcyBtZXRob2QgY2FuIGJlIHdyb25nIGlmIHVzZXJzIHVzZSBhIFZlZ2EgdGhlbWUuXG4gICAgLy8gKE5vdCBzdXJlIGhvdyB0byBjb3JyZWN0bHkgaGFuZGxlIHRoYXQgeWV0LikuXG4gICAgaWYgKHBhcnQgPT09ICdncmlkJyB8fCBwYXJ0ID09PSAndGl0bGUnKSB7XG4gICAgICAgIHJldHVybiAhIWF4aXNbcGFydF07XG4gICAgfVxuICAgIC8vIE90aGVyIHBhcnRzIGFyZSBlbmFibGVkIGJ5IGRlZmF1bHQsIHNvIHRoZXkgc2hvdWxkIG5vdCBiZSBmYWxzZSBvciBudWxsLlxuICAgIHJldHVybiAhaXNGYWxzZU9yTnVsbChheGlzW3BhcnRdKTtcbn1cbi8qKlxuICogTWFrZSBhbiBpbm5lciBheGlzIGZvciBzaG93aW5nIGdyaWQgZm9yIHNoYXJlZCBheGlzLlxuICovXG5mdW5jdGlvbiBwYXJzZUdyaWRBeGlzKGNoYW5uZWwsIG1vZGVsKSB7XG4gICAgLy8gRklYTUU6IHN1cHBvcnQgYWRkaW5nIHRpY2tzIGZvciBncmlkIGF4aXMgdGhhdCBhcmUgaW5uZXIgYXhlcyBvZiBmYWNldGVkIHBsb3RzLlxuICAgIHJldHVybiBwYXJzZUF4aXMoY2hhbm5lbCwgbW9kZWwsIHRydWUpO1xufVxuZXhwb3J0cy5wYXJzZUdyaWRBeGlzID0gcGFyc2VHcmlkQXhpcztcbmZ1bmN0aW9uIHBhcnNlTWFpbkF4aXMoY2hhbm5lbCwgbW9kZWwpIHtcbiAgICByZXR1cm4gcGFyc2VBeGlzKGNoYW5uZWwsIG1vZGVsLCBmYWxzZSk7XG59XG5leHBvcnRzLnBhcnNlTWFpbkF4aXMgPSBwYXJzZU1haW5BeGlzO1xuZnVuY3Rpb24gcGFyc2VBeGlzKGNoYW5uZWwsIG1vZGVsLCBpc0dyaWRBeGlzKSB7XG4gICAgdmFyIGF4aXMgPSBtb2RlbC5heGlzKGNoYW5uZWwpO1xuICAgIHZhciB2Z0F4aXMgPSB7XG4gICAgICAgIHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbClcbiAgICB9O1xuICAgIC8vIDEuMi4gQWRkIHByb3BlcnRpZXNcbiAgICBheGlzXzEuQVhJU19QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKHByb3BlcnR5LCBheGlzLCBjaGFubmVsLCBtb2RlbCwgaXNHcmlkQXhpcyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2Z0F4aXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGdyaWRTY2FsZSBzaW5jZSBncmlkU2NhbGUgaXMgbm90IGEgVmVnYS1MaXRlIEF4aXMgcHJvcGVydHkuXG4gICAgdmFyIGdyaWRTY2FsZSA9IGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKCdncmlkU2NhbGUnLCBheGlzLCBjaGFubmVsLCBtb2RlbCwgaXNHcmlkQXhpcyk7XG4gICAgaWYgKGdyaWRTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZnQXhpcy5ncmlkU2NhbGUgPSBncmlkU2NhbGU7XG4gICAgfVxuICAgIC8vIDIpIEFkZCBndWlkZSBlbmNvZGUgZGVmaW5pdGlvbiBncm91cHNcbiAgICB2YXIgZW5jb2RlU3BlYyA9IGF4aXMuZW5jb2RlIHx8IHt9O1xuICAgIEFYSVNfUEFSVFMuZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICBpZiAoIWhhc0F4aXNQYXJ0KHZnQXhpcywgcGFydCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY3JlYXRlIGVuY29kZSBmb3IgYSBkaXNhYmxlZCBwYXJ0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oQHl1aGFubHUpOiBpbnN0ZWFkIG9mIGNhbGxpbmcgZW5jb2RlW3BhcnRdLCBicmVhayB0aGlzIGxpbmUgYmFzZWQgb24gcGFydCB0eXBlXG4gICAgICAgIC8vIGFzIGRpZmZlcmVudCByZXF1aXJlIGRpZmZlcmVudCBwYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChwYXJ0ID09PSAnbGFiZWxzJykge1xuICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGUubGFiZWxzKG1vZGVsLCBjaGFubmVsLCBlbmNvZGVTcGVjLmxhYmVscyB8fCB7fSwgdmdBeGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3BlY1twYXJ0XSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB1dGlsXzEua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmdBeGlzLmVuY29kZSA9IHZnQXhpcy5lbmNvZGUgfHwge307XG4gICAgICAgICAgICB2Z0F4aXMuZW5jb2RlW3BhcnRdID0geyB1cGRhdGU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmdBeGlzO1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUocHJvcGVydHksIHNwZWNpZmllZEF4aXMsIGNoYW5uZWwsIG1vZGVsLCBpc0dyaWRBeGlzKSB7XG4gICAgdmFyIGZpZWxkRGVmID0gbW9kZWwuZmllbGREZWYoY2hhbm5lbCk7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlICdsYWJlbHMnOlxuICAgICAgICAgICAgcmV0dXJuIGlzR3JpZEF4aXMgPyBmYWxzZSA6IHNwZWNpZmllZEF4aXNbcHJvcGVydHldO1xuICAgICAgICBjYXNlICdkb21haW4nOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmRvbWFpbihwcm9wZXJ0eSwgc3BlY2lmaWVkQXhpcywgaXNHcmlkQXhpcywgY2hhbm5lbCk7XG4gICAgICAgIGNhc2UgJ3RpY2tzJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy50aWNrcyhwcm9wZXJ0eSwgc3BlY2lmaWVkQXhpcywgaXNHcmlkQXhpcywgY2hhbm5lbCk7XG4gICAgICAgIGNhc2UgJ2Zvcm1hdCc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuZm9ybWF0KHNwZWNpZmllZEF4aXMsIGNoYW5uZWwsIGZpZWxkRGVmLCBtb2RlbC5jb25maWcpO1xuICAgICAgICBjYXNlICdncmlkJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5ncmlkKG1vZGVsLCBjaGFubmVsLCBpc0dyaWRBeGlzKTsgLy8gRklYTUU6IHJlZmFjdG9yIHRoaXNcbiAgICAgICAgY2FzZSAnZ3JpZFNjYWxlJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5ncmlkU2NhbGUobW9kZWwsIGNoYW5uZWwsIGlzR3JpZEF4aXMpO1xuICAgICAgICBjYXNlICdvcmllbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLm9yaWVudChzcGVjaWZpZWRBeGlzLCBjaGFubmVsKTtcbiAgICAgICAgY2FzZSAndGlja0NvdW50JzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy50aWNrQ291bnQoc3BlY2lmaWVkQXhpcywgY2hhbm5lbCwgZmllbGREZWYpOyAvLyBUT0RPOiBzY2FsZVR5cGVcbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnRpdGxlKHNwZWNpZmllZEF4aXMsIGZpZWxkRGVmLCBtb2RlbC5jb25maWcsIGlzR3JpZEF4aXMpO1xuICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnZhbHVlcyhzcGVjaWZpZWRBeGlzKTtcbiAgICAgICAgY2FzZSAnemluZGV4JzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy56aW5kZXgoc3BlY2lmaWVkQXhpcywgaXNHcmlkQXhpcyk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgICByZXR1cm4gc3BlY2lmaWVkQXhpc1twcm9wZXJ0eV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljR0Z5YzJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWhlR2x6TDNCaGNuTmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNiVU5CUVdsRU8wRkJTV3BFTEdsRFFVRnRRenRCUVVOdVF5d3JRa0ZCYVVNN1FVRkZha01zYlVOQlFUUkRPMEZCU1RWRExFbEJRVTBzVlVGQlZTeEhRVUZsTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTFCUVUwc1JVRkJSU3hSUVVGUkxFVkJRVVVzVDBGQlR5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMEZCUlRsRkxEUkNRVUZ0UXl4TFFVRlpMRVZCUVVVc1dVRkJkVUk3U1VGRGRFVXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlV5eEpRVUZKTEVWQlFVVXNUMEZCVHp0UlFVTXZReXhKUVVGTkxFMUJRVTBzUjBGQllTeEZRVUZGTEVOQlFVTTdVVUZETlVJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVFSXNTVUZCVFN4SlFVRkpMRWRCUVVjc1lVRkJZU3hEUVVGRExFOUJRVThzUlVGQlJTeExRVUZMTEVOQlFVTXNRMEZCUXp0WlFVTXpReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVsQlFVa3NZVUZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYUVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTndRaXhEUVVGRE8xbEJSVVFzU1VGQlRTeEpRVUZKTEVkQlFVY3NZVUZCWVN4RFFVRkRMRTlCUVU4c1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF6dFpRVU16UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFFTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU53UWl4RFFVRkRPMWxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU4wUWl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzVFVGQlRTeERRVUZETzFsQlEzcENMRU5CUVVNN1VVRkRTQ3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTmtMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZ3UWtRc1owUkJiMEpETzBGQlJVUXNkVUpCUVhWQ0xFTkJRV2xDTzBsQlEzUkRMRTFCUVUwc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eEpRVUZKTEVOQlFVTXNTMEZCU3l4SlFVRkpMRU5CUVVNN1FVRkRia01zUTBGQlF6dEJRVVZFT3p0SFFVVkhPMEZCUTBnc2RVSkJRWFZDTEVsQlFWazdTVUZEYWtNc1RVRkJUU3hEUVVGRExGZEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNWVUZCUXl4SlFVRkpMRWxCUVVzc1QwRkJRU3hYUVVGWExFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RlFVRjJRaXhEUVVGMVFpeERRVUZETEVOQlFVTTdRVUZETjBRc1EwRkJRenRCUVVWRUxIRkNRVUZ4UWl4SlFVRlpMRVZCUVVVc1NVRkJZenRKUVVNdlF5dzBSRUZCTkVRN1NVRkROVVFzWjBSQlFXZEVPMGxCUldoRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4TlFVRk5MRWxCUVVrc1NVRkJTU3hMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRkRUlzUTBGQlF6dEpRVU5FTERKRlFVRXlSVHRKUVVNelJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdRVUZEY0VNc1EwRkJRenRCUVVWRU96dEhRVVZITzBGQlEwZ3NkVUpCUVRoQ0xFOUJRV2RDTEVWQlFVVXNTMEZCV1R0SlFVTXhSQ3hyUmtGQmEwWTdTVUZEYkVZc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eFBRVUZQTEVWQlFVVXNTMEZCU3l4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8wRkJRM3BETEVOQlFVTTdRVUZJUkN4elEwRkhRenRCUVVWRUxIVkNRVUU0UWl4UFFVRm5RaXhGUVVGRkxFdEJRVms3U1VGRE1VUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMEZCUXpGRExFTkJRVU03UVVGR1JDeHpRMEZGUXp0QlFVVkVMRzFDUVVGdFFpeFBRVUZuUWl4RlFVRkZMRXRCUVZrc1JVRkJSU3hWUVVGdFFqdEpRVU53UlN4SlFVRk5MRWxCUVVrc1IwRkJSeXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUldwRExFbEJRVTBzVFVGQlRTeEhRVUZYTzFGQlEzSkNMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNRMEZCUXp0TFFVTm9ReXhEUVVGRE8wbEJSVVlzYzBKQlFYTkNPMGxCUTNSQ0xITkNRVUZsTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1VVRkJVVHRSUVVOMlF5eEpRVUZOTEV0QlFVc3NSMEZCUnl3d1FrRkJNRUlzUTBGQlF5eFJRVUZSTEVWQlFVVXNTVUZCU1N4RlFVRkZMRTlCUVU4c1JVRkJSU3hMUVVGTExFVkJRVVVzVlVGQlZTeERRVUZETEVOQlFVTTdVVUZEY2tZc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRlRUlzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVNelFpeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3dyUlVGQkswVTdTVUZETDBVc1NVRkJUU3hUUVVGVExFZEJRVWNzTUVKQlFUQkNMRU5CUVVNc1YwRkJWeXhGUVVGRkxFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTMEZCU3l4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRE8wbEJRelZHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRk5CUVZNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6RkNMRTFCUVUwc1EwRkJReXhUUVVGVExFZEJRVWNzVTBGQlV5eERRVUZETzBsQlEycERMRU5CUVVNN1NVRkZSQ3gzUTBGQmQwTTdTVUZGZUVNc1NVRkJUU3hWUVVGVkxFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMHNTVUZCU1N4RlFVRkZMRU5CUVVNN1NVRkRja01zVlVGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRlRMRWxCUVVrN1VVRkRPVUlzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXZRaXhuUkVGQlowUTdXVUZEYUVRc1RVRkJUU3hEUVVGRE8xRkJRMVFzUTBGQlF6dFJRVU5FTEhOR1FVRnpSanRSUVVOMFJpdzJRMEZCTmtNN1VVRkROME1zU1VGQlNTeExRVUZMTEVOQlFVTTdVVUZEVml4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTndRaXhMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxGVkJRVlVzUTBGQlF5eE5RVUZOTEVsQlFVa3NSVUZCUlN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRek5GTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOS0xFdEJRVXNzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJRMjVETEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eEpRVUZKTEZkQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnNSQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4TlFVRk5MRWxCUVVrc1JVRkJSU3hEUVVGRE8xbEJRM0JETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUlVGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNN1VVRkRlRU1zUTBGQlF6dEpRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUlVnc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEJRVU5vUWl4RFFVRkRPMEZCUlVRc2IwTkJRVzlETEZGQlFYTkNMRVZCUVVVc1lVRkJiVUlzUlVGQlJTeFBRVUZuUWl4RlFVRkZMRXRCUVZrc1JVRkJSU3hWUVVGdFFqdEpRVU5zU1N4SlFVRk5MRkZCUVZFc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUlhwRExFMUJRVTBzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha0lzUzBGQlN5eFJRVUZSTzFsQlExZ3NUVUZCVFN4RFFVRkRMRlZCUVZVc1IwRkJSeXhMUVVGTExFZEJRVWNzWVVGQllTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUTNSRUxFdEJRVXNzVVVGQlVUdFpRVU5ZTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUlVGQlJTeGhRVUZoTEVWQlFVVXNWVUZCVlN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRM0JGTEV0QlFVc3NUMEZCVHp0WlFVTldMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4aFFVRmhMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEyNUZMRXRCUVVzc1VVRkJVVHRaUVVOWUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1JVRkJSU3hQUVVGUExFVkJRVVVzVVVGQlVTeEZRVUZGTEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOMFJTeExRVUZMTEUxQlFVMDdXVUZEVkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zZFVKQlFYVkNPMUZCUTNoRkxFdEJRVXNzVjBGQlZ6dFpRVU5rTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1VVRkRja1FzUzBGQlN5eFJRVUZSTzFsQlExZ3NUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zWVVGQllTeEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUXpsRExFdEJRVXNzVjBGQlZ6dFpRVU5rTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRV0VzUlVGQlJTeFBRVUZQTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhyUWtGQmEwSTdVVUZET1VVc1MwRkJTeXhQUVVGUE8xbEJRMVlzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1lVRkJZU3hGUVVGRkxGRkJRVkVzUlVGQlJTeExRVUZMTEVOQlFVTXNUVUZCVFN4RlFVRkZMRlZCUVZVc1EwRkJReXhEUVVGRE8xRkJRM2hGTEV0QlFVc3NVVUZCVVR0WlFVTllMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUTNKRExFdEJRVXNzVVVGQlVUdFpRVU5ZTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExHRkJRV0VzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0SlFVTnVSQ3hEUVVGRE8wbEJRMFFzZDBOQlFYZERPMGxCUTNoRExFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRha01zUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vLi4vbG9nXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0ZXRpbWVcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBmb3JtYXQoc3BlY2lmaWVkQXhpcywgY2hhbm5lbCwgZmllbGREZWYsIGNvbmZpZykge1xuICAgIHJldHVybiBjb21tb25fMS5udW1iZXJGb3JtYXQoZmllbGREZWYsIHNwZWNpZmllZEF4aXMuZm9ybWF0LCBjb25maWcsIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG4vLyBUT0RPOiB3ZSBuZWVkIHRvIHJlZmFjdG9yIHRoaXMgbWV0aG9kIGFmdGVyIHdlIHRha2UgY2FyZSBvZiBjb25maWcgcmVmYWN0b3Jpbmdcbi8qKlxuICogRGVmYXVsdCBydWxlcyBmb3Igd2hldGhlciB0byBzaG93IGEgZ3JpZCBzaG91bGQgYmUgc2hvd24gZm9yIGEgY2hhbm5lbC5cbiAqIElmIGBncmlkYCBpcyB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgIGZvciBvcmRpbmFsIHNjYWxlcyB0aGF0IGFyZSBub3QgYmlubmVkXG4gKi9cbmZ1bmN0aW9uIGdyaWRTaG93KG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIGdyaWQgPSBtb2RlbC5heGlzKGNoYW5uZWwpLmdyaWQ7XG4gICAgaWYgKGdyaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZ3JpZDtcbiAgICB9XG4gICAgcmV0dXJuICFtb2RlbC5oYXNEaXNjcmV0ZVNjYWxlKGNoYW5uZWwpICYmICFtb2RlbC5maWVsZERlZihjaGFubmVsKS5iaW47XG59XG5leHBvcnRzLmdyaWRTaG93ID0gZ3JpZFNob3c7XG5mdW5jdGlvbiBncmlkKG1vZGVsLCBjaGFubmVsLCBpc0dyaWRBeGlzKSB7XG4gICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ST1cgfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLkNPTFVNTikge1xuICAgICAgICAvLyBuZXZlciBhcHBseSBncmlkIGZvciBST1cgYW5kIENPTFVNTiBzaW5jZSB3ZSBtYW51YWxseSBjcmVhdGUgcnVsZS1ncm91cCBmb3IgdGhlbVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNHcmlkQXhpcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZ3JpZFNob3cobW9kZWwsIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5ncmlkID0gZ3JpZDtcbmZ1bmN0aW9uIGdyaWRTY2FsZShtb2RlbCwgY2hhbm5lbCwgaXNHcmlkQXhpcykge1xuICAgIGlmIChpc0dyaWRBeGlzKSB7XG4gICAgICAgIHZhciBncmlkQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgaWYgKG1vZGVsLnNjYWxlKGdyaWRDaGFubmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnNjYWxlTmFtZShncmlkQ2hhbm5lbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ3JpZFNjYWxlID0gZ3JpZFNjYWxlO1xuZnVuY3Rpb24gb3JpZW50KHNwZWNpZmllZEF4aXMsIGNoYW5uZWwpIHtcbiAgICB2YXIgb3JpZW50ID0gc3BlY2lmaWVkQXhpcy5vcmllbnQ7XG4gICAgaWYgKG9yaWVudCkge1xuICAgICAgICByZXR1cm4gb3JpZW50O1xuICAgIH1cbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuQ09MVU1OOlxuICAgICAgICAgICAgLy8gRklYTUUgdGVzdCBhbmQgZGVjaWRlXG4gICAgICAgICAgICByZXR1cm4gJ3RvcCc7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlg6XG4gICAgICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlJPVzpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuWTpcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uICovXG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFMSURfQ0hBTk5FTF9GT1JfQVhJUyk7XG59XG5leHBvcnRzLm9yaWVudCA9IG9yaWVudDtcbmZ1bmN0aW9uIHRpY2tDb3VudChzcGVjaWZpZWRBeGlzLCBjaGFubmVsLCBmaWVsZERlZikge1xuICAgIHZhciBjb3VudCA9IHNwZWNpZmllZEF4aXMudGlja0NvdW50O1xuICAgIGlmIChjb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gRklYTUUgZGVwZW5kcyBvbiBzY2FsZSB0eXBlIHRvb1xuICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiAhZmllbGREZWYuYmluKSB7XG4gICAgICAgIC8vIFZlZ2EncyBkZWZhdWx0IHRpY2tDb3VudCBvZnRlbiBsZWFkIHRvIGEgbG90IG9mIGxhYmVsIG9jY2x1c2lvbiBvbiBYIHdpdGhvdXQgOTAgZGVncmVlIHJvdGF0aW9uXG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy50aWNrQ291bnQgPSB0aWNrQ291bnQ7XG5mdW5jdGlvbiB0aXRsZShzcGVjaWZpZWRBeGlzLCBmaWVsZERlZiwgY29uZmlnLCBpc0dyaWRBeGlzKSB7XG4gICAgaWYgKGlzR3JpZEF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHNwZWNpZmllZEF4aXMudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVkQXhpcy50aXRsZTtcbiAgICB9XG4gICAgLy8gaWYgbm90IGRlZmluZWQsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lIGF4aXMgdGl0bGUgZnJvbSBmaWVsZCBkZWZcbiAgICB2YXIgZmllbGRUaXRsZSA9IGZpZWxkZGVmXzEudGl0bGUoZmllbGREZWYsIGNvbmZpZyk7XG4gICAgdmFyIG1heExlbmd0aCA9IHNwZWNpZmllZEF4aXMudGl0bGVNYXhMZW5ndGg7XG4gICAgcmV0dXJuIG1heExlbmd0aCA/IHV0aWxfMS50cnVuY2F0ZShmaWVsZFRpdGxlLCBtYXhMZW5ndGgpIDogZmllbGRUaXRsZTtcbn1cbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcbmZ1bmN0aW9uIHZhbHVlcyhzcGVjaWZpZWRBeGlzKSB7XG4gICAgdmFyIHZhbHMgPSBzcGVjaWZpZWRBeGlzLnZhbHVlcztcbiAgICBpZiAoc3BlY2lmaWVkQXhpcy52YWx1ZXMgJiYgZGF0ZXRpbWVfMS5pc0RhdGVUaW1lKHZhbHNbMF0pKSB7XG4gICAgICAgIHJldHVybiB2YWxzLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSA9IHRydWUgYXMgZW5kIHVzZXIgd29uJ3QgcHV0IDAgPSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS50aW1lc3RhbXAoZHQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmZ1bmN0aW9uIHppbmRleChzcGVjaWZpZWRBeGlzLCBpc0dyaWRBeGlzKSB7XG4gICAgdmFyIHogPSBzcGVjaWZpZWRBeGlzLnppbmRleDtcbiAgICBpZiAoeiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB6O1xuICAgIH1cbiAgICBpZiAoaXNHcmlkQXhpcykge1xuICAgICAgICAvLyBpZiBncmlkIGlzIHRydWUsIG5lZWQgdG8gcHV0IGxheWVyIG9uIHRoZSBiYWNrIHNvIHRoYXQgZ3JpZCBpcyBiZWhpbmQgbWFya3NcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAxOyAvLyBvdGhlcndpc2UgcmV0dXJuIHVuZGVmaW5lZCBhbmQgdXNlIFZlZ2EncyBkZWZhdWx0LlxufVxuZXhwb3J0cy56aW5kZXggPSB6aW5kZXg7XG5mdW5jdGlvbiBkb21haW5BbmRUaWNrcyhwcm9wZXJ0eSwgc3BlY2lmaWVkQXhpcywgaXNHcmlkQXhpcywgY2hhbm5lbCkge1xuICAgIGlmIChpc0dyaWRBeGlzIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ST1cgfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLkNPTFVNTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzcGVjaWZpZWRBeGlzW3Byb3BlcnR5XTtcbn1cbmV4cG9ydHMuZG9tYWluQW5kVGlja3MgPSBkb21haW5BbmRUaWNrcztcbmV4cG9ydHMuZG9tYWluID0gZG9tYWluQW5kVGlja3M7XG5leHBvcnRzLnRpY2tzID0gZG9tYWluQW5kVGlja3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljblZzWlhNdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWhlR2x6TDNKMWJHVnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNLMEpCUVdsRE8wRkJSMnBETEhsRFFVRjVSRHRCUVVWNlJDd3lRMEZCSzBRN1FVRkRMMFFzTWtOQlFXZEZPMEZCUTJoRkxHMURRVUZ2UXp0QlFVZHdReXh2UTBGQmRVTTdRVUZIZGtNc1owSkJRWFZDTEdGQlFXMUNMRVZCUVVVc1QwRkJaMElzUlVGQlJTeFJRVUZyUWl4RlFVRkZMRTFCUVdNN1NVRkRPVVlzVFVGQlRTeERRVUZETEhGQ1FVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxHRkJRV0VzUTBGQlF5eE5RVUZOTEVWQlFVVXNUVUZCVFN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wRkJRM1pGTEVOQlFVTTdRVUZHUkN4M1FrRkZRenRCUVVWRUxHbEdRVUZwUmp0QlFVTnFSanM3TzBkQlIwYzdRVUZEU0N4clFrRkJlVUlzUzBGQldTeEZRVUZGTEU5QlFXZENPMGxCUTNKRUxFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEzUkRMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNaQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlVRc1RVRkJUU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTTdRVUZETVVVc1EwRkJRenRCUVZCRUxEUkNRVTlETzBGQlJVUXNZMEZCY1VJc1MwRkJXU3hGUVVGRkxFOUJRV2RDTEVWQlFVVXNWVUZCYlVJN1NVRkRkRVVzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMR0ZCUVVjc1NVRkJTU3hQUVVGUExFdEJRVXNzWjBKQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNVU1zYlVaQlFXMUdPMUZCUTI1R0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdTVUZEWml4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZEYmtJc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wRkJRMnhETEVOQlFVTTdRVUZZUkN4dlFrRlhRenRCUVVWRUxHMUNRVUV3UWl4TFFVRlpMRVZCUVVVc1QwRkJaMElzUlVGQlJTeFZRVUZ0UWp0SlFVTXpSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJZc1NVRkJUU3hYUVVGWExFZEJRVmtzVDBGQlR5eExRVUZMTEVkQlFVY3NSMEZCUnl4SFFVRkhMRWRCUVVjc1IwRkJSeXhEUVVGRE8xRkJRM3BFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xRkJRM1JETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dEJRVU51UWl4RFFVRkRPMEZCVWtRc09FSkJVVU03UVVGRlJDeG5Ra0ZCZFVJc1lVRkJiVUlzUlVGQlJTeFBRVUZuUWp0SlFVTXhSQ3hKUVVGTkxFMUJRVTBzUjBGQlJ5eGhRVUZoTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTNCRExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRXQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzBsQlEyaENMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFdEJRVXNzWjBKQlFVMDdXVUZEVkN4M1FrRkJkMEk3V1VGRGVFSXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVObUxFdEJRVXNzVjBGQlF6dFpRVU5LTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkRiRUlzUzBGQlN5eGhRVUZITEVOQlFVTTdVVUZEVkN4TFFVRkxMRmRCUVVNN1dVRkRTaXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzBsQlEyeENMRU5CUVVNN1NVRkRSQ3h4UkVGQmNVUTdTVUZEY2tRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEVOQlFVTTdRVUZEZUVRc1EwRkJRenRCUVd4Q1JDeDNRa0ZyUWtNN1FVRkZSQ3h0UWtGQk1FSXNZVUZCYlVJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEZGQlFXdENPMGxCUTJwR0xFbEJRVTBzUzBGQlN5eEhRVUZITEdGQlFXRXNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRkRU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFSXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVObUxFTkJRVU03U1VGRlJDeHJRMEZCYTBNN1NVRkRiRU1zUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRmRCUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTI1RExHdEhRVUZyUnp0UlFVTnNSeXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlExZ3NRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03UVVGRGJrSXNRMEZCUXp0QlFXSkVMRGhDUVdGRE8wRkJSVVFzWlVGQmMwSXNZVUZCYlVJc1JVRkJSU3hSUVVGclFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4VlFVRnRRanRKUVVOb1J5eEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMllzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRXRCUVVzc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkRMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zUzBGQlN5eERRVUZETzBsQlF6ZENMRU5CUVVNN1NVRkZSQ3h2UlVGQmIwVTdTVUZEY0VVc1NVRkJUU3hWUVVGVkxFZEJRVWNzWjBKQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRmJrUXNTVUZCVFN4VFFVRlRMRWRCUVZjc1lVRkJZU3hEUVVGRExHTkJRV01zUTBGQlF6dEpRVU4yUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhIUVVGSExHVkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNVMEZCVXl4RFFVRkRMRWRCUVVjc1ZVRkJWU3hEUVVGRE8wRkJRMnhGTEVOQlFVTTdRVUZpUkN4elFrRmhRenRCUVVWRUxHZENRVUYxUWl4aFFVRnRRanRKUVVONFF5eEpRVUZOTEVsQlFVa3NSMEZCUnl4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRMnhETEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1EwRkJReXhOUVVGTkxFbEJRVWtzY1VKQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVRc1RVRkJUU3hEUVVGRkxFbEJRVzFDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1JVRkJSVHRaUVVOcVF5eHhSRUZCY1VRN1dVRkRja1FzVFVGQlRTeERRVUZETEc5Q1FVRlRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF6ZENMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJWRVFzZDBKQlUwTTdRVUZGUkN4blFrRkJkVUlzWVVGQmJVSXNSVUZCUlN4VlFVRnRRanRKUVVNM1JDeEpRVUZOTEVOQlFVTXNSMEZCUnl4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzQkNMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFdDeERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5tTERoRlFVRTRSVHRSUVVNNVJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTFnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4eFJFRkJjVVE3UVVGRGFrVXNRMEZCUXp0QlFWWkVMSGRDUVZWRE8wRkJSVVFzZDBKQlFTdENMRkZCUVhOQ0xFVkJRVVVzWVVGQmJVSXNSVUZCUlN4VlFVRnRRaXhGUVVGRkxFOUJRV2RDTzBsQlF5OUhMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzU1VGQlNTeFBRVUZQTEV0QlFVc3NZVUZCUnl4SlFVRkpMRTlCUVU4c1MwRkJTeXhuUWtGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRSQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEyWXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdRVUZEYWtNc1EwRkJRenRCUVV4RUxIZERRVXRETzBGQlJWa3NVVUZCUVN4TlFVRk5MRWRCUVVjc1kwRkJZeXhEUVVGRE8wRkJRM2hDTEZGQlFVRXNTMEZCU3l4SFFVRkhMR05CUVdNc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ1wiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uL2ZpZWxkZGVmXCIpO1xudmFyIHR5cGVfMSA9IHJlcXVpcmUoXCIuLi90eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHNwZWNfMSA9IHJlcXVpcmUoXCIuLi9zcGVjXCIpO1xudmFyIHRpbWV1bml0XzEgPSByZXF1aXJlKFwiLi4vdGltZXVuaXRcIik7XG52YXIgZmFjZXRfMSA9IHJlcXVpcmUoXCIuL2ZhY2V0XCIpO1xudmFyIGxheWVyXzEgPSByZXF1aXJlKFwiLi9sYXllclwiKTtcbnZhciB1bml0XzEgPSByZXF1aXJlKFwiLi91bml0XCIpO1xuZnVuY3Rpb24gYnVpbGRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKHNwZWNfMS5pc0ZhY2V0U3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbmV3IGZhY2V0XzEuRmFjZXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHNwZWNfMS5pc0xheWVyU3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbmV3IGxheWVyXzEuTGF5ZXJNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKTtcbiAgICB9XG4gICAgaWYgKHNwZWNfMS5pc1VuaXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgdW5pdF8xLlVuaXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFMSURfU1BFQyk7XG59XG5leHBvcnRzLmJ1aWxkTW9kZWwgPSBidWlsZE1vZGVsO1xuZnVuY3Rpb24gYXBwbHlDb25maWcoZSwgY29uZmlnLCAvLyBUT0RPKCMxODQyKTogY29uc29saWRhdGUgTWFya0NvbmZpZyB8IFRleHRDb25maWc/XG4gICAgcHJvcHNMaXN0KSB7XG4gICAgcHJvcHNMaXN0LmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlW3Byb3BlcnR5XSA9IHsgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZTtcbn1cbmV4cG9ydHMuYXBwbHlDb25maWcgPSBhcHBseUNvbmZpZztcbmZ1bmN0aW9uIGFwcGx5TWFya0NvbmZpZyhlLCBtb2RlbCwgcHJvcHNMaXN0KSB7XG4gICAgcHJvcHNMaXN0LmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldE1hcmtDb25maWcocHJvcGVydHksIG1vZGVsLm1hcmsoKSwgbW9kZWwuY29uZmlnKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVbcHJvcGVydHldID0geyB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlO1xufVxuZXhwb3J0cy5hcHBseU1hcmtDb25maWcgPSBhcHBseU1hcmtDb25maWc7XG4vKipcbiAqIFJldHVybiB2YWx1ZSBtYXJrIHNwZWNpZmljIGNvbmZpZyBwcm9wZXJ0eSBpZiBleGlzdHMuXG4gKiBPdGhlcndpc2UsIHJldHVybiBnZW5lcmFsIG1hcmsgc3BlY2lmaWMgY29uZmlnLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrQ29uZmlnKHByb3AsIG1hcmssIGNvbmZpZykge1xuICAgIHZhciBtYXJrU3BlY2lmaWNDb25maWcgPSBjb25maWdbbWFya107XG4gICAgaWYgKG1hcmtTcGVjaWZpY0NvbmZpZ1twcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtYXJrU3BlY2lmaWNDb25maWdbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBjb25maWcubWFya1twcm9wXTtcbn1cbmV4cG9ydHMuZ2V0TWFya0NvbmZpZyA9IGdldE1hcmtDb25maWc7XG4vKipcbiAqIFJldHVybnMgbnVtYmVyIGZvcm1hdCBmb3IgYSBmaWVsZERlZlxuICpcbiAqIEBwYXJhbSBmb3JtYXQgZXhwbGljaXRseSBzcGVjaWZpZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG51bWJlckZvcm1hdChmaWVsZERlZiwgZm9ybWF0LCBjb25maWcsIGNoYW5uZWwpIHtcbiAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gdHlwZV8xLlFVQU5USVRBVElWRSkge1xuICAgICAgICAvLyBhZGQgbnVtYmVyIGZvcm1hdCBmb3IgcXVhbnRpdGF0aXZlIHR5cGUgb25seVxuICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50JyAmJiBjaGFubmVsID09PSBjaGFubmVsXzEuVEVYVCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IG5lZWQgYSBtb3JlIGhvbGlzdGljIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgIHJldHVybiAnZCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBtYWtlIHRoaXMgd29yayBjb3JyZWN0bHkgZm9yIG51bWVyaWMgb3JkaW5hbCAvIG5vbWluYWwgdHlwZVxuICAgICAgICByZXR1cm4gY29uZmlnLm51bWJlckZvcm1hdDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMubnVtYmVyRm9ybWF0ID0gbnVtYmVyRm9ybWF0O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lIGV4cHJlc3Npb24gdXNlZCBmb3IgYXhpcy9sZWdlbmQgbGFiZWxzIG9yIHRleHQgbWFyayBmb3IgYSB0ZW1wb3JhbCBmaWVsZFxuICovXG5mdW5jdGlvbiB0aW1lRm9ybWF0RXhwcmVzc2lvbihmaWVsZCwgdGltZVVuaXQsIGZvcm1hdCwgc2hvcnRUaW1lTGFiZWxzLCB0aW1lRm9ybWF0Q29uZmlnKSB7XG4gICAgaWYgKCF0aW1lVW5pdCB8fCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm90IHRpbWUgdW5pdCwgb3IgaWYgdXNlciBleHBsaWNpdGx5IHNwZWNpZnkgZm9ybWF0IGZvciBheGlzL2xlZ2VuZC90ZXh0LlxuICAgICAgICB2YXIgX2Zvcm1hdCA9IGZvcm1hdCB8fCB0aW1lRm9ybWF0Q29uZmlnOyAvLyBvbmx5IHVzZSBjb25maWcudGltZUZvcm1hdCBpZiB0aGVyZSBpcyBubyB0aW1lVW5pdC5cbiAgICAgICAgcmV0dXJuIFwidGltZUZvcm1hdChcIiArIGZpZWxkICsgXCIsICdcIiArIF9mb3JtYXQgKyBcIicpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGltZXVuaXRfMS5mb3JtYXRFeHByZXNzaW9uKHRpbWVVbml0LCBmaWVsZCwgc2hvcnRUaW1lTGFiZWxzKTtcbiAgICB9XG59XG5leHBvcnRzLnRpbWVGb3JtYXRFeHByZXNzaW9uID0gdGltZUZvcm1hdEV4cHJlc3Npb247XG4vKipcbiAqIFJldHVybiBWZWdhIHNvcnQgcGFyYW1ldGVycyAodHVwbGUgb2YgZmllbGQgYW5kIG9yZGVyKS5cbiAqL1xuZnVuY3Rpb24gc29ydFBhcmFtcyhvcmRlckRlZikge1xuICAgIHJldHVybiAodXRpbF8xLmlzQXJyYXkob3JkZXJEZWYpID8gb3JkZXJEZWYgOiBbb3JkZXJEZWZdKS5yZWR1Y2UoZnVuY3Rpb24gKHMsIG9yZGVyQ2hhbm5lbERlZikge1xuICAgICAgICBzLmZpZWxkLnB1c2goZmllbGRkZWZfMS5maWVsZChvcmRlckNoYW5uZWxEZWYsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pKTtcbiAgICAgICAgcy5vcmRlci5wdXNoKG9yZGVyQ2hhbm5lbERlZi5zb3J0IHx8ICdhc2NlbmRpbmcnKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSwgeyBmaWVsZDogW10sIG9yZGVyOiBbXSB9KTtcbn1cbmV4cG9ydHMuc29ydFBhcmFtcyA9IHNvcnRQYXJhbXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lZMjl0Ylc5dUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdlkyOXRiVzl1TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzTkVKQlFUaENPMEZCUlRsQ0xITkRRVUY1UXp0QlFVVjZReXgzUTBGQk1rUTdRVUZITTBRc1owTkJRWEZETzBGQlEzSkRMR2REUVVGblF6dEJRVVZvUXl4blEwRkJiVVU3UVVGRGJrVXNkME5CUVRaRE8wRkJSVGRETEdsRFFVRnRRenRCUVVOdVF5eHBRMEZCYlVNN1FVRkZia01zSzBKQlFXbERPMEZCUldwRExHOUNRVUV5UWl4SlFVRlZMRVZCUVVVc1RVRkJZU3hGUVVGRkxHVkJRWFZDTEVWQlFVVXNUVUZCWXp0SlFVTXpSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eHJRa0ZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hyUWtGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF5OUVMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eHJRa0ZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hyUWtGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF5OUVMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eHBRa0ZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3huUWtGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVVc1pVRkJaU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF6bEVMRU5CUVVNN1NVRkZSQ3hOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4UFFVRlBMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU03UVVGRE5VTXNRMEZCUXp0QlFXUkVMR2REUVdORE8wRkJSVVFzY1VKQlFUUkNMRU5CUVdkQ0xFVkJRM2hETEUxQlFUUkRMRVZCUVVVc2IwUkJRVzlFTzBsQlEyeEhMRk5CUVcxQ08wbEJRM0pDTEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJReXhSUVVGUk8xRkJRM3BDTEVsQlFVMHNTMEZCU3l4SFFVRkhMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU12UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjRRaXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRExFTkJRVU03VVVGREwwSXNRMEZCUXp0SlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMGdzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTllMRU5CUVVNN1FVRldSQ3hyUTBGVlF6dEJRVVZFTEhsQ1FVRm5ReXhEUVVGblFpeEZRVUZGTEV0QlFXZENMRVZCUVVVc1UwRkJLMEk3U1VGRGFrY3NVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGRExGRkJRVkU3VVVGRGVrSXNTVUZCVFN4TFFVRkxMRWRCUVVjc1lVRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETzFGQlEyeEZMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoQ0xFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RlFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVU1zUTBGQlF6dFJRVU12UWl4RFFVRkRPMGxCUTBnc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFNDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTFnc1EwRkJRenRCUVZKRUxEQkRRVkZETzBGQlJVUTdPenRIUVVkSE8wRkJRMGdzZFVKQlFUQkVMRWxCUVU4c1JVRkJSU3hKUVVGVkxFVkJRVVVzVFVGQll6dEpRVU16Uml4SlFVRk5MR3RDUVVGclFpeEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVONFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRek5ETEUxQlFVMHNRMEZCUXl4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTnNReXhEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03UVVGRE0wSXNRMEZCUXp0QlFVNUVMSE5EUVUxRE8wRkJSVVE3T3pzN1IwRkpSenRCUVVOSUxITkNRVUUyUWl4UlFVRnJRaXhGUVVGRkxFMUJRV01zUlVGQlJTeE5RVUZqTEVWQlFVVXNUMEZCWjBJN1NVRkRMMFlzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1MwRkJTeXh0UWtGQldTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnVReXdyUTBGQkswTTdVVUZGTDBNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03VVVGRGFFSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4TFFVRkxMRTlCUVU4c1NVRkJTU3hQUVVGUExFdEJRVXNzWTBGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTVSQ3h4UkVGQmNVUTdXVUZEY2tRc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF6dFJRVU5pTEVOQlFVTTdVVUZEUkN3MFJVRkJORVU3VVVGRE5VVXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU03U1VGRE4wSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03UVVGRGJrSXNRMEZCUXp0QlFXUkVMRzlEUVdORE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N3NFFrRkJjVU1zUzBGQllTeEZRVUZGTEZGQlFXdENMRVZCUVVVc1RVRkJZeXhGUVVGRkxHVkJRWGRDTEVWQlFVVXNaMEpCUVhkQ08wbEJRM2hKTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hKUVVGSkxFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc2QwWkJRWGRHTzFGQlEzaEdMRWxCUVUwc1QwRkJUeXhIUVVGSExFMUJRVTBzU1VGQlNTeG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExITkVRVUZ6UkR0UlFVTnNSeXhOUVVGTkxFTkJRVU1zWjBKQlFXTXNTMEZCU3l4WFFVRk5MRTlCUVU4c1QwRkJTU3hEUVVGRE8wbEJRemxETEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFMUJRVTBzUTBGQlF5d3lRa0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzUzBGQlN5eEZRVUZGTEdWQlFXVXNRMEZCUXl4RFFVRkRPMGxCUXpWRUxFTkJRVU03UVVGRFNDeERRVUZETzBGQlVrUXNiMFJCVVVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEc5Q1FVRXlRaXhSUVVGNVF6dEpRVU5zUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhqUVVGUExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NVVUZCVVN4SFFVRkhMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4RFFVRkRMRVZCUVVVc1pVRkJaVHRSUVVNelJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlN5eERRVUZETEdWQlFXVXNSVUZCUlN4RlFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBRc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1NVRkJTU3hYUVVGWExFTkJRVU1zUTBGQlF6dFJRVU5zUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMWdzUTBGQlF5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkRMRVZCUVVVc1JVRkJSU3hMUVVGTExFVkJRVVVzUlVGQlJTeEZRVUZETEVOQlFVTXNRMEZCUXp0QlFVTTFRaXhEUVVGRE8wRkJUa1FzWjBOQlRVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8qKlxuICogTW9kdWxlIGZvciBjb21waWxpbmcgVmVnYS1saXRlIHNwZWMgaW50byBWZWdhIHNwZWMuXG4gKi9cbnZhciBjb25maWdfMSA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4uL2RhdGFcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ1wiKTtcbnZhciBzcGVjXzEgPSByZXF1aXJlKFwiLi4vc3BlY1wiKTtcbnZhciB0b3BsZXZlbHByb3BzXzEgPSByZXF1aXJlKFwiLi4vdG9wbGV2ZWxwcm9wc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBzZWxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3NlbGVjdGlvbi9zZWxlY3Rpb25cIik7XG5mdW5jdGlvbiBjb21waWxlKGlucHV0U3BlYywgbG9nZ2VyKSB7XG4gICAgaWYgKGxvZ2dlcikge1xuICAgICAgICAvLyBzZXQgdGhlIHNpbmdsZXRvbiBsb2dnZXIgdG8gdGhlIHByb3ZpZGVkIGxvZ2dlclxuICAgICAgICBsb2cuc2V0KGxvZ2dlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIDEuIENvbnZlcnQgaW5wdXQgc3BlYyBpbnRvIGEgbm9ybWFsIGZvcm1cbiAgICAgICAgLy8gKERlY29tcG9zZSBhbGwgZXh0ZW5kZWQgdW5pdCBzcGVjcyBpbnRvIGNvbXBvc2l0aW9uIG9mIHVuaXQgc3BlYy4pXG4gICAgICAgIHZhciBzcGVjID0gc3BlY18xLm5vcm1hbGl6ZShpbnB1dFNwZWMpO1xuICAgICAgICAvLyAyLiBJbnN0YW50aWF0ZSB0aGUgbW9kZWwgd2l0aCBkZWZhdWx0IGNvbmZpZ1xuICAgICAgICB2YXIgY29uZmlnID0gY29uZmlnXzEuaW5pdENvbmZpZyhpbnB1dFNwZWMuY29uZmlnKTtcbiAgICAgICAgdmFyIG1vZGVsID0gY29tbW9uXzEuYnVpbGRNb2RlbChzcGVjLCBudWxsLCAnJywgY29uZmlnKTtcbiAgICAgICAgLy8gMy4gUGFyc2UgZWFjaCBwYXJ0IG9mIHRoZSBtb2RlbCB0byBwcm9kdWNlIGNvbXBvbmVudHMgdGhhdCB3aWxsIGJlIGFzc2VtYmxlZCBsYXRlclxuICAgICAgICAvLyBXZSB0cmF2ZXJzZSB0aGUgd2hvbGUgdHJlZSB0byBwYXJzZSBvbmNlIGZvciBlYWNoIHR5cGUgb2YgY29tcG9uZW50c1xuICAgICAgICAvLyAoZS5nLiwgZGF0YSwgbGF5b3V0LCBtYXJrLCBzY2FsZSkuXG4gICAgICAgIC8vIFBsZWFzZSBzZWUgaW5zaWRlIG1vZGVsLnBhcnNlKCkgZm9yIG9yZGVyIGZvciBjb21waWxhdGlvbi5cbiAgICAgICAgbW9kZWwucGFyc2UoKTtcbiAgICAgICAgLy8gNC4gQXNzZW1ibGUgYSBWZWdhIFNwZWMgZnJvbSB0aGUgcGFyc2VkIGNvbXBvbmVudHMgaW4gMy5cbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlKG1vZGVsLCBnZXRUb3BMZXZlbFByb3BlcnRpZXMoaW5wdXRTcGVjLCBjb25maWcpKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBzaW5nbGV0b24gbG9nZ2VyIGlmIGEgbG9nZ2VyIGlzIHByb3ZpZGVkXG4gICAgICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgICAgIGxvZy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmZ1bmN0aW9uIGdldFRvcExldmVsUHJvcGVydGllcyh0b3BMZXZlbFNwZWMsIGNvbmZpZykge1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCB0b3BsZXZlbHByb3BzXzEuZXh0cmFjdFRvcExldmVsUHJvcGVydGllcyhjb25maWcpLCB0b3BsZXZlbHByb3BzXzEuZXh0cmFjdFRvcExldmVsUHJvcGVydGllcyh0b3BMZXZlbFNwZWMpKTtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlKG1vZGVsLCB0b3BMZXZlbFByb3BlcnRpZXMpIHtcbiAgICAvLyBUT0RPOiBjaGFuZ2UgdHlwZSB0byBiZWNvbWUgVmdTcGVjXG4gICAgdmFyIG91dHB1dCA9IHV0aWxfMS5leHRlbmQoe1xuICAgICAgICAkc2NoZW1hOiAnaHR0cDovL3ZlZ2EuZ2l0aHViLmlvL3NjaGVtYS92ZWdhL3YzLjAuanNvbicsXG4gICAgfSwgeyBhdXRvc2l6ZTogJ3BhZCcgfSwgLy8gQ3VycmVudGx5IHdlIGRvbid0IHN1cHBvcnQgY3VzdG9tIGF1dG9zaXplXG4gICAgdG9wTGV2ZWxQcm9wZXJ0aWVzLCB7XG4gICAgICAgIC8vIE1hcCBjYWxjdWxhdGVkIGxheW91dCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHdpZHRoIGFuZCBoZWlnaHQgc2lnbmFscy5cbiAgICAgICAgc2lnbmFsczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiBcImRhdGEoJ1wiICsgbW9kZWwuZ2V0TmFtZShkYXRhXzEuTEFZT1VUKSArIFwiJylbMF0uXCIgKyBtb2RlbC5nZXROYW1lKCd3aWR0aCcpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogXCJkYXRhKCdcIiArIG1vZGVsLmdldE5hbWUoZGF0YV8xLkxBWU9VVCkgKyBcIicpWzBdLlwiICsgbW9kZWwuZ2V0TmFtZSgnaGVpZ2h0JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgXS5jb25jYXQoc2VsZWN0aW9uXzEuYXNzZW1ibGVUb3BMZXZlbFNpZ25hbHMobW9kZWwpKVxuICAgIH0sIHtcbiAgICAgICAgZGF0YTogW10uY29uY2F0KG1vZGVsLmFzc2VtYmxlRGF0YSgpLCBtb2RlbC5hc3NlbWJsZUxheW91dChbXSksIG1vZGVsLmFzc2VtYmxlU2VsZWN0aW9uRGF0YShbXSkpLFxuICAgICAgICBtYXJrczogW2Fzc2VtYmxlUm9vdEdyb3VwKG1vZGVsKV1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzcGVjOiBvdXRwdXRcbiAgICAgICAgLy8gVE9ETzogYWRkIHdhcm5pbmcgLyBlcnJvcnMgaGVyZVxuICAgIH07XG59XG5mdW5jdGlvbiBhc3NlbWJsZVJvb3RHcm91cChtb2RlbCkge1xuICAgIHZhciByb290R3JvdXAgPSB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogbW9kZWwuZ2V0TmFtZSgnbWFpbi1ncm91cCcpLFxuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIH0sIG1vZGVsLmRlc2NyaXB0aW9uID8geyBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfSA6IHt9LCB7XG4gICAgICAgIGZyb206IHsgZGF0YTogbW9kZWwuZ2V0TmFtZShkYXRhXzEuTEFZT1VUKSB9LFxuICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgIHVwZGF0ZTogdXRpbF8xLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHsgZmllbGQ6IG1vZGVsLmdldE5hbWUoJ3dpZHRoJykgfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHsgZmllbGQ6IG1vZGVsLmdldE5hbWUoJ2hlaWdodCcpIH1cbiAgICAgICAgICAgIH0sIG1vZGVsLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzKG1vZGVsLmNvbmZpZy5jZWxsKSlcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB1dGlsXzEuZXh0ZW5kKHJvb3RHcm91cCwgbW9kZWwuYXNzZW1ibGVHcm91cCgpKTtcbn1cbmV4cG9ydHMuYXNzZW1ibGVSb290R3JvdXAgPSBhc3NlbWJsZVJvb3RHcm91cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyOXRjR2xzWlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDJOdmJYQnBiR1V1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUU3TzBkQlJVYzdRVUZEU0N4dlEwRkJOa003UVVGRE4wTXNaME5CUVN0Q08wRkJReTlDTERSQ1FVRTRRanRCUVVNNVFpeG5RMEZCTUVRN1FVRkRNVVFzYTBSQlFTdEZPMEZCUXk5RkxHZERRVUVyUWp0QlFVTXZRaXh0UTBGQmIwTTdRVUZGY0VNc2JVUkJRVGhFTzBGQlJUbEVMR2xDUVVGM1FpeFRRVUZwUXl4RlFVRkZMRTFCUVRSQ08wbEJRM0pHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFdDeHJSRUZCYTBRN1VVRkRiRVFzUjBGQlJ5eERRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlJVUXNTVUZCU1N4RFFVRkRPMUZCUTBnc01rTkJRVEpETzFGQlF6TkRMSEZGUVVGeFJUdFJRVU55UlN4SlFVRk5MRWxCUVVrc1IwRkJSeXhuUWtGQlV5eERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRPMUZCUld4RExDdERRVUVyUXp0UlFVTXZReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eHRRa0ZCVlN4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU0xUXl4SlFVRk5MRXRCUVVzc1IwRkJSeXh0UWtGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVVc1JVRkJSU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzFGQlJXcEVMSEZHUVVGeFJqdFJRVU55Uml4MVJVRkJkVVU3VVVGRGRrVXNjVU5CUVhGRE8xRkJRM0pETERaRVFVRTJSRHRSUVVNM1JDeExRVUZMTEVOQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNN1VVRkZaQ3d5UkVGQk1rUTdVVUZETTBRc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVWQlFVVXNjVUpCUVhGQ0xFTkJRVU1zVTBGQlV5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRia1VzUTBGQlF6dFpRVUZUTEVOQlFVTTdVVUZEVkN4eFJFRkJjVVE3VVVGRGNrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5ZTEVkQlFVY3NRMEZCUXl4TFFVRkxMRVZCUVVVc1EwRkJRenRSUVVOa0xFTkJRVU03U1VGRFNDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFUZENSQ3d3UWtFMlFrTTdRVUZIUkN3clFrRkJLMElzV1VGQk1rSXNSVUZCUlN4TlFVRmpPMGxCUTNoRkxFMUJRVTBzYzBKQlEwUXNlVU5CUVhsQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVWQlEycERMSGxEUVVGNVFpeERRVUZETEZsQlFWa3NRMEZCUXl4RlFVTXhRenRCUVVOS0xFTkJRVU03UVVGRlJDeHJRa0ZCYTBJc1MwRkJXU3hGUVVGRkxHdENRVUZ6UXp0SlFVTndSU3h4UTBGQmNVTTdTVUZEY2tNc1NVRkJUU3hOUVVGTkxFZEJRVWNzWVVGQlRTeERRVU51UWp0UlFVTkZMRTlCUVU4c1JVRkJSU3cyUTBGQk5rTTdTMEZEZGtRc1JVRkRSQ3hGUVVGRExGRkJRVkVzUlVGQlJTeExRVUZMTEVWQlFVTXNSVUZCUlN3MlEwRkJOa003U1VGRGFFVXNhMEpCUVd0Q0xFVkJRMnhDTzFGQlEwVXNjMFZCUVhORk8xRkJRM1JGTEU5QlFVOHNSVUZCUlR0WlFVTlFPMmRDUVVORkxFbEJRVWtzUlVGQlJTeFBRVUZQTzJkQ1FVTmlMRTFCUVUwc1JVRkJSU3hYUVVGVExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNZVUZCVFN4RFFVRkRMR05CUVZNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVYzdZVUZEZUVVN1dVRkRSRHRuUWtGRFJTeEpRVUZKTEVWQlFVVXNVVUZCVVR0blFrRkRaQ3hOUVVGTkxFVkJRVVVzVjBGQlV5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVUwc1EwRkJReXhqUVVGVExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNVVUZCVVN4RFFVRkhPMkZCUTNwRk8xTkJRMFlzUTBGQlF5eE5RVUZOTEVOQlFVTXNiVU5CUVhWQ0xFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTMEZEZWtNc1JVRkJRenRSUVVOQkxFbEJRVWtzUlVGQlJTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVTmlMRXRCUVVzc1EwRkJReXhaUVVGWkxFVkJRVVVzUlVGRGNFSXNTMEZCU3l4RFFVRkRMR05CUVdNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGRGVFSXNTMEZCU3l4RFFVRkRMSEZDUVVGeFFpeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVTm9RenRSUVVORUxFdEJRVXNzUlVGQlJTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzB0QlEyeERMRU5CUVVNc1EwRkJRenRKUVVWTUxFMUJRVTBzUTBGQlF6dFJRVU5NTEVsQlFVa3NSVUZCUlN4TlFVRk5PMUZCUTFvc2EwTkJRV3RETzB0QlEyNURMRU5CUVVNN1FVRkRTaXhEUVVGRE8wRkJSVVFzTWtKQlFXdERMRXRCUVZrN1NVRkROVU1zU1VGQlRTeFRRVUZUTEVkQlFVY3NZVUZCVFN4RFFVTjBRanRSUVVORkxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRmxCUVZrc1EwRkJRenRSUVVOcVF5eEpRVUZKTEVWQlFVVXNUMEZCVHp0TFFVTmtMRVZCUTBRc1MwRkJTeXhEUVVGRExGZEJRVmNzUjBGQlJ5eEZRVUZETEZkQlFWY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1YwRkJWeXhGUVVGRExFZEJRVWNzUlVGQlJTeEZRVU42UkR0UlFVTkZMRWxCUVVrc1JVRkJSU3hGUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVUwc1EwRkJReXhGUVVGRE8xRkJRMjVETEUxQlFVMHNSVUZCUlR0WlFVTk9MRTFCUVUwc1JVRkJSU3hoUVVGTkxFTkJRMW83WjBKQlEwVXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVNN1owSkJRM1JETEUxQlFVMHNSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkRPMkZCUTNwRExFVkJRMFFzUzBGQlN5eERRVUZETERaQ1FVRTJRaXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUTNaRU8xTkJRMFk3UzBGRFJpeERRVUZETEVOQlFVTTdTVUZGVEN4TlFVRk5MRU5CUVVNc1lVRkJUU3hEUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVOQlFVTXNZVUZCWVN4RlFVRkZMRU5CUVVNc1EwRkJRenRCUVVOc1JDeERRVUZETzBGQmNrSkVMRGhEUVhGQ1F5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG5mdW5jdGlvbiBhZGREaW1lbnNpb24oZGltcywgZmllbGREZWYpIHtcbiAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgIGRpbXNbZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSldID0gdHJ1ZTtcbiAgICAgICAgZGltc1tmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSldID0gdHJ1ZTtcbiAgICAgICAgLy8gY29uc3Qgc2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsKTtcbiAgICAgICAgLy8gaWYgKHNjYWxlVHlwZShzY2FsZSwgZmllbGREZWYsIGNoYW5uZWwsIG1vZGVsLm1hcmsoKSkgPT09IFNjYWxlVHlwZS5PUkRJTkFMKSB7XG4gICAgICAgIC8vIGFsc28gcHJvZHVjZSBiaW5fcmFuZ2UgaWYgdGhlIGJpbm5lZCBmaWVsZCB1c2Ugb3JkaW5hbCBzY2FsZVxuICAgICAgICBkaW1zW2ZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAncmFuZ2UnIH0pXSA9IHRydWU7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpbXNbZmllbGRkZWZfMS5maWVsZChmaWVsZERlZildID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbXM7XG59XG5mdW5jdGlvbiBtZXJnZU1lYXN1cmVzKHBhcmVudE1lYXN1cmVzLCBjaGlsZE1lYXN1cmVzKSB7XG4gICAgZm9yICh2YXIgZmllbGRfMSBpbiBjaGlsZE1lYXN1cmVzKSB7XG4gICAgICAgIGlmIChjaGlsZE1lYXN1cmVzLmhhc093blByb3BlcnR5KGZpZWxkXzEpKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHdlIG1lcmdlIGEgbWVhc3VyZSwgd2UgZWl0aGVyIGhhdmUgdG8gYWRkIGFuIGFnZ3JlZ2F0aW9uIG9wZXJhdG9yIG9yIGV2ZW4gYSBuZXcgZmllbGRcbiAgICAgICAgICAgIHZhciBvcHMgPSBjaGlsZE1lYXN1cmVzW2ZpZWxkXzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgb3AgaW4gb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wcy5oYXNPd25Qcm9wZXJ0eShvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkXzEgaW4gcGFyZW50TWVhc3VyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBvcGVyYXRvciB0byBleGlzdGluZyBtZWFzdXJlIGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNZWFzdXJlc1tmaWVsZF8xXVtvcF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50TWVhc3VyZXNbZmllbGRfMV0gPSB7IG9wOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgQWdncmVnYXRlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQWdncmVnYXRlTm9kZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9ucyBzdHJpbmcgc2V0IGZvciBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIG1lYXN1cmVzIGRpY3Rpb25hcnkgbWFwcGluZyBmaWVsZCBuYW1lID0+IGRpY3Qgc2V0IG9mIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFnZ3JlZ2F0ZU5vZGUoZGltZW5zaW9ucywgbWVhc3VyZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGltZW5zaW9ucyA9IGRpbWVuc2lvbnM7XG4gICAgICAgIF90aGlzLm1lYXN1cmVzID0gbWVhc3VyZXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWdncmVnYXRlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlTm9kZSh1dGlsXzEuZXh0ZW5kKHt9LCB0aGlzLmRpbWVuc2lvbnMpLCB1dGlsXzEuZHVwbGljYXRlKHRoaXMubWVhc3VyZXMpKTtcbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgaXNBZ2dyZWdhdGUgPSBmYWxzZTtcbiAgICAgICAgbW9kZWwuZm9yRWFjaEZpZWxkRGVmKGZ1bmN0aW9uIChmZCkge1xuICAgICAgICAgICAgaWYgKGZkLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGlzQWdncmVnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtZWFzID0ge307XG4gICAgICAgIHZhciBkaW1zID0ge307XG4gICAgICAgIGlmICghaXNBZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gY3JlYXRlIHRoaXMgbm9kZSBpZiB0aGUgbW9kZWwgaGFzIG5vIGFnZ3JlZ2F0aW9uXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5mb3JFYWNoRmllbGREZWYoZnVuY3Rpb24gKGZpZWxkRGVmLCBjaGFubmVsKSB7XG4gICAgICAgICAgICBpZiAoZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgICAgICAgICBtZWFzWycqJ10gPSBtZWFzWycqJ10gfHwge307XG4gICAgICAgICAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXN0cmluZy1saXRlcmFsICovXG4gICAgICAgICAgICAgICAgICAgIG1lYXNbJyonXVsnY291bnQnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tc3RyaW5nLWxpdGVyYWwgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lYXNbZmllbGREZWYuZmllbGRdID0gbWVhc1tmaWVsZERlZi5maWVsZF0gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG1lYXNbZmllbGREZWYuZmllbGRdW2ZpZWxkRGVmLmFnZ3JlZ2F0ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgbWluL21heCBzbyB3ZSBjYW4gdXNlIHRoZWlyIHVuaW9uIGFzIHVuYWdncmVnYXRlZCBkb21haW5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZSAmJiBzY2FsZS5kb21haW4gPT09ICd1bmFnZ3JlZ2F0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWFzW2ZpZWxkRGVmLmZpZWxkXVsnbWluJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVhc1tmaWVsZERlZi5maWVsZF1bJ21heCddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZERpbWVuc2lvbihkaW1zLCBmaWVsZERlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKE9iamVjdC5rZXlzKGRpbXMpLmxlbmd0aCArIE9iamVjdC5rZXlzKG1lYXMpLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWdncmVnYXRlTm9kZShkaW1zLCBtZWFzKTtcbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghdXRpbF8xLmRpZmZlcih0aGlzLmRpbWVuc2lvbnMsIG90aGVyLmRpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgICBtZXJnZU1lYXN1cmVzKHRoaXMubWVhc3VyZXMsIG90aGVyLm1lYXN1cmVzKTtcbiAgICAgICAgICAgIG90aGVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nLmRlYnVnKCdkaWZmZXJlbnQgZGltZW5zaW9ucywgY2Fubm90IG1lcmdlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUucHJvdG90eXBlLmFkZERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZmllbGRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBfdGhpcy5kaW1lbnNpb25zW2ZdID0gdHJ1ZTsgfSk7XG4gICAgfTtcbiAgICBBZ2dyZWdhdGVOb2RlLnByb3RvdHlwZS5kZXBlbmRlbnRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgdXRpbF8xLmtleXModGhpcy5kaW1lbnNpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBvdXRbZl0gPSB0cnVlOyB9KTtcbiAgICAgICAgdXRpbF8xLmtleXModGhpcy5tZWFzdXJlcykuZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXR1cm4gb3V0W21dID0gdHJ1ZTsgfSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBBZ2dyZWdhdGVOb2RlLnByb3RvdHlwZS5wcm9kdWNlZEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB1dGlsXzEua2V5cyh0aGlzLm1lYXN1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdXRpbF8xLmtleXMoX3RoaXMubWVhc3VyZXNbZmllbGRdKS5mb3JFYWNoKGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgICAgIG91dFtvcCArIFwiX1wiICsgZmllbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIEFnZ3JlZ2F0ZU5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgb3BzID0gW107XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgdXRpbF8xLmtleXModGhpcy5tZWFzdXJlcykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHV0aWxfMS5rZXlzKF90aGlzLm1lYXN1cmVzW2ZpZWxkXSkuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgICAgICBncm91cGJ5OiB1dGlsXzEua2V5cyh0aGlzLmRpbWVuc2lvbnMpLFxuICAgICAgICAgICAgb3BzOiBvcHMsXG4gICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEFnZ3JlZ2F0ZU5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLkFnZ3JlZ2F0ZU5vZGUgPSBBZ2dyZWdhdGVOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVdkbmNtVm5ZWFJsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdlpHRjBZUzloWjJkeVpXZGhkR1V1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRMEVzTWtOQlFTdERPMEZCUXk5RExDdENRVUZwUXp0QlFVTnFReXh0UTBGQk5FVTdRVUZITlVVc2RVTkJRWGRETzBGQlJYaERMSE5DUVVGelFpeEpRVUZuUXl4RlFVRkZMRkZCUVd0Q08wbEJRM2hGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycENMRWxCUVVrc1EwRkJReXhuUWtGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4RlFVRkRMRk5CUVZNc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1RUxFbEJRVWtzUTBGQlF5eG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVWQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJSV3BFTEhORFFVRnpRenRSUVVOMFF5eHBSa0ZCYVVZN1VVRkRha1lzSzBSQlFTdEVPMUZCUXk5RUxFbEJRVWtzUTBGQlF5eG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeFBRVUZQTEVWQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRMjVFTEVsQlFVazdTVUZEVGl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEpRVUZKTEVOQlFVTXNaMEpCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTXZRaXhEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRkZSQ3gxUWtGQmRVSXNZMEZCYlVNc1JVRkJSU3hoUVVGclF6dEpRVU0xUml4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGTkxFOUJRVXNzU1VGQlNTeGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4RExFVkJRVVVzUTBGQlF5eERRVUZETEdGQlFXRXNRMEZCUXl4alFVRmpMRU5CUVVNc1QwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaERMRFpHUVVFMlJqdFpRVU0zUml4SlFVRk5MRWRCUVVjc1IwRkJSeXhoUVVGaExFTkJRVU1zVDBGQlN5eERRVUZETEVOQlFVTTdXVUZEYWtNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlRTeEZRVUZGTEVsQlFVa3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExHTkJRV01zUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRek5DTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVVzc1NVRkJTU3hqUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzNkQ1FVTTFRaXg1UTBGQmVVTTdkMEpCUTNwRExHTkJRV01zUTBGQlF5eFBRVUZMTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1IwRkJSeXhKUVVGSkxFTkJRVU03YjBKQlEyNURMRU5CUVVNN2IwSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdkMEpCUTA0c1kwRkJZeXhEUVVGRExFOUJRVXNzUTBGQlF5eEhRVUZITEVWQlFVTXNSVUZCUlN4RlFVRkZMRWxCUVVrc1JVRkJReXhEUVVGRE8yOUNRVU55UXl4RFFVRkRPMmRDUVVOSUxFTkJRVU03V1VGRFNDeERRVUZETzFGQlEwZ3NRMEZCUXp0SlFVTklMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVE3U1VGQmJVTXNlVU5CUVZrN1NVRkxOME03T3p0UFFVZEhPMGxCUTBnc2RVSkJRVzlDTEZWQlFYRkNMRVZCUVZVc1VVRkJlVUk3VVVGQk5VVXNXVUZEUlN4cFFrRkJUeXhUUVVOU08xRkJSbTFDTEdkQ1FVRlZMRWRCUVZZc1ZVRkJWU3hEUVVGWE8xRkJRVlVzWTBGQlVTeEhRVUZTTEZGQlFWRXNRMEZCYVVJN08wbEJSVFZGTEVOQlFVTTdTVUZXVFN3MlFrRkJTeXhIUVVGYU8xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NZVUZCWVN4RFFVRkRMR0ZCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzU1VGQlNTeERRVUZETEZWQlFWVXNRMEZCUXl4RlFVRkZMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRiRVlzUTBGQlF6dEpRVlZoTEd0Q1FVRkpMRWRCUVd4Q0xGVkJRVzFDTEV0QlFWazdVVUZETjBJc1NVRkJTU3hYUVVGWExFZEJRVWNzUzBGQlN5eERRVUZETzFGQlEzaENMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zVlVGQlFTeEZRVUZGTzFsQlEzUkNMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOcVFpeFhRVUZYTEVkQlFVY3NTVUZCU1N4RFFVRkRPMWxCUTNKQ0xFTkJRVU03VVVGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRWxCUVUwc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGQlF6dFJRVU5vUWl4SlFVRk5MRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRmFFSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycENMRGhFUVVFNFJEdFpRVU01UkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVVZFTEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1ZVRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR6dFpRVU4wUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRka0lzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRk5CUVZNc1MwRkJTeXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTnVReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dHZRa0ZETlVJc2MwTkJRWE5ETzI5Q1FVTjBReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8yOUNRVU14UWl4eFEwRkJjVU03WjBKQlEzWkRMRU5CUVVNN1owSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdiMEpCUTA0c1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXp0dlFrRkRiRVFzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zVTBGQlV5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMjlDUVVWb1JDd3JSRUZCSzBRN2IwSkJReTlFTEVsQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdiMEpCUTI1RExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4TFFVRkxMRU5CUVVNc1RVRkJUU3hMUVVGTExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUXpkRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzNkQ1FVTnVReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF6dHZRa0ZEY2tNc1EwRkJRenRuUWtGRFNDeERRVUZETzFsQlEwZ3NRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5PTEZsQlFWa3NRMEZCUXl4SlFVRkpMRVZCUVVVc1VVRkJVU3hEUVVGRExFTkJRVU03V1VGREwwSXNRMEZCUXp0UlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVOa0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4aFFVRmhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzBsQlEzWkRMRU5CUVVNN1NVRkZUU3cyUWtGQlN5eEhRVUZhTEZWQlFXRXNTMEZCYjBJN1VVRkRMMElzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4aFFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGVkJRVlVzUlVGQlJTeExRVUZMTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJReTlETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0WlFVTTNReXhMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdVVUZEYWtJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXh2UTBGQmIwTXNRMEZCUXl4RFFVRkRPMUZCUTJ4RUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVMHNjVU5CUVdFc1IwRkJjRUlzVlVGQmNVSXNUVUZCWjBJN1VVRkJja01zYVVKQlJVTTdVVUZFUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVUVzUTBGQlF5eEpRVUZKTEU5QlFVRXNTMEZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFYcENMRU5CUVhsQ0xFTkJRVU1zUTBGQlF6dEpRVU5xUkN4RFFVRkRPMGxCUlUwc2RVTkJRV1VzUjBGQmRFSTdVVUZEUlN4SlFVRk5MRWRCUVVjc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRlppeFhRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEVOQlFVTXNTVUZCU1N4UFFVRkJMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVWQlFXSXNRMEZCWVN4RFFVRkRMRU5CUVVNN1VVRkRiRVFzVjBGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeEZRVUZpTEVOQlFXRXNRMEZCUXl4RFFVRkRPMUZCUldoRUxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdTVUZEWWl4RFFVRkRPMGxCUlUwc2MwTkJRV01zUjBGQmNrSTdVVUZCUVN4cFFrRlZRenRSUVZSRExFbEJRVTBzUjBGQlJ5eEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVm1MRmRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1MwRkJTenRaUVVNdlFpeFhRVUZKTEVOQlFVTXNTMEZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRVZCUVVVN1owSkJRMjVETEVkQlFVY3NRMEZCU1N4RlFVRkZMRk5CUVVrc1MwRkJUeXhEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETzFsQlF5OUNMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMHdzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZGU0N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRE8wbEJRMklzUTBGQlF6dEpRVVZOTEdkRFFVRlJMRWRCUVdZN1VVRkJRU3hwUWtGblFrTTdVVUZtUXl4SlFVRk5MRWRCUVVjc1IwRkJZU3hGUVVGRkxFTkJRVU03VVVGRGVrSXNTVUZCVFN4TlFVRk5MRWRCUVdFc1JVRkJSU3hEUVVGRE8xRkJRelZDTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNTMEZCU3p0WlFVTXZRaXhYUVVGSkxFTkJRVU1zUzBGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEVWQlFVVTdaMEpCUTI1RExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRMklzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVOeVFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTk1MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETzFsQlEwd3NTVUZCU1N4RlFVRkZMRmRCUVZjN1dVRkRha0lzVDBGQlR5eEZRVUZGTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRE8xbEJRemxDTEVkQlFVY3NTMEZCUVR0WlFVTklMRTFCUVUwc1VVRkJRVHRUUVVOUUxFTkJRVU03U1VGRFNpeERRVUZETzBsQlEwZ3NiMEpCUVVNN1FVRkJSQ3hEUVVGRExFRkJPVWRFTEVOQlFXMURMSFZDUVVGWkxFZEJPRWM1UXp0QlFUbEhXU3h6UTBGQllTSjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBhZ2dyZWdhdGVfMSA9IHJlcXVpcmUoXCIuL2FnZ3JlZ2F0ZVwiKTtcbnZhciBiaW5fMSA9IHJlcXVpcmUoXCIuL2JpblwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG52YXIgZmFjZXRfMSA9IHJlcXVpcmUoXCIuL2ZhY2V0XCIpO1xudmFyIGZvcm1hdHBhcnNlXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRwYXJzZVwiKTtcbnZhciBub25wb3NpdGl2ZWZpbHRlcl8xID0gcmVxdWlyZShcIi4vbm9ucG9zaXRpdmVmaWx0ZXJcIik7XG52YXIgbnVsbGZpbHRlcl8xID0gcmVxdWlyZShcIi4vbnVsbGZpbHRlclwiKTtcbnZhciBvcHRpbWl6ZXJzXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzXCIpO1xudmFyIG9wdGltaXplcnMgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzXCIpO1xudmFyIHBhdGhvcmRlcl8xID0gcmVxdWlyZShcIi4vcGF0aG9yZGVyXCIpO1xudmFyIHNvdXJjZV8xID0gcmVxdWlyZShcIi4vc291cmNlXCIpO1xudmFyIHN0YWNrXzEgPSByZXF1aXJlKFwiLi9zdGFja1wiKTtcbnZhciB0aW1ldW5pdF8xID0gcmVxdWlyZShcIi4vdGltZXVuaXRcIik7XG52YXIgdHJhbnNmb3Jtc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3Jtc1wiKTtcbmV4cG9ydHMuRkFDRVRfU0NBTEVfUFJFRklYID0gJ3NjYWxlXyc7XG4vKipcbiAqIFN0YXJ0IG9wdGltaXphdGlvbiBwYXRoIGZyb20gdGhlIHJvb3QuIFVzZWZ1bCBmb3IgcmVtb3Zpbmcgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVVubmVjZXNzYXJ5Tm9kZXMobm9kZSkge1xuICAgIC8vIHJlbW92ZSBlbXB0eSBub24gcG9zaXRpdmUgZmlsdGVyXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub25wb3NpdGl2ZWZpbHRlcl8xLk5vblBvc2l0aXZlRmlsdGVyTm9kZSAmJiB1dGlsXzEuZXZlcnkodXRpbF8xLnZhbHMobm9kZS5maWx0ZXIpLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gYiA9PT0gZmFsc2U7IH0pKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBlbXB0eSBudWxsIGZpbHRlciBub2Rlc1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgbnVsbGZpbHRlcl8xLk51bGxGaWx0ZXJOb2RlICYmIHV0aWxfMS5ldmVyeSh1dGlsXzEudmFscyhub2RlLmZpbHRlcmVkRmllbGRzKSwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgPT09IG51bGw7IH0pKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBvdXRwdXQgbm9kZXMgdGhhdCBhcmUgbm90IHJlcXVpcmVkXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUgJiYgIW5vZGUucmVxdWlyZWQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHJlbW92ZVVubmVjZXNzYXJ5Tm9kZXMpO1xufVxuLyoqXG4gKiBDbG9uZXMgdGhlIHN1YnRyZWUgYW5kIGlnbm9yZXMgb3V0cHV0IG5vZGVzIGV4Y2VwdCBmb3IgdGhlIGxlYWZzLCB3aGljaCBhcmUgcmVuYW1lZC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTdWJ0cmVlKGZhY2V0KSB7XG4gICAgZnVuY3Rpb24gY2xvbmUobm9kZSkge1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgcGF0aG9yZGVyXzEuT3JkZXJOb2RlKSkge1xuICAgICAgICAgICAgdmFyIGNvcHlfMSA9IG5vZGUuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmIChjb3B5XzEgaW5zdGFuY2VvZiBkYXRhZmxvd18xLk91dHB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IGV4cG9ydHMuRkFDRVRfU0NBTEVfUFJFRklYICsgZmFjZXQubW9kZWwuZ2V0TmFtZShjb3B5XzEuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb3B5XzEuc291cmNlID0gbmV3TmFtZTtcbiAgICAgICAgICAgICAgICBmYWNldC5tb2RlbC5jb21wb25lbnQuZGF0YS5vdXRwdXROb2Rlc1tuZXdOYW1lXSA9IGNvcHlfMTtcbiAgICAgICAgICAgICAgICB1dGlsXzEuZmxhdHRlbihub2RlLmNoaWxkcmVuLm1hcChjbG9uZSkpLmZvckVhY2goZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4ucGFyZW50ID0gY29weV8xOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvcHlfMSBpbnN0YW5jZW9mIGFnZ3JlZ2F0ZV8xLkFnZ3JlZ2F0ZU5vZGUgfHwgY29weV8xIGluc3RhbmNlb2Ygc3RhY2tfMS5TdGFja05vZGUpIHtcbiAgICAgICAgICAgICAgICBjb3B5XzEuYWRkRGltZW5zaW9ucyhmYWNldC5maWVsZHMpO1xuICAgICAgICAgICAgICAgIHV0aWxfMS5mbGF0dGVuKG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lKSkuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gbi5wYXJlbnQgPSBjb3B5XzE7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmZsYXR0ZW4obm9kZS5jaGlsZHJlbi5tYXAoY2xvbmUpKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnBhcmVudCA9IGNvcHlfMTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW2NvcHlfMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxfMS5mbGF0dGVuKG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogTW92ZSBmYWNldCBub2RlcyBkb3duIHRvIHRoZSBuZXh0IGZvcmsgb3Igb3V0cHV0IG5vZGUuIEFsc28gcHVsbCB0aGUgbWFpbiBvdXRwdXQgd2l0aCB0aGUgZmFjZXQgbm9kZS5cbiAqIEFmdGVyIG1vdmluZyBkb3duIHRoZSBmYWNldCBub2RlLCBtYWtlIGEgY29weSBvZiB0aGUgc3VidHJlZSBhbmQgbWFrZSBpdCBhIGNoaWxkIG9mIHRoZSBtYWluIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gbW92ZUZhY2V0RG93bihub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBmYWNldF8xLkZhY2V0Tm9kZSkge1xuICAgICAgICBpZiAobm9kZS5udW1DaGlsZHJlbigpID09PSAxICYmICEobm9kZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIGRhdGFmbG93XzEuT3V0cHV0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIG1vdmUgZG93biB1bnRpbCB3ZSBoaXQgYSBmb3JrIG9yIG91dHB1dCBub2RlXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgYWdncmVnYXRlXzEuQWdncmVnYXRlTm9kZSB8fCBjaGlsZCBpbnN0YW5jZW9mIHN0YWNrXzEuU3RhY2tOb2RlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWRkRGltZW5zaW9ucyhub2RlLmZpZWxkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5zd2FwV2l0aFBhcmVudCgpO1xuICAgICAgICAgICAgbW92ZUZhY2V0RG93bihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1vdmUgbWFpbiB0byBmYWNldFxuICAgICAgICAgICAgbW92ZU1haW5Eb3duVG9GYWNldChub2RlLm1vZGVsLmNvbXBvbmVudC5kYXRhLm1haW4pO1xuICAgICAgICAgICAgLy8gcmVwbGljYXRlIHRoZSBzdWJ0cmVlIGFuZCBwbGFjZSBpdCBiZWZvcmUgdGhlIGZhY2V0J3MgbWFpbiBub2RlXG4gICAgICAgICAgICB2YXIgY29weSA9IHV0aWxfMS5mbGF0dGVuKG5vZGUuY2hpbGRyZW4ubWFwKGNsb25lU3VidHJlZShub2RlKSkpO1xuICAgICAgICAgICAgY29weS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnBhcmVudCA9IG5vZGUubW9kZWwuY29tcG9uZW50LmRhdGEubWFpbjsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChtb3ZlRmFjZXREb3duKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtb3ZlTWFpbkRvd25Ub0ZhY2V0KG5vZGUpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGRhdGFmbG93XzEuT3V0cHV0Tm9kZSAmJiBub2RlLnR5cGUgPT09IGRhdGFfMS5NQUlOKSB7XG4gICAgICAgIGlmIChub2RlLm51bUNoaWxkcmVuKCkgPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIGZhY2V0XzEuRmFjZXROb2RlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnN3YXBXaXRoUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgbW92ZU1haW5Eb3duVG9GYWNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIGFsbCBsZWFmIG5vZGVzLlxuICovXG5mdW5jdGlvbiBnZXRMZWF2ZXMocm9vdHMpIHtcbiAgICB2YXIgbGVhdmVzID0gW107XG4gICAgZnVuY3Rpb24gYXBwZW5kKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubnVtQ2hpbGRyZW4oKSA9PT0gMCkge1xuICAgICAgICAgICAgbGVhdmVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goYXBwZW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByb290cy5mb3JFYWNoKGFwcGVuZCk7XG4gICAgcmV0dXJuIGxlYXZlcztcbn1cbi8qKlxuICogUHJpbnQgZGVidWcgaW5mb3JtYXRpb24gZm9yIGRhdGFmbG93IHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGRlYnVnKG5vZGUpIHtcbiAgICBjb25zb2xlLmxvZyhcIlwiICsgbm9kZS5jb25zdHJ1Y3Rvci5uYW1lICsgKG5vZGUuZGVidWdOYW1lID8gXCIgKFwiICsgbm9kZS5kZWJ1Z05hbWUgKyBcIilcIiA6ICcnKSArIFwiIC0+IFwiICsgKG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgYy5jb25zdHJ1Y3Rvci5uYW1lICsgKGMuZGVidWdOYW1lID8gXCIgKFwiICsgYy5kZWJ1Z05hbWUgKyBcIilcIiA6ICcnKTtcbiAgICB9KSkpO1xuICAgIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChkZWJ1Zyk7XG59XG5mdW5jdGlvbiBtYWtlV2Fsa1RyZWUoZGF0YSkge1xuICAgIC8vIHRvIG5hbWUgZGF0YXNvdXJjZXNcbiAgICB2YXIgZGF0YXNldEluZGV4ID0gMDtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIGRvd24gdGhlIHRyZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2Fsa1RyZWUobm9kZSwgZGF0YVNvdXJjZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGZvcm1hdHBhcnNlXzEuUGFyc2VOb2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgaW5zdGFuY2VvZiBzb3VyY2VfMS5Tb3VyY2VOb2RlICYmIGRhdGFTb3VyY2UuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5mb3JtYXQucGFyc2UgPSBub2RlLmFzc2VtYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGluc3RhbnRpYXRlIHBhcnNlIG5leHQgdG8gc291cmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZmFjZXRfMS5GYWNldE5vZGUpIHtcbiAgICAgICAgICAgIGlmICghZGF0YVNvdXJjZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5uYW1lID0gXCJkYXRhX1wiICsgZGF0YXNldEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFTb3VyY2Uuc291cmNlIHx8IGRhdGFTb3VyY2UudHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVNvdXJjZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVNvdXJjZS5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmFzc2VtYmxlKCkuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZGF0YS5wdXNoKGQpOyB9KTtcbiAgICAgICAgICAgIC8vIGJyZWFrIGhlcmUgYmVjYXVzZSB0aGUgcmVzdCBvZiB0aGUgdHJlZSBoYXMgdG8gYmUgdGFrZW4gY2FyZSBvZiBieSB0aGUgZmFjZXQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiB0cmFuc2Zvcm1zXzEuRmlsdGVyTm9kZSB8fFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIG51bGxmaWx0ZXJfMS5OdWxsRmlsdGVyTm9kZSB8fFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIHRyYW5zZm9ybXNfMS5DYWxjdWxhdGVOb2RlIHx8XG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgYWdncmVnYXRlXzEuQWdncmVnYXRlTm9kZSB8fFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIHBhdGhvcmRlcl8xLk9yZGVyTm9kZSkge1xuICAgICAgICAgICAgZGF0YVNvdXJjZS50cmFuc2Zvcm0ucHVzaChub2RlLmFzc2VtYmxlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9ucG9zaXRpdmVmaWx0ZXJfMS5Ob25Qb3NpdGl2ZUZpbHRlck5vZGUgfHxcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBiaW5fMS5CaW5Ob2RlIHx8XG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgdGltZXVuaXRfMS5UaW1lVW5pdE5vZGUgfHxcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBzdGFja18xLlN0YWNrTm9kZSkge1xuICAgICAgICAgICAgZGF0YVNvdXJjZS50cmFuc2Zvcm0gPSBkYXRhU291cmNlLnRyYW5zZm9ybS5jb25jYXQobm9kZS5hc3NlbWJsZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGRhdGFmbG93XzEuT3V0cHV0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2Uuc291cmNlICYmIGRhdGFTb3VyY2UudHJhbnNmb3JtLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc291cmNlID0gZGF0YVNvdXJjZS5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudCBpbnN0YW5jZW9mIGRhdGFmbG93XzEuT3V0cHV0Tm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhbiBvdXRwdXQgbm9kZSBtYXkgYmUgcmVxdWlyZWQgYnV0IHdlIHN0aWxsIGRvIG5vdCBhc3NlbWJsZSBhXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgZGF0YSBzb3VyY2UgZm9yIGl0LlxuICAgICAgICAgICAgICAgIG5vZGUuc291cmNlID0gZGF0YVNvdXJjZS5uYW1lO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGhhcHBlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhU291cmNlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5uYW1lID0gXCJkYXRhX1wiICsgZGF0YXNldEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhlcmUgd2Ugc2V0IHRoZSBuYW1lIG9mIHRoZSBkYXRhc291cmNlIHdlIGdlbmVyYXRlZC4gRnJvbSBub3cgb25cbiAgICAgICAgICAgICAgICAvLyBvdGhlciBhc3NlbWJsZXJzIGNhbiB1c2UgaXQuXG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2UgPSBkYXRhU291cmNlLm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBub2RlIGhhcyBtb3JlIHRoYW4gb25lIGNoaWxkLCB3ZSB3aWxsIGFkZCBhIGRhdGFzb3VyY2UgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgIGlmIChub2RlLm51bUNoaWxkcmVuKCkgPT09IDEgJiYgZGF0YVNvdXJjZS50cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZGF0YVNvdXJjZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gbmV3RGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChub2RlLm51bUNoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAvLyBkb25lXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhU291cmNlLnNvdXJjZSB8fCBkYXRhU291cmNlLnRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBwdXNoIGVtcHR5IGRhdGFzb3VyY2VzIHRoYXQgYXJlIHNpbXBseSByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgd2Fsa1RyZWUobm9kZS5jaGlsZHJlblswXSwgZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VfMiA9IGRhdGFTb3VyY2UubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFTb3VyY2Uuc291cmNlIHx8IGRhdGFTb3VyY2UudHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlXzIgPSBkYXRhU291cmNlLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZV8yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBbXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB3YWxrVHJlZShjaGlsZCwgbmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdhbGtUcmVlO1xufVxuLyoqXG4gKiBBc3NlbWJsZSBkYXRhIHNvdXJjZXMgdGhhdCBhcmUgZGVyaXZlZCBmcm9tIGZhY2V0ZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYXNzZW1ibGVGYWNldERhdGEocm9vdCkge1xuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHdhbGtUcmVlID0gbWFrZVdhbGtUcmVlKGRhdGEpO1xuICAgIHJvb3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIHdhbGtUcmVlKGNoaWxkLCB7XG4gICAgICAgIHNvdXJjZTogcm9vdC5uYW1lLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICB0cmFuc2Zvcm06IFtdXG4gICAgfSk7IH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy5hc3NlbWJsZUZhY2V0RGF0YSA9IGFzc2VtYmxlRmFjZXREYXRhO1xuLyoqXG4gKiBDcmVhdGUgVmVnYSBEYXRhIGFycmF5IGZyb20gYSBnaXZlbiBjb21waWxlZCBtb2RlbCBhbmQgYXBwZW5kIGFsbCBvZiB0aGVtIHRvIHRoZSBnaXZlbiBhcnJheVxuICpcbiAqIEBwYXJhbSAgbW9kZWxcbiAqIEBwYXJhbSAgZGF0YSBhcnJheVxuICogQHJldHVybiBtb2RpZmllZCBkYXRhIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlRGF0YShyb290cykge1xuICAgIHZhciBkYXRhID0gW107XG4gICAgcm9vdHMuZm9yRWFjaChyZW1vdmVVbm5lY2Vzc2FyeU5vZGVzKTtcbiAgICAvLyBwYXJzZSBuZWVkcyB0byBiZSBuZXh0IHRvIHNvdXJjZXNcbiAgICBnZXRMZWF2ZXMocm9vdHMpLmZvckVhY2gob3B0aW1pemVyc18xLm9wdGltaXplRnJvbUxlYXZlcyhvcHRpbWl6ZXJzLnBhcnNlKSk7XG4gICAgcm9vdHMuZm9yRWFjaChtb3ZlRmFjZXREb3duKTtcbiAgICAvLyByb290cy5mb3JFYWNoKGRlYnVnKTtcbiAgICB2YXIgd2Fsa1RyZWUgPSBtYWtlV2Fsa1RyZWUoZGF0YSk7XG4gICAgdmFyIHNvdXJjZUluZGV4ID0gMDtcbiAgICByb290cy5mb3JFYWNoKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICAgIC8vIGFzc2lnbiBhIG5hbWUgaWYgdGhlIHNvdXJjZSBkb2VzIG5vdCBoYXZlIGEgbmFtZSB5ZXRcbiAgICAgICAgaWYgKCFyb290Lmhhc05hbWUoKSkge1xuICAgICAgICAgICAgcm9vdC5kYXRhTmFtZSA9IFwic291cmNlX1wiICsgc291cmNlSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3RGF0YSA9IHJvb3QuYXNzZW1ibGUoKTtcbiAgICAgICAgd2Fsa1RyZWUocm9vdCwgbmV3RGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmFzc2VtYmxlRGF0YSA9IGFzc2VtYmxlRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYTnpaVzFpYkdVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDJGemMyVnRZbXhsTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzYlVOQlFXZERPMEZCUldoRExHMURRVUZuUkR0QlFVZG9SQ3g1UTBGQk1FTTdRVUZETVVNc05rSkJRVGhDTzBGQlF6bENMSFZEUVVGdlJEdEJRVU53UkN4cFEwRkJhME03UVVGRGJFTXNOa05CUVhkRE8wRkJRM2hETEhsRVFVRXdSRHRCUVVNeFJDd3lRMEZCTkVNN1FVRkROVU1zTWtOQlFXZEVPMEZCUTJoRUxIbERRVUV5UXp0QlFVTXpReXg1UTBGQmMwTTdRVUZEZEVNc2JVTkJRVzlETzBGQlEzQkRMR2xEUVVGclF6dEJRVU5zUXl4MVEwRkJkME03UVVGRGVFTXNNa05CUVhWRU8wRkJSekZETEZGQlFVRXNhMEpCUVd0Q0xFZEJRVWNzVVVGQlVTeERRVUZETzBGQlJUTkRPenRIUVVWSE8wRkJRMGdzWjBOQlFXZERMRWxCUVd0Q08wbEJRMmhFTEcxRFFVRnRRenRKUVVOdVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRmxCUVZrc2VVTkJRWEZDTEVsQlFVa3NXVUZCU3l4RFFVRkRMRmRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJRU3hEUVVGRExFdEJRVXNzUzBGQlN5eEZRVUZZTEVOQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFJpeEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFTEdsRFFVRnBRenRKUVVOcVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRmxCUVZrc01rSkJRV01zU1VGQlNTeFpRVUZMTEVOQlFVTXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhqUVVGakxFTkJRVU1zUlVGQlJTeFZRVUZCTEVOQlFVTXNTVUZCU1N4UFFVRkJMRU5CUVVNc1MwRkJTeXhKUVVGSkxFVkJRVllzUTBGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNoR0xFbEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0SlFVTm9RaXhEUVVGRE8wbEJSVVFzTkVOQlFUUkRPMGxCUXpWRExFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NXVUZCV1N4eFFrRkJWU3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha1FzU1VGQlNTeERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGRlJDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXh6UWtGQmMwSXNRMEZCUXl4RFFVRkRPMEZCUTJoRUxFTkJRVU03UVVGRlJEczdSMEZGUnp0QlFVTklMSE5DUVVGelFpeExRVUZuUWp0SlFVTndReXhsUVVGbExFbEJRV3RDTzFGQlF5OUNMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEZsQlFWa3NjVUpCUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUXl4SlFVRk5MRTFCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTTdXVUZGTVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlNTeFpRVUZaTEhGQ1FVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU12UWl4SlFVRk5MRTlCUVU4c1IwRkJSeXd3UWtGQmEwSXNSMEZCUnl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN1owSkJRM1JGTEUxQlFVa3NRMEZCUXl4TlFVRk5MRWRCUVVjc1QwRkJUeXhEUVVGRE8yZENRVVYwUWl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhIUVVGSExFMUJRVWtzUTBGQlF6dG5Ra0ZGZGtRc1kwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVTXNRMEZCWlN4SlFVRkxMRTlCUVVFc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZKTEVWQlFXWXNRMEZCWlN4RFFVRkRMRU5CUVVNN1dVRkRiRVlzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGSkxGbEJRVmtzZVVKQlFXRXNTVUZCU1N4TlFVRkpMRmxCUVZrc2FVSkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNSRkxFMUJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVVZxUXl4alFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlF5eERRVUZsTEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVWtzUlVGQlppeERRVUZsTEVOQlFVTXNRMEZCUXp0WlFVTnNSaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTA0c1kwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVTXNRMEZCWlN4SlFVRkxMRTlCUVVFc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZKTEVWQlFXWXNRMEZCWlN4RFFVRkRMRU5CUVVNN1dVRkRiRVlzUTBGQlF6dFpRVVZFTEUxQlFVMHNRMEZCUXl4RFFVRkRMRTFCUVVrc1EwRkJReXhEUVVGRE8xRkJRMmhDTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1kwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE0wTXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQlJVUTdPenRIUVVkSE8wRkJRMGdzZFVKQlFYVkNMRWxCUVd0Q08wbEJRM1pETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1dVRkJXU3hwUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTVRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RlFVRkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhaUVVGWkxIRkNRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNVVVzSzBOQlFTdERPMWxCUlM5RExFbEJRVTBzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRkwwSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhaUVVGWkxIbENRVUZoTEVsQlFVa3NTMEZCU3l4WlFVRlpMR2xDUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnFSU3hMUVVGTExFTkJRVU1zWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETzFsQlJVUXNTMEZCU3l4RFFVRkRMR05CUVdNc1JVRkJSU3hEUVVGRE8xbEJRM1pDTEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOMFFpeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXh4UWtGQmNVSTdXVUZEY2tJc2JVSkJRVzFDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUlhCRUxHdEZRVUZyUlR0WlFVTnNSU3hKUVVGTkxFbEJRVWtzUjBGQmJVSXNZMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE5VVXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFTkJRVU1zU1VGQlNTeFBRVUZCTEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1JVRkJla01zUTBGQmVVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4aFFVRmhMRU5CUVVNc1EwRkJRenRKUVVOMlF5eERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVVkVMRFpDUVVFMlFpeEpRVUZyUWp0SlFVTTNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEZsQlFWa3NjVUpCUVZVc1NVRkJTU3hKUVVGSkxFTkJRVU1zU1VGQlNTeExRVUZMTEZkQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRja1FzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1JVRkJSU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBJc1NVRkJUU3hMUVVGTExFZEJRVWNzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVVdlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhaUVVGWkxHbENRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnhETEV0QlFVc3NRMEZCUXl4alFVRmpMRVZCUVVVc1EwRkJRenRuUWtGRGRrSXNiVUpCUVcxQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZETlVJc1EwRkJRenRSUVVOSUxFTkJRVU03U1VGRFNDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVZEVPenRIUVVWSE8wRkJRMGdzYlVKQlFXMUNMRXRCUVhGQ08wbEJRM1JETEVsQlFVMHNUVUZCVFN4SFFVRnRRaXhGUVVGRkxFTkJRVU03U1VGRGJFTXNaMEpCUVdkQ0xFbEJRV3RDTzFGQlEyaERMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemRDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGNFSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03VVVGRGFFTXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUTNSQ0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdRVUZEYUVJc1EwRkJRenRCUVVWRU96dEhRVVZITzBGQlEwZ3NaVUZCWlN4SlFVRnJRanRKUVVNdlFpeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRXRCUVVrc1NVRkJTU3hEUVVGRExGZEJRVzFDTEVOQlFVTXNTVUZCU1N4SlFVRkhMRWxCUVVrc1EwRkJReXhUUVVGVExFZEJRVWNzVDBGQlN5eEpRVUZKTEVOQlFVTXNVMEZCVXl4TlFVRkhMRWRCUVVjc1JVRkJSU3hoUVVNeFJpeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVUVzUTBGQlF6dFJRVU5zUWl4TlFVRk5MRU5CUVVNc1MwRkJTU3hEUVVGRExFTkJRVU1zVjBGQmJVSXNRMEZCUXl4SlFVRkpMRWxCUVVjc1EwRkJReXhEUVVGRExGTkJRVk1zUjBGQlJ5eFBRVUZMTEVOQlFVTXNRMEZCUXl4VFFVRlRMRTFCUVVjc1IwRkJSeXhGUVVGRkxFTkJRVVVzUTBGQlF6dEpRVU51Uml4RFFVRkRMRU5CUVVNc1EwRkRSaXhEUVVGRExFTkJRVU03U1VGRFNpeFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRMnhDTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBGQlF5OUNMRU5CUVVNN1FVRkZSQ3h6UWtGQmMwSXNTVUZCWXp0SlFVTnNReXh6UWtGQmMwSTdTVUZEZEVJc1NVRkJTU3haUVVGWkxFZEJRVWNzUTBGQlF5eERRVUZETzBsQlJYSkNPenRQUVVWSE8wbEJRMGdzYTBKQlFXdENMRWxCUVd0Q0xFVkJRVVVzVlVGQmEwSTdVVUZEZEVRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeFpRVUZaTEhWQ1FVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxGbEJRVmtzYlVKQlFWVXNTVUZCU1N4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETTBRc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hEUVVGRE8xbEJRelZETEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRFJEUVVFMFF5eERRVUZETEVOQlFVTTdXVUZEYUVVc1EwRkJRenRSUVVOSUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRmxCUVZrc2FVSkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrSXNWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhWUVVGUkxGbEJRVmtzUlVGQlNTeERRVUZETzFsQlF6ZERMRU5CUVVNN1dVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRWxCUVVrc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE1VUXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVJc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RFFVRkRPMWxCUXpsQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRUaXhKUVVGSkxFTkJRVU1zU1VGQlNTeEhRVUZITEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNN1dVRkRhRU1zUTBGQlF6dFpRVVZFTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eEZRVUZhTEVOQlFWa3NRMEZCUXl4RFFVRkRPMWxCUlRORExHZEdRVUZuUmp0WlFVTm9SaXhOUVVGTkxFTkJRVU03VVVGRFZDeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3haUVVGWkxIVkNRVUZWTzFsQlF6VkNMRWxCUVVrc1dVRkJXU3d5UWtGQll6dFpRVU01UWl4SlFVRkpMRmxCUVZrc01FSkJRV0U3V1VGRE4wSXNTVUZCU1N4WlFVRlpMSGxDUVVGaE8xbEJRemRDTEVsQlFVa3NXVUZCV1N4eFFrRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0xUWl4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVNM1F5eERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3haUVVGWkxIbERRVUZ4UWp0WlFVTjJReXhKUVVGSkxGbEJRVmtzWVVGQlR6dFpRVU4yUWl4SlFVRkpMRmxCUVZrc2RVSkJRVms3V1VGRE5VSXNTVUZCU1N4WlFVRlpMR2xDUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkNMRlZCUVZVc1EwRkJReXhUUVVGVExFZEJRVWNzVlVGQlZTeERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdVVUZEZEVVc1EwRkJRenRSUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NXVUZCV1N4eFFrRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU12UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zVFVGQlRTeEpRVUZKTEZWQlFWVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpORUxFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NWVUZCVlN4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVOc1F5eERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEZsQlFWa3NjVUpCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6ZERMREJGUVVFd1JUdG5Ra0ZETVVVc0swSkJRU3RDTzJkQ1FVTXZRaXhKUVVGSkxFTkJRVU1zVFVGQlRTeEhRVUZITEZWQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNN1owSkJRemxDTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU03V1VGRGJrTXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5PTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNKQ0xGVkJRVlVzUTBGQlF5eEpRVUZKTEVkQlFVY3NWVUZCVVN4WlFVRlpMRVZCUVVrc1EwRkJRenRuUWtGRE4wTXNRMEZCUXp0blFrRkZSQ3h0UlVGQmJVVTdaMEpCUTI1RkxDdENRVUVyUWp0blFrRkRMMElzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4VlFVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRE8yZENRVVU1UWl3clJVRkJLMFU3WjBKQlF5OUZMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVWQlFVVXNTMEZCU3l4RFFVRkRMRWxCUVVrc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGFFVXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dHZRa0ZEZEVJc1NVRkJUU3hQUVVGUExFZEJRVmM3ZDBKQlEzUkNMRWxCUVVrc1JVRkJSU3hKUVVGSk8zZENRVU5XTEUxQlFVMHNSVUZCUlN4VlFVRlZMRU5CUVVNc1NVRkJTVHQzUWtGRGRrSXNVMEZCVXl4RlFVRkZMRVZCUVVVN2NVSkJRMlFzUTBGQlF6dHZRa0ZEUml4VlFVRlZMRWRCUVVjc1QwRkJUeXhEUVVGRE8yZENRVU4yUWl4RFFVRkRPMWxCUTBnc1EwRkJRenRSUVVOSUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkNMRXRCUVVzc1EwRkJRenRuUWtGRFNpeFBRVUZQTzJkQ1FVTlFMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNTVUZCU1N4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVNeFJDd3lSRUZCTWtRN2IwSkJRek5FTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU03WjBKQlEzaENMRU5CUVVNN1owSkJRMFFzUzBGQlN5eERRVUZETzFsQlExSXNTMEZCU3l4RFFVRkRPMmRDUVVOS0xGRkJRVkVzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzJkQ1FVTjJReXhMUVVGTExFTkJRVU03V1VGRFVqdG5Ra0ZEUlN4SlFVRkpMRkZCUVUwc1IwRkJSeXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVTTNRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRWxCUVVrc1ZVRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE1VUXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVJc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRUaXhSUVVGTkxFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXp0blFrRkROMElzUTBGQlF6dG5Ra0ZGUkN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZCTEV0QlFVczdiMEpCUTNwQ0xFbEJRVTBzVDBGQlR5eEhRVUZYTzNkQ1FVTjBRaXhKUVVGSkxFVkJRVVVzU1VGQlNUdDNRa0ZEVml4TlFVRk5MRVZCUVVVc1VVRkJUVHQzUWtGRFpDeFRRVUZUTEVWQlFVVXNSVUZCUlR0eFFrRkRaQ3hEUVVGRE8yOUNRVU5HTEZGQlFWRXNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03WjBKQlF6TkNMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5JTEV0QlFVc3NRMEZCUXp0UlFVTldMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXp0QlFVTnNRaXhEUVVGRE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N3eVFrRkJhME1zU1VGQlpUdEpRVU12UXl4SlFVRk5MRWxCUVVrc1IwRkJZU3hGUVVGRkxFTkJRVU03U1VGRE1VSXNTVUZCVFN4UlFVRlJMRWRCUVVjc1dVRkJXU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlJYQkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNTMEZCU3l4SlFVRkpMRTlCUVVFc1VVRkJVU3hEUVVGRExFdEJRVXNzUlVGQlJUdFJRVU0zUXl4TlFVRk5MRVZCUVVVc1NVRkJTU3hEUVVGRExFbEJRVWs3VVVGRGFrSXNTVUZCU1N4RlFVRkZMRWxCUVVrN1VVRkRWaXhUUVVGVExFVkJRVVVzUlVGQlJUdExRVU5rTEVOQlFVTXNSVUZLTmtJc1EwRkpOMElzUTBGQlF5eERRVUZETzBsQlJVb3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGWVJDdzRRMEZYUXp0QlFVVkVPenM3T3pzN1IwRk5SenRCUVVOSUxITkNRVUUyUWl4TFFVRnRRanRKUVVNNVF5eEpRVUZOTEVsQlFVa3NSMEZCWVN4RlFVRkZMRU5CUVVNN1NVRkZNVUlzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4elFrRkJjMElzUTBGQlF5eERRVUZETzBsQlJYUkRMRzlEUVVGdlF6dEpRVU53UXl4VFFVRlRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEN0Q1FVRnJRaXhEUVVGRExGVkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUlM5RUxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNN1NVRkZOMElzZDBKQlFYZENPMGxCUlhoQ0xFbEJRVTBzVVVGQlVTeEhRVUZITEZsQlFWa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVWd1F5eEpRVUZKTEZkQlFWY3NSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkZjRUlzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRWxCUVVrN1VVRkRhRUlzZFVSQlFYVkVPMUZCUTNaRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UWl4SlFVRkpMRU5CUVVNc1VVRkJVU3hIUVVGSExGbEJRVlVzVjBGQlZ5eEZRVUZKTEVOQlFVTTdVVUZETlVNc1EwRkJRenRSUVVWRUxFbEJRVTBzVDBGQlR5eEhRVUZYTEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJRenRSUVVWNFF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRekZDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUlVnc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dEJRVU5rTEVOQlFVTTdRVUUxUWtRc2IwTkJORUpESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgYmluXzEgPSByZXF1aXJlKFwiLi4vLi4vYmluXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG5mdW5jdGlvbiBudW1iZXJGb3JtYXRFeHByKGV4cHIsIGZvcm1hdCkge1xuICAgIHJldHVybiBcImZvcm1hdChcIiArIGV4cHIgKyBcIiwgJ1wiICsgZm9ybWF0ICsgXCInKVwiO1xufVxuZnVuY3Rpb24gcmFuZ2VGb3JtdWxhKG1vZGVsLCBmaWVsZERlZiwgY2hhbm5lbCkge1xuICAgIHZhciBkaXNjcmV0ZURvbWFpbiA9IHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4obW9kZWwuc2NhbGUoY2hhbm5lbCkudHlwZSk7XG4gICAgaWYgKGRpc2NyZXRlRG9tYWluKSB7XG4gICAgICAgIC8vIHJlYWQgZm9ybWF0IGZyb20gYXhpcyBvciBsZWdlbmQsIGlmIHRoZXJlIGlzIG5vIGZvcm1hdCB0aGVuIHVzZSBjb25maWcubnVtYmVyRm9ybWF0XG4gICAgICAgIHZhciBmb3JtYXQgPSAobW9kZWwuYXhpcyhjaGFubmVsKSB8fCBtb2RlbC5sZWdlbmQoY2hhbm5lbCkgfHwge30pLmZvcm1hdCB8fFxuICAgICAgICAgICAgbW9kZWwuY29uZmlnLm51bWJlckZvcm1hdDtcbiAgICAgICAgdmFyIHN0YXJ0RmllbGQgPSBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGRhdHVtOiB0cnVlLCBiaW5TdWZmaXg6ICdzdGFydCcgfSk7XG4gICAgICAgIHZhciBlbmRGaWVsZCA9IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgZGF0dW06IHRydWUsIGJpblN1ZmZpeDogJ2VuZCcgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtdWxhQXM6IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAncmFuZ2UnIH0pLFxuICAgICAgICAgICAgZm9ybXVsYTogbnVtYmVyRm9ybWF0RXhwcihzdGFydEZpZWxkLCBmb3JtYXQpICsgXCIgKyAnIC0gJyArIFwiICsgbnVtYmVyRm9ybWF0RXhwcihlbmRGaWVsZCwgZm9ybWF0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG52YXIgQmluTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmluTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaW5Ob2RlKGJpbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYmlucyA9IGJpbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmluTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluTm9kZSh1dGlsXzEuZHVwbGljYXRlKHRoaXMuYmlucykpO1xuICAgIH07XG4gICAgQmluTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBiaW5zID0gbW9kZWwucmVkdWNlRmllbGREZWYoZnVuY3Rpb24gKGJpbkNvbXBvbmVudCwgZmllbGREZWYsIGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZERlZkJpbiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpLmJpbjtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZkJpbikge1xuICAgICAgICAgICAgICAgIHZhciBiaW4gPSB1dGlsXzEuaXNCb29sZWFuKGZpZWxkRGVmQmluKSA/IHt9IDogZmllbGREZWZCaW47XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGJpbl8xLmJpblRvU3RyaW5nKGZpZWxkRGVmLmJpbikgKyBcIl9cIiArIGZpZWxkRGVmLmZpZWxkO1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBiaW5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbkNvbXBvbmVudFtrZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluOiBiaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGREZWYuZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhczogW2ZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pLCBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiB1dGlsXzEudmFyTmFtZShtb2RlbC5nZXROYW1lKGtleSArIFwiX2JpbnNcIikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW50U2lnbmFsOiBtb2RlbC5nZXROYW1lKGtleSArICdfZXh0ZW50JylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluQ29tcG9uZW50W2tleV0gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBiaW5Db21wb25lbnRba2V5XSwgcmFuZ2VGb3JtdWxhKG1vZGVsLCBmaWVsZERlZiwgY2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJpbkNvbXBvbmVudDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoYmlucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJpbk5vZGUoYmlucyk7XG4gICAgfTtcbiAgICBCaW5Ob2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLmJpbnMgPSB1dGlsXzEuZXh0ZW5kKG90aGVyLmJpbnMpO1xuICAgICAgICBvdGhlci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIEJpbk5vZGUucHJvdG90eXBlLnByb2R1Y2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIHV0aWxfMS52YWxzKHRoaXMuYmlucykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgYy5hcy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7IHJldHVybiBvdXRbZl0gPSB0cnVlOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBCaW5Ob2RlLnByb3RvdHlwZS5kZXBlbmRlbnRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgdXRpbF8xLnZhbHModGhpcy5iaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBvdXRbYy5maWVsZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIEJpbk5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmZsYXR0ZW4odXRpbF8xLnZhbHModGhpcy5iaW5zKS5tYXAoZnVuY3Rpb24gKGJpbikge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFtdO1xuICAgICAgICAgICAgdmFyIGJpblRyYW5zID0gdHNsaWJfMS5fX2Fzc2lnbih7IHR5cGU6ICdiaW4nLCBmaWVsZDogYmluLmZpZWxkLCBhczogYmluLmFzLCBzaWduYWw6IGJpbi5zaWduYWwgfSwgYmluLmJpbik7XG4gICAgICAgICAgICBpZiAoIWJpbi5iaW4uZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXh0ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGJpbi5maWVsZCxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBiaW4uZXh0ZW50U2lnbmFsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmluVHJhbnMuZXh0ZW50ID0geyBzaWduYWw6IGJpbi5leHRlbnRTaWduYWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKGJpblRyYW5zKTtcbiAgICAgICAgICAgIGlmIChiaW4uZm9ybXVsYSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Zvcm11bGEnLFxuICAgICAgICAgICAgICAgICAgICBleHByOiBiaW4uZm9ybXVsYSxcbiAgICAgICAgICAgICAgICAgICAgYXM6IGJpbi5mb3JtdWxhQXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5Ob2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5CaW5Ob2RlID0gQmluTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVltbHVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2WkdGMFlTOWlhVzR1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzYVVOQlFYZEVPMEZCUlhoRUxESkRRVUVyUXp0QlFVTXZReXh4UTBGQk9FTTdRVUZET1VNc2JVTkJRWFZITzBGQlIzWkhMSFZEUVVGM1F6dEJRVWQ0UXl3d1FrRkJNRUlzU1VGQldTeEZRVUZGTEUxQlFXTTdTVUZEY0VRc1RVRkJUU3hEUVVGRExGbEJRVlVzU1VGQlNTeFhRVUZOTEUxQlFVMHNUMEZCU1N4RFFVRkRPMEZCUTNoRExFTkJRVU03UVVGRlJDeHpRa0ZCYzBJc1MwRkJXU3hGUVVGRkxGRkJRV3RDTEVWQlFVVXNUMEZCWjBJN1NVRkRjRVVzU1VGQlRTeGpRVUZqTEVkQlFVY3NlVUpCUVdsQ0xFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVVZ3UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhqUVVGakxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNUNMSE5HUVVGelJqdFJRVU4wUml4SlFVRk5MRTFCUVUwc1IwRkJSeXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTk8xbEJRM2hGTEV0QlFVc3NRMEZCUXl4TlFVRk5MRU5CUVVNc1dVRkJXU3hEUVVGRE8xRkJSVFZDTEVsQlFVMHNWVUZCVlN4SFFVRkhMR2RDUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRWxCUVVrc1JVRkJSU3hUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBSU3hKUVVGTkxGRkJRVkVzUjBGQlJ5eG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeEpRVUZKTEVWQlFVVXNVMEZCVXl4RlFVRkZMRXRCUVVzc1JVRkJReXhEUVVGRExFTkJRVU03VVVGRmJFVXNUVUZCVFN4RFFVRkRPMWxCUTB3c1UwRkJVeXhGUVVGRkxHZENRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVNc1UwRkJVeXhGUVVGRkxFOUJRVThzUlVGQlF5eERRVUZETzFsQlEyaEVMRTlCUVU4c1JVRkJTeXhuUWtGQlowSXNRMEZCUXl4VlFVRlZMRVZCUVVVc1RVRkJUU3hEUVVGRExHMUNRVUZqTEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeE5RVUZOTEVOQlFVYzdVMEZEYmtjc1EwRkJRenRKUVVOS0xFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVdWRU8wbEJRVFpDTEcxRFFVRlpPMGxCUzNaRExHbENRVUZ2UWl4SlFVRjNRanRSUVVFMVF5eFpRVU5GTEdsQ1FVRlBMRk5CUTFJN1VVRkdiVUlzVlVGQlNTeEhRVUZLTEVsQlFVa3NRMEZCYjBJN08wbEJSVFZETEVOQlFVTTdTVUZPVFN4MVFrRkJTeXhIUVVGYU8xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NUMEZCVHl4RFFVRkRMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNME1zUTBGQlF6dEpRVTFoTEZsQlFVa3NSMEZCYkVJc1ZVRkJiVUlzUzBGQldUdFJRVU0zUWl4SlFVRk5MRWxCUVVrc1IwRkJSeXhMUVVGTExFTkJRVU1zWTBGQll5eERRVUZETEZWQlFVTXNXVUZCWjBNc1JVRkJSU3hSUVVGclFpeEZRVUZGTEU5QlFXZENPMWxCUTNaSExFbEJRVTBzVjBGQlZ5eEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETzFsQlEyaEVMRVZCUVVVc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJoQ0xFbEJRVTBzUjBGQlJ5eEhRVUZSTEdkQ1FVRlRMRU5CUVVNc1YwRkJWeXhEUVVGRExFZEJRVWNzUlVGQlJTeEhRVUZITEZkQlFWY3NRMEZCUXp0blFrRkRNMFFzU1VGQlRTeEhRVUZITEVkQlFVMHNhVUpCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEZOQlFVa3NVVUZCVVN4RFFVRkRMRXRCUVU4c1EwRkJRenRuUWtGRk4wUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzU1VGQlNTeFpRVUZaTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRek5DTEZsQlFWa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1IwRkJSenQzUWtGRGJFSXNSMEZCUnl4RlFVRkZMRWRCUVVjN2QwSkJRMUlzUzBGQlN5eEZRVUZGTEZGQlFWRXNRMEZCUXl4TFFVRkxPM2RDUVVOeVFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4blFrRkJTeXhEUVVGRExGRkJRVkVzUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhGUVVGRkxHZENRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUlVGQlF5eERRVUZETEVOQlFVTTdkMEpCUTJoR0xFMUJRVTBzUlVGQlJTeGpRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJTU3hIUVVGSExGVkJRVThzUTBGQlF5eERRVUZETzNkQ1FVTTNReXhaUVVGWkxFVkJRVVVzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRWRCUVVjc1UwRkJVeXhEUVVGRE8zRkNRVU0zUXl4RFFVRkRPMmRDUVVOS0xFTkJRVU03WjBKQlJVUXNXVUZCV1N4RFFVRkRMRWRCUVVjc1EwRkJReXgzUWtGRFdpeFpRVUZaTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUTJwQ0xGbEJRVmtzUTBGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVNeFF5eERRVUZETzFsQlEwb3NRMEZCUXp0WlFVTkVMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU03VVVGRGRFSXNRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJSVkFzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJRc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNelFpeERRVUZETzBsQlJVMHNkVUpCUVVzc1IwRkJXaXhWUVVGaExFdEJRV003VVVGRGVrSXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhoUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFdEJRVXNzUTBGQlF5eE5RVUZOTEVWQlFVVXNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVTBzWjBOQlFXTXNSMEZCY2tJN1VVRkRSU3hKUVVGTkxFZEJRVWNzUjBGQlJ5eEZRVUZGTEVOQlFVTTdVVUZGWml4WFFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRU5CUVVNN1dVRkRka0lzUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hGUVVGaUxFTkJRV0VzUTBGQlF5eERRVUZETzFGQlEyNURMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXp0SlFVTmlMRU5CUVVNN1NVRkZUU3hwUTBGQlpTeEhRVUYwUWp0UlFVTkZMRWxCUVUwc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZtTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNRMEZCUXp0WlFVTjJRaXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOMFFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVMHNNRUpCUVZFc1IwRkJaanRSUVVORkxFMUJRVTBzUTBGQlF5eGpRVUZQTEVOQlFVTXNWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4SFFVRkhPMWxCUTNCRExFbEJRVTBzVTBGQlV5eEhRVUZyUWl4RlFVRkZMRU5CUVVNN1dVRkZjRU1zU1VGQlRTeFJRVUZSTEhOQ1FVTldMRWxCUVVrc1JVRkJSU3hMUVVGTExFVkJRMWdzUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4TFFVRkxMRVZCUTJoQ0xFVkJRVVVzUlVGQlJTeEhRVUZITEVOQlFVTXNSVUZCUlN4RlFVTldMRTFCUVUwc1JVRkJSU3hIUVVGSExFTkJRVU1zVFVGQlRTeEpRVU5tTEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUTJJc1EwRkJRenRaUVVWR0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTndRaXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETzI5Q1FVTmlMRWxCUVVrc1JVRkJSU3hSUVVGUk8yOUNRVU5rTEV0QlFVc3NSVUZCUlN4SFFVRkhMRU5CUVVNc1MwRkJTenR2UWtGRGFFSXNUVUZCVFN4RlFVRkZMRWRCUVVjc1EwRkJReXhaUVVGWk8ybENRVU42UWl4RFFVRkRMRU5CUVVNN1owSkJRMGdzVVVGQlVTeERRVUZETEUxQlFVMHNSMEZCUnl4RlFVRkRMRTFCUVUwc1JVRkJSU3hIUVVGSExFTkJRVU1zV1VGQldTeEZRVUZETEVOQlFVTTdXVUZETDBNc1EwRkJRenRaUVVWRUxGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1dVRkZla0lzUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyaENMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU03YjBKQlEySXNTVUZCU1N4RlFVRkZMRk5CUVZNN2IwSkJRMllzU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4UFFVRlBPMjlDUVVOcVFpeEZRVUZGTEVWQlFVVXNSMEZCUnl4RFFVRkRMRk5CUVZNN2FVSkJRMnhDTEVOQlFVTXNRMEZCUXp0WlFVTk1MRU5CUVVNN1dVRkZSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzFGQlEyNUNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFRpeERRVUZETzBsQlEwZ3NZMEZCUXp0QlFVRkVMRU5CUVVNc1FVRndSMFFzUTBGQk5rSXNkVUpCUVZrc1IwRnZSM2hETzBGQmNFZFpMREJDUVVGUEluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyoqXG4gKiBBIG5vZGUgaW4gdGhlIGRhdGFmbG93IHRyZWUuXG4gKi9cbnZhciBEYXRhRmxvd05vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFGbG93Tm9kZShkZWJ1Z05hbWUpIHtcbiAgICAgICAgdGhpcy5kZWJ1Z05hbWUgPSBkZWJ1Z05hbWU7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgbm9kZSB3aXRoIGEgZGVlcCBjb3B5LlxuICAgICAqL1xuICAgIERhdGFGbG93Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIG5vZGUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBmaWVsZHMgdGhhdCBhcmUgYmVpbmcgY3JlYXRlZCBieSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5wcm9kdWNlZEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH07XG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5kZXBlbmRlbnRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhRmxvd05vZGUucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgcGFyZW50IG9mIHRoZSBub2RlIGFuZCBhbHNvIGFkZCB0aGlzIG5vdCB0byB0aGUgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudC5hZGRDaGlsZCh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFGbG93Tm9kZS5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRGF0YUZsb3dOb2RlLnByb3RvdHlwZS5udW1DaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB9O1xuICAgIERhdGFGbG93Tm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfTtcbiAgICBEYXRhRmxvd05vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKG9sZENoaWxkKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZSh0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG9sZENoaWxkKSwgMSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbm9kZSBmcm9tIHRoZSBkYXRhZmxvdy5cbiAgICAgKi9cbiAgICBEYXRhRmxvd05vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIGNoaWxkLnBhcmVudCA9IF90aGlzLl9wYXJlbnQ7IH0pO1xuICAgICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfTtcbiAgICBEYXRhRmxvd05vZGUucHJvdG90eXBlLnN3YXBXaXRoUGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgLy8gcmVjb25uZWN0IHRoZSBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnBhcmVudCA9IHBhcmVudDsgfSk7XG4gICAgICAgIC8vIHJlbW92ZSBvbGQgbGlua3NcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTsgLy8gZXF1aXZhbGVudCB0byByZW1vdmluZyBldmVyeSBjaGlsZCBsaW5rIG9uZSBieSBvbmVcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBwYXJlbnQucGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudCk7XG4gICAgICAgIC8vIHN3YXAgdHdvIG5vZGVzXG4gICAgICAgIHRoaXMucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgICBwYXJlbnQucGFyZW50ID0gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBEYXRhRmxvd05vZGU7XG59KCkpO1xuZXhwb3J0cy5EYXRhRmxvd05vZGUgPSBEYXRhRmxvd05vZGU7XG52YXIgT3V0cHV0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3V0cHV0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRwdXROb2RlKHNvdXJjZSwgdHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzb3VyY2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICBfdGhpcy5fcmVmY291bnQgPSAwO1xuICAgICAgICBfdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE91dHB1dE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xvbmVPYmogPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY2xvbmVPYmouX3NvdXJjZSA9IHRoaXMuX3NvdXJjZTtcbiAgICAgICAgY2xvbmVPYmouZGVidWdOYW1lID0gJ2Nsb25lXycgKyB0aGlzLmRlYnVnTmFtZTtcbiAgICAgICAgY2xvbmVPYmouX3JlZmNvdW50ID0gdGhpcy5fcmVmY291bnQ7XG4gICAgICAgIHJldHVybiBjbG9uZU9iajtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPdXRwdXROb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCB0aGUgZGF0YXNvdXJjZSBuYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBEdXJpbmcgdGhlIHBhcnNpbmcgcGhhc2UsIHRoaXMgd2lsbCByZXR1cm4gdGhlIHNpbXBsZSBuYW1lIHN1Y2ggYXMgJ21haW4nIG9yICdyYXcnLlxuICAgICAgICAgKiBJdCBpcyBjcnVjaWFsIHRvIHJlcXVlc3QgdGhlIG5hbWUgZnJvbSBhbiBvdXRwdXQgbm9kZSB0byBtYXJrIGl0IGFzIGEgcmVxdWlyZWQgbm9kZS5cbiAgICAgICAgICogSWYgbm9ib2R5IGV2ZXIgcmVxdWVzdHMgdGhlIG5hbWUsIHRoaXMgZGF0YXNvdXJjZSB3aWxsIG5vdCBiZSBpbnN0YW50aWF0ZWQgaW4gdGhlIGFzc2VtYmxlIHBoYXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiB0aGUgYXNzZW1ibGUgcGhhc2UsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNvcnJlY3QgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVmY291bnQrKztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3V0cHV0Tm9kZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWZjb3VudCA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBPdXRwdXROb2RlO1xufShEYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuT3V0cHV0Tm9kZSA9IE91dHB1dE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laR0YwWVdac2IzY3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlrWVhSaEwyUmhkR0ZtYkc5M0xuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVV0Qk96dEhRVVZITzBGQlEwZzdTVUZMUlN4elFrRkJORUlzVTBGQmEwSTdVVUZCYkVJc1kwRkJVeXhIUVVGVUxGTkJRVk1zUTBGQlV6dFJRVXAwUXl4alFVRlRMRWRCUVcxQ0xFVkJRVVVzUTBGQlF6dFJRVVV2UWl4WlFVRlBMRWRCUVdsQ0xFbEJRVWtzUTBGQlF6dEpRVVZoTEVOQlFVTTdTVUZGYmtRN08wOUJSVWM3U1VGRFNTdzBRa0ZCU3l4SFFVRmFPMUZCUTBVc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhEUVVGRE8wbEJRM1pETEVOQlFVTTdTVUZGUkRzN1QwRkZSenRKUVVOSkxIRkRRVUZqTEVkQlFYSkNPMUZCUTBVc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dEpRVU5hTEVOQlFVTTdTVUZGVFN4elEwRkJaU3hIUVVGMFFqdFJRVU5GTEUxQlFVMHNRMEZCUXl4RlFVRkZMRU5CUVVNN1NVRkRXaXhEUVVGRE8wbEJSVVFzYzBKQlFVa3NaME5CUVUwN1lVRkJWanRaUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUTNSQ0xFTkJRVU03VVVGRlJEczdWMEZGUnp0aFFVTklMRlZCUVZjc1RVRkJiMEk3V1VGRE4wSXNTVUZCU1N4RFFVRkRMRTlCUVU4c1IwRkJSeXhOUVVGTkxFTkJRVU03V1VGRGRFSXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU40UWl4RFFVRkRPenM3VDBGU1FUdEpRVlZFTEhOQ1FVRkpMR3REUVVGUk8yRkJRVm83V1VGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJRenRSUVVONFFpeERRVUZET3pzN1QwRkJRVHRKUVVWTkxHdERRVUZYTEVkQlFXeENPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGRlRTd3JRa0ZCVVN4SFFVRm1MRlZCUVdkQ0xFdEJRVzFDTzFGQlEycERMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRPMGxCUXpkQ0xFTkJRVU03U1VGRlRTeHJRMEZCVnl4SFFVRnNRaXhWUVVGdFFpeFJRVUZ6UWp0UlFVTjJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNM1JDeERRVUZETzBsQlJVUTdPMDlCUlVjN1NVRkRTU3cyUWtGQlRTeEhRVUZpTzFGQlFVRXNhVUpCUjBNN1VVRkdReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkJMRXRCUVVzc1NVRkJTU3hQUVVGQkxFdEJRVXNzUTBGQlF5eE5RVUZOTEVkQlFVY3NTMEZCU1N4RFFVRkRMRTlCUVU4c1JVRkJNMElzUTBGQk1rSXNRMEZCUXl4RFFVRkRPMUZCUXpkRUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRMnBETEVOQlFVTTdTVUZGVFN4eFEwRkJZeXhIUVVGeVFqdFJRVU5GTEVsQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU03VVVGRE5VSXNTVUZCVFN4VFFVRlRMRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVVZvUXl4NVFrRkJlVUk3VVVGRGVrSXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRU5CUVVNc1RVRkJUU3hIUVVGSExFMUJRVTBzUlVGQmFrSXNRMEZCYVVJc1EwRkJReXhEUVVGRE8xRkJSUzlETEcxQ1FVRnRRanRSUVVOdVFpeEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRkxIRkVRVUZ4UkR0UlFVTXpSU3hOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNwQ0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJSMnhETEdsQ1FVRnBRanRSUVVOcVFpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRk5CUVZNc1EwRkJRenRSUVVONFFpeE5RVUZOTEVOQlFVTXNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJRenRKUVVOMlFpeERRVUZETzBsQlEwZ3NiVUpCUVVNN1FVRkJSQ3hEUVVGRExFRkJPVVZFTEVsQk9FVkRPMEZCT1VWWkxHOURRVUZaTzBGQlowWjZRanRKUVVGblF5eHpRMEZCV1R0SlFXTXhReXh2UWtGQldTeE5RVUZqTEVWQlFXdENMRWxCUVc5Q08xRkJRV2hGTEZsQlEwVXNhMEpCUVUwc1RVRkJUU3hEUVVGRExGTkJSMlE3VVVGS01rTXNWVUZCU1N4SFFVRktMRWxCUVVrc1EwRkJaMEk3VVVGV2VFUXNaVUZCVXl4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVdGd1FpeExRVUZKTEVOQlFVTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJRenM3U1VGRGVFSXNRMEZCUXp0SlFWcE5MREJDUVVGTExFZEJRVm83VVVGRFJTeEpRVUZOTEZGQlFWRXNSMEZCUnl4SlFVRlZMRWxCUVVrc1EwRkJReXhYUVVGWkxFTkJRVU03VVVGRE4wTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1IwRkJSeXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEyaERMRkZCUVZFc1EwRkJReXhUUVVGVExFZEJRVWNzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNN1VVRkRMME1zVVVGQlVTeERRVUZETEZOQlFWTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRE8xRkJRM0JETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRV2xDUkN4elFrRkJTU3c0UWtGQlRUdFJRVlJXT3pzN096czdPenRYUVZGSE8yRkJRMGc3V1VGRFJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1dVRkRha0lzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNN1VVRkRkRUlzUTBGQlF6dGhRVVZFTEZWQlFWY3NUVUZCWXp0WlFVTjJRaXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEUxQlFVMHNRMEZCUXp0UlFVTjRRaXhEUVVGRE96czdUMEZLUVR0SlFVMUVMSE5DUVVGSkxHZERRVUZSTzJGQlFWbzdXVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZETlVJc1EwRkJRenM3TzA5QlFVRTdTVUZEU0N4cFFrRkJRenRCUVVGRUxFTkJRVU1zUVVGNlEwUXNRMEZCWjBNc1dVRkJXU3hIUVhsRE0wTTdRVUY2UTFrc1owTkJRVlVpZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xuLyoqXG4gKiBBIG5vZGUgdGhhdCBoZWxwcyB1cyB0cmFjayB3aGF0IGZpZWxkcyB3ZSBhcmUgZmFjZXRpbmcgYnkuXG4gKi9cbnZhciBGYWNldE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZhY2V0Tm9kZSwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbW9kZWwgVGhlIGZhY2V0IG1vZGVsLlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhpcyBmYWNldCBzb3VyY2Ugd2lsbCBoYXZlLlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBzb3VyY2UgZGF0YSBmb3IgdGhpcyBmYWNldCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZhY2V0Tm9kZShtb2RlbCwgbmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIGlmIChtb2RlbC5mYWNldC5jb2x1bW4pIHtcbiAgICAgICAgICAgIF90aGlzLmNvbHVtbkZpZWxkID0gbW9kZWwuZmllbGQoY2hhbm5lbF8xLkNPTFVNTik7XG4gICAgICAgICAgICBfdGhpcy5jb2x1bW5OYW1lID0gbW9kZWwuZ2V0TmFtZSgnY29sdW1uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVsLmZhY2V0LnJvdykge1xuICAgICAgICAgICAgX3RoaXMucm93RmllbGQgPSBtb2RlbC5maWVsZChjaGFubmVsXzEuUk9XKTtcbiAgICAgICAgICAgIF90aGlzLnJvd05hbWUgPSBtb2RlbC5nZXROYW1lKCdyb3cnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNldE5vZGUucHJvdG90eXBlLCBcImZpZWxkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uRmllbGQpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCh0aGlzLmNvbHVtbkZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvd0ZpZWxkKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2godGhpcy5yb3dGaWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZXROb2RlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG5hbWUgdG8gcmVmZXJlbmNlIHRoaXMgc291cmNlIGlzIGl0cyBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZhY2V0Tm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5jb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBieTogW3RoaXMuY29sdW1uRmllbGRdXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yb3dOYW1lKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMucm93TmFtZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnk6IFt0aGlzLnJvd0ZpZWxkXVxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICByZXR1cm4gRmFjZXROb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5GYWNldE5vZGUgPSBGYWNldE5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqWlhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDJaaFkyVjBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVRkJMSGxEUVVFd1F6dEJRVWN4UXl4MVEwRkJiMFE3UVVGRmNFUTdPMGRCUlVjN1FVRkRTRHRKUVVFclFpeHhRMEZCV1R0SlFVOTZRenM3T3p0UFFVbEhPMGxCUTBnc2JVSkJRVzFETEV0QlFXbENMRVZCUVd0Q0xFbEJRVmtzUlVGQlV5eEpRVUZaTzFGQlFYWkhMRmxCUTBVc2FVSkJRVThzVTBGWFVqdFJRVnByUXl4WFFVRkxMRWRCUVV3c1MwRkJTeXhEUVVGWk8xRkJRV3RDTEZWQlFVa3NSMEZCU2l4SlFVRkpMRU5CUVZFN1VVRkJVeXhWUVVGSkxFZEJRVW9zU1VGQlNTeERRVUZSTzFGQlIzSkhMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlFpeExRVUZKTEVOQlFVTXNWMEZCVnl4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zWjBKQlFVMHNRMEZCUXl4RFFVRkRPMWxCUTNaRExFdEJRVWtzUTBGQlF5eFZRVUZWTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU0xUXl4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JDTEV0QlFVa3NRMEZCUXl4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eGhRVUZITEVOQlFVTXNRMEZCUXp0WlFVTnFReXhMUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGRFTXNRMEZCUXpzN1NVRkRTQ3hEUVVGRE8wbEJSVVFzYzBKQlFVa3NOa0pCUVUwN1lVRkJWanRaUVVORkxFbEJRVTBzVFVGQlRTeEhRVUZoTEVWQlFVVXNRMEZCUXp0WlFVTTFRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTTdXVUZEYUVNc1EwRkJRenRaUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5zUWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0WlFVTTNRaXhEUVVGRE8xbEJRMFFzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTm9RaXhEUVVGRE96czdUMEZCUVR0SlFVdEVMSE5DUVVGSkxEWkNRVUZOTzFGQlNGWTdPMWRCUlVjN1lVRkRTRHRaUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFTkJRVU03T3p0UFFVRkJPMGxCUlUwc05FSkJRVkVzUjBGQlpqdFJRVU5GTEVsQlFVMHNTVUZCU1N4SFFVRmhMRVZCUVVVc1EwRkJRenRSUVVVeFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53UWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRE8yZENRVU5TTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1ZVRkJWVHRuUWtGRGNrSXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhKUVVGSk8yZENRVU5xUWl4VFFVRlRMRVZCUVVVc1EwRkJRenQzUWtGRFZpeEpRVUZKTEVWQlFVVXNWMEZCVnp0M1FrRkRha0lzVDBGQlR5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJRenR4UWtGRE5VSXNRMEZCUXp0aFFVTklMRU5CUVVNc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5xUWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRE8yZENRVU5TTEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1QwRkJUenRuUWtGRGJFSXNUVUZCVFN4RlFVRkZMRWxCUVVrc1EwRkJReXhKUVVGSk8yZENRVU5xUWl4VFFVRlRMRVZCUVVVc1EwRkJRenQzUWtGRFZpeEpRVUZKTEVWQlFVVXNWMEZCVnp0M1FrRkRha0lzVDBGQlR5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJRenR4UWtGRGVrSXNRMEZCUXp0aFFVTklMRU5CUVVNc1EwRkJRenRSUVVOTUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVOSUxHZENRVUZETzBGQlFVUXNRMEZCUXl4QlFYWkZSQ3hEUVVFclFpeDFRa0ZCV1N4SFFYVkZNVU03UVVGMlJWa3NPRUpCUVZNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGRhdGFfMSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhXCIpO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0ZXRpbWVcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXJcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNmb3JtXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbnZhciBQYXJzZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXJzZU5vZGUocGFyc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX3BhcnNlID0ge307XG4gICAgICAgIF90aGlzLl9wYXJzZSA9IHBhcnNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBhcnNlTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBwYXJzZSA9IHt9O1xuICAgICAgICB2YXIgY2FsY0ZpZWxkTWFwID0gbW9kZWwudHJhbnNmb3Jtcy5maWx0ZXIodHJhbnNmb3JtXzEuaXNDYWxjdWxhdGUpLnJlZHVjZShmdW5jdGlvbiAoZmllbGRNYXAsIGZvcm11bGEpIHtcbiAgICAgICAgICAgIGZpZWxkTWFwW2Zvcm11bGEuYXNdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZE1hcDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBQYXJzZSBmaWx0ZXIgZmllbGRzXG4gICAgICAgIG1vZGVsLnRyYW5zZm9ybXMuZmlsdGVyKHRyYW5zZm9ybV8xLmlzRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB0cmFuc2Zvcm0uZmlsdGVyO1xuICAgICAgICAgICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyID0gW2ZpbHRlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIEZvciBFcXVhbEZpbHRlciwganVzdCB1c2UgdGhlIGVxdWFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIEZvciBSYW5nZUZpbHRlciBhbmQgT25lT2ZGaWx0ZXIsIGFsbCBhcnJheSBtZW1iZXJzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNhbWUgdHlwZSwgc28gd2Ugb25seSB1c2UgdGhlIGZpcnN0IG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyXzEuaXNFcXVhbEZpbHRlcihmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmLmVxdWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWx0ZXJfMS5pc1JhbmdlRmlsdGVyKGYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGYucmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbHRlcl8xLmlzT25lT2ZGaWx0ZXIoZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKGYub25lT2YgfHwgZlsnaW4nXSlbMF07XG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlIC0tIGZvciBmaWx0ZXIgZXhwcmVzc2lvbiwgd2UgY2FuJ3QgaW5mZXIgYW55dGhpbmdcbiAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRldGltZV8xLmlzRGF0ZVRpbWUodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VbZlsnZmllbGQnXV0gPSAnZGF0ZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzTnVtYmVyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlW2ZbJ2ZpZWxkJ11dID0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlW2ZbJ2ZpZWxkJ11dID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFBhcnNlIGVuY29kZWQgZmllbGRzXG4gICAgICAgIG1vZGVsLmZvckVhY2hGaWVsZERlZihmdW5jdGlvbiAoZmllbGREZWYpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwpIHtcbiAgICAgICAgICAgICAgICBwYXJzZVtmaWVsZERlZi5maWVsZF0gPSAnZGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuUVVBTlRJVEFUSVZFKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNDb3VudChmaWVsZERlZikgfHwgY2FsY0ZpZWxkTWFwW2ZpZWxkRGVmLmZpZWxkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlW2ZpZWxkRGVmLmZpZWxkXSA9ICdudW1iZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3VzdG9tIHBhcnNlIHNob3VsZCBvdmVycmlkZSBpbmZlcnJlZCBwYXJzZVxuICAgICAgICB2YXIgZGF0YSA9IG1vZGVsLmRhdGE7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGFfMS5pc1VybERhdGEoZGF0YSkgJiYgZGF0YS5mb3JtYXQgJiYgZGF0YS5mb3JtYXQucGFyc2UpIHtcbiAgICAgICAgICAgIHZhciBwXzEgPSBkYXRhLmZvcm1hdC5wYXJzZTtcbiAgICAgICAgICAgIHV0aWxfMS5rZXlzKHBfMSkuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICBwYXJzZVtmaWVsZF0gPSBwXzFbZmllbGRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocGFyc2UpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcnNlTm9kZS5wcm90b3R5cGUsIFwicGFyc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGFyc2VOb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLl9wYXJzZSA9IHV0aWxfMS5leHRlbmQodGhpcy5fcGFyc2UsIG90aGVyLnBhcnNlKTtcbiAgICAgICAgb3RoZXIucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBQYXJzZU5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2U7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5QYXJzZU5vZGUgPSBQYXJzZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labTl5YldGMGNHRnljMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5a1lYUmhMMlp2Y20xaGRIQmhjbk5sTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVUZCTEcxRFFVRnhRenRCUVVOeVF5d3lRMEZCYjBRN1FVRkRjRVFzTWtOQlFXbEVPMEZCUTJwRUxIVkRRVUY1UlR0QlFVTjZSU3h0UTBGQmEwUTdRVUZEYkVRc2JVTkJRVEpGTzBGQlJUTkZMRFpEUVVFeVJqdEJRVVV6Uml4MVEwRkJkME03UVVGRmVFTTdTVUZCSzBJc2NVTkJRVms3U1VGSGVrTXNiVUpCUVZrc1MwRkJiVUk3VVVGQkwwSXNXVUZEUlN4cFFrRkJUeXhUUVVkU08xRkJUazhzV1VGQlRTeEhRVUZwUWl4RlFVRkZMRU5CUVVNN1VVRkxhRU1zUzBGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNN08wbEJRM1JDTEVOQlFVTTdTVUZGWVN4alFVRkpMRWRCUVd4Q0xGVkJRVzFDTEV0QlFWazdVVUZETjBJc1NVRkJUU3hMUVVGTExFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJXcENMRWxCUVUwc1dVRkJXU3hIUVVGSExFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4RFFVRkRMSFZDUVVGWExFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4UlFVRlJMRVZCUVVVc1QwRkJNa0k3V1VGRGNrY3NVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdXVUZETlVJc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF6dFJRVU5zUWl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRlVDeHpRa0ZCYzBJN1VVRkRkRUlzUzBGQlN5eERRVUZETEZWQlFWVXNRMEZCUXl4TlFVRk5MRU5CUVVNc2IwSkJRVkVzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkRMRk5CUVRCQ08xbEJRMjVGTEVsQlFVa3NUVUZCVFN4SFFVRkhMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU03V1VGRE9VSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhqUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOeVFpeE5RVUZOTEVkQlFVY3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVOd1FpeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFTkJRVU03WjBKQlEyUXNTVUZCU1N4SFFVRkhMRWRCUVhsRExFbEJRVWtzUTBGQlF6dG5Ra0ZEY2tRc1owUkJRV2RFTzJkQ1FVTm9SQ3hwUlVGQmFVVTdaMEpCUTJwRkxDdERRVUVyUXp0blFrRkRMME1zUlVGQlJTeERRVUZETEVOQlFVTXNjMEpCUVdFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNKQ0xFZEJRVWNzUjBGQlJ5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRPMmRDUVVOb1FpeERRVUZETzJkQ1FVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHpRa0ZCWVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETlVJc1IwRkJSeXhIUVVGSExFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMjVDTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEhOQ1FVRmhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTFRaXhIUVVGSExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4SlFVRkpMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOb1F5eERRVUZETEVOQlFVTXNlVVJCUVhsRU8yZENRVVV6UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTlNMRVZCUVVVc1EwRkJReXhEUVVGRExIRkNRVUZWTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU53UWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRPMjlDUVVNM1FpeERRVUZETzI5Q1FVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU42UWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NVVUZCVVN4RFFVRkRPMjlDUVVNdlFpeERRVUZETzI5Q1FVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU42UWl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVkQlFVY3NVVUZCVVN4RFFVRkRPMjlDUVVNdlFpeERRVUZETzJkQ1FVTklMRU5CUVVNN1dVRkRTQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUlVnc2RVSkJRWFZDTzFGQlEzWkNMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zVlVGQlF5eFJRVUZyUWp0WlFVTjJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4TFFVRkxMR1ZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF5OUNMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRPMWxCUTJwRExFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFbEJRVWtzUzBGQlN5eHRRa0ZCV1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE1VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2EwSkJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNTVUZCU1N4WlFVRlpMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRkRVFzVFVGQlRTeERRVUZETzJkQ1FVTlVMRU5CUVVNN1owSkJRMFFzUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhSUVVGUkxFTkJRVU03V1VGRGJrTXNRMEZCUXp0UlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzT0VOQlFUaERPMUZCUXpsRExFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRlRUlzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4SlFVRkpMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1NVRkJTU3hKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRhRVVzU1VGQlRTeEhRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03V1VGRE5VSXNWMEZCU1N4RFFVRkRMRWRCUVVNc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZETEV0QlFVczdaMEpCUTNCQ0xFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4SFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03V1VGRE1VSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRUQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEVsQlFVa3NVMEZCVXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZGUkN4elFrRkJWeXcwUWtGQlN6dGhRVUZvUWp0WlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETzFGQlEzSkNMRU5CUVVNN096dFBRVUZCTzBsQlIwMHNlVUpCUVVzc1IwRkJXaXhWUVVGaExFdEJRV2RDTzFGQlF6TkNMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzWVVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlF5OURMRXRCUVVzc1EwRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dEpRVU5xUWl4RFFVRkRPMGxCUlUwc05FSkJRVkVzUjBGQlpqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRM0pDTEVOQlFVTTdTVUZEU0N4blFrRkJRenRCUVVGRUxFTkJRVU1zUVVGeVJrUXNRMEZCSzBJc2RVSkJRVmtzUjBGeFJqRkRPMEZCY2taWkxEaENRVUZUSW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG52YXIgTm9uUG9zaXRpdmVGaWx0ZXJOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhOb25Qb3NpdGl2ZUZpbHRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9uUG9zaXRpdmVGaWx0ZXJOb2RlKGZpbHRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5vblBvc2l0aXZlRmlsdGVyTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9uUG9zaXRpdmVGaWx0ZXJOb2RlKHV0aWxfMS5leHRlbmQoe30sIHRoaXMuX2ZpbHRlcikpO1xuICAgIH07XG4gICAgTm9uUG9zaXRpdmVGaWx0ZXJOb2RlLm1ha2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9IG1vZGVsLmNoYW5uZWxzKCkucmVkdWNlKGZ1bmN0aW9uIChub25Qb3NpdGl2ZUNvbXBvbmVudCwgY2hhbm5lbCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgICAgICAgICBpZiAoIXNjYWxlIHx8ICFtb2RlbC5maWVsZChjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHNldCBhbnl0aGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBub25Qb3NpdGl2ZUNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vblBvc2l0aXZlQ29tcG9uZW50W21vZGVsLmZpZWxkKGNoYW5uZWwpXSA9IHNjYWxlLnR5cGUgPT09IHNjYWxlXzEuU2NhbGVUeXBlLkxPRztcbiAgICAgICAgICAgIHJldHVybiBub25Qb3NpdGl2ZUNvbXBvbmVudDtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGZpbHRlcikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vblBvc2l0aXZlRmlsdGVyTm9kZShmaWx0ZXIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vblBvc2l0aXZlRmlsdGVyTm9kZS5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOb25Qb3NpdGl2ZUZpbHRlck5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdXRpbF8xLmtleXModGhpcy5fZmlsdGVyKS5maWx0ZXIoZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGZpbHRlciBmaWVsZHMgKGtleXMpIHdpdGggdmFsdWUgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2ZpbHRlcltmaWVsZF07XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICAgICAgZXhwcjogJ2RhdHVtW1wiJyArIGZpZWxkICsgJ1wiXSA+IDAnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBOb25Qb3NpdGl2ZUZpbHRlck5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLk5vblBvc2l0aXZlRmlsdGVyTm9kZSA9IE5vblBvc2l0aXZlRmlsdGVyTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJtOXVjRzl6YVhScGRtVm1hV3gwWlhJdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDI1dmJuQnZjMmwwYVhabFptbHNkR1Z5TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVUZCTEhGRFFVRnpRenRCUVVOMFF5eHRRMEZCZVVRN1FVRkhla1FzZFVOQlFYZERPMEZCUlhoRE8wbEJRVEpETEdsRVFVRlpPMGxCVDNKRUxDdENRVUZaTEUxQlFYRkNPMUZCUVdwRExGbEJRMFVzYVVKQlFVOHNVMEZIVWp0UlFVUkRMRXRCUVVrc1EwRkJReXhQUVVGUExFZEJRVWNzVFVGQlRTeERRVUZET3p0SlFVTjRRaXhEUVVGRE8wbEJVazBzY1VOQlFVc3NSMEZCV2p0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxIRkNRVUZ4UWl4RFFVRkRMR0ZCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkROMFFzUTBGQlF6dEpRVkZoTERCQ1FVRkpMRWRCUVd4Q0xGVkJRVzFDTEV0QlFWazdVVUZETjBJc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVExHOUNRVUZ2UWl4RlFVRkZMRTlCUVU4N1dVRkRNMFVzU1VGQlRTeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU51UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTndReXh4UWtGQmNVSTdaMEpCUTNKQ0xFMUJRVTBzUTBGQlF5eHZRa0ZCYjBJc1EwRkJRenRaUVVNNVFpeERRVUZETzFsQlEwUXNiMEpCUVc5Q0xFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NhVUpCUVZNc1EwRkJReXhIUVVGSExFTkJRVU03V1VGRE1VVXNUVUZCVFN4RFFVRkRMRzlDUVVGdlFpeERRVUZETzFGQlF6bENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dFJRVVZRTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEVsQlFVa3NjVUpCUVhGQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZETTBNc1EwRkJRenRKUVVWRUxITkNRVUZKTEhsRFFVRk5PMkZCUVZZN1dVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTjBRaXhEUVVGRE96czdUMEZCUVR0SlFVVk5MSGREUVVGUkxFZEJRV1k3VVVGQlFTeHBRa0ZWUXp0UlFWUkRMRTFCUVUwc1EwRkJReXhYUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGRExFdEJRVXM3V1VGRGNrTXNPRU5CUVRoRE8xbEJRemxETEUxQlFVMHNRMEZCUXl4TFFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlF6ZENMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZUTEV0QlFVczdXVUZEYmtJc1RVRkJUU3hEUVVGRE8yZENRVU5NTEVsQlFVa3NSVUZCUlN4UlFVRlJPMmRDUVVOa0xFbEJRVWtzUlVGQlJTeFRRVUZUTEVkQlFVY3NTMEZCU3l4SFFVRkhMRkZCUVZFN1lVRkRaQ3hEUVVGRE8xRkJRM3BDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVOSUxEUkNRVUZETzBGQlFVUXNRMEZCUXl4QlFUbERSQ3hEUVVFeVF5eDFRa0ZCV1N4SFFUaERkRVE3UVVFNVExa3NjMFJCUVhGQ0luMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGRhdGFmbG93XzEgPSByZXF1aXJlKFwiLi9kYXRhZmxvd1wiKTtcbnZhciBERUZBVUxUX05VTExfRklMVEVSUyA9IHtcbiAgICBub21pbmFsOiBmYWxzZSxcbiAgICBvcmRpbmFsOiBmYWxzZSxcbiAgICBxdWFudGl0YXRpdmU6IHRydWUsXG4gICAgdGVtcG9yYWw6IHRydWVcbn07XG52YXIgTnVsbEZpbHRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE51bGxGaWx0ZXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE51bGxGaWx0ZXJOb2RlKGZpZWxkcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZmlsdGVyZWRGaWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTnVsbEZpbHRlck5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE51bGxGaWx0ZXJOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5fZmlsdGVyZWRGaWVsZHMpKTtcbiAgICB9O1xuICAgIE51bGxGaWx0ZXJOb2RlLm1ha2UgPSBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IG1vZGVsLnJlZHVjZUZpZWxkRGVmKGZ1bmN0aW9uIChhZ2dyZWdhdG9yLCBmaWVsZERlZikge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSAhPT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5jb25maWcuZmlsdGVySW52YWxpZCB8fFxuICAgICAgICAgICAgICAgICAgICAobW9kZWwuY29uZmlnLmZpbHRlckludmFsaWQgPT09IHVuZGVmaW5lZCAmJiAoZmllbGREZWYuZmllbGQgJiYgREVGQVVMVF9OVUxMX0ZJTFRFUlNbZmllbGREZWYudHlwZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdG9yW2ZpZWxkRGVmLmZpZWxkXSA9IGZpZWxkRGVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmaW5lIHRoaXMgc28gd2Uga25vdyB0aGF0IHdlIGRvbid0IGZpbHRlciBudWxscyBmb3IgdGhpcyBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBtZXJnZSBpbnRvIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRvcltmaWVsZERlZi5maWVsZF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZ2dyZWdhdG9yO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWVsZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOdWxsRmlsdGVyTm9kZShmaWVsZHMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bGxGaWx0ZXJOb2RlLnByb3RvdHlwZSwgXCJmaWx0ZXJlZEZpZWxkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRmllbGRzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOdWxsRmlsdGVyTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHQgPSBPYmplY3Qua2V5cyh0aGlzLl9maWx0ZXJlZEZpZWxkcykubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrICsgJyAnICsgdXRpbF8xLmhhc2goX3RoaXMuX2ZpbHRlcmVkRmllbGRzW2tdKTsgfSk7XG4gICAgICAgIHZhciBvID0gT2JqZWN0LmtleXMob3RoZXIuZmlsdGVyZWRGaWVsZHMpLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gayArICcgJyArIHV0aWxfMS5oYXNoKG90aGVyLmZpbHRlcmVkRmllbGRzW2tdKTsgfSk7XG4gICAgICAgIGlmICghdXRpbF8xLmRpZmZlckFycmF5KHQsIG8pKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJlZEZpZWxkcyA9IHV0aWxfMS5leHRlbmQodGhpcy5fZmlsdGVyZWRGaWVsZHMsIG90aGVyLl9maWx0ZXJlZEZpZWxkcyk7XG4gICAgICAgICAgICBvdGhlci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTnVsbEZpbHRlck5vZGUucHJvdG90eXBlLmFzc2VtYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmlsdGVycyA9IHV0aWxfMS5rZXlzKHRoaXMuX2ZpbHRlcmVkRmllbGRzKS5yZWR1Y2UoZnVuY3Rpb24gKF9maWx0ZXJzLCBmaWVsZCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkRGVmID0gX3RoaXMuX2ZpbHRlcmVkRmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9maWx0ZXJzLnB1c2goJ2RhdHVtW1wiJyArIGZpZWxkRGVmLmZpZWxkICsgJ1wiXSAhPT0gbnVsbCcpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuY29udGFpbnMoW3R5cGVfMS5RVUFOVElUQVRJVkUsIHR5cGVfMS5URU1QT1JBTF0sIGZpZWxkRGVmLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlcy8xNDM2KTpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIGJlIGV2ZW4gc21hcnRlciBhbmQgYWRkIE5hTiBmaWx0ZXIgZm9yIE4sTyB0aGF0IGFyZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhc2VkIG9uIHRoZSBgcGFyc2VgIHByb3BlcnR5IG9uY2Ugd2UgaGF2ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgX2ZpbHRlcnMucHVzaCgnIWlzTmFOKGRhdHVtW1wiJyArIGZpZWxkRGVmLmZpZWxkICsgJ1wiXSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlcnM7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgICAgICAgICAgZXhwcjogZmlsdGVycy5qb2luKCcgJiYgJylcbiAgICAgICAgICAgIH0gOiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIE51bGxGaWx0ZXJOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5OdWxsRmlsdGVyTm9kZSA9IE51bGxGaWx0ZXJOb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYm5Wc2JHWnBiSFJsY2k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyUmhkR0V2Ym5Wc2JHWnBiSFJsY2k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN4dFEwRkJhMFE3UVVGRGJFUXNiVU5CUVRoR08wRkJSemxHTEhWRFFVRjNRenRCUVVkNFF5eEpRVUZOTEc5Q1FVRnZRaXhIUVVGSE8wbEJRek5DTEU5QlFVOHNSVUZCUlN4TFFVRkxPMGxCUTJRc1QwRkJUeXhGUVVGRkxFdEJRVXM3U1VGRFpDeFpRVUZaTEVWQlFVVXNTVUZCU1R0SlFVTnNRaXhSUVVGUkxFVkJRVVVzU1VGQlNUdERRVU5tTEVOQlFVTTdRVUZGUmp0SlFVRnZReXd3UTBGQldUdEpRVTg1UXl4M1FrRkJXU3hOUVVGelFqdFJRVUZzUXl4WlFVTkZMR2xDUVVGUExGTkJSMUk3VVVGRVF5eExRVUZKTEVOQlFVTXNaVUZCWlN4SFFVRkhMRTFCUVUwc1EwRkJRenM3U1VGRGFFTXNRMEZCUXp0SlFWSk5MRGhDUVVGTExFZEJRVm83VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4alFVRmpMRU5CUVVNc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNM1JDeERRVUZETzBsQlVXRXNiVUpCUVVrc1IwRkJiRUlzVlVGQmJVSXNTMEZCV1R0UlFVTTNRaXhKUVVGTkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVVNc1ZVRkJNRUlzUlVGQlJTeFJRVUZyUWp0WlFVTnFSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4TFFVRkxMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyNURMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNZVUZCWVR0dlFrRkROVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMR0ZCUVdFc1MwRkJTeXhUUVVGVExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4SlFVRkpMRzlDUVVGdlFpeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjRSeXhWUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4SFFVRkhMRkZCUVZFc1EwRkJRenRuUWtGRGVFTXNRMEZCUXp0blFrRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dHZRa0ZEVGl4dFJVRkJiVVU3YjBKQlEyNUZMRFpEUVVFMlF6dHZRa0ZETjBNc1ZVRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJRM0JETEVOQlFVTTdXVUZEU0N4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF6dFJRVU53UWl4RFFVRkRMRVZCUVVVc1JVRkJiMElzUTBGQlF5eERRVUZETzFGQlJYcENMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU5rTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hqUVVGakxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdTVUZEY0VNc1EwRkJRenRKUVVWRUxITkNRVUZKTERCRFFVRmpPMkZCUVd4Q08xbEJRMGtzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNN1VVRkRhRU1zUTBGQlF6czdPMDlCUVVFN1NVRkZUU3c0UWtGQlN5eEhRVUZhTEZWQlFXRXNTMEZCY1VJN1VVRkJiRU1zYVVKQlVVTTdVVUZRUXl4SlFVRk5MRU5CUVVNc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlFTeERRVUZETEVsQlFVa3NUMEZCUVN4RFFVRkRMRWRCUVVjc1IwRkJSeXhIUVVGSExGZEJRVWtzUTBGQlF5eExRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFVkJRWFpETEVOQlFYVkRMRU5CUVVNc1EwRkJRenRSUVVNNVJpeEpRVUZOTEVOQlFVTXNSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJRU3hEUVVGRExFbEJRVWtzVDBGQlFTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRmRCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRVZCUVhaRExFTkJRWFZETEVOQlFVTXNRMEZCUXp0UlFVVTVSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEd0Q1FVRlhMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhKUVVGSkxFTkJRVU1zWlVGQlpTeEhRVUZITEdGQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hGUVVGRkxFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNRMEZCUXp0WlFVTXpSU3hMUVVGTExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdVVUZEYWtJc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRlRTeHBRMEZCVVN4SFFVRm1PMUZCUVVFc2FVSkJiMEpETzFGQmJrSkRMRWxCUVUwc1QwRkJUeXhIUVVGSExGZEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zVVVGQlVTeEZRVUZGTEV0QlFVczdXVUZEYUVVc1NVRkJUU3hSUVVGUkxFZEJRVWNzUzBGQlNTeERRVUZETEdWQlFXVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRaUVVNM1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVJc1VVRkJVU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVkQlFVY3NVVUZCVVN4RFFVRkRMRXRCUVVzc1IwRkJSeXhoUVVGaExFTkJRVU1zUTBGQlF6dG5Ra0ZETVVRc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNiVUpCUVZrc1JVRkJSU3hsUVVGUkxFTkJRVU1zUlVGQlJTeFJRVUZSTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU4wUkN4MVJFRkJkVVE3YjBKQlEzWkVMSEZGUVVGeFJUdHZRa0ZEY2tVc2FVUkJRV2xFTzI5Q1FVTnFSQ3hSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhIUVVGRkxGRkJRVkVzUTBGQlF5eExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRU5CUVVNN1owSkJRekZFTEVOQlFVTTdXVUZEU0N4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF6dFJRVU5zUWl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03VVVGRlVDeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1IwRkJSeXhEUVVGRE8xbEJRM1pDTzJkQ1FVTkZMRWxCUVVrc1JVRkJSU3hSUVVGUk8yZENRVU5rTEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF6dGhRVU16UWl4SFFVRkhMRWxCUVVrc1EwRkJRenRKUVVOaUxFTkJRVU03U1VGRFNDeHhRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRjBSVVFzUTBGQmIwTXNkVUpCUVZrc1IwRnpSUzlETzBGQmRFVlpMSGREUVVGakluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmb3JtYXRwYXJzZV8xID0gcmVxdWlyZShcIi4vZm9ybWF0cGFyc2VcIik7XG52YXIgc291cmNlXzEgPSByZXF1aXJlKFwiLi9zb3VyY2VcIik7XG4vKipcbiAqIFN0YXJ0IG9wdGltaXphdGlvbiBwYXRoIGF0IHRoZSBsZWF2ZXMuIFVzZWZ1bCBmb3IgbWVyZ2luZyB1cCB0aGluZ3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplRnJvbUxlYXZlcyhmKSB7XG4gICAgZnVuY3Rpb24gb3B0aW1pemVOZXh0RnJvbUxlYXZlcyhub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnBhcmVudCBpbnN0YW5jZW9mIHNvdXJjZV8xLlNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSBzb3VyY2Ugbm9kZSBjYW5ub3QgaGF2ZSBwYXJlbnRzIGFuZCByb290cyBoYWV2IHRvIGJlIHNvdXJjZSBub2Rlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dCA9IG5vZGUucGFyZW50O1xuICAgICAgICBmKG5vZGUpO1xuICAgICAgICBvcHRpbWl6ZU5leHRGcm9tTGVhdmVzKG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW1pemVOZXh0RnJvbUxlYXZlcztcbn1cbmV4cG9ydHMub3B0aW1pemVGcm9tTGVhdmVzID0gb3B0aW1pemVGcm9tTGVhdmVzO1xuZnVuY3Rpb24gcGFyc2Uobm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICAvLyBtb3ZlIHBhcnNlIHVwIGJ5IG1lcmdpbmcgb3Igc3dhcHBpbmdcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGZvcm1hdHBhcnNlXzEuUGFyc2VOb2RlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBmb3JtYXRwYXJzZV8xLlBhcnNlTm9kZSkge1xuICAgICAgICAgICAgcGFyZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5zd2FwV2l0aFBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYjNCMGFXMXBlbVZ5Y3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyUmhkR0V2YjNCMGFXMXBlbVZ5Y3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVXRCTERaRFFVRjNRenRCUVVWNFF5eHRRMEZCYjBNN1FVRkxjRU03TzBkQlJVYzdRVUZEU0N3MFFrRkJiVU1zUTBGQkswSTdTVUZEYUVVc1owTkJRV2RETEVsQlFXdENPMUZCUTJoRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRmxCUVZrc2JVSkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZEVNc1RVRkJUU3hEUVVGRE8xRkJRMVFzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc2MwVkJRWE5GTEVOQlFVTXNRMEZCUXp0UlFVTXhSaXhEUVVGRE8xRkJSVVFzU1VGQlRTeEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVONlFpeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRVaXh6UWtGQmMwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNdlFpeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMSE5DUVVGelFpeERRVUZETzBGQlEyaERMRU5CUVVNN1FVRmtSQ3huUkVGalF6dEJRVWRFTEdWQlFYTkNMRWxCUVd0Q08wbEJRM1JETEVsQlFVMHNUVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRk0wSXNkVU5CUVhWRE8wbEJRM1pETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1dVRkJXU3gxUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTVRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEZsQlFWa3NkVUpCUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU55UWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeEpRVUZKTEVOQlFVTXNZMEZCWXl4RlFVRkZMRU5CUVVNN1VVRkRlRUlzUTBGQlF6dEpRVU5JTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCV0VRc2MwSkJWME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfMSA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhXCIpO1xudmFyIGZhY2V0XzEgPSByZXF1aXJlKFwiLi4vZmFjZXRcIik7XG52YXIgdW5pdF8xID0gcmVxdWlyZShcIi4uL3VuaXRcIik7XG52YXIgYWdncmVnYXRlXzEgPSByZXF1aXJlKFwiLi9hZ2dyZWdhdGVcIik7XG52YXIgYmluXzEgPSByZXF1aXJlKFwiLi9iaW5cIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIGZhY2V0XzIgPSByZXF1aXJlKFwiLi9mYWNldFwiKTtcbnZhciBmb3JtYXRwYXJzZV8xID0gcmVxdWlyZShcIi4vZm9ybWF0cGFyc2VcIik7XG52YXIgbm9ucG9zaXRpdmVmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL25vbnBvc2l0aXZlZmlsdGVyXCIpO1xudmFyIG51bGxmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL251bGxmaWx0ZXJcIik7XG52YXIgcGF0aG9yZGVyXzEgPSByZXF1aXJlKFwiLi9wYXRob3JkZXJcIik7XG52YXIgc291cmNlXzEgPSByZXF1aXJlKFwiLi9zb3VyY2VcIik7XG52YXIgc3RhY2tfMSA9IHJlcXVpcmUoXCIuL3N0YWNrXCIpO1xudmFyIHRpbWV1bml0XzEgPSByZXF1aXJlKFwiLi90aW1ldW5pdFwiKTtcbnZhciB0cmFuc2Zvcm1zXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zXCIpO1xuZnVuY3Rpb24gcGFyc2VSb290KG1vZGVsLCBzb3VyY2VzKSB7XG4gICAgaWYgKG1vZGVsLmRhdGEgfHwgIW1vZGVsLnBhcmVudCkge1xuICAgICAgICAvLyBpZiB0aGUgbW9kZWwgZGVmaW5lcyBhIGRhdGEgc291cmNlIG9yIGlzIHRoZSByb290LCBjcmVhdGUgYSBzb3VyY2Ugbm9kZVxuICAgICAgICB2YXIgc291cmNlID0gbmV3IHNvdXJjZV8xLlNvdXJjZU5vZGUobW9kZWwpO1xuICAgICAgICB2YXIgaGFzaCA9IHNvdXJjZS5oYXNoKCk7XG4gICAgICAgIGlmIChoYXNoIGluIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIC8vIHVzZSBhIHJlZmVyZW5jZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzb3VyY2VcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VzW2hhc2hdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkZCBhIG5ldyBvbmVcbiAgICAgICAgICAgIHNvdXJjZXNbaGFzaF0gPSBzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgc291cmNlIGRlZmluZWQgKG92ZXJyaWRpbmcgcGFyZW50J3MgZGF0YSksIHVzZSB0aGUgcGFyZW50J3MgZmFjZXQgcm9vdCBvciBtYWluLlxuICAgICAgICByZXR1cm4gbW9kZWwucGFyZW50LmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdCA/IG1vZGVsLnBhcmVudC5jb21wb25lbnQuZGF0YS5mYWNldFJvb3QgOiBtb2RlbC5wYXJlbnQuY29tcG9uZW50LmRhdGEubWFpbjtcbiAgICB9XG59XG4vKlxuRGVzY3JpcHRpb24gb2YgdGhlIGRhdGFmbG93IChodHRwOi8vYXNjaWlmbG93LmNvbS8pOlxuXG4gICAgICstLS0tLS0tLStcbiAgICAgfCBTb3VyY2UgfFxuICAgICArLS0tKy0tLS0rXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICAgUGFyc2VcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgVHJhbnNmb3Jtc1xuKEZpbHRlciwgQ29tcHV0ZSwgLi4uKVxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBOdWxsIEZpbHRlclxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICAgQmlubmluZ1xuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBUaW1ldW5pdFxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICAgKy0tKy0tK1xuICAgICAgfCBSYXcgfFxuICAgICAgKy0tLS0tK1xuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBBZ2dyZWdhdGVcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgICBTdGFja1xuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICAgPjAgRmlsdGVyXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgIFBhdGggT3JkZXJcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICstLS0tLS0tLS0tK1xuICAgfCAgIE1haW4gICArLS0tLT4gTGF5b3V0XG4gICArLS0tLS0tLS0tLStcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgKy0tLS0tLS0rXG4gICAgIHwgRmFjZXQgfC0tLS0+IENoaWxkIGRhdGEuLi5cbiAgICAgKy0tLS0tLS0rXG5cbiovXG5mdW5jdGlvbiBwYXJzZURhdGEobW9kZWwpIHtcbiAgICB2YXIgcm9vdCA9IHBhcnNlUm9vdChtb2RlbCwgbW9kZWwuY29tcG9uZW50LmRhdGEuc291cmNlcyk7XG4gICAgdmFyIG91dHB1dE5vZGVzID0gbW9kZWwuY29tcG9uZW50LmRhdGEub3V0cHV0Tm9kZXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgaGVhZCBvZiB0aGUgdHJlZSB0aGF0IHdlIGFyZSBhcHBlbmRpbmcgdG9cbiAgICB2YXIgaGVhZCA9IHJvb3Q7XG4gICAgdmFyIHBhcnNlID0gZm9ybWF0cGFyc2VfMS5QYXJzZU5vZGUubWFrZShtb2RlbCk7XG4gICAgcGFyc2UucGFyZW50ID0gcm9vdDtcbiAgICBoZWFkID0gcGFyc2U7XG4gICAgaWYgKG1vZGVsLnRyYW5zZm9ybXMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgX2EgPSB0cmFuc2Zvcm1zXzEucGFyc2VUcmFuc2Zvcm1BcnJheShtb2RlbCksIGZpcnN0ID0gX2EuZmlyc3QsIGxhc3QgPSBfYS5sYXN0O1xuICAgICAgICBmaXJzdC5wYXJlbnQgPSBoZWFkO1xuICAgICAgICBoZWFkID0gbGFzdDtcbiAgICB9XG4gICAgdmFyIG51bGxGaWx0ZXIgPSBudWxsZmlsdGVyXzEuTnVsbEZpbHRlck5vZGUubWFrZShtb2RlbCk7XG4gICAgaWYgKG51bGxGaWx0ZXIpIHtcbiAgICAgICAgbnVsbEZpbHRlci5wYXJlbnQgPSBoZWFkO1xuICAgICAgICBoZWFkID0gbnVsbEZpbHRlcjtcbiAgICB9XG4gICAgdmFyIGJpbiA9IGJpbl8xLkJpbk5vZGUubWFrZShtb2RlbCk7XG4gICAgaWYgKGJpbikge1xuICAgICAgICBiaW4ucGFyZW50ID0gaGVhZDtcbiAgICAgICAgaGVhZCA9IGJpbjtcbiAgICB9XG4gICAgdmFyIHR1ID0gdGltZXVuaXRfMS5UaW1lVW5pdE5vZGUubWFrZShtb2RlbCk7XG4gICAgaWYgKHR1KSB7XG4gICAgICAgIHR1LnBhcmVudCA9IGhlYWQ7XG4gICAgICAgIGhlYWQgPSB0dTtcbiAgICB9XG4gICAgLy8gYWRkIGFuIG91dHB1dCBub2RlIHByZSBhZ2dyZWdhdGlvblxuICAgIHZhciByYXdOYW1lID0gbW9kZWwuZ2V0TmFtZShkYXRhXzEuUkFXKTtcbiAgICB2YXIgcmF3ID0gbmV3IGRhdGFmbG93XzEuT3V0cHV0Tm9kZShyYXdOYW1lLCBkYXRhXzEuUkFXKTtcbiAgICBvdXRwdXROb2Rlc1tyYXdOYW1lXSA9IHJhdztcbiAgICByYXcucGFyZW50ID0gaGVhZDtcbiAgICBoZWFkID0gcmF3O1xuICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIHVuaXRfMS5Vbml0TW9kZWwpIHtcbiAgICAgICAgdmFyIGFnZyA9IGFnZ3JlZ2F0ZV8xLkFnZ3JlZ2F0ZU5vZGUubWFrZShtb2RlbCk7XG4gICAgICAgIGlmIChhZ2cpIHtcbiAgICAgICAgICAgIGFnZy5wYXJlbnQgPSBoZWFkO1xuICAgICAgICAgICAgaGVhZCA9IGFnZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiB1bml0XzEuVW5pdE1vZGVsKSB7XG4gICAgICAgIHZhciBzdGFjayA9IHN0YWNrXzEuU3RhY2tOb2RlLm1ha2UobW9kZWwpO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIHN0YWNrLnBhcmVudCA9IGhlYWQ7XG4gICAgICAgICAgICBoZWFkID0gc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5vblBvc0ZpbHRlciA9IG5vbnBvc2l0aXZlZmlsdGVyXzEuTm9uUG9zaXRpdmVGaWx0ZXJOb2RlLm1ha2UobW9kZWwpO1xuICAgIGlmIChub25Qb3NGaWx0ZXIpIHtcbiAgICAgICAgbm9uUG9zRmlsdGVyLnBhcmVudCA9IGhlYWQ7XG4gICAgICAgIGhlYWQgPSBub25Qb3NGaWx0ZXI7XG4gICAgfVxuICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIHVuaXRfMS5Vbml0TW9kZWwpIHtcbiAgICAgICAgdmFyIG9yZGVyID0gcGF0aG9yZGVyXzEuT3JkZXJOb2RlLm1ha2UobW9kZWwpO1xuICAgICAgICBpZiAob3JkZXIpIHtcbiAgICAgICAgICAgIG9yZGVyLnBhcmVudCA9IGhlYWQ7XG4gICAgICAgICAgICBoZWFkID0gb3JkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3V0cHV0IG5vZGUgZm9yIG1hcmtzXG4gICAgdmFyIG1haW5OYW1lID0gbW9kZWwuZ2V0TmFtZShkYXRhXzEuTUFJTik7XG4gICAgdmFyIG1haW4gPSBuZXcgZGF0YWZsb3dfMS5PdXRwdXROb2RlKG1haW5OYW1lLCBkYXRhXzEuTUFJTik7XG4gICAgb3V0cHV0Tm9kZXNbbWFpbk5hbWVdID0gbWFpbjtcbiAgICBtYWluLnBhcmVudCA9IGhlYWQ7XG4gICAgaGVhZCA9IG1haW47XG4gICAgLy8gYWRkIGZhY2V0IG1hcmtlclxuICAgIHZhciBmYWNldFJvb3QgPSBudWxsO1xuICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIGZhY2V0XzEuRmFjZXRNb2RlbCkge1xuICAgICAgICB2YXIgZmFjZXROYW1lID0gbW9kZWwuZ2V0TmFtZSgnZmFjZXQnKTtcbiAgICAgICAgZmFjZXRSb290ID0gbmV3IGZhY2V0XzIuRmFjZXROb2RlKG1vZGVsLCBmYWNldE5hbWUsIG1haW4uc291cmNlKTtcbiAgICAgICAgb3V0cHV0Tm9kZXNbZmFjZXROYW1lXSA9IGZhY2V0Um9vdDtcbiAgICAgICAgZmFjZXRSb290LnBhcmVudCA9IGhlYWQ7XG4gICAgICAgIGhlYWQgPSBmYWNldFJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZXM6IG1vZGVsLmNvbXBvbmVudC5kYXRhLnNvdXJjZXMsXG4gICAgICAgIG91dHB1dE5vZGVzOiBvdXRwdXROb2RlcyxcbiAgICAgICAgbWFpbjogbWFpbixcbiAgICAgICAgZmFjZXRSb290OiBmYWNldFJvb3RcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZURhdGEgPSBwYXJzZURhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljR0Z5YzJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDNCaGNuTmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNiVU5CUVhGRE8wRkJSWEpETEd0RFFVRnZRenRCUVVWd1F5eG5RMEZCYTBNN1FVRkRiRU1zZVVOQlFUQkRPMEZCUXpGRExEWkNRVUU0UWp0QlFVTTVRaXgxUTBGQmIwUTdRVUZEY0VRc2FVTkJRV3RETzBGQlEyeERMRFpEUVVGM1F6dEJRVVY0UXl4NVJFRkJNRVE3UVVGRE1VUXNNa05CUVRSRE8wRkJRelZETEhsRFFVRnpRenRCUVVOMFF5eHRRMEZCYjBNN1FVRkRjRU1zYVVOQlFXdERPMEZCUTJ4RExIVkRRVUYzUXp0QlFVTjRReXd5UTBGQmFVUTdRVUZGYWtRc2JVSkJRVzFDTEV0QlFWa3NSVUZCUlN4UFFVRjVRanRKUVVONFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRhRU1zTUVWQlFUQkZPMUZCUXpGRkxFbEJRVTBzVFVGQlRTeEhRVUZITEVsQlFVa3NiVUpCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU55UXl4SlFVRk5MRWxCUVVrc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTTdVVUZETTBJc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeEpRVUZKTEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRjRUlzT0VOQlFUaERPMWxCUXpsRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRka0lzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c01FSkJRVEJDTzFsQlF6RkNMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTTdXVUZEZGtJc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU5vUWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNjVWRCUVhGSE8xRkJRM0pITEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVNeFNDeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVVkVPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3p0RlFXdEVSVHRCUVVWR0xHMUNRVUV3UWl4TFFVRlpPMGxCUTNCRExFbEJRVTBzU1VGQlNTeEhRVUZITEZOQlFWTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkZOVVFzU1VGQlRTeFhRVUZYTEVkQlFVY3NTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETzBsQlJYSkVMSGRFUVVGM1JEdEpRVU40UkN4SlFVRkpMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU03U1VGRmFFSXNTVUZCVFN4TFFVRkxMRWRCUVVjc2RVSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRjRU1zUzBGQlN5eERRVUZETEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNN1NVRkRjRUlzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXp0SlFVVmlMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE1VSXNTVUZCUVN3MFEwRkJNRU1zUlVGQmVrTXNaMEpCUVVzc1JVRkJSU3hqUVVGSkxFTkJRU3RDTzFGQlEycEVMRXRCUVVzc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEzQkNMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU03U1VGRFpDeERRVUZETzBsQlJVUXNTVUZCVFN4VlFVRlZMRWRCUVVjc01rSkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRPVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVObUxGVkJRVlVzUTBGQlF5eE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTNwQ0xFbEJRVWtzUjBGQlJ5eFZRVUZWTEVOQlFVTTdTVUZEY0VJc1EwRkJRenRKUVVWRUxFbEJRVTBzUjBGQlJ5eEhRVUZITEdGQlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRGFFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5TTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRMnhDTEVsQlFVa3NSMEZCUnl4SFFVRkhMRU5CUVVNN1NVRkRZaXhEUVVGRE8wbEJSVVFzU1VGQlRTeEZRVUZGTEVkQlFVY3NkVUpCUVZrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdTVUZEY0VNc1JVRkJSU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTlFMRVZCUVVVc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEycENMRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVU03U1VGRFdpeERRVUZETzBsQlJVUXNjVU5CUVhGRE8wbEJRM0pETEVsQlFVMHNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlJ5eERRVUZETEVOQlFVTTdTVUZEYmtNc1NVRkJUU3hIUVVGSExFZEJRVWNzU1VGQlNTeHhRa0ZCVlN4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGSExFTkJRVU1zUTBGQlF6dEpRVU42UXl4WFFVRlhMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUjBGQlJ5eERRVUZETzBsQlF6TkNMRWRCUVVjc1EwRkJReXhOUVVGTkxFZEJRVWNzU1VGQlNTeERRVUZETzBsQlEyeENMRWxCUVVrc1IwRkJSeXhIUVVGSExFTkJRVU03U1VGRldDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRmxCUVZrc1owSkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETDBJc1NVRkJUU3hIUVVGSExFZEJRVWNzZVVKQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGRFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5TTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8xbEJRMnhDTEVsQlFVa3NSMEZCUnl4SFFVRkhMRU5CUVVNN1VVRkRZaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1dVRkJXU3huUWtGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXZRaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eHBRa0ZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF6dFJRVU53UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExWXNTMEZCU3l4RFFVRkRMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU03V1VGRGNFSXNTVUZCU1N4SFFVRkhMRXRCUVVzc1EwRkJRenRSUVVObUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVUXNTVUZCVFN4WlFVRlpMRWRCUVVjc2VVTkJRWEZDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRM1pFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrSXNXVUZCV1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRE0wSXNTVUZCU1N4SFFVRkhMRmxCUVZrc1EwRkJRenRKUVVOMFFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhaUVVGWkxHZENRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFbEJRVTBzUzBGQlN5eEhRVUZITEhGQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFGQlEzQkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVml4TFFVRkxMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF6dFpRVU53UWl4SlFVRkpMRWRCUVVjc1MwRkJTeXhEUVVGRE8xRkJRMllzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZGUkN4M1FrRkJkMEk3U1VGRGVFSXNTVUZCVFN4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFhRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTnlReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eEpRVUZKTEhGQ1FVRlZMRU5CUVVNc1VVRkJVU3hGUVVGRkxGZEJRVWtzUTBGQlF5eERRVUZETzBsQlF6VkRMRmRCUVZjc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdTVUZETjBJc1NVRkJTU3hEUVVGRExFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTTdTVUZEYmtJc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dEpRVVZhTEcxQ1FVRnRRanRKUVVOdVFpeEpRVUZKTEZOQlFWTXNSMEZCUnl4SlFVRkpMRU5CUVVNN1NVRkRja0lzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4WlFVRlpMR3RDUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaERMRWxCUVUwc1UwRkJVeXhIUVVGSExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRla01zVTBGQlV5eEhRVUZITEVsQlFVa3NhVUpCUVZNc1EwRkJReXhMUVVGTExFVkJRVVVzVTBGQlV5eEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVONlJDeFhRVUZYTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWRCUVVjc1UwRkJVeXhEUVVGRE8xRkJRMjVETEZOQlFWTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRM2hDTEVsQlFVa3NSMEZCUnl4VFFVRlRMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXp0UlFVTk1MRTlCUVU4c1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBPMUZCUTNKRExGZEJRVmNzWVVGQlFUdFJRVU5ZTEVsQlFVa3NUVUZCUVR0UlFVTktMRk5CUVZNc1YwRkJRVHRMUVVOV0xFTkJRVU03UVVGRFNpeERRVUZETzBGQmFFZEVMRGhDUVdkSFF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vZW5jb2RpbmdcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIE9yZGVyTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoT3JkZXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9yZGVyTm9kZShzb3J0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNvcnQgPSBzb3J0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9yZGVyTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3JkZXJOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5zb3J0KSk7XG4gICAgfTtcbiAgICBPcmRlck5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgc29ydCA9IG51bGw7XG4gICAgICAgIGlmICh1dGlsXzEuY29udGFpbnMoWydsaW5lJywgJ2FyZWEnXSwgbW9kZWwubWFyaygpKSkge1xuICAgICAgICAgICAgaWYgKG1vZGVsLm1hcmsoKSA9PT0gJ2xpbmUnICYmIG1vZGVsLmNoYW5uZWxIYXNGaWVsZCgnb3JkZXInKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBvbmx5IGxpbmUsIHNvcnQgYnkgdGhlIG9yZGVyIGZpZWxkIGlmIGl0IGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBzb3J0ID0gY29tbW9uXzEuc29ydFBhcmFtcyhtb2RlbC5lbmNvZGluZy5vcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYm90aCBsaW5lIGFuZCBhcmVhLCB3ZSBzb3J0IHZhbHVlcyBiYXNlZCBvbiBkaW1lbnNpb24gYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHZhciBkaW1lbnNpb25DaGFubmVsID0gbW9kZWwubWFya0RlZi5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG1vZGVsLnNvcnQoZGltZW5zaW9uQ2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvcnRGaWVsZCA9IHNvcnRfMS5pc1NvcnRGaWVsZChzKSA/XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkZGVmXzEuZmllbGQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgb3AgbWlnaHQgbm90IGFscmVhZHkgZXhpc3Q/XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogd2hhdCBpZiBkaW1lbnNpb25DaGFubmVsICh4IG9yIHkpIGNvbnRhaW5zIGN1c3RvbSBkb21haW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGU6IGVuY29kaW5nXzEuaXNBZ2dyZWdhdGUobW9kZWwuZW5jb2RpbmcpID8gcy5vcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzLmZpZWxkXG4gICAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoZGltZW5zaW9uQ2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdzdGFydCcgfSk7XG4gICAgICAgICAgICAgICAgc29ydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNvcnRGaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICdkZXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9yZGVyTm9kZShzb3J0KTtcbiAgICB9O1xuICAgIE9yZGVyTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnY29sbGVjdCcsXG4gICAgICAgICAgICBzb3J0OiB0aGlzLnNvcnRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBPcmRlck5vZGU7XG59KGRhdGFmbG93XzEuRGF0YUZsb3dOb2RlKSk7XG5leHBvcnRzLk9yZGVyTm9kZSA9IE9yZGVyTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNHRjBhRzl5WkdWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZaR0YwWVM5d1lYUm9iM0prWlhJdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc01rTkJRVEpETzBGQlF6TkRMREpEUVVGeFF6dEJRVU55UXl4dFEwRkJkVU03UVVGRGRrTXNiVU5CUVN0RE8wRkJSeTlETEc5RFFVRnhRenRCUVVWeVF5eDFRMEZCZDBNN1FVRkZlRU03U1VGQkswSXNjVU5CUVZrN1NVRkxla01zYlVKQlFXOUNMRWxCUVZrN1VVRkJhRU1zV1VGRFJTeHBRa0ZCVHl4VFFVTlNPMUZCUm0xQ0xGVkJRVWtzUjBGQlNpeEpRVUZKTEVOQlFWRTdPMGxCUldoRExFTkJRVU03U1VGT1RTeDVRa0ZCU3l4SFFVRmFPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzVTBGQlV5eERRVUZETEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZETjBNc1EwRkJRenRKUVUxaExHTkJRVWtzUjBGQmJFSXNWVUZCYlVJc1MwRkJaMEk3VVVGRGFrTXNTVUZCU1N4SlFVRkpMRWRCUVZjc1NVRkJTU3hEUVVGRE8xRkJSWGhDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVZFc1EwRkJReXhEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETjBNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4TFFVRkxMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE9VUXNOa1JCUVRaRU8yZENRVU0zUkN4SlFVRkpMRWRCUVVjc2JVSkJRVlVzUTBGQlF5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRekZETEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeDFSVUZCZFVVN1owSkJRM1pGTEVsQlFVMHNaMEpCUVdkQ0xFZEJRV01zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRXRCUVVzc1dVRkJXU3hIUVVGSExFZEJRVWNzUjBGQlJ5eEhRVUZITEVOQlFVTTdaMEpCUTNSR0xFbEJRVTBzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXp0blFrRkRka01zU1VGQlRTeFRRVUZUTEVkQlFVY3NhMEpCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6bENMR2RDUVVGTExFTkJRVU03ZDBKQlEwb3NNRU5CUVRCRE8zZENRVU14UXl4dFJVRkJiVVU3ZDBKQlEyNUZMRk5CUVZNc1JVRkJSU3h6UWtGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEZOQlFWTTdkMEpCUTNwRUxFdEJRVXNzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3p0eFFrRkRaaXhEUVVGRE8yOUNRVU5HTEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNSVUZCUXl4VFFVRlRMRVZCUVVVc1QwRkJUeXhGUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZGZEVRc1NVRkJTU3hIUVVGSE8yOUNRVU5NTEV0QlFVc3NSVUZCUlN4VFFVRlRPMjlDUVVOb1FpeExRVUZMTEVWQlFVVXNXVUZCV1R0cFFrRkRjRUlzUTBGQlF6dFpRVU5LTEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJRc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlJVMHNORUpCUVZFc1IwRkJaanRSUVVORkxFMUJRVTBzUTBGQlF6dFpRVU5NTEVsQlFVa3NSVUZCUlN4VFFVRlRPMWxCUTJZc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eEpRVUZKTzFOQlEyaENMRU5CUVVNN1NVRkRTaXhEUVVGRE8wbEJRMGdzWjBKQlFVTTdRVUZCUkN4RFFVRkRMRUZCTDBORUxFTkJRU3RDTEhWQ1FVRlpMRWRCSzBNeFF6dEJRUzlEV1N3NFFrRkJVeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG52YXIgU291cmNlTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU291cmNlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlKG1vZGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gbW9kZWwuZGF0YSB8fCB7IG5hbWU6ICdzb3VyY2UnIH07XG4gICAgICAgIGlmIChkYXRhXzEuaXNJbmxpbmVEYXRhKGRhdGEpKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGEudmFsdWVzLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogeyB0eXBlOiAnanNvbicgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhXzEuaXNVcmxEYXRhKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IGV4dGVuc2lvbiBmcm9tIFVSTCB1c2luZyBzbmlwcGV0IGZyb21cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjgwOTI5L2hvdy10by1leHRyYWN0LWV4dGVuc2lvbi1mcm9tLWZpbGVuYW1lLXN0cmluZy1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEV4dGVuc2lvbiA9IC8oPzpcXC4oW14uXSspKT8kLy5leGVjKGRhdGEudXJsKVsxXTtcbiAgICAgICAgICAgIGlmICghdXRpbF8xLmNvbnRhaW5zKFsnanNvbicsICdjc3YnLCAndHN2JywgJ3RvcG9qc29uJ10sIGRlZmF1bHRFeHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEV4dGVuc2lvbiA9ICdqc29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhRm9ybWF0ID0gZGF0YS5mb3JtYXQgfHwge307XG4gICAgICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3IgZm9ybWVyIGBkYXRhLmZvcm1hdFR5cGVgIHByb3BlcnR5XG4gICAgICAgICAgICB2YXIgZm9ybWF0VHlwZSA9IGRhdGFGb3JtYXQudHlwZSB8fCBkYXRhWydmb3JtYXRUeXBlJ107XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBkYXRhRm9ybWF0LnByb3BlcnR5LCBmZWF0dXJlID0gZGF0YUZvcm1hdC5mZWF0dXJlLCBtZXNoID0gZGF0YUZvcm1hdC5tZXNoO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRzbGliXzEuX19hc3NpZ24oeyB0eXBlOiBmb3JtYXRUeXBlID8gZm9ybWF0VHlwZSA6IGRlZmF1bHRFeHRlbnNpb24gfSwgKHByb3BlcnR5ID8geyBwcm9wZXJ0eTogcHJvcGVydHkgfSA6IHt9KSwgKGZlYXR1cmUgPyB7IGZlYXR1cmU6IGZlYXR1cmUgfSA6IHt9KSwgKG1lc2ggPyB7IG1lc2g6IG1lc2ggfSA6IHt9KSk7XG4gICAgICAgICAgICBfdGhpcy5fZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IGRhdGEudXJsLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFfMS5pc05hbWVkRGF0YShkYXRhKSkge1xuICAgICAgICAgICAgX3RoaXMuX25hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTm9kZS5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNvdXJjZU5vZGUucHJvdG90eXBlLmhhc05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX25hbWU7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTm9kZS5wcm90b3R5cGUsIFwiZGF0YU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgdW5pcXVlIGlkZW50aWZpciBmb3IgdGhpcyBkYXRhIHNvdXJjZS5cbiAgICAgKi9cbiAgICBTb3VyY2VOb2RlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGF0YV8xLmlzSW5saW5lRGF0YSh0aGlzLl9kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5oYXNoKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFfMS5pc1VybERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnVybCArIFwiIFwiICsgdXRpbF8xLmhhc2godGhpcy5fZGF0YS5mb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFfMS5pc05hbWVkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZScpO1xuICAgIH07XG4gICAgU291cmNlTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHsgbmFtZTogdGhpcy5fbmFtZSB9LCB0aGlzLl9kYXRhLCB7IHRyYW5zZm9ybTogW10gfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTm9kZTtcbn0oZGF0YWZsb3dfMS5EYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMjkxY21ObExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZaR0YwWVM5emIzVnlZMlV1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzYlVOQlFUUkZPMEZCUXpWRkxHMURRVUV3UXp0QlFVY3hReXgxUTBGQmQwTTdRVUZGZUVNN1NVRkJaME1zYzBOQlFWazdTVUZMTVVNc2IwSkJRVmtzUzBGQldUdFJRVUY0UWl4WlFVTkZMR2xDUVVGUExGTkJiME5TTzFGQmJFTkRMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVsQlFVa3NSVUZCUXl4SlFVRkpMRVZCUVVVc1VVRkJVU3hGUVVGRExFTkJRVU03VVVGRk5VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2JVSkJRVmtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka0lzUzBGQlNTeERRVUZETEV0QlFVc3NSMEZCUnp0blFrRkRXQ3hOUVVGTkxFVkJRVVVzU1VGQlNTeERRVUZETEUxQlFVMDdaMEpCUTI1Q0xFMUJRVTBzUlVGQlJTeEZRVUZETEVsQlFVa3NSVUZCUlN4TlFVRk5MRVZCUVVNN1lVRkRka0lzUTBGQlF6dFJRVU5LTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE0wSXNaMFJCUVdkRU8xbEJRMmhFTEhkSFFVRjNSenRaUVVONFJ5eEpRVUZKTEdkQ1FVRm5RaXhIUVVGSExHbENRVUZwUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNMFFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4VlFVRlZMRU5CUVVNc1JVRkJSU3huUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNFVXNaMEpCUVdkQ0xFZEJRVWNzVFVGQlRTeERRVUZETzFsQlF6VkNMRU5CUVVNN1dVRkRSQ3hKUVVGTkxGVkJRVlVzUjBGQlpTeEpRVUZKTEVOQlFVTXNUVUZCVFN4SlFVRkpMRVZCUVVVc1EwRkJRenRaUVVWcVJDeHRSVUZCYlVVN1dVRkRia1VzU1VGQlRTeFZRVUZWTEVkQlFXVXNWVUZCVlN4RFFVRkRMRWxCUVVrc1NVRkJTU3hKUVVGSkxFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTTdXVUZET1VRc1NVRkJRU3c0UWtGQlVTeEZRVUZGTERSQ1FVRlBMRVZCUVVVc2MwSkJRVWtzUTBGQlpUdFpRVVUzUXl4SlFVRk5MRTFCUVUwc2MwSkJRMVlzU1VGQlNTeEZRVUZGTEZWQlFWVXNSMEZCUnl4VlFVRlZMRWRCUVVjc1owSkJRV2RDTEVsQlF6ZERMRU5CUVVNc1VVRkJVU3hIUVVGSExFVkJRVU1zVVVGQlVTeFZRVUZCTEVWQlFVTXNSMEZCUnl4RlFVRkZMRU5CUVVNc1JVRkROVUlzUTBGQlF5eFBRVUZQTEVkQlFVY3NSVUZCUXl4UFFVRlBMRk5CUVVFc1JVRkJReXhIUVVGSExFVkJRVVVzUTBGQlF5eEZRVU14UWl4RFFVRkRMRWxCUVVrc1IwRkJSeXhGUVVGRExFbEJRVWtzVFVGQlFTeEZRVUZETEVkQlFVY3NSVUZCUlN4RFFVRkRMRU5CUTNoQ0xFTkJRVU03V1VGRlJpeExRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhPMmRDUVVOWUxFZEJRVWNzUlVGQlJTeEpRVUZKTEVOQlFVTXNSMEZCUnp0blFrRkRZaXhOUVVGTkxGRkJRVUU3WVVGRFVDeERRVUZETzFGQlEwb3NRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHJRa0ZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU0zUWl4TFFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEZWtJc1EwRkJRenM3U1VGRFNDeERRVUZETzBsQlJVUXNjMEpCUVVrc05FSkJRVWs3WVVGQlVqdFpRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRM0JDTEVOQlFVTTdPenRQUVVGQk8wbEJSVTBzTkVKQlFVOHNSMEZCWkR0UlFVTkZMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJSVVFzYzBKQlFVa3NaME5CUVZFN1lVRkJXanRaUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTNCQ0xFTkJRVU03WVVGRlJDeFZRVUZoTEVsQlFWazdXVUZEZGtJc1NVRkJTU3hEUVVGRExFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTTdVVUZEY0VJc1EwRkJRenM3TzA5QlNrRTdTVUZOUkRzN1QwRkZSenRKUVVOSkxIbENRVUZKTEVkQlFWZzdVVUZEUlN4RlFVRkZMRU5CUVVNc1EwRkJReXh0UWtGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE4wSXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTTdVVUZETVVJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU55UWl4TlFVRk5MRU5CUVVrc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEhRVUZITEZOQlFVa3NWMEZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZITEVOQlFVTTdVVUZEZUVRc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4clFrRkJWeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEZWtJc1EwRkJRenRSUVVORUxFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zUTBGQlF6dEpRVU40UXl4RFFVRkRPMGxCUlUwc05rSkJRVkVzUjBGQlpqdFJRVU5GTEUxQlFVMHNiMEpCUTBvc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eExRVUZMTEVsQlEySXNTVUZCU1N4RFFVRkRMRXRCUVVzc1NVRkRZaXhUUVVGVExFVkJRVVVzUlVGQlJTeEpRVU5pTzBsQlEwb3NRMEZCUXp0SlFVTklMR2xDUVVGRE8wRkJRVVFzUTBGQlF5eEJRV3BHUkN4RFFVRm5ReXgxUWtGQldTeEhRV2xHTTBNN1FVRnFSbGtzWjBOQlFWVWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB2ZWdhX3V0aWxfMSA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBkYXRhZmxvd18xID0gcmVxdWlyZShcIi4vZGF0YWZsb3dcIik7XG5mdW5jdGlvbiBnZXRTdGFja0J5RmllbGRzKG1vZGVsKSB7XG4gICAgcmV0dXJuIG1vZGVsLnN0YWNrLnN0YWNrQnkucmVkdWNlKGZ1bmN0aW9uIChmaWVsZHMsIGJ5KSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gYnkuY2hhbm5lbDtcbiAgICAgICAgdmFyIGZpZWxkRGVmID0gYnkuZmllbGREZWY7XG4gICAgICAgIHZhciBzY2FsZSA9IG1vZGVsLnNjYWxlKGNoYW5uZWwpO1xuICAgICAgICB2YXIgX2ZpZWxkID0gZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwge1xuICAgICAgICAgICAgYmluU3VmZml4OiBzY2FsZSAmJiBzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlLnR5cGUpID8gJ3JhbmdlJyA6ICdzdGFydCdcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfZmllbGQpIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKF9maWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9LCBbXSk7XG59XG52YXIgU3RhY2tOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdGFja05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhY2tOb2RlKHN0YWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9zdGFjayA9IHN0YWNrO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YWNrTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5fc3RhY2spKTtcbiAgICB9O1xuICAgIFN0YWNrTm9kZS5tYWtlID0gZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBzdGFja1Byb3BlcnRpZXMgPSBtb2RlbC5zdGFjaztcbiAgICAgICAgaWYgKCFzdGFja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cGJ5ID0gW107XG4gICAgICAgIGlmIChzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwpIHtcbiAgICAgICAgICAgIHZhciBncm91cGJ5RmllbGREZWYgPSBtb2RlbC5maWVsZERlZihzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwpO1xuICAgICAgICAgICAgaWYgKGdyb3VwYnlGaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgQmluLCB3ZSBuZWVkIHRvIGFkZCBib3RoIHN0YXJ0IGFuZCBlbmQgdG8gZW5zdXJlIHRoYXQgYm90aCBnZXQgaW1wdXRlZFxuICAgICAgICAgICAgICAgIC8vIGFuZCBpbmNsdWRlZCBpbiB0aGUgc3RhY2sgb3V0cHV0IChodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzE4MDUpLlxuICAgICAgICAgICAgICAgIGdyb3VwYnkucHVzaChtb2RlbC5maWVsZChzdGFja1Byb3BlcnRpZXMuZ3JvdXBieUNoYW5uZWwsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pKTtcbiAgICAgICAgICAgICAgICBncm91cGJ5LnB1c2gobW9kZWwuZmllbGQoc3RhY2tQcm9wZXJ0aWVzLmdyb3VwYnlDaGFubmVsLCB7IGJpblN1ZmZpeDogJ2VuZCcgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBieS5wdXNoKG1vZGVsLmZpZWxkKHN0YWNrUHJvcGVydGllcy5ncm91cGJ5Q2hhbm5lbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFja2J5ID0gZ2V0U3RhY2tCeUZpZWxkcyhtb2RlbCk7XG4gICAgICAgIHZhciBvcmRlckRlZiA9IG1vZGVsLmVuY29kaW5nLm9yZGVyO1xuICAgICAgICB2YXIgc29ydDtcbiAgICAgICAgaWYgKG9yZGVyRGVmKSB7XG4gICAgICAgICAgICBzb3J0ID0gY29tbW9uXzEuc29ydFBhcmFtcyhvcmRlckRlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0ID0gZGVzY2VuZGluZyBieSBzdGFja0ZpZWxkc1xuICAgICAgICAgICAgLy8gRklYTUUgaXMgdGhlIGRlZmF1bHQgaGVyZSBjb3JyZWN0IGZvciBiaW5uZWQgZmllbGRzP1xuICAgICAgICAgICAgc29ydCA9IHN0YWNrYnkucmVkdWNlKGZ1bmN0aW9uIChzLCBmaWVsZCkge1xuICAgICAgICAgICAgICAgIHMuZmllbGQucHVzaChmaWVsZCk7XG4gICAgICAgICAgICAgICAgcy5vcmRlci5wdXNoKCdkZXNjZW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9LCB7IGZpZWxkOiBbXSwgb3JkZXI6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tOb2RlKHtcbiAgICAgICAgICAgIGdyb3VwYnk6IGdyb3VwYnksXG4gICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoc3RhY2tQcm9wZXJ0aWVzLmZpZWxkQ2hhbm5lbCksXG4gICAgICAgICAgICBzdGFja2J5OiBzdGFja2J5LFxuICAgICAgICAgICAgc29ydDogc29ydCxcbiAgICAgICAgICAgIG9mZnNldDogc3RhY2tQcm9wZXJ0aWVzLm9mZnNldCxcbiAgICAgICAgICAgIGltcHV0ZTogdXRpbF8xLmNvbnRhaW5zKFsnYXJlYScsICdsaW5lJ10sIG1vZGVsLm1hcmsoKSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrTm9kZS5wcm90b3R5cGUsIFwic3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhY2tOb2RlLnByb3RvdHlwZS5hZGREaW1lbnNpb25zID0gZnVuY3Rpb24gKGZpZWxkcykge1xuICAgICAgICB0aGlzLl9zdGFjay5ncm91cGJ5ID0gdGhpcy5fc3RhY2suZ3JvdXBieS5jb25jYXQoZmllbGRzKTtcbiAgICB9O1xuICAgIFN0YWNrTm9kZS5wcm90b3R5cGUuZGVwZW5kZW50RmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZF0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGFjay5ncm91cGJ5LmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG91dFtmXSA9IHRydWU7IH0pO1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLl9zdGFjay5zb3J0LmZpZWxkO1xuICAgICAgICB2ZWdhX3V0aWxfMS5pc0FycmF5KGZpZWxkKSA/IGZpZWxkLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIG91dFtmXSA9IHRydWU7IH0pIDogb3V0W2ZpZWxkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBTdGFja05vZGUucHJvdG90eXBlLnByb2R1Y2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZCArICdfc3RhcnQnXSA9IHRydWU7XG4gICAgICAgIG91dFt0aGlzLl9zdGFjay5maWVsZCArICdfZW5kJ10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgU3RhY2tOb2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFtdO1xuICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICAgICAgLy8gSW1wdXRlXG4gICAgICAgIGlmIChzdGFjay5pbXB1dGUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaW1wdXRlJyxcbiAgICAgICAgICAgICAgICBmaWVsZDogc3RhY2suZmllbGQsXG4gICAgICAgICAgICAgICAgZ3JvdXBieTogc3RhY2suc3RhY2tieSxcbiAgICAgICAgICAgICAgICBvcmRlcmJ5OiBzdGFjay5ncm91cGJ5LFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhY2tcbiAgICAgICAgdHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3N0YWNrJyxcbiAgICAgICAgICAgIGdyb3VwYnk6IHN0YWNrLmdyb3VwYnksXG4gICAgICAgICAgICBmaWVsZDogc3RhY2suZmllbGQsXG4gICAgICAgICAgICBzb3J0OiBzdGFjay5zb3J0LFxuICAgICAgICAgICAgYXM6IFtcbiAgICAgICAgICAgICAgICBzdGFjay5maWVsZCArICdfc3RhcnQnLFxuICAgICAgICAgICAgICAgIHN0YWNrLmZpZWxkICsgJ19lbmQnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb2Zmc2V0OiBzdGFjay5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfTtcbiAgICByZXR1cm4gU3RhY2tOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5TdGFja05vZGUgPSBTdGFja05vZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1JoWTJzdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOWtZWFJoTDNOMFlXTnJMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVRkJMSFZEUVVGclF6dEJRVU5zUXl3eVEwRkJjVU03UVVGRGNrTXNjVU5CUVRoRE8wRkJSVGxETEcxRFFVRXJRenRCUVVVdlF5eHZRMEZCY1VNN1FVRkhja01zZFVOQlFYZERPMEZCUlhoRExEQkNRVUV3UWl4TFFVRlpPMGxCUTNCRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eE5RVUZOTEVWQlFVVXNSVUZCUlR0UlFVTXpReXhKUVVGTkxFOUJRVThzUjBGQlJ5eEZRVUZGTEVOQlFVTXNUMEZCVHl4RFFVRkRPMUZCUXpOQ0xFbEJRVTBzVVVGQlVTeEhRVUZITEVWQlFVVXNRMEZCUXl4UlFVRlJMRU5CUVVNN1VVRkZOMElzU1VGQlRTeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU51UXl4SlFVRk5MRTFCUVUwc1IwRkJSeXhuUWtGQlN5eERRVUZETEZGQlFWRXNSVUZCUlR0WlFVTTNRaXhUUVVGVExFVkJRVVVzUzBGQlN5eEpRVUZKTEhsQ1FVRnBRaXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4UFFVRlBMRWRCUVVjc1QwRkJUenRUUVVOMFJTeERRVUZETEVOQlFVTTdVVUZEU0N4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExZ3NUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU4wUWl4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU5vUWl4RFFVRkRMRVZCUVVVc1JVRkJZeXhEUVVGRExFTkJRVU03UVVGRGNrSXNRMEZCUXp0QlFXZERSRHRKUVVFclFpeHhRMEZCV1R0SlFVOTZReXh0UWtGQldTeExRVUZ4UWp0UlFVRnFReXhaUVVORkxHbENRVUZQTEZOQlIxSTdVVUZFUXl4TFFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF6czdTVUZEZEVJc1EwRkJRenRKUVZKTkxIbENRVUZMTEVkQlFWbzdVVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hUUVVGVExFTkJRVU1zWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU12UXl4RFFVRkRPMGxCVVdFc1kwRkJTU3hIUVVGc1FpeFZRVUZ0UWl4TFFVRm5RanRSUVVWcVF5eEpRVUZOTEdWQlFXVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJSWEJETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU55UWl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVVZFTEVsQlFVMHNUMEZCVHl4SFFVRkhMRVZCUVVVc1EwRkJRenRSUVVOdVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1kwRkJZeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UXl4SlFVRk5MR1ZCUVdVc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEdWQlFXVXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJRenRaUVVOMlJTeEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZUVJc05rVkJRVFpGTzJkQ1FVTTNSU3h2UmtGQmIwWTdaMEpCUTNCR0xFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zWTBGQll5eEZRVUZGTEVWQlFVTXNVMEZCVXl4RlFVRkZMRTlCUVU4c1JVRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYUVZc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhqUVVGakxFVkJRVVVzUlVGQlF5eFRRVUZUTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhHTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeFBRVUZQTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROVVFzUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZGUkN4SlFVRk5MRTlCUVU4c1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVONFF5eEpRVUZOTEZGQlFWRXNSMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVVYwUXl4SlFVRkpMRWxCUVZrc1EwRkJRenRSUVVOcVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMklzU1VGQlNTeEhRVUZITEcxQ1FVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRE9VSXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRMDRzYzBOQlFYTkRPMWxCUTNSRExIVkVRVUYxUkR0WlFVTjJSQ3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRkRMRU5CUVVNc1JVRkJSU3hMUVVGTE8yZENRVU0zUWl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXp0blFrRkRjRUlzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFTkJRVU03WjBKQlF6TkNMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFdDeERRVUZETEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVNc1JVRkJSU3hGUVVGRkxFdEJRVXNzUlVGQlJTeEZRVUZGTEVWQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpWQ0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4VFFVRlRMRU5CUVVNN1dVRkRia0lzVDBGQlR5eFRRVUZCTzFsQlExQXNTMEZCU3l4RlFVRkZMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEZsQlFWa3NRMEZCUXp0WlFVTm9SQ3hQUVVGUExGTkJRVUU3V1VGRFVDeEpRVUZKTEUxQlFVRTdXVUZEU2l4TlFVRk5MRVZCUVVVc1pVRkJaU3hEUVVGRExFMUJRVTA3V1VGRE9VSXNUVUZCVFN4RlFVRkZMR1ZCUVZFc1EwRkJReXhEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU03VTBGRGFrUXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWRUxITkNRVUZKTERSQ1FVRkxPMkZCUVZRN1dVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXp0UlFVTnlRaXhEUVVGRE96czdUMEZCUVR0SlFVVk5MR2xEUVVGaExFZEJRWEJDTEZWQlFYRkNMRTFCUVdkQ08xRkJRMjVETEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1QwRkJUeXhIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU16UkN4RFFVRkRPMGxCUlUwc2JVTkJRV1VzUjBGQmRFSTdVVUZEUlN4SlFVRk5MRWRCUVVjc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRlppeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdVVUZET1VJc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVFc1EwRkJReXhKUVVGSkxFOUJRVUVzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWxCUVVrc1JVRkJZaXhEUVVGaExFTkJRVU1zUTBGQlF6dFJRVU5vUkN4SlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRja01zYlVKQlFVOHNRMEZCUXl4TFFVRkxMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNRMEZCUXl4SlFVRkpMRTlCUVVFc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCWWl4RFFVRmhMRU5CUVVNc1IwRkJSeXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUlhaRkxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdTVUZEWWl4RFFVRkRPMGxCUlUwc2EwTkJRV01zUjBGQmNrSTdVVUZEUlN4SlFVRk5MRWRCUVVjc1IwRkJSeXhGUVVGRkxFTkJRVU03VVVGRlppeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFZEJRVWNzVVVGQlVTeERRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTNwRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1IwRkJSeXhOUVVGTkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdVVUZGZGtNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF6dEpRVU5pTEVOQlFVTTdTVUZGVFN3MFFrRkJVU3hIUVVGbU8xRkJRMFVzU1VGQlRTeFRRVUZUTEVkQlFXdENMRVZCUVVVc1EwRkJRenRSUVVWd1F5eEpRVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJSVEZDTEZOQlFWTTdVVUZEVkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnFRaXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVTmlMRWxCUVVrc1JVRkJSU3hSUVVGUk8yZENRVU5rTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTenRuUWtGRGJFSXNUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhQUVVGUE8yZENRVU4wUWl4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVTg3WjBKQlEzUkNMRTFCUVUwc1JVRkJSU3hQUVVGUE8yZENRVU5tTEV0QlFVc3NSVUZCUlN4RFFVRkRPMkZCUTFRc1EwRkJReXhEUVVGRE8xRkJRMHdzUTBGQlF6dFJRVVZFTEZGQlFWRTdVVUZEVWl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRMklzU1VGQlNTeEZRVUZGTEU5QlFVODdXVUZEWWl4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVTg3V1VGRGRFSXNTMEZCU3l4RlFVRkZMRXRCUVVzc1EwRkJReXhMUVVGTE8xbEJRMnhDTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1NVRkJTVHRaUVVOb1FpeEZRVUZGTEVWQlFVVTdaMEpCUTBZc1MwRkJTeXhEUVVGRExFdEJRVXNzUjBGQlJ5eFJRVUZSTzJkQ1FVTjBRaXhMUVVGTExFTkJRVU1zUzBGQlN5eEhRVUZITEUxQlFVMDdZVUZEY2tJN1dVRkRSQ3hOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEUxQlFVMDdVMEZEY2tJc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJRMGdzWjBKQlFVTTdRVUZCUkN4RFFVRkRMRUZCZUVoRUxFTkJRU3RDTEhWQ1FVRlpMRWRCZDBneFF6dEJRWGhJV1N3NFFrRkJVeUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIHRpbWV1bml0XzEgPSByZXF1aXJlKFwiLi4vLi4vdGltZXVuaXRcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIFRpbWVVbml0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZVVuaXROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVVbml0Tm9kZShmb3JtdWxhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZvcm11bGEgPSBmb3JtdWxhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRpbWVVbml0Tm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZVVuaXROb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy5mb3JtdWxhKSk7XG4gICAgfTtcbiAgICBUaW1lVW5pdE5vZGUubWFrZSA9IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgZm9ybXVsYSA9IG1vZGVsLnJlZHVjZUZpZWxkRGVmKGZ1bmN0aW9uICh0aW1lVW5pdENvbXBvbmVudCwgZmllbGREZWYpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwgJiYgZmllbGREZWYudGltZVVuaXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYpO1xuICAgICAgICAgICAgICAgIHRpbWVVbml0Q29tcG9uZW50W2ZdID0ge1xuICAgICAgICAgICAgICAgICAgICBhczogZixcbiAgICAgICAgICAgICAgICAgICAgdGltZVVuaXQ6IGZpZWxkRGVmLnRpbWVVbml0LFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGREZWYuZmllbGRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVVbml0Q29tcG9uZW50O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhmb3JtdWxhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGltZVVuaXROb2RlKGZvcm11bGEpO1xuICAgIH07XG4gICAgVGltZVVuaXROb2RlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB0aGlzLmZvcm11bGEgPSB1dGlsXzEuZXh0ZW5kKHRoaXMuZm9ybXVsYSwgb3RoZXIuZm9ybXVsYSk7XG4gICAgICAgIG90aGVyLnJlbW92ZSgpO1xuICAgIH07XG4gICAgVGltZVVuaXROb2RlLnByb3RvdHlwZS5wcm9kdWNlZEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IHt9O1xuICAgICAgICB1dGlsXzEudmFscyh0aGlzLmZvcm11bGEpLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIG91dFtmLmFzXSA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgVGltZVVuaXROb2RlLnByb3RvdHlwZS5kZXBlbmRlbnRGaWVsZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSB7fTtcbiAgICAgICAgdXRpbF8xLnZhbHModGhpcy5mb3JtdWxhKS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBvdXRbZi5maWVsZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIFRpbWVVbml0Tm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEudmFscyh0aGlzLmZvcm11bGEpLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgICAgICAgICAgYXM6IGMuYXMsXG4gICAgICAgICAgICAgICAgZXhwcjogdGltZXVuaXRfMS5maWVsZEV4cHIoYy50aW1lVW5pdCwgYy5maWVsZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVVbml0Tm9kZTtcbn0oZGF0YWZsb3dfMS5EYXRhRmxvd05vZGUpKTtcbmV4cG9ydHMuVGltZVVuaXROb2RlID0gVGltZVVuaXROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEdsdFpYVnVhWFF1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5a1lYUmhMM1JwYldWMWJtbDBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3T3p0QlFVVkJMREpEUVVFclF6dEJRVU12UXl3eVEwRkJiVVE3UVVGRGJrUXNiVU5CUVc5RE8wRkJRM0JETEcxRFFVRnZSVHRCUVVsd1JTeDFRMEZCZDBNN1FVRlRlRU03U1VGQmEwTXNkME5CUVZrN1NVRkxOVU1zYzBKQlFXOUNMRTlCUVdkRE8xRkJRWEJFTEZsQlEwVXNhVUpCUVU4c1UwRkRVanRSUVVadFFpeGhRVUZQTEVkQlFWQXNUMEZCVHl4RFFVRjVRanM3U1VGRmNFUXNRMEZCUXp0SlFVNU5MRFJDUVVGTExFZEJRVm83VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4WlFVRlpMRU5CUVVNc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOdVJDeERRVUZETzBsQlRXRXNhVUpCUVVrc1IwRkJiRUlzVlVGQmJVSXNTMEZCV1R0UlFVTTNRaXhKUVVGTkxFOUJRVThzUjBGQlJ5eExRVUZMTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVVNc2FVSkJRVzlETEVWQlFVVXNVVUZCYTBJN1dVRkROVVlzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1MwRkJTeXhsUVVGUkxFbEJRVWtzVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM0JFTEVsQlFVMHNRMEZCUXl4SFFVRkhMR2RDUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdaMEpCUXpGQ0xHbENRVUZwUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSE8yOUNRVU55UWl4RlFVRkZMRVZCUVVVc1EwRkJRenR2UWtGRFRDeFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRkZCUVZFN2IwSkJRek5DTEV0QlFVc3NSVUZCUlN4UlFVRlJMRU5CUVVNc1MwRkJTenRwUWtGRGRFSXNRMEZCUXp0WlFVTktMRU5CUVVNN1dVRkRSQ3hOUVVGTkxFTkJRVU1zYVVKQlFXbENMRU5CUVVNN1VVRkRNMElzUTBGQlF5eEZRVUZGTEVWQlFUWkNMRU5CUVVNc1EwRkJRenRSUVVWc1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JETEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETEVsQlFVa3NXVUZCV1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRMjVETEVOQlFVTTdTVUZGVFN3MFFrRkJTeXhIUVVGYUxGVkJRV0VzUzBGQmJVSTdVVUZET1VJc1NVRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eGhRVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEYmtRc1MwRkJTeXhEUVVGRExFMUJRVTBzUlVGQlJTeERRVUZETzBsQlEycENMRU5CUVVNN1NVRkZUU3h4UTBGQll5eEhRVUZ5UWp0UlFVTkZMRWxCUVUwc1IwRkJSeXhIUVVGSExFVkJRVVVzUTBGQlF6dFJRVVZtTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNRMEZCUXp0WlFVTXhRaXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlFVVXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOdVFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVklMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03U1VGRFlpeERRVUZETzBsQlJVMHNjME5CUVdVc1IwRkJkRUk3VVVGRFJTeEpRVUZOTEVkQlFVY3NSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkZaaXhYUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFTkJRVU03V1VGRE1VSXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTTdVVUZEZEVJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRlNDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMGxCUTJJc1EwRkJRenRKUVVWTkxDdENRVUZSTEVkQlFXWTdVVUZEUlN4TlFVRk5MRU5CUVVNc1YwRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJRU3hEUVVGRE8xbEJRemRDTEUxQlFVMHNRMEZCUXp0blFrRkRUQ3hKUVVGSkxFVkJRVVVzVTBGQlV6dG5Ra0ZEWml4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRExFVkJRVVU3WjBKQlExSXNTVUZCU1N4RlFVRkZMRzlDUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRE8yRkJRMllzUTBGQlF6dFJRVU14UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRFNDeHRRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRXZSRVFzUTBGQmEwTXNkVUpCUVZrc1IwRXJSRGRETzBGQkwwUlpMRzlEUVVGWkluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHZlZ2FfdXRpbF8xID0gcmVxdWlyZShcInZlZ2EtdXRpbFwiKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWx0ZXJcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciB0cmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2Zvcm1cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZGF0YWZsb3dfMSA9IHJlcXVpcmUoXCIuL2RhdGFmbG93XCIpO1xudmFyIEZpbHRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEZpbHRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyTm9kZShmaWx0ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpbHRlck5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlck5vZGUodXRpbF8xLmR1cGxpY2F0ZSh0aGlzLmZpbHRlcikpO1xuICAgIH07XG4gICAgRmlsdGVyTm9kZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSAodmVnYV91dGlsXzEuaXNBcnJheSh0aGlzLmZpbHRlcikgPyB0aGlzLmZpbHRlciA6IFt0aGlzLmZpbHRlcl0pLmNvbmNhdCh2ZWdhX3V0aWxfMS5pc0FycmF5KG90aGVyLmZpbHRlcikgPyBvdGhlci5maWx0ZXIgOiBbb3RoZXIuZmlsdGVyXSk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfTtcbiAgICBGaWx0ZXJOb2RlLnByb3RvdHlwZS5hc3NlbWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgICAgICAgZXhwcjogZmlsdGVyXzEuZXhwcmVzc2lvbih0aGlzLmZpbHRlcilcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5GaWx0ZXJOb2RlID0gRmlsdGVyTm9kZTtcbi8qKlxuICogV2UgZG9uJ3Qga25vdyB3aGF0IGEgY2FsY3VsYXRlIG5vZGUgZGVwZW5kcyBvbiBzbyB3ZSBzaG91bGQgbmV2ZXIgbW92ZSBpdCBiZXlvbmQgYW55dGhpbmcgdGhhdCBwcm9kdWNlcyBmaWVsZHMuXG4gKi9cbnZhciBDYWxjdWxhdGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDYWxjdWxhdGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGN1bGF0ZU5vZGUodHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDYWxjdWxhdGVOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxjdWxhdGVOb2RlKHV0aWxfMS5kdXBsaWNhdGUodGhpcy50cmFuc2Zvcm0pKTtcbiAgICB9O1xuICAgIENhbGN1bGF0ZU5vZGUucHJvdG90eXBlLnByb2R1Y2VkRmllbGRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0ge307XG4gICAgICAgIG91dFt0aGlzLnRyYW5zZm9ybS5hc10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgQ2FsY3VsYXRlTm9kZS5wcm90b3R5cGUuYXNzZW1ibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZm9ybXVsYScsXG4gICAgICAgICAgICBleHByOiB0aGlzLnRyYW5zZm9ybS5jYWxjdWxhdGUsXG4gICAgICAgICAgICBhczogdGhpcy50cmFuc2Zvcm0uYXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxjdWxhdGVOb2RlO1xufShkYXRhZmxvd18xLkRhdGFGbG93Tm9kZSkpO1xuZXhwb3J0cy5DYWxjdWxhdGVOb2RlID0gQ2FsY3VsYXRlTm9kZTtcbi8qKlxuICogUGFyc2VzIGEgdHJhbnNmb3JtcyBhcnJheSBpbnRvIGEgY2hhaW4gb2YgY29ubmVjdGVkIGRhdGFmbG93IG5vZGVzLlxuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybUFycmF5KG1vZGVsKSB7XG4gICAgdmFyIGZpcnN0O1xuICAgIHZhciBsYXN0O1xuICAgIHZhciBub2RlO1xuICAgIHZhciBwcmV2aW91cztcbiAgICBtb2RlbC50cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybV8xLmlzQ2FsY3VsYXRlKHQpKSB7XG4gICAgICAgICAgICBub2RlID0gbmV3IENhbGN1bGF0ZU5vZGUodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtXzEuaXNGaWx0ZXIodCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgRmlsdGVyTm9kZSh0LmZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbnZhbGlkVHJhbnNmb3JtSWdub3JlZCh0KSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub2RlO1xuICAgIH0pO1xuICAgIGxhc3QgPSBub2RlO1xuICAgIHJldHVybiB7IGZpcnN0OiBmaXJzdCwgbGFzdDogbGFzdCB9O1xufVxuZXhwb3J0cy5wYXJzZVRyYW5zZm9ybUFycmF5ID0gcGFyc2VUcmFuc2Zvcm1BcnJheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRISmhibk5tYjNKdGN5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMlJoZEdFdmRISmhibk5tYjNKdGN5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDFRMEZCYTBNN1FVRkRiRU1zZFVOQlFXZEVPMEZCUTJoRUxDdENRVUZwUXp0QlFVTnFReXcyUTBGQk1rWTdRVUZETTBZc2JVTkJRWEZETzBGQlIzSkRMSFZEUVVGM1F6dEJRVWQ0UXp0SlFVRm5ReXh6UTBGQldUdEpRVXN4UXl4dlFrRkJiMElzVFVGQmVVSTdVVUZCTjBNc1dVRkRSU3hwUWtGQlR5eFRRVU5TTzFGQlJtMUNMRmxCUVUwc1IwRkJUaXhOUVVGTkxFTkJRVzFDT3p0SlFVVTNReXhEUVVGRE8wbEJUazBzTUVKQlFVc3NSMEZCV2p0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxGVkJRVlVzUTBGQlF5eG5Ra0ZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEyaEVMRU5CUVVNN1NVRk5UU3d3UWtGQlN5eEhRVUZhTEZWQlFXRXNTMEZCYVVJN1VVRkROVUlzU1VGQlNTeERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRzFDUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRM1pGTEcxQ1FVRlBMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVjZSQ3hKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWTkxEWkNRVUZSTEVkQlFXWTdVVUZEUlN4TlFVRk5MRU5CUVVNN1dVRkRUQ3hKUVVGSkxFVkJRVVVzVVVGQlVUdFpRVU5rTEVsQlFVa3NSVUZCUlN4dFFrRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTTdVMEZET1VJc1EwRkJRenRKUVVOS0xFTkJRVU03U1VGRFNDeHBRa0ZCUXp0QlFVRkVMRU5CUVVNc1FVRjBRa1FzUTBGQlowTXNkVUpCUVZrc1IwRnpRak5ETzBGQmRFSlpMR2REUVVGVk8wRkJkMEoyUWpzN1IwRkZSenRCUVVOSU8wbEJRVzFETEhsRFFVRlpPMGxCU3pkRExIVkNRVUZ2UWl4VFFVRTJRanRSUVVGcVJDeFpRVU5GTEdsQ1FVRlBMRk5CUTFJN1VVRkdiVUlzWlVGQlV5eEhRVUZVTEZOQlFWTXNRMEZCYjBJN08wbEJSV3BFTEVOQlFVTTdTVUZPVFN3MlFrRkJTeXhIUVVGYU8xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NZVUZCWVN4RFFVRkRMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRkRVFzUTBGQlF6dEpRVTFOTEhORFFVRmpMRWRCUVhKQ08xRkJRMFVzU1VGQlRTeEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRPMUZCUTJZc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRemxDTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN1NVRkRZaXhEUVVGRE8wbEJSVTBzWjBOQlFWRXNSMEZCWmp0UlFVTkZMRTFCUVUwc1EwRkJRenRaUVVOTUxFbEJRVWtzUlVGQlJTeFRRVUZUTzFsQlEyWXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV6dFpRVU01UWl4RlFVRkZMRVZCUVVVc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEZRVUZGTzFOQlEzUkNMRU5CUVVNN1NVRkRTaXhEUVVGRE8wbEJRMGdzYjBKQlFVTTdRVUZCUkN4RFFVRkRMRUZCZEVKRUxFTkJRVzFETEhWQ1FVRlpMRWRCYzBJNVF6dEJRWFJDV1N4elEwRkJZVHRCUVhkQ01VSTdPMGRCUlVjN1FVRkRTQ3cyUWtGQmIwTXNTMEZCV1R0SlFVTTVReXhKUVVGSkxFdEJRVzFDTEVOQlFVTTdTVUZEZUVJc1NVRkJTU3hKUVVGclFpeERRVUZETzBsQlEzWkNMRWxCUVVrc1NVRkJhMElzUTBGQlF6dEpRVU4yUWl4SlFVRkpMRkZCUVhOQ0xFTkJRVU03U1VGRk0wSXNTMEZCU3l4RFFVRkRMRlZCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlF5eERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTTFRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eDFRa0ZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU51UWl4SlFVRkpMRWRCUVVjc1NVRkJTU3hoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4dlFrRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhKUVVGSkxFZEJRVWNzU1VGQlNTeFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8xRkJRMnhETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXgxUWtGQmRVSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBFTEUxQlFVMHNRMEZCUXp0UlFVTlVMRU5CUVVNN1VVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOYUxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTTdVVUZEWml4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMRkZCUVZFc1EwRkJRenRSUVVONlFpeERRVUZETzFGQlEwUXNVVUZCVVN4SFFVRkhMRWxCUVVrc1EwRkJRenRKUVVOc1FpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVklMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU03U1VGRldpeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRTlCUVVFc1JVRkJSU3hKUVVGSkxFMUJRVUVzUlVGQlF5eERRVUZETzBGQlEzWkNMRU5CUVVNN1FVRXpRa1FzYTBSQk1rSkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vZGF0YVwiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vZmllbGRkZWZcIik7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uL2xvZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciB2ZWdhX3NjaGVtYV8xID0gcmVxdWlyZShcIi4uL3ZlZ2Euc2NoZW1hXCIpO1xudmFyIHBhcnNlXzEgPSByZXF1aXJlKFwiLi9heGlzL3BhcnNlXCIpO1xudmFyIHJ1bGVzXzEgPSByZXF1aXJlKFwiLi9heGlzL3J1bGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4vY29tbW9uXCIpO1xudmFyIGFzc2VtYmxlXzEgPSByZXF1aXJlKFwiLi9kYXRhL2Fzc2VtYmxlXCIpO1xudmFyIHBhcnNlXzIgPSByZXF1aXJlKFwiLi9kYXRhL3BhcnNlXCIpO1xudmFyIGxheW91dF8xID0gcmVxdWlyZShcIi4vbGF5b3V0XCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBpbml0XzEgPSByZXF1aXJlKFwiLi9zY2FsZS9pbml0XCIpO1xudmFyIHBhcnNlXzMgPSByZXF1aXJlKFwiLi9zY2FsZS9wYXJzZVwiKTtcbnZhciBGYWNldE1vZGVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGYWNldE1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZhY2V0TW9kZWwoc3BlYywgcGFyZW50LCBwYXJlbnRHaXZlbk5hbWUsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYXhlcyA9IHt9O1xuICAgICAgICBfdGhpcy5sZWdlbmRzID0ge307XG4gICAgICAgIF90aGlzLnN0YWNrID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3NwYWNpbmcgPSB7fTtcbiAgICAgICAgdmFyIGNoaWxkID0gX3RoaXMuY2hpbGQgPSBjb21tb25fMS5idWlsZE1vZGVsKHNwZWMuc3BlYywgX3RoaXMsIF90aGlzLmdldE5hbWUoJ2NoaWxkJyksIGNvbmZpZyk7XG4gICAgICAgIF90aGlzLmNoaWxkcmVuID0gW2NoaWxkXTtcbiAgICAgICAgdmFyIGZhY2V0ID0gX3RoaXMuZmFjZXQgPSBfdGhpcy5pbml0RmFjZXQoc3BlYy5mYWNldCk7XG4gICAgICAgIF90aGlzLnNjYWxlcyA9IF90aGlzLmluaXRTY2FsZXNBbmRTcGFjaW5nKGZhY2V0LCBfdGhpcy5jb25maWcpO1xuICAgICAgICBfdGhpcy5heGVzID0gX3RoaXMuaW5pdEF4aXMoZmFjZXQsIF90aGlzLmNvbmZpZywgY2hpbGQpO1xuICAgICAgICBfdGhpcy5sZWdlbmRzID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuaW5pdEZhY2V0ID0gZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgICAgIC8vIGNsb25lIHRvIHByZXZlbnQgc2lkZSBlZmZlY3QgdG8gdGhlIG9yaWdpbmFsIHNwZWNcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nXzEucmVkdWNlKGZhY2V0LCBmdW5jdGlvbiAobm9ybWFsaXplZEZhY2V0LCBmaWVsZERlZiwgY2hhbm5lbCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsXzEuY29udGFpbnMoW2NoYW5uZWxfMS5ST1csIGNoYW5uZWxfMS5DT0xVTU5dLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIC8vIERyb3AgdW5zdXBwb3J0ZWQgY2hhbm5lbFxuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmluY29tcGF0aWJsZUNoYW5uZWwoY2hhbm5lbCwgJ2ZhY2V0JykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRmFjZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBhcnJheSBvZiByb3cgLyBjb2x1bW4gP1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmLmZpZWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5lbXB0eUZpZWxkRGVmKGZpZWxkRGVmLCBjaGFubmVsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGYWNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgdHlwZSB0byBmdWxsLCBsb3dlcmNhc2UgdHlwZSwgb3IgYXVnbWVudCB0aGUgZmllbGREZWYgd2l0aCBhIGRlZmF1bHQgdHlwZSBpZiBtaXNzaW5nLlxuICAgICAgICAgICAgbm9ybWFsaXplZEZhY2V0W2NoYW5uZWxdID0gZmllbGRkZWZfMS5ub3JtYWxpemUoZmllbGREZWYsIGNoYW5uZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRGYWNldDtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuaW5pdFNjYWxlc0FuZFNwYWNpbmcgPSBmdW5jdGlvbiAoZmFjZXQsIGNvbmZpZykge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2NoYW5uZWxfMS5ST1csIGNoYW5uZWxfMS5DT0xVTU5dLnJlZHVjZShmdW5jdGlvbiAoX3NjYWxlLCBjaGFubmVsKSB7XG4gICAgICAgICAgICBpZiAoZmFjZXRbY2hhbm5lbF0pIHtcbiAgICAgICAgICAgICAgICBfc2NhbGVbY2hhbm5lbF0gPSBpbml0XzEuZGVmYXVsdChjaGFubmVsLCBmYWNldFtjaGFubmVsXSwgY29uZmlnLCB1bmRlZmluZWQsIC8vIEZhY2V0IGRvZXNuJ3QgaGF2ZSBvbmUgc2luZ2xlIG1hcmtcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIC8vIFRPRE8oIzE2NDcpOiBzdXBwb3J0IHdpZHRoIC8gaGVpZ2h0IGhlcmVcbiAgICAgICAgICAgICAgICBbXSAvLyBUaGVyZSBpcyBubyB4eVJhbmdlU3RlcHMgaGVyZSBhbmQgdGhlcmUgaXMgbm8gbmVlZCB0byBpbnB1dFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbW9kZWwuX3NwYWNpbmdbY2hhbm5lbF0gPSBzcGFjaW5nKGZhY2V0W2NoYW5uZWxdLnNjYWxlIHx8IHt9LCBtb2RlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc2NhbGU7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmluaXRBeGlzID0gZnVuY3Rpb24gKGZhY2V0LCBjb25maWcsIGNoaWxkKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbY2hhbm5lbF8xLlJPVywgY2hhbm5lbF8xLkNPTFVNTl0ucmVkdWNlKGZ1bmN0aW9uIChfYXhpcywgY2hhbm5lbCkge1xuICAgICAgICAgICAgaWYgKGZhY2V0W2NoYW5uZWxdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNTcGVjID0gZmFjZXRbY2hhbm5lbF0uYXhpcztcbiAgICAgICAgICAgICAgICBpZiAoYXhpc1NwZWMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBheGlzQ29uZmlnID0gY29uZmlnLmZhY2V0ICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmZhY2V0LmF4aXMgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5mYWNldC5heGlzIDoge307XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbEF4aXMgPSBfYXhpc1tjaGFubmVsXSA9IHRzbGliXzEuX19hc3NpZ24oe30sIGF4aXNTcGVjLCBheGlzQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ST1cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5QXhpcyA9IGNoaWxkLmF4aXMoY2hhbm5lbF8xLlkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHlBeGlzICYmIHlBeGlzLm9yaWVudCAhPT0gJ3JpZ2h0JyAmJiBtb2RlbEF4aXMub3JpZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEF4aXMub3JpZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbC5oYXNEZXNjZW5kYW50V2l0aEZpZWxkT25DaGFubmVsKGNoYW5uZWxfMS5YKSAmJiBtb2RlbEF4aXMubGFiZWxBbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxBeGlzLmxhYmVsQW5nbGUgPSBtb2RlbEF4aXMub3JpZW50ID09PSAncmlnaHQnID8gOTAgOiAyNzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2F4aXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmNoYW5uZWxIYXNGaWVsZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZmFjZXRbY2hhbm5lbF07XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5maWVsZERlZiA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0W2NoYW5uZWxdO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUucGFyc2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5kYXRhID0gcGFyc2VfMi5wYXJzZURhdGEodGhpcyk7XG4gICAgICAgIHRoaXMuY2hpbGQucGFyc2VEYXRhKCk7XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5wYXJzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogQGFydmluZCBjYW4gd3JpdGUgdGhpc1xuICAgICAgICAvLyBXZSBtaWdodCBuZWVkIHRvIHNwbGl0IHRoaXMgaW50byBjb21waWxlU2VsZWN0aW9uRGF0YSBhbmQgY29tcGlsZVNlbGVjdGlvblNpZ25hbHM/XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5wYXJzZUxheW91dERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucGFyc2VMYXlvdXREYXRhKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmxheW91dCA9IGxheW91dF8xLnBhcnNlRmFjZXRMYXlvdXQodGhpcyk7XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5wYXJzZVNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuICAgICAgICBjaGlsZC5wYXJzZVNjYWxlKCk7XG4gICAgICAgIC8vIEZpcnN0LCBhZGQgc2NhbGUgZm9yIHJvdyBhbmQgY29sdW1uLlxuICAgICAgICB2YXIgc2NhbGVDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudC5zY2FsZXMgPSBwYXJzZV8zLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIC8vIFRoZW4sIG1vdmUgc2hhcmVkL3VuaW9uIGZyb20gaXRzIGNoaWxkIHNwZWMuXG4gICAgICAgIHV0aWxfMS5rZXlzKGNoaWxkLmNvbXBvbmVudC5zY2FsZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgc2NhbGVcbiAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZU5hbWVXaXRob3V0UHJlZml4ID0gc2NhbGUubmFtZS5zdWJzdHIoY2hpbGQuZ2V0TmFtZSgnJykubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG1vZGVsLnNjYWxlTmFtZShzY2FsZU5hbWVXaXRob3V0UHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5yZW5hbWVTY2FsZShzY2FsZS5uYW1lLCBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICBzY2FsZS5uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBzY2FsZSBkb21haW4gd2l0aCBkYXRhIG91dHB1dCBmcm9tIGEgY2xvbmVkIHN1YnRyZWUgYWZ0ZXIgdGhlIGZhY2V0LlxuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG4gICAgICAgICAgICAgICAgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmRG9tYWluKGRvbWFpbikgfHwgdmVnYV9zY2hlbWFfMS5pc0ZpZWxkUmVmVW5pb25Eb21haW4oZG9tYWluKSkge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZGF0YSA9IGFzc2VtYmxlXzEuRkFDRVRfU0NBTEVfUFJFRklYICsgX3RoaXMuZ2V0TmFtZShkb21haW4uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmVW5pb25lZERvbWFpbihkb21haW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5maWVsZHMgPSBkb21haW4uZmllbGRzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIGYsIHsgZGF0YTogYXNzZW1ibGVfMS5GQUNFVF9TQ0FMRV9QUkVGSVggKyBfdGhpcy5nZXROYW1lKGYuZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIHB1dCBpbiBwYXJlbnQsIGp1c3QgcmVtb3ZlIHRoZSBjaGlsZCdzIHNjYWxlLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5jb21wb25lbnQuc2NhbGVzW2NoYW5uZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5wYXJzZU1hcmsoKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQubWFyayA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXROYW1lKCdjZWxsJyksXG4gICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb21wb25lbnQuZGF0YS5mYWNldFJvb3QuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwYnk6IFtdLmNvbmNhdCh0aGlzLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuUk9XKSA/IFt0aGlzLmZpZWxkKGNoYW5uZWxfMS5ST1cpXSA6IFtdLCB0aGlzLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuQ09MVU1OKSA/IFt0aGlzLmZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pXSA6IFtdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBnZXRGYWNldEdyb3VwUHJvcGVydGllcyh0aGlzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnBhcnNlQXhpcygpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5heGVzID0gcGFyc2VfMS5wYXJzZUF4aXNDb21wb25lbnQodGhpcywgW2NoYW5uZWxfMS5ST1csIGNoYW5uZWxfMS5DT0xVTU5dKTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlQXhpc0dyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiB3aXRoIG5lc3RpbmcsIHdlIG1pZ2h0IG5lZWQgdG8gY29uc2lkZXIgY2FsbGluZyBjaGlsZFxuICAgICAgICAvLyB0aGlzLmNoaWxkLnBhcnNlQXhpc0dyb3VwKCk7XG4gICAgICAgIHZhciB4QXhpc0dyb3VwID0gcGFyc2VBeGlzR3JvdXBzKHRoaXMsIGNoYW5uZWxfMS5YKTtcbiAgICAgICAgdmFyIHlBeGlzR3JvdXAgPSBwYXJzZUF4aXNHcm91cHModGhpcywgY2hhbm5lbF8xLlkpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5heGlzR3JvdXBzID0gdXRpbF8xLmV4dGVuZCh4QXhpc0dyb3VwID8geyB4OiB4QXhpc0dyb3VwIH0gOiB7fSwgeUF4aXNHcm91cCA/IHsgeTogeUF4aXNHcm91cCB9IDoge30pO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUucGFyc2VHcmlkR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IHdpdGggbmVzdGluZywgd2UgbWlnaHQgbmVlZCB0byBjb25zaWRlciBjYWxsaW5nIGNoaWxkXG4gICAgICAgIC8vIHRoaXMuY2hpbGQucGFyc2VHcmlkR3JvdXAoKTtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZDtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZ3JpZEdyb3VwcyA9IHV0aWxfMS5leHRlbmQoIWNoaWxkLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuWCkgJiYgdGhpcy5jaGFubmVsSGFzRmllbGQoY2hhbm5lbF8xLkNPTFVNTikgPyB7IGNvbHVtbjogZ2V0Q29sdW1uR3JpZEdyb3Vwcyh0aGlzKSB9IDoge30sICFjaGlsZC5jaGFubmVsSGFzRmllbGQoY2hhbm5lbF8xLlkpICYmIHRoaXMuY2hhbm5lbEhhc0ZpZWxkKGNoYW5uZWxfMS5ST1cpID8geyByb3c6IGdldFJvd0dyaWRHcm91cHModGhpcykgfSA6IHt9KTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnBhcnNlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnBhcnNlTGVnZW5kKCk7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgbGVnZW5kIGZvciBpbmRlcGVuZGVudCBub24tcG9zaXRpb24gc2NhbGUgYWNyb3NzIGZhY2V0c1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGxlZ2VuZCBmb3IgZmllbGQgcmVmZXJlbmNlIG9mIHBhcmVudCBkYXRhIChlLmcuLCBmb3IgU1BMT00pXG4gICAgICAgIC8vIEZvciBub3csIGFzc3VtaW5nIHRoYXQgbm9uLXBvc2l0aW9uYWwgc2NhbGVzIGFyZSBhbHdheXMgc2hhcmVkIGFjcm9zcyBmYWNldHNcbiAgICAgICAgLy8gVGh1cywganVzdCBtb3ZlIGFsbCBsZWdlbmRzIGZyb20gaXRzIGNoaWxkXG4gICAgICAgIHRoaXMuY29tcG9uZW50LmxlZ2VuZHMgPSB0aGlzLmNoaWxkLmNvbXBvbmVudC5sZWdlbmRzO1xuICAgICAgICB0aGlzLmNoaWxkLmNvbXBvbmVudC5sZWdlbmRzID0ge307XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXNzZW1ibGUgZGF0YSBpbiB0aGUgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlXzEuYXNzZW1ibGVEYXRhKHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmRhdGEuc291cmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2lnbmFscyA9IGZ1bmN0aW9uIChzaWduYWxzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTGF5b3V0ID0gZnVuY3Rpb24gKGxheW91dERhdGEpIHtcbiAgICAgICAgLy8gUG9zdGZpeCB0cmF2ZXJzYWwg4oCTIGxheW91dCBpcyBhc3NlbWJsZWQgYm90dG9tLXVwXG4gICAgICAgIHRoaXMuY2hpbGQuYXNzZW1ibGVMYXlvdXQobGF5b3V0RGF0YSk7XG4gICAgICAgIHJldHVybiBsYXlvdXRfMS5hc3NlbWJsZUxheW91dCh0aGlzLCBsYXlvdXREYXRhKTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlTWFya3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXNzZW1ibGVfMS5hc3NlbWJsZUZhY2V0RGF0YSh0aGlzLmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdCk7XG4gICAgICAgIHZhciBtYXJrID0gdGhpcy5jb21wb25lbnQubWFya1swXTtcbiAgICAgICAgLy8gY29ycmVjdCB0aGUgbmFtZSBvZiB0aGUgZmFjZXRlZCBkYXRhIHNvdXJjZVxuICAgICAgICBtYXJrLmZyb20uZmFjZXQubmFtZSA9IHRoaXMuY29tcG9uZW50LmRhdGEuZmFjZXRSb290Lm5hbWU7XG4gICAgICAgIG1hcmsuZnJvbS5mYWNldC5kYXRhID0gdGhpcy5jb21wb25lbnQuZGF0YS5mYWNldFJvb3QuZGF0YTtcbiAgICAgICAgdmFyIG1hcmtzID0gW10uY29uY2F0KFxuICAgICAgICAvLyBheGlzR3JvdXAgaXMgYSBtYXBwaW5nIHRvIFZnTWFya0dyb3VwXG4gICAgICAgIHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmF4aXNHcm91cHMpLCB1dGlsXzEuZmxhdHRlbih1dGlsXzEudmFscyh0aGlzLmNvbXBvbmVudC5ncmlkR3JvdXBzKSksIHV0aWxfMS5leHRlbmQobWFyaywgZGF0YS5sZW5ndGggPiAwID8geyBkYXRhOiBkYXRhIH0gOiB7fSwgdGhpcy5jaGlsZC5hc3NlbWJsZUdyb3VwKCkpKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzLm1hcCh0aGlzLmNvcnJlY3REYXRhTmFtZXMpO1xuICAgIH07XG4gICAgRmFjZXRNb2RlbC5wcm90b3R5cGUuY2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbY2hhbm5lbF8xLlJPVywgY2hhbm5lbF8xLkNPTFVNTl07XG4gICAgfTtcbiAgICBGYWNldE1vZGVsLnByb3RvdHlwZS5nZXRNYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWNldDtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLnNwYWNpbmcgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3BhY2luZ1tjaGFubmVsXTtcbiAgICB9O1xuICAgIEZhY2V0TW9kZWwucHJvdG90eXBlLmlzRmFjZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIEZhY2V0TW9kZWw7XG59KG1vZGVsXzEuTW9kZWwpKTtcbmV4cG9ydHMuRmFjZXRNb2RlbCA9IEZhY2V0TW9kZWw7XG5mdW5jdGlvbiBoYXNTdWJQbG90V2l0aFh5KG1vZGVsKSB7XG4gICAgcmV0dXJuIG1vZGVsLmhhc0Rlc2NlbmRhbnRXaXRoRmllbGRPbkNoYW5uZWwoJ3gnKSB8fFxuICAgICAgICBtb2RlbC5oYXNEZXNjZW5kYW50V2l0aEZpZWxkT25DaGFubmVsKCd5Jyk7XG59XG5leHBvcnRzLmhhc1N1YlBsb3RXaXRoWHkgPSBoYXNTdWJQbG90V2l0aFh5O1xuZnVuY3Rpb24gc3BhY2luZyhzY2FsZSwgbW9kZWwsIGNvbmZpZykge1xuICAgIGlmIChzY2FsZS5zcGFjaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlLnNwYWNpbmc7XG4gICAgfVxuICAgIGlmICghaGFzU3ViUGxvdFdpdGhYeShtb2RlbCkpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3VicGxvdCB3aXRoIHgveSwgaXQncyBhIHNpbXBsZSB0YWJsZSBzbyB0aGVyZSBzaG91bGQgYmUgbm8gc3BhY2luZy5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBjb25maWcuc2NhbGUuZmFjZXRTcGFjaW5nO1xufVxuZXhwb3J0cy5zcGFjaW5nID0gc3BhY2luZztcbmZ1bmN0aW9uIGdldEZhY2V0R3JvdXBQcm9wZXJ0aWVzKG1vZGVsKSB7XG4gICAgdmFyIGNoaWxkID0gbW9kZWwuY2hpbGQ7XG4gICAgdmFyIG1lcmdlZENlbGxDb25maWcgPSB1dGlsXzEuZXh0ZW5kKHt9LCBjaGlsZC5jb25maWcuY2VsbCwgY2hpbGQuY29uZmlnLmZhY2V0LmNlbGwpO1xuICAgIHJldHVybiB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgeDogbW9kZWwuY2hhbm5lbEhhc0ZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pID8ge1xuICAgICAgICAgICAgc2NhbGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuQ09MVU1OKSxcbiAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsXzEuQ09MVU1OKSxcbiAgICAgICAgICAgIC8vIG9mZnNldCBieSB0aGUgc3BhY2luZyAvIDJcbiAgICAgICAgICAgIG9mZnNldDogbW9kZWwuc3BhY2luZyhjaGFubmVsXzEuQ09MVU1OKSAvIDJcbiAgICAgICAgfSA6IHsgdmFsdWU6IG1vZGVsLmNvbmZpZy5zY2FsZS5mYWNldFNwYWNpbmcgLyAyIH0sXG4gICAgICAgIHk6IG1vZGVsLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsXzEuUk9XKSA/IHtcbiAgICAgICAgICAgIHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlJPVyksXG4gICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoY2hhbm5lbF8xLlJPVyksXG4gICAgICAgICAgICAvLyBvZmZzZXQgYnkgdGhlIHNwYWNpbmcgLyAyXG4gICAgICAgICAgICBvZmZzZXQ6IG1vZGVsLnNwYWNpbmcoY2hhbm5lbF8xLlJPVykgLyAyXG4gICAgICAgIH0gOiB7IHZhbHVlOiBtb2RlbC5jb25maWcuc2NhbGUuZmFjZXRTcGFjaW5nIC8gMiB9LFxuICAgICAgICB3aWR0aDogeyBmaWVsZDogeyBwYXJlbnQ6IG1vZGVsLmNoaWxkLnNpemVOYW1lKCd3aWR0aCcpIH0gfSxcbiAgICAgICAgaGVpZ2h0OiB7IGZpZWxkOiB7IHBhcmVudDogbW9kZWwuY2hpbGQuc2l6ZU5hbWUoJ2hlaWdodCcpIH0gfVxuICAgIH0sIGhhc1N1YlBsb3RXaXRoWHkobW9kZWwpID8gY2hpbGQuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMobWVyZ2VkQ2VsbENvbmZpZykgOiB7fSk7XG59XG4vLyBUT0RPOiBtb3ZlIHRoZSByZXN0IG9mIHRoZSBmaWxlIHNyYy9jb21waWxlL2ZhY2V0LyoudHNcbmZ1bmN0aW9uIHBhcnNlQXhpc0dyb3Vwcyhtb2RlbCwgY2hhbm5lbCkge1xuICAgIC8vIFRPRE86IGFkZCBhIGNhc2Ugd2hlcmUgaW5uZXIgc3BlYyBpcyBub3QgYSB1bml0IChmYWNldC9sYXllci9jb25jYXQpXG4gICAgdmFyIGF4aXNHcm91cCA9IG51bGw7XG4gICAgdmFyIGNoaWxkID0gbW9kZWwuY2hpbGQ7XG4gICAgaWYgKGNoaWxkLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsKSkge1xuICAgICAgICBpZiAoY2hpbGQuYXhpcyhjaGFubmVsKSkge1xuICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBncm91cCBmb3IgdGhlIHNoYXJlZCBheGVzXG4gICAgICAgICAgICAgICAgYXhpc0dyb3VwID0gZ2V0U2hhcmVkQXhpc0dyb3VwKG1vZGVsLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuYXhpcyhjaGFubmVsKSAmJiBydWxlc18xLmdyaWRTaG93KGNoaWxkLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaW5uZXIgYXhpcyAoYWthIGF4aXMgdGhhdCBzaG93cyBvbmx5IGdyaWQgdG8gKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXSA9IFtwYXJzZV8xLnBhcnNlR3JpZEF4aXMoY2hhbm5lbCwgY2hpbGQpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBleGlzdGluZyBjaGlsZCBheGVzXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgYXhlcyBzdXBwb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF4aXNHcm91cDtcbn1cbmZ1bmN0aW9uIGdldFNoYXJlZEF4aXNHcm91cChtb2RlbCwgY2hhbm5lbCkge1xuICAgIHZhciBpc1ggPSBjaGFubmVsID09PSAneCc7XG4gICAgdmFyIGZhY2V0Q2hhbm5lbCA9IGlzWCA/ICdjb2x1bW4nIDogJ3Jvdyc7XG4gICAgdmFyIGhhc0ZhY2V0ID0gISFtb2RlbC5mYWNldFtmYWNldENoYW5uZWxdO1xuICAgIHZhciBheGVzR3JvdXAgPSB7XG4gICAgICAgIG5hbWU6IG1vZGVsLmdldE5hbWUoY2hhbm5lbCArICctYXhlcycpLFxuICAgICAgICB0eXBlOiAnZ3JvdXAnXG4gICAgfTtcbiAgICBpZiAoaGFzRmFjZXQpIHtcbiAgICAgICAgLy8gTmVlZCB0byBkcml2ZSB0aGlzIHdpdGggc3BlY2lhbCBkYXRhIHNvdXJjZSB0aGF0IGhhcyBvbmUgaXRlbSBmb3IgZWFjaCBjb2x1bW4vcm93IHZhbHVlLlxuICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCBvbmx5IG5lZWQgdG8gZHJpdmUgdGhpcyB3aXRoIHNwZWNpYWwgZGF0YSBzb3VyY2UgaWYgdGhlcmUgYXJlIGJvdGggcm93IGFuZCBjb2x1bW5cbiAgICAgICAgLy8gSG93ZXZlciwgaXQgbWlnaHQgYmUgc2xpZ2h0bHkgZGlmZmljdWx0IGFzIHdlIGhhdmUgdG8gbWVyZ2UgdGhpcyB3aXRoIHRoZSBtYWluIGdyb3VwLlxuICAgICAgICBheGVzR3JvdXAuZnJvbSA9IHsgZGF0YTogY2hhbm5lbCA9PT0gJ3gnID8gbW9kZWwuZ2V0TmFtZSgnY29sdW1uJykgOiBtb2RlbC5nZXROYW1lKCdyb3cnKSB9O1xuICAgIH1cbiAgICBpZiAoaXNYKSB7XG4gICAgICAgIGF4ZXNHcm91cC5lbmNvZGUgPSB7XG4gICAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogeyBmaWVsZDogeyBwYXJlbnQ6IG1vZGVsLmNoaWxkLnNpemVOYW1lKCd3aWR0aCcpIH0gfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHsgZmllbGQ6IHsgZ3JvdXA6ICdoZWlnaHQnIH0gfSxcbiAgICAgICAgICAgICAgICB4OiBoYXNGYWNldCA/IHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuQ09MVU1OKSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG1vZGVsLmZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pLFxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgYnkgdGhlIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtb2RlbC5zcGFjaW5nKGNoYW5uZWxfMS5DT0xVTU4pIC8gMlxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9tIHNwYWNpbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgYnkgdGhlIHNwYWNpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1vZGVsLmNvbmZpZy5zY2FsZS5mYWNldFNwYWNpbmcgLyAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXhlc0dyb3VwLmVuY29kZSA9IHtcbiAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0gfSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHsgZmllbGQ6IHsgcGFyZW50OiBtb2RlbC5jaGlsZC5zaXplTmFtZSgnaGVpZ2h0JykgfSB9LFxuICAgICAgICAgICAgICAgIHk6IGhhc0ZhY2V0ID8ge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ST1cpLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoY2hhbm5lbF8xLlJPVyksXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBieSB0aGUgc3BhY2luZ1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1vZGVsLnNwYWNpbmcoY2hhbm5lbF8xLlJPVykgLyAyXG4gICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGJ5IHRoZSBzcGFjaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RlbC5jb25maWcuc2NhbGUuZmFjZXRTcGFjaW5nIC8gMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXhlc0dyb3VwLmF4ZXMgPSBbcGFyc2VfMS5wYXJzZU1haW5BeGlzKGNoYW5uZWwsIG1vZGVsLmNoaWxkKV07XG4gICAgcmV0dXJuIGF4ZXNHcm91cDtcbn1cbmV4cG9ydHMuZ2V0U2hhcmVkQXhpc0dyb3VwID0gZ2V0U2hhcmVkQXhpc0dyb3VwO1xuZnVuY3Rpb24gZ2V0Um93R3JpZEdyb3Vwcyhtb2RlbCkge1xuICAgIHZhciBmYWNldEdyaWRDb25maWcgPSBtb2RlbC5jb25maWcuZmFjZXQuZ3JpZDtcbiAgICB2YXIgcm93R3JpZCA9IHtcbiAgICAgICAgbmFtZTogbW9kZWwuZ2V0TmFtZSgncm93LWdyaWQnKSxcbiAgICAgICAgdHlwZTogJ3J1bGUnLFxuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICBkYXRhOiBtb2RlbC5nZXREYXRhTmFtZShkYXRhXzEuTUFJTilcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgICAgICB5OiB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlJPVyksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsXzEuUk9XKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeDogeyB2YWx1ZTogMCwgb2Zmc2V0OiAtZmFjZXRHcmlkQ29uZmlnLm9mZnNldCB9LFxuICAgICAgICAgICAgICAgIHgyOiB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0sIG9mZnNldDogZmFjZXRHcmlkQ29uZmlnLm9mZnNldCB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLmNvbG9yIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLm9wYWNpdHkgfSxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogeyB2YWx1ZTogMC41IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFtyb3dHcmlkLCB7XG4gICAgICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKCdyb3ctZ3JpZC1lbmQnKSxcbiAgICAgICAgICAgIHR5cGU6ICdydWxlJyxcbiAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgICAgICB5OiB7IGZpZWxkOiB7IGdyb3VwOiAnaGVpZ2h0JyB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHg6IHsgdmFsdWU6IDAsIG9mZnNldDogLWZhY2V0R3JpZENvbmZpZy5vZmZzZXQgfSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IHsgZmllbGQ6IHsgZ3JvdXA6ICd3aWR0aCcgfSwgb2Zmc2V0OiBmYWNldEdyaWRDb25maWcub2Zmc2V0IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLmNvbG9yIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHsgdmFsdWU6IGZhY2V0R3JpZENvbmZpZy5vcGFjaXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB7IHZhbHVlOiAwLjUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfV07XG59XG5mdW5jdGlvbiBnZXRDb2x1bW5HcmlkR3JvdXBzKG1vZGVsKSB7XG4gICAgdmFyIGZhY2V0R3JpZENvbmZpZyA9IG1vZGVsLmNvbmZpZy5mYWNldC5ncmlkO1xuICAgIHZhciBjb2x1bW5HcmlkID0ge1xuICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKCdjb2x1bW4tZ3JpZCcpLFxuICAgICAgICB0eXBlOiAncnVsZScsXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGRhdGE6IG1vZGVsLmdldERhdGFOYW1lKGRhdGFfMS5NQUlOKVxuICAgICAgICB9LFxuICAgICAgICBlbmNvZGU6IHtcbiAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuQ09MVU1OKSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IG1vZGVsLmZpZWxkKGNoYW5uZWxfMS5DT0xVTU4pXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5OiB7IHZhbHVlOiAwLCBvZmZzZXQ6IC1mYWNldEdyaWRDb25maWcub2Zmc2V0IH0sXG4gICAgICAgICAgICAgICAgeTI6IHsgZmllbGQ6IHsgZ3JvdXA6ICdoZWlnaHQnIH0sIG9mZnNldDogZmFjZXRHcmlkQ29uZmlnLm9mZnNldCB9LFxuICAgICAgICAgICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLmNvbG9yIH0sXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLm9wYWNpdHkgfSxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogeyB2YWx1ZTogMC41IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFtjb2x1bW5HcmlkLCB7XG4gICAgICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKCdjb2x1bW4tZ3JpZC1lbmQnKSxcbiAgICAgICAgICAgIHR5cGU6ICdydWxlJyxcbiAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgICAgICB4OiB7IGZpZWxkOiB7IGdyb3VwOiAnd2lkdGgnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgeTogeyB2YWx1ZTogMCwgb2Zmc2V0OiAtZmFjZXRHcmlkQ29uZmlnLm9mZnNldCB9LFxuICAgICAgICAgICAgICAgICAgICB5MjogeyBmaWVsZDogeyBncm91cDogJ2hlaWdodCcgfSwgb2Zmc2V0OiBmYWNldEdyaWRDb25maWcub2Zmc2V0IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZmFjZXRHcmlkQ29uZmlnLmNvbG9yIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHsgdmFsdWU6IGZhY2V0R3JpZENvbmZpZy5vcGFjaXR5IH0sXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiB7IHZhbHVlOiAwLjUgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqWlhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5bVlXTmxkQzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkRRU3h6UTBGQmMwUTdRVUZGZEVRc1owTkJRVFpDTzBGQlF6ZENMSGREUVVGdFF6dEJRVVZ1UXl4M1EwRkJaMFE3UVVGRmFFUXNORUpCUVRoQ08wRkJTVGxDTEdkRFFVRnZSVHRCUVVOd1JTdzRRMEZQZDBJN1FVRkRlRUlzYzBOQlFUaEZPMEZCUXpsRkxITkRRVUZ6UXp0QlFVTjBReXh0UTBGQmIwTTdRVUZEY0VNc05FTkJRVzlHTzBGQlEzQkdMSE5EUVVGMVF6dEJRVU4yUXl4dFEwRkJNRVE3UVVGRE1VUXNhVU5CUVRoQ08wRkJRemxDTEhGRFFVRnhRenRCUVVOeVF5eDFRMEZCWjBRN1FVRkhhRVE3U1VGQlowTXNjME5CUVVzN1NVRnhRbTVETEc5Q1FVRlpMRWxCUVdVc1JVRkJSU3hOUVVGaExFVkJRVVVzWlVGQmRVSXNSVUZCUlN4TlFVRmpPMUZCUVc1R0xGbEJRMFVzYTBKQlFVMHNTVUZCU1N4RlFVRkZMRTFCUVUwc1JVRkJSU3hsUVVGbExFVkJRVVVzVFVGQlRTeERRVUZETEZOQlV6ZERPMUZCZWtKclFpeFpRVUZOTEVkQlFXZENMRVZCUVVVc1EwRkJRenRSUVVWNlFpeFZRVUZKTEVkQlFXVXNSVUZCUlN4RFFVRkRPMUZCUlhSQ0xHRkJRVThzUjBGQmFVSXNSVUZCUlN4RFFVRkRPMUZCU1RsQ0xGZEJRVXNzUjBGQmIwSXNTVUZCU1N4RFFVRkRPMUZCUlRkQ0xHTkJRVkVzUjBGSGNrSXNSVUZCUlN4RFFVRkRPMUZCUzB3c1NVRkJUU3hMUVVGTExFZEJRVWtzUzBGQlNTeERRVUZETEV0QlFVc3NSMEZCUnl4dFFrRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVWQlFVVXNTMEZCU1N4RlFVRkZMRXRCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1VVRkRka1lzUzBGQlNTeERRVUZETEZGQlFWRXNSMEZCUnl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJSWGhDTEVsQlFVMHNTMEZCU3l4SFFVRkpMRXRCUVVrc1EwRkJReXhMUVVGTExFZEJRVWNzUzBGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGRrUXNTMEZCU1N4RFFVRkRMRTFCUVUwc1IwRkJTU3hMUVVGSkxFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1MwRkJTeXhGUVVGRkxFdEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTTNSQ3hMUVVGSkxFTkJRVU1zU1VGQlNTeEhRVUZMTEV0QlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhGUVVGRkxFdEJRVWtzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1VVRkRka1FzUzBGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4RlFVRkZMRU5CUVVNN08wbEJRM0JDTEVOQlFVTTdTVUZIVHl3NFFrRkJVeXhIUVVGcVFpeFZRVUZyUWl4TFFVRlpPMUZCUXpWQ0xHOUVRVUZ2UkR0UlFVTndSQ3hOUVVGTkxFTkJRVU1zYVVKQlFVMHNRMEZCUXl4TFFVRkxMRVZCUVVVc1ZVRkJVeXhsUVVGbExFVkJRVVVzVVVGQmEwSXNSVUZCUlN4UFFVRm5RanRaUVVOcVJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMR1ZCUVZFc1EwRkJReXhEUVVGRExHRkJRVWNzUlVGQlJTeG5Ra0ZCVFN4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjBReXd5UWtGQk1rSTdaMEpCUXpOQ0xFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETlVRc1RVRkJUU3hEUVVGRExHVkJRV1VzUTBGQlF6dFpRVU42UWl4RFFVRkRPMWxCUlVRc1owTkJRV2RETzFsQlEyaERMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFrTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdGQlFXRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZGtRc1RVRkJUU3hEUVVGRExHVkJRV1VzUTBGQlF6dFpRVU42UWl4RFFVRkRPMWxCUlVRc1owZEJRV2RITzFsQlEyaEhMR1ZCUVdVc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eHZRa0ZCVXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU40UkN4TlFVRk5MRU5CUVVNc1pVRkJaU3hEUVVGRE8xRkJRM3BDTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOVUxFTkJRVU03U1VGRlR5eDVRMEZCYjBJc1IwRkJOVUlzVlVGQk5rSXNTMEZCV1N4RlFVRkZMRTFCUVdNN1VVRkRka1FzU1VGQlRTeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eERRVUZETEdGQlFVY3NSVUZCUlN4blFrRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWTXNUVUZCVFN4RlFVRkZMRTlCUVU4N1dVRkRiRVFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtJc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEdOQlFWTXNRMEZEZWtJc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4TlFVRk5MRVZCUXk5Q0xGTkJRVk1zUlVGQlJTeHhRMEZCY1VNN1owSkJRMmhFTEZOQlFWTXNSVUZCUlN3eVEwRkJNa003WjBKQlEzUkVMRVZCUVVVc1EwRkJReXc0UkVGQk9FUTdhVUpCUTJ4RkxFTkJRVU03WjBKQlJVWXNTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUjBGQlJ5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeEZRVUZGTEVWQlFVVXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8xbEJReTlGTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRMmhDTEVOQlFVTXNSVUZCUlN4RlFVRkZMRU5CUVVNc1EwRkJRenRKUVVOVUxFTkJRVU03U1VGRlR5dzJRa0ZCVVN4SFFVRm9RaXhWUVVGcFFpeExRVUZaTEVWQlFVVXNUVUZCWXl4RlFVRkZMRXRCUVZrN1VVRkRla1FzU1VGQlRTeExRVUZMTEVkQlFVY3NTVUZCU1N4RFFVRkRPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eERRVUZETEdGQlFVY3NSVUZCUlN4blFrRkJUU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWTXNTMEZCU3l4RlFVRkZMRTlCUVU4N1dVRkRha1FzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtJc1NVRkJUU3hSUVVGUkxFZEJRVWNzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJRenRuUWtGRGNrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNaQ0xFbEJRVTBzVlVGQlZTeEhRVUZQTEUxQlFVMHNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhKUVVGSkxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRk5CUVZNc1IwRkJSU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSMEZCUnl4RlFVRkZMRU5CUVVNN2IwSkJRemRITEVsQlFVMHNVMEZCVXl4SFFVRkhMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zZDBKQlF6TkNMRkZCUVZFc1JVRkRVaXhWUVVGVkxFTkJRMlFzUTBGQlF6dHZRa0ZGUml4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzWVVGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRjRUlzU1VGQlRTeExRVUZMTEVkQlFWRXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhYUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZEYWtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1QwRkJUeXhKUVVGSkxGTkJRVk1zUTBGQlF5eE5RVUZOTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenMwUWtGRGVFVXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXhQUVVGUExFTkJRVU03ZDBKQlF6ZENMRU5CUVVNN2QwSkJRMFFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMQ3RDUVVFclFpeERRVUZETEZkQlFVTXNRMEZCUXl4SlFVRkpMRk5CUVZNc1EwRkJReXhWUVVGVkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXpzMFFrRkRia1lzVTBGQlV5eERRVUZETEZWQlFWVXNSMEZCUnl4VFFVRlRMRU5CUVVNc1RVRkJUU3hMUVVGTExFOUJRVThzUjBGQlJ5eEZRVUZGTEVkQlFVY3NSMEZCUnl4RFFVRkRPM2RDUVVOcVJTeERRVUZETzI5Q1FVTklMRU5CUVVNN1owSkJRMGdzUTBGQlF6dFpRVU5JTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8xRkJRMllzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVWTkxHOURRVUZsTEVkQlFYUkNMRlZCUVhWQ0xFOUJRV2RDTzFGQlEzSkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNdlFpeERRVUZETzBsQlJVMHNOa0pCUVZFc1IwRkJaaXhWUVVGblFpeFBRVUZuUWp0UlFVTTVRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlJVMHNPRUpCUVZNc1IwRkJhRUk3VVVGRFJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1IwRkJSeXhwUWtGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNSRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNN1NVRkRla0lzUTBGQlF6dEpRVVZOTEcxRFFVRmpMRWRCUVhKQ08xRkJRMFVzSzBKQlFTdENPMUZCUXk5Q0xIRkdRVUZ4Ump0SlFVTjJSaXhEUVVGRE8wbEJSVTBzYjBOQlFXVXNSMEZCZEVJN1VVRkRSU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEdWQlFXVXNSVUZCUlN4RFFVRkRPMUZCUXpkQ0xFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4SFFVRkhMSGxDUVVGblFpeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUTJwRUxFTkJRVU03U1VGRlRTd3JRa0ZCVlN4SFFVRnFRanRSUVVGQkxHbENRWE5EUXp0UlFYSkRReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTNwQ0xFbEJRVTBzUzBGQlN5eEhRVUZITEVsQlFVa3NRMEZCUXp0UlFVVnVRaXhMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZGTEVOQlFVTTdVVUZGYmtJc2RVTkJRWFZETzFGQlEzWkRMRWxCUVUwc1kwRkJZeXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4SFFVRkhMR1ZCUVcxQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZGZWtVc0swTkJRU3RETzFGQlF5OURMRmRCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGQkxFOUJRVTg3V1VGRE1VTXNPRU5CUVRoRE8xbEJRemxETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlExUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1kwRkJZeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzJkQ1FVVjRSU3hKUVVGTkxITkNRVUZ6UWl4SFFVRkhMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdaMEpCUXpORkxFbEJRVTBzVDBGQlR5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc2MwSkJRWE5DTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRemxFTEV0QlFVc3NRMEZCUXl4WFFVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0blFrRkRka01zUzBGQlN5eERRVUZETEVsQlFVa3NSMEZCUnl4UFFVRlBMRU5CUVVNN1owSkJSWEpDTEcxR1FVRnRSanRuUWtGRGJrWXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dG5Ra0ZGTlVJc1JVRkJSU3hEUVVGRExFTkJRVU1zTmtKQlFXVXNRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3h0UTBGQmNVSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6ZEVMRTFCUVUwc1EwRkJReXhKUVVGSkxFZEJRVWNzTmtKQlFXdENMRWRCUVVjc1MwRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJReTlFTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEc5RFFVRnpRaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRNVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZETEVOQlFWazdkMEpCUXpkRExFMUJRVTBzYzBKQlEwUXNRMEZCUXl4SlFVTktMRWxCUVVrc1JVRkJSU3cyUWtGQmEwSXNSMEZCUnl4TFFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZETDBNN2IwSkJRMG9zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTB3c1EwRkJRenRuUWtGRlJDeHhSRUZCY1VRN1owSkJRM0pFTEU5QlFVOHNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEZWtNc1EwRkJRenRSUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVVk5MRGhDUVVGVExFZEJRV2hDTzFGQlEwVXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFJRVVYyUWl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUjBGQlJ5eERRVUZETzJkQ1FVTnlRaXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNN1owSkJRekZDTEVsQlFVa3NSVUZCUlN4UFFVRlBPMmRDUVVOaUxFbEJRVWtzUlVGQlJUdHZRa0ZEU2l4TFFVRkxMRVZCUVVVN2QwSkJRMHdzU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTzNkQ1FVTjRReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWs3ZDBKQlEzaERMRTlCUVU4c1JVRkJSU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVU5vUWl4SlFVRkpMRU5CUVVNc1pVRkJaU3hEUVVGRExHRkJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhoUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSVUZEYkVRc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eG5Ra0ZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEdkQ1FVRk5MRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUTBGRGVrUTdjVUpCUTBZN2FVSkJRMFk3WjBKQlEwUXNUVUZCVFN4RlFVRkZPMjlDUVVOT0xFMUJRVTBzUlVGQlJTeDFRa0ZCZFVJc1EwRkJReXhKUVVGSkxFTkJRVU03YVVKQlEzUkRPMkZCUTBZc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZOTERoQ1FVRlRMRWRCUVdoQ08xRkJRMFVzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRSUVVOMlFpeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1IwRkJSeXd3UWtGQmEwSXNRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhoUVVGSExFVkJRVVVzWjBKQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRhRVVzUTBGQlF6dEpRVVZOTEcxRFFVRmpMRWRCUVhKQ08xRkJRMFVzT0VSQlFUaEVPMUZCUXpsRUxDdENRVUVyUWp0UlFVVXZRaXhKUVVGTkxGVkJRVlVzUjBGQlJ5eGxRVUZsTEVOQlFVTXNTVUZCU1N4RlFVRkZMRmRCUVVNc1EwRkJReXhEUVVGRE8xRkJRelZETEVsQlFVMHNWVUZCVlN4SFFVRkhMR1ZCUVdVc1EwRkJReXhKUVVGSkxFVkJRVVVzVjBGQlF5eERRVUZETEVOQlFVTTdVVUZGTlVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFZRVUZWTEVkQlFVY3NZVUZCVFN4RFFVTm9ReXhWUVVGVkxFZEJRVWNzUlVGQlF5eERRVUZETEVWQlFVVXNWVUZCVlN4RlFVRkRMRWRCUVVjc1JVRkJSU3hGUVVOcVF5eFZRVUZWTEVkQlFVY3NSVUZCUXl4RFFVRkRMRVZCUVVVc1ZVRkJWU3hGUVVGRExFZEJRVWNzUlVGQlJTeERRVU5zUXl4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVWTkxHMURRVUZqTEVkQlFYSkNPMUZCUTBVc09FUkJRVGhFTzFGQlF6bEVMQ3RDUVVFclFqdFJRVVV2UWl4SlFVRk5MRXRCUVVzc1IwRkJSeXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlJYcENMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVlVGQlZTeEhRVUZITEdGQlFVMHNRMEZEYUVNc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEZkQlFVTXNRMEZCUXl4SlFVRkpMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zWjBKQlFVMHNRMEZCUXl4SFFVRkhMRVZCUVVNc1RVRkJUU3hGUVVGRkxHMUNRVUZ0UWl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRExFZEJRVWNzUlVGQlJTeEZRVU53Unl4RFFVRkRMRXRCUVVzc1EwRkJReXhsUVVGbExFTkJRVU1zVjBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMR1ZCUVdVc1EwRkJReXhoUVVGSExFTkJRVU1zUjBGQlJ5eEZRVUZETEVkQlFVY3NSVUZCUlN4blFrRkJaMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUXl4SFFVRkhMRVZCUVVVc1EwRkROVVlzUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZGVFN4blEwRkJWeXhIUVVGc1FqdFJRVU5GTEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGRmVrSXNkMFZCUVhkRk8xRkJRM2hGTERSRlFVRTBSVHRSUVVVMVJTd3JSVUZCSzBVN1VVRkRMMFVzTmtOQlFUWkRPMUZCUXpkRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNUMEZCVHl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJSU3hEUVVGRE8wbEJRM0JETEVOQlFVTTdTVUZGVFN4cFEwRkJXU3hIUVVGdVFqdFJRVU5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtJc2FVTkJRV2xETzFsQlEycERMRTFCUVUwc1EwRkJReXgxUWtGQldTeERRVUZETEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFvc1EwRkJRenRKUVVWTkxHdEVRVUUyUWl4SFFVRndRenRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlUwc2IwTkJRV1VzUjBGQmRFSXNWVUZCZFVJc1QwRkJXVHRSUVVOcVF5eE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRPMGxCUTFvc1EwRkJRenRKUVVWTkxEQkRRVUZ4UWl4SFFVRTFRaXhWUVVFMlFpeEpRVUZqTzFGQlEzcERMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFdpeERRVUZETzBsQlJVMHNiVU5CUVdNc1IwRkJja0lzVlVGQmMwSXNWVUZCYjBJN1VVRkRlRU1zYjBSQlFXOUVPMUZCUTNCRUxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNZMEZCWXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRE8xRkJRM1JETEUxQlFVMHNRMEZCUXl4MVFrRkJZeXhEUVVGRExFbEJRVWtzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0SlFVTXhReXhEUVVGRE8wbEJSVTBzYTBOQlFXRXNSMEZCY0VJN1VVRkRSU3hKUVVGTkxFbEJRVWtzUjBGQlJ5dzBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVVNVJDeEpRVUZOTEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVndReXc0UTBGQk9FTTdVVUZET1VNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRNVVFzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRk1VUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1JVRkJSU3hEUVVGRExFMUJRVTA3VVVGRGNrSXNkME5CUVhkRE8xRkJRM2hETEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGVkJRVlVzUTBGQlF5eEZRVU12UWl4alFVRlBMRU5CUVVNc1YwRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1JVRkRlRU1zWVVGQlRTeERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUjBGQlJ5eEZRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRVZCUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4aFFVRmhMRVZCUVVVc1EwRkJReXhEUVVNNVJTeERRVUZETzFGQlJVWXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEdkQ1FVRm5RaXhEUVVGRExFTkJRVU03U1VGRE1VTXNRMEZCUXp0SlFVVk5MRFpDUVVGUkxFZEJRV1k3VVVGRFJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4aFFVRkhMRVZCUVVVc1owSkJRVTBzUTBGQlF5eERRVUZETzBsQlEzWkNMRU5CUVVNN1NVRkZVeXdyUWtGQlZTeEhRVUZ3UWp0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETzBsQlEzQkNMRU5CUVVNN1NVRkZUU3cwUWtGQlR5eEhRVUZrTEZWQlFXVXNUMEZCWjBJN1VVRkROMElzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGFFTXNRMEZCUXp0SlFVVk5MRFJDUVVGUExFZEJRV1E3VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVOSUxHbENRVUZETzBGQlFVUXNRMEZCUXl4QlFTOVNSQ3hEUVVGblF5eGhRVUZMTEVkQksxSndRenRCUVM5U1dTeG5RMEZCVlR0QlFXbFRka0lzTUVKQlFXbERMRXRCUVdsQ08wbEJRMmhFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc0swSkJRU3RDTEVOQlFVTXNSMEZCUnl4RFFVRkRPMUZCUXk5RExFdEJRVXNzUTBGQlF5d3JRa0ZCSzBJc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dEJRVU12UXl4RFFVRkRPMEZCU0VRc05FTkJSME03UVVGRlJDeHBRa0ZCZDBJc1MwRkJXU3hGUVVGRkxFdEJRV2xDTEVWQlFVVXNUVUZCWXp0SlFVTnlSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU03U1VGRGRrSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6ZENMSE5HUVVGelJqdFJRVU4wUml4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMWdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF6dEJRVU51UXl4RFFVRkRPMEZCVmtRc01FSkJWVU03UVVGRlJDeHBRMEZCYVVNc1MwRkJhVUk3U1VGRGFFUXNTVUZCVFN4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU14UWl4SlFVRk5MR2RDUVVGblFpeEhRVUZITEdGQlFVMHNRMEZCUXl4RlFVRkZMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZGYUVZc1RVRkJUU3hEUVVGRExHRkJRVTBzUTBGQlF6dFJRVU5XTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1pVRkJaU3hEUVVGRExHZENRVUZOTEVOQlFVTXNSMEZCUnp0WlFVTXZRaXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4blFrRkJUU3hEUVVGRE8xbEJRemxDTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExHZENRVUZOTEVOQlFVTTdXVUZETVVJc05FSkJRVFJDTzFsQlF6VkNMRTFCUVUwc1JVRkJSU3hMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEdkQ1FVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRE8xTkJRMnhETEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4SFFVRkhMRU5CUVVNc1JVRkJRenRSUVVWc1JDeERRVUZETEVWQlFVVXNTMEZCU3l4RFFVRkRMR1ZCUVdVc1EwRkJReXhoUVVGSExFTkJRVU1zUjBGQlJ6dFpRVU01UWl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eGhRVUZITEVOQlFVTTdXVUZETTBJc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNZVUZCUnl4RFFVRkRPMWxCUTNaQ0xEUkNRVUUwUWp0WlFVTTFRaXhOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4aFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRE8xTkJReTlDTEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4SFFVRkhMRU5CUVVNc1JVRkJRenRSUVVWb1JDeExRVUZMTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1JVRkJReXhOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFVkJRVU1zUlVGQlF6dFJRVU4yUkN4TlFVRk5MRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVTXNSVUZCUXp0TFFVTXhSQ3hGUVVORUxHZENRVUZuUWl4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5dzJRa0ZCTmtJc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4SFFVRkhMRVZCUVVVc1EwRkRja1lzUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZGUkN4NVJFRkJlVVE3UVVGRmVrUXNlVUpCUVhsQ0xFdEJRV2xDTEVWQlFVVXNUMEZCYTBJN1NVRkROVVFzZFVWQlFYVkZPMGxCUTNaRkxFbEJRVWtzVTBGQlV5eEhRVUZSTEVsQlFVa3NRMEZCUXp0SlFVVXhRaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUXpGQ0xFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNURMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlJWUXNhME5CUVd0RE8yZENRVU5zUXl4VFFVRlRMRWRCUVVjc2EwSkJRV3RDTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8yZENRVVV2UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMR2RDUVVGUkxFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGNFUXNjVVJCUVhGRU8yOUNRVU55UkN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4RFFVRkRMSEZDUVVGaExFTkJRVU1zVDBGQlR5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnhGTEVOQlFVTTdaMEpCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlEwNHNOa0pCUVRaQ08yOUNRVU0zUWl4UFFVRlBMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMmRDUVVOMlF5eERRVUZETzFsQlEwZ3NRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5PTERKRFFVRXlRenRaUVVNM1F5eERRVUZETzFGQlEwZ3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzBGQlEyNUNMRU5CUVVNN1FVRkhSQ3cwUWtGQmJVTXNTMEZCYVVJc1JVRkJSU3hQUVVGclFqdEpRVU4wUlN4SlFVRk5MRWRCUVVjc1IwRkJSeXhQUVVGUExFdEJRVXNzUjBGQlJ5eERRVUZGTzBsQlF6ZENMRWxCUVUwc1dVRkJXU3hIUVVGSExFZEJRVWNzUjBGQlJ5eFJRVUZSTEVkQlFVY3NTMEZCU3l4RFFVRkRPMGxCUXpWRExFbEJRVTBzVVVGQlVTeEhRVUZITEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETzBsQlJUZERMRWxCUVUwc1UwRkJVeXhIUVVGclFqdFJRVU12UWl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVkQlFVY3NUMEZCVHl4RFFVRkRPMUZCUTNSRExFbEJRVWtzUlVGQlJTeFBRVUZQTzB0QlEyUXNRMEZCUXp0SlFVVkdMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEWWl3eVJrRkJNa1k3VVVGRk0wWXNiVWRCUVcxSE8xRkJRMjVITEhkR1FVRjNSanRSUVVONFJpeFRRVUZUTEVOQlFVTXNTVUZCU1N4SFFVRkhMRVZCUVVNc1NVRkJTU3hGUVVGRkxFOUJRVThzUzBGQlN5eEhRVUZITEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhGUVVGRExFTkJRVU03U1VGRE5VWXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVWl4VFFVRlRMRU5CUVVNc1RVRkJUU3hIUVVGSE8xbEJRMnBDTEUxQlFVMHNSVUZCUlR0blFrRkRUaXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNSVUZCUXl4TlFVRk5MRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVNc1JVRkJRenRuUWtGRGRrUXNUVUZCVFN4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEZGQlFWRXNSVUZCUXl4RlFVRkRPMmRDUVVOc1F5eERRVUZETEVWQlFVVXNVVUZCVVN4SFFVRkhPMjlDUVVOYUxFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMR2RDUVVGTkxFTkJRVU03YjBKQlF6bENMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEdkQ1FVRk5MRU5CUVVNN2IwSkJRekZDTEhkQ1FVRjNRanR2UWtGRGVFSXNUVUZCVFN4RlFVRkZMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zWjBKQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNN2FVSkJRMnhETEVkQlFVYzdiMEpCUTBZc2IwTkJRVzlETzI5Q1FVTndReXgzUWtGQmQwSTdiMEpCUTNoQ0xFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhaUVVGWkxFZEJRVWNzUTBGQlF6dHBRa0ZETTBNN1lVRkRSanRUUVVOR0xFTkJRVU03U1VGRFNpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhUUVVGVExFTkJRVU1zVFVGQlRTeEhRVUZITzFsQlEycENMRTFCUVUwc1JVRkJSVHRuUWtGRFRpeExRVUZMTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZETEVWQlFVTTdaMEpCUTJoRExFMUJRVTBzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4RlFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJReXhGUVVGRE8yZENRVU42UkN4RFFVRkRMRVZCUVVVc1VVRkJVU3hIUVVGSE8yOUNRVU5hTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRVWNzUTBGQlF6dHZRa0ZETTBJc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNZVUZCUnl4RFFVRkRPMjlDUVVOMlFpeDNRa0ZCZDBJN2IwSkJRM2hDTEUxQlFVMHNSVUZCUlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExHRkJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTTdhVUpCUXk5Q0xFZEJRVWM3YjBKQlEwWXNkMEpCUVhkQ08yOUNRVU40UWl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4SFFVRkhMRU5CUVVNN2FVSkJRek5ETzJGQlEwWTdVMEZEUml4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVWRUxGTkJRVk1zUTBGQlF5eEpRVUZKTEVkQlFVY3NRMEZCUXl4eFFrRkJZU3hEUVVGRExFOUJRVThzUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOMlJDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMEZCUTI1Q0xFTkJRVU03UVVGMlJFUXNaMFJCZFVSRE8wRkJSMFFzTUVKQlFUQkNMRXRCUVZrN1NVRkRjRU1zU1VGQlRTeGxRVUZsTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeERRVUZETzBsQlJXaEVMRWxCUVUwc1QwRkJUeXhIUVVGSE8xRkJRMlFzU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJWU3hEUVVGRE8xRkJReTlDTEVsQlFVa3NSVUZCUlN4TlFVRk5PMUZCUTFvc1NVRkJTU3hGUVVGRk8xbEJRMG9zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4WFFVRlhMRU5CUVVNc1YwRkJTU3hEUVVGRE8xTkJRemxDTzFGQlEwUXNUVUZCVFN4RlFVRkZPMWxCUTA0c1RVRkJUU3hGUVVGRk8yZENRVU5PTEVOQlFVTXNSVUZCUlR0dlFrRkRSQ3hMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4aFFVRkhMRU5CUVVNN2IwSkJRek5DTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExHRkJRVWNzUTBGQlF6dHBRa0ZEZUVJN1owSkJRMFFzUTBGQlF5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eGxRVUZsTEVOQlFVTXNUVUZCVFN4RlFVRkRPMmRDUVVNNVF5eEZRVUZGTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZETEVWQlFVVXNUVUZCVFN4RlFVRkZMR1ZCUVdVc1EwRkJReXhOUVVGTkxFVkJRVU03WjBKQlF6ZEVMRTFCUVUwc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeGxRVUZsTEVOQlFVTXNTMEZCU3l4RlFVRkRPMmRDUVVOMFF5eGhRVUZoTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1pVRkJaU3hEUVVGRExFOUJRVThzUlVGQlF6dG5Ra0ZETDBNc1YwRkJWeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEVkQlFVY3NSVUZCUXp0aFFVTXhRanRUUVVOR08wdEJRMFlzUTBGQlF6dEpRVVZHTEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1JVRkJSVHRaUVVObUxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR05CUVdNc1EwRkJRenRaUVVOdVF5eEpRVUZKTEVWQlFVVXNUVUZCVFR0WlFVTmFMRTFCUVUwc1JVRkJSVHRuUWtGRFRpeE5RVUZOTEVWQlFVVTdiMEpCUTA0c1EwRkJReXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJReXhGUVVGRE8yOUNRVU0zUWl4RFFVRkRMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eEZRVUZGTEUxQlFVMHNSVUZCUlN4RFFVRkRMR1ZCUVdVc1EwRkJReXhOUVVGTkxFVkJRVU03YjBKQlF6bERMRVZCUVVVc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzWlVGQlpTeERRVUZETEUxQlFVMHNSVUZCUXp0dlFrRkROMFFzVFVGQlRTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMR1ZCUVdVc1EwRkJReXhMUVVGTExFVkJRVU03YjBKQlEzUkRMR0ZCUVdFc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeGxRVUZsTEVOQlFVTXNUMEZCVHl4RlFVRkRPMjlDUVVNdlF5eFhRVUZYTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1IwRkJSeXhGUVVGRE8ybENRVU14UWp0aFFVTkdPMU5CUTBZc1EwRkJReXhEUVVGRE8wRkJRMHdzUTBGQlF6dEJRVVZFTERaQ1FVRTJRaXhMUVVGWk8wbEJRM1pETEVsQlFVMHNaVUZCWlN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXp0SlFVVm9SQ3hKUVVGTkxGVkJRVlVzUjBGQlJ6dFJRVU5xUWl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eGhRVUZoTEVOQlFVTTdVVUZEYkVNc1NVRkJTU3hGUVVGRkxFMUJRVTA3VVVGRFdpeEpRVUZKTEVWQlFVVTdXVUZEU2l4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExGZEJRVmNzUTBGQlF5eFhRVUZKTEVOQlFVTTdVMEZET1VJN1VVRkRSQ3hOUVVGTkxFVkJRVVU3V1VGRFRpeE5RVUZOTEVWQlFVVTdaMEpCUTA0c1EwRkJReXhGUVVGRk8yOUNRVU5FTEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExHZENRVUZOTEVOQlFVTTdiMEpCUXpsQ0xFdEJRVXNzUlVGQlJTeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMR2RDUVVGTkxFTkJRVU03YVVKQlF6TkNPMmRDUVVORUxFTkJRVU1zUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1RVRkJUU3hGUVVGRkxFTkJRVU1zWlVGQlpTeERRVUZETEUxQlFVMHNSVUZCUXp0blFrRkRPVU1zUlVGQlJTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlF5eEZRVUZGTEUxQlFVMHNSVUZCUlN4bFFVRmxMRU5CUVVNc1RVRkJUU3hGUVVGRE8yZENRVU01UkN4TlFVRk5MRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzWlVGQlpTeERRVUZETEV0QlFVc3NSVUZCUXp0blFrRkRkRU1zWVVGQllTeEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMR1ZCUVdVc1EwRkJReXhQUVVGUExFVkJRVU03WjBKQlF5OURMRmRCUVZjc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeEhRVUZITEVWQlFVTTdZVUZETVVJN1UwRkRSanRMUVVOR0xFTkJRVU03U1VGRlJpeE5RVUZOTEVOQlFVTXNRMEZCUXl4VlFVRlZMRVZCUVVjN1dVRkRia0lzU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTTdXVUZEZEVNc1NVRkJTU3hGUVVGRkxFMUJRVTA3V1VGRFdpeE5RVUZOTEVWQlFVVTdaMEpCUTA0c1RVRkJUU3hGUVVGRk8yOUNRVU5PTEVOQlFVTXNSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVTXNSVUZCUXp0dlFrRkROVUlzUTBGQlF5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRU5CUVVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eGxRVUZsTEVOQlFVTXNUVUZCVFN4RlFVRkRPMjlDUVVNNVF5eEZRVUZGTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeEZRVUZETEVWQlFVVXNUVUZCVFN4RlFVRkZMR1ZCUVdVc1EwRkJReXhOUVVGTkxFVkJRVU03YjBKQlF6bEVMRTFCUVUwc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeGxRVUZsTEVOQlFVTXNTMEZCU3l4RlFVRkRPMjlDUVVOMFF5eGhRVUZoTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1pVRkJaU3hEUVVGRExFOUJRVThzUlVGQlF6dHZRa0ZETDBNc1YwRkJWeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEVkQlFVY3NSVUZCUXp0cFFrRkRNVUk3WVVGRFJqdFRRVU5HTEVOQlFVTXNRMEZCUXp0QlFVTk1MRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi9tYXJrXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIHZlZ2Ffc2NoZW1hXzEgPSByZXF1aXJlKFwiLi4vdmVnYS5zY2hlbWFcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG52YXIgYXNzZW1ibGVfMSA9IHJlcXVpcmUoXCIuL2RhdGEvYXNzZW1ibGVcIik7XG52YXIgcGFyc2VfMSA9IHJlcXVpcmUoXCIuL2RhdGEvcGFyc2VcIik7XG52YXIgbGF5b3V0XzEgPSByZXF1aXJlKFwiLi9sYXlvdXRcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGRvbWFpbl8xID0gcmVxdWlyZShcIi4vc2NhbGUvZG9tYWluXCIpO1xudmFyIExheWVyTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKExheWVyTW9kZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5ZXJNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBjb25maWcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNjYWxlcyA9IHt9O1xuICAgICAgICBfdGhpcy5heGVzID0ge307XG4gICAgICAgIF90aGlzLmxlZ2VuZHMgPSB7fTtcbiAgICAgICAgX3RoaXMuc3RhY2sgPSBudWxsO1xuICAgICAgICBfdGhpcy53aWR0aCA9IHNwZWMud2lkdGg7XG4gICAgICAgIF90aGlzLmhlaWdodCA9IHNwZWMuaGVpZ2h0O1xuICAgICAgICBfdGhpcy5jaGlsZHJlbiA9IHNwZWMubGF5ZXIubWFwKGZ1bmN0aW9uIChsYXllciwgaSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZVxuICAgICAgICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBtb2RlbCBoYXMgdG8gYmUgYSB1bml0IG1vZGVsIGJlY2F1c2Ugd2UgcGFzcyBpbiBhIHVuaXQgc3BlY1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmJ1aWxkTW9kZWwobGF5ZXIsIF90aGlzLCBfdGhpcy5nZXROYW1lKCdsYXllcl8nICsgaSksIGNvbmZpZyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmNoYW5uZWxIYXNGaWVsZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIC8vIGxheWVyIGRvZXMgbm90IGhhdmUgYW55IGNoYW5uZWxzXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmhhc0Rpc2NyZXRlU2NhbGUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAvLyBzaW5jZSB3ZSBhc3N1bWUgc2hhcmVkIHNjYWxlcyB3ZSBjYW4ganVzdCBhc2sgdGhlIGZpcnN0IGNoaWxkXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdLmhhc0Rpc2NyZXRlU2NhbGUoY2hhbm5lbCk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5maWVsZERlZiA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBsYXllciBkb2VzIG5vdCBoYXZlIGZpZWxkIGRlZnNcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZGF0YSA9IHBhcnNlXzEucGFyc2VEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZURhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5wYXJzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogQGFydmluZCBjYW4gd3JpdGUgdGhpc1xuICAgICAgICAvLyBXZSBtaWdodCBuZWVkIHRvIHNwbGl0IHRoaXMgaW50byBjb21waWxlU2VsZWN0aW9uRGF0YSBhbmQgY29tcGlsZVNlbGVjdGlvblNpZ25hbHM/XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5wYXJzZUxheW91dERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IGNvcnJlY3RseSB1bmlvbiBvcmRpbmFsIHNjYWxlcyByYXRoZXIgdGhhbiBqdXN0IHVzaW5nIHRoZSBsYXlvdXQgb2YgdGhlIGZpcnN0IGNoaWxkXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlTGF5b3V0RGF0YSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQubGF5b3V0ID0gbGF5b3V0XzEucGFyc2VMYXllckxheW91dCh0aGlzKTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICAgIHZhciBzY2FsZUNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50LnNjYWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZVNjYWxlKCk7XG4gICAgICAgICAgICAvLyBGSVhNRSgjMTYwMik6IGNvcnJlY3RseSBpbXBsZW1lbnQgaW5kZXBlbmRlbnQgc2NhbGVcbiAgICAgICAgICAgIC8vIEFsc28gbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBzY2FsZXMgYXJlIGFjdHVhbGx5IGNvbXBhdGlibGUsIGUuZy4gdXNlIHRoZSBzYW1lIHNvcnQgb3IgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmtleXMoY2hpbGQuY29tcG9uZW50LnNjYWxlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRTY2FsZSA9IGNoaWxkLmNvbXBvbmVudC5zY2FsZXNbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbFNjYWxlID0gc2NhbGVDb21wb25lbnRbY2hhbm5lbF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRTY2FsZSB8fCB2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKGNoaWxkU2NhbGUuZG9tYWluKSB8fCAobW9kZWxTY2FsZSAmJiB2ZWdhX3NjaGVtYV8xLmlzU2lnbmFsUmVmRG9tYWluKG1vZGVsU2NhbGUuZG9tYWluKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1lcmdlIHNpZ25hbCByZWYgZG9tYWluc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbFNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbFNjYWxlLmRvbWFpbiA9IGRvbWFpbl8xLnVuaW9uRG9tYWlucyhtb2RlbFNjYWxlLmRvbWFpbiwgY2hpbGRTY2FsZS5kb21haW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbmFtZSBjaGlsZCBzY2FsZSB0byBwYXJlbnQgc2NhbGVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZU5hbWVXaXRob3V0UHJlZml4ID0gY2hpbGRTY2FsZS5uYW1lLnN1YnN0cihjaGlsZC5nZXROYW1lKCcnKS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG1vZGVsLnNjYWxlTmFtZShzY2FsZU5hbWVXaXRob3V0UHJlZml4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVuYW1lU2NhbGUoY2hpbGRTY2FsZS5uYW1lLCBuZXdOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRTY2FsZS5uYW1lID0gbmV3TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG1lcmdlZCBzY2FsZXMgZnJvbSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGQuY29tcG9uZW50LnNjYWxlc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5wYXJzZU1hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlTWFyaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlQXhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF4aXNDb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudC5heGVzID0ge307XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcnNlQXhpcygpO1xuICAgICAgICAgICAgLy8gVE9ETzogY29ycmVjdGx5IGltcGxlbWVudCBpbmRlcGVuZGVudCBheGVzXG4gICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5rZXlzKGNoaWxkLmNvbXBvbmVudC5heGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgbXVsdGlwbGUgYXhlcyBmb3Igc2hhcmVkIHNjYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgdXNlIHRoZSBmaXJzdCBheGlzIGRlZmluaXRpb24gZm9yIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWF4aXNDb21wb25lbnRbY2hhbm5lbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQuYXhlc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlQXhpc0dyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlR3JpZEdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLnBhcnNlTGVnZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVnZW5kQ29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQubGVnZW5kcyA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJzZUxlZ2VuZCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogY29ycmVjdGx5IGltcGxlbWVudCBpbmRlcGVuZGVudCBheGVzXG4gICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5rZXlzKGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgdXNlIHRoZSBmaXJzdCBsZWdlbmQgZGVmaW5pdGlvbiBmb3IgZWFjaCBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVnZW5kQ29tcG9uZW50W2NoYW5uZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRDb21wb25lbnRbY2hhbm5lbF0gPSBjaGlsZC5jb21wb25lbnQubGVnZW5kc1tjaGFubmVsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmFzc2VtYmxlUGFyZW50R3JvdXBQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGNlbGxDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmFwcGx5Q29uZmlnKHt9LCBjZWxsQ29uZmlnLCBtYXJrXzEuRklMTF9TVFJPS0VfQ09ORklHLmNvbmNhdChbJ2NsaXAnXSkpO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTaWduYWxzID0gZnVuY3Rpb24gKHNpZ25hbHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTZWxlY3Rpb25EYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAvLyBvbmx5IGFzc2VtYmxlIGRhdGEgaW4gdGhlIHJvb3RcbiAgICAgICAgICAgIHJldHVybiBhc3NlbWJsZV8xLmFzc2VtYmxlRGF0YSh1dGlsXzEudmFscyh0aGlzLmNvbXBvbmVudC5kYXRhLnNvdXJjZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNjYWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29tYmluZSB3aXRoIHNjYWxlcyBmcm9tIGNoaWxkcmVuXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAoc2NhbGVzLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVzLmNvbmNhdChjLmFzc2VtYmxlU2NhbGVzKCkpO1xuICAgICAgICB9LCBfc3VwZXIucHJvdG90eXBlLmFzc2VtYmxlU2NhbGVzLmNhbGwodGhpcykpO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVMYXlvdXQgPSBmdW5jdGlvbiAobGF5b3V0RGF0YSkge1xuICAgICAgICAvLyBQb3N0Zml4IHRyYXZlcnNhbCDigJMgbGF5b3V0IGlzIGFzc2VtYmxlZCBib3R0b20tdXBcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYXNzZW1ibGVMYXlvdXQobGF5b3V0RGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGF5b3V0XzEuYXNzZW1ibGVMYXlvdXQodGhpcywgbGF5b3V0RGF0YSk7XG4gICAgfTtcbiAgICBMYXllck1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZU1hcmtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbmx5IGNoaWxkcmVuIGhhdmUgbWFya3NcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5mbGF0dGVuKHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmFzc2VtYmxlTWFya3MoKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuY2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIExheWVyTW9kZWwucHJvdG90eXBlLmdldE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGF5ZXJNb2RlbC5wcm90b3R5cGUuaXNMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gTGF5ZXJNb2RlbDtcbn0obW9kZWxfMS5Nb2RlbCkpO1xuZXhwb3J0cy5MYXllck1vZGVsID0gTGF5ZXJNb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJHRjVaWEl1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlzWVhsbGNpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGTFFTeG5RMEZCTWtNN1FVRkpNME1zWjBOQlFXdEVPMEZCUTJ4RUxEaERRVUZwUmp0QlFVVnFSaXh0UTBGQmFVUTdRVUZEYWtRc05FTkJRVFpETzBGQlF6ZERMSE5EUVVGMVF6dEJRVU4yUXl4dFEwRkJNRVE3UVVGRE1VUXNhVU5CUVRoQ08wRkJRemxDTEhsRFFVRTBRenRCUVVrMVF6dEpRVUZuUXl4elEwRkJTenRKUVRKQ2JrTXNiMEpCUVZrc1NVRkJaU3hGUVVGRkxFMUJRV0VzUlVGQlJTeGxRVUYxUWl4RlFVRkZMRTFCUVdNN1VVRkJia1lzV1VGRFJTeHJRa0ZCVFN4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxHVkJRV1VzUlVGQlJTeE5RVUZOTEVOQlFVTXNVMEZWTjBNN1VVRnVRMnRDTEZsQlFVMHNSMEZCWjBJc1JVRkJSU3hEUVVGRE8xRkJSWHBDTEZWQlFVa3NSMEZCWlN4RlFVRkZMRU5CUVVNN1VVRkZkRUlzWVVGQlR5eEhRVUZwUWl4RlFVRkZMRU5CUVVNN1VVRkpPVUlzVjBGQlN5eEhRVUZ2UWl4SlFVRkpMRU5CUVVNN1VVRnRRalZETEV0QlFVa3NRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dFJRVU40UWl4TFFVRkpMRU5CUVVNc1RVRkJUU3hIUVVGSExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZGTVVJc1MwRkJTU3hEUVVGRExGRkJRVkVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETzFsQlEzUkRMSEZEUVVGeFF6dFpRVU55UXl3clJVRkJLMFU3V1VGREwwVXNUVUZCVFN4RFFVRkRMRzFDUVVGVkxFTkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVa3NSVUZCUlN4TFFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUjBGQlJ5eERRVUZETEVOQlFVTXNSVUZCUlN4TlFVRk5MRU5CUVdNc1EwRkJRenRSUVVOc1JpeERRVUZETEVOQlFVTXNRMEZCUXpzN1NVRkRUQ3hEUVVGRE8wbEJSVTBzYjBOQlFXVXNSMEZCZEVJc1ZVRkJkVUlzVDBGQlowSTdVVUZEY2tNc2JVTkJRVzFETzFGQlEyNURMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRFppeERRVUZETzBsQlJVMHNjVU5CUVdkQ0xFZEJRWFpDTEZWQlFYZENMRTlCUVdkQ08xRkJRM1JETEdkRlFVRm5SVHRSUVVOb1JTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU53UkN4RFFVRkRPMGxCUlUwc05rSkJRVkVzUjBGQlppeFZRVUZuUWl4UFFVRm5RanRSUVVNNVFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc2FVTkJRV2xETzBsQlEyaEVMRU5CUVVNN1NVRkZUU3c0UWtGQlV5eEhRVUZvUWp0UlFVTkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zU1VGQlNTeEhRVUZITEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGRFTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlF5eExRVUZMTzFsQlF6RkNMRXRCUVVzc1EwRkJReXhUUVVGVExFVkJRVVVzUTBGQlF6dFJRVU53UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOTUxFTkJRVU03U1VGRlRTeHRRMEZCWXl4SFFVRnlRanRSUVVORkxDdENRVUVyUWp0UlFVTXZRaXh4UmtGQmNVWTdTVUZEZGtZc1EwRkJRenRKUVVWTkxHOURRVUZsTEVkQlFYUkNPMUZCUTBVc05FWkJRVFJHTzFGQlF6VkdMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVRXNTMEZCU3p0WlFVTjZRaXhMUVVGTExFTkJRVU1zWlVGQlpTeEZRVUZGTEVOQlFVTTdVVUZETVVJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFNDeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1IwRkJSeXg1UWtGQlowSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOcVJDeERRVUZETzBsQlJVMHNLMEpCUVZVc1IwRkJha0k3VVVGRFJTeEpRVUZOTEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNN1VVRkZia0lzU1VGQlRTeGpRVUZqTEVkQlFXdENMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeEhRVUZITEVWQlFVVXNRMEZCUXp0UlFVVnFSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRlRMRXRCUVVzN1dVRkRiRU1zUzBGQlN5eERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRPMWxCUlc1Q0xITkVRVUZ6UkR0WlFVTjBSQ3gxUjBGQmRVYzdXVUZEZGtjc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRWQ3hYUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlV5eFBRVUZQTzI5Q1FVTnVSQ3hKUVVGTkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dHZRa0ZEYmtRc1NVRkJUU3hWUVVGVkxFZEJRVWNzWTBGQll5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMjlDUVVVelF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRlZCUVZVc1NVRkJTU3dyUWtGQmFVSXNRMEZCUXl4VlFVRlZMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVsQlFVa3NLMEpCUVdsQ0xFTkJRVU1zVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU5vU0N4cFEwRkJhVU03ZDBKQlEycERMRTFCUVUwc1EwRkJRenR2UWtGRFZDeERRVUZETzI5Q1FVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTTdkMEpCUTJZc1ZVRkJWU3hEUVVGRExFMUJRVTBzUjBGQlJ5eHhRa0ZCV1N4RFFVRkRMRlZCUVZVc1EwRkJReXhOUVVGTkxFVkJRVVVzVlVGQlZTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMjlDUVVONlJTeERRVUZETzI5Q1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8zZENRVU5PTEdOQlFXTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhWUVVGVkxFTkJRVU03YjBKQlEzWkRMRU5CUVVNN2IwSkJSVVFzYzBOQlFYTkRPMjlDUVVOMFF5eEpRVUZOTEhOQ1FVRnpRaXhIUVVGSExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNN2IwSkJRMmhHTEVsQlFVMHNUMEZCVHl4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zYzBKQlFYTkNMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03YjBKQlF6bEVMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenR2UWtGRE5VTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU03YjBKQlJURkNMSEZEUVVGeFF6dHZRa0ZEY2tNc1QwRkJUeXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRuUWtGRGVrTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRUQ3hEUVVGRE8xRkJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVEN4RFFVRkRPMGxCUlUwc09FSkJRVk1zUjBGQmFFSTdVVUZEUlN4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZUTEV0QlFVczdXVUZEYkVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUlVGQlJTeERRVUZETzFGQlEzQkNMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZOTERoQ1FVRlRMRWRCUVdoQ08xRkJRMFVzU1VGQlRTeGhRVUZoTEVkQlFVY3NTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFZEJRVWNzUlVGQlJTeERRVUZETzFGQlJTOURMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWTXNTMEZCU3p0WlFVTnNReXhMUVVGTExFTkJRVU1zVTBGQlV5eEZRVUZGTEVOQlFVTTdXVUZGYkVJc05rTkJRVFpETzFsQlF6ZERMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTFRc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVk1zVDBGQlR6dHZRa0ZEYWtRc0swTkJRU3RETzI5Q1FVVXZReXh6UkVGQmMwUTdiMEpCUTNSRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dDNRa0ZETlVJc1lVRkJZU3hEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzI5Q1FVTjZSQ3hEUVVGRE8yZENRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTB3c1EwRkJRenRSUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVVk5MRzFEUVVGakxFZEJRWEpDTzFGQlEwVXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlRTeHRRMEZCWXl4SFFVRnlRanRSUVVORkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlUwc1owTkJRVmNzUjBGQmJFSTdVVUZEUlN4SlFVRk5MR1ZCUVdVc1IwRkJSeXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEU5QlFVOHNSMEZCUnl4RlFVRkZMRU5CUVVNN1VVRkZjRVFzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJVeXhMUVVGTE8xbEJRMnhETEV0QlFVc3NRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJRenRaUVVWd1FpdzJRMEZCTmtNN1dVRkROME1zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRFZDeFhRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCVXl4UFFVRlBPMjlDUVVOd1JDeDNSRUZCZDBRN2IwSkJRM2hFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1pVRkJaU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0M1FrRkRPVUlzWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMjlDUVVNNVJDeERRVUZETzJkQ1FVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMHdzUTBGQlF6dFJRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWTkxHdEVRVUUyUWl4SFFVRndReXhWUVVGeFF5eFZRVUZ6UWp0UlFVTjZSQ3hOUVVGTkxFTkJRVU1zYjBKQlFWY3NRMEZCUXl4RlFVRkZMRVZCUVVVc1ZVRkJWU3hGUVVGRkxIbENRVUZyUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTXhSU3hEUVVGRE8wbEJSVTBzYjBOQlFXVXNSMEZCZEVJc1ZVRkJkVUlzVDBGQll6dFJRVU51UXl4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZOTERCRFFVRnhRaXhIUVVFMVFpeFZRVUUyUWl4SlFVRmpPMUZCUTNwRExFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEV2l4RFFVRkRPMGxCUlUwc2FVTkJRVmtzUjBGQmJrSTdVVUZEUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJ4Q0xHbERRVUZwUXp0WlFVTnFReXhOUVVGTkxFTkJRVU1zZFVKQlFWa3NRMEZCUXl4WFFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlJDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVOYUxFTkJRVU03U1VGRlRTeHRRMEZCWXl4SFFVRnlRanRSUVVORkxHOURRVUZ2UXp0UlFVTndReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJReXhOUVVGTkxFVkJRVVVzUTBGQlF6dFpRVU53UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNZMEZCWXl4RlFVRkZMRU5CUVVNc1EwRkJRenRSUVVNelF5eERRVUZETEVWQlFVVXNhVUpCUVUwc1kwRkJZeXhYUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU0zUWl4RFFVRkRPMGxCUlUwc2JVTkJRV01zUjBGQmNrSXNWVUZCYzBJc1ZVRkJiMEk3VVVGRGVFTXNiMFJCUVc5RU8xRkJRM0JFTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUzBGQlN6dFpRVU14UWl4TFFVRkxMRU5CUVVNc1kwRkJZeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETzFGQlEyNURMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMGdzVFVGQlRTeERRVUZETEhWQ1FVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZUU3hyUTBGQllTeEhRVUZ3UWp0UlFVTkZMREpDUVVFeVFqdFJRVU16UWl4TlFVRk5MRU5CUVVNc1kwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1MwRkJTenRaUVVOeVF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMR0ZCUVdFc1JVRkJSU3hEUVVGRE8xRkJReTlDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUaXhEUVVGRE8wbEJSVTBzTmtKQlFWRXNSMEZCWmp0UlFVTkZMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU03U1VGRFdpeERRVUZETzBsQlJWTXNLMEpCUVZVc1IwRkJjRUk3VVVGRFJTeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWTkxEUkNRVUZQTEVkQlFXUTdVVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVU5JTEdsQ1FVRkRPMEZCUVVRc1EwRkJReXhCUVRGT1JDeERRVUZuUXl4aFFVRkxMRWRCTUU1d1F6dEJRVEZPV1N4blEwRkJWU0o5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vZGF0YVwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZW1ibGVMYXlvdXQobW9kZWwsIGxheW91dERhdGEpIHtcbiAgICB2YXIgbGF5b3V0Q29tcG9uZW50ID0gbW9kZWwuY29tcG9uZW50LmxheW91dDtcbiAgICBpZiAoIWxheW91dENvbXBvbmVudC53aWR0aCAmJiAhbGF5b3V0Q29tcG9uZW50LmhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5b3V0RGF0YTsgLy8gRG8gbm90aGluZ1xuICAgIH1cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICB2YXIgZGlzdGluY3RGaWVsZHMgPSB1dGlsXzEua2V5cyh1dGlsXzEuZXh0ZW5kKGxheW91dENvbXBvbmVudC53aWR0aC5kaXN0aW5jdCwgbGF5b3V0Q29tcG9uZW50LmhlaWdodC5kaXN0aW5jdCkpO1xuICAgICAgICB2YXIgZm9ybXVsYSA9IGxheW91dENvbXBvbmVudC53aWR0aC5mb3JtdWxhLmNvbmNhdChsYXlvdXRDb21wb25lbnQuaGVpZ2h0LmZvcm11bGEpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7IHR5cGU6ICdmb3JtdWxhJyB9LCBmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkaXN0aW5jdEZpZWxkcy5sZW5ndGggPiAwID8ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG1vZGVsLmdldE5hbWUoZGF0YV8xLkxBWU9VVCksXG4gICAgICAgICAgICAgICAgc291cmNlOiBtb2RlbC5sb29rdXBEYXRhU291cmNlKGxheW91dENvbXBvbmVudC53aWR0aC5zb3VyY2UgfHwgbGF5b3V0Q29tcG9uZW50LmhlaWdodC5zb3VyY2UpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiBkaXN0aW5jdEZpZWxkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogZGlzdGluY3RGaWVsZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuICdkaXN0aW5jdCc7IH0pXG4gICAgICAgICAgICAgICAgICAgIH1dLmNvbmNhdChmb3JtdWxhKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb2RlbC5nZXROYW1lKGRhdGFfMS5MQVlPVVQpLFxuICAgICAgICAgICAgICAgIHZhbHVlczogW3t9XSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGZvcm11bGFcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gRklYTUU6IGltcGxlbWVudFxuICAgIC8vIG90aGVyd2lzZSwgd2UgbmVlZCB0byBqb2luIHdpZHRoIGFuZCBoZWlnaHQgKGNyb3NzKVxufVxuZXhwb3J0cy5hc3NlbWJsZUxheW91dCA9IGFzc2VtYmxlTGF5b3V0O1xuLy8gRklYTUU6IGZvciBuZXN0aW5nIHggYW5kIHksIHdlIG5lZWQgdG8gZGVjbGFyZSB4LHkgbGF5b3V0IHNlcGFyYXRlbHkgYmVmb3JlIGpvaW5pbmcgbGF0ZXJcbi8vIEZvciBub3csIGxldCdzIGFsd2F5cyBhc3N1bWUgc2hhcmVkIHNjYWxlXG5mdW5jdGlvbiBwYXJzZVVuaXRMYXlvdXQobW9kZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcGFyc2VVbml0U2l6ZUxheW91dChtb2RlbCwgY2hhbm5lbF8xLlgpLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlVW5pdFNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWxfMS5ZKVxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlVW5pdExheW91dCA9IHBhcnNlVW5pdExheW91dDtcbmZ1bmN0aW9uIHBhcnNlVW5pdFNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgZGlzdGluY3QgPSBnZXREaXN0aW5jdChtb2RlbCwgY2hhbm5lbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiB1dGlsXzEua2V5cyhkaXN0aW5jdCkubGVuZ3RoID4gMCA/IG1vZGVsLmdldERhdGFOYW1lKGRhdGFfMS5NQUlOKSA6IG51bGwsXG4gICAgICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICAgICAgZm9ybXVsYTogW3tcbiAgICAgICAgICAgICAgICBhczogbW9kZWwuY2hhbm5lbFNpemVOYW1lKGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgIGV4cHI6IHVuaXRTaXplRXhwcihtb2RlbCwgY2hhbm5lbClcbiAgICAgICAgICAgIH1dXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuaXRTaXplRXhwcihtb2RlbCwgY2hhbm5lbCkge1xuICAgIHZhciBzY2FsZSA9IG1vZGVsLnNjYWxlKGNoYW5uZWwpO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZS50eXBlKSAmJiBzY2FsZS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBzcGVjIGhhcyB0b3AgbGV2ZWwgc2l6ZSBvciBzcGVjaWZpZWQgcmFuZ2VTdGVwID0gZml0LCBpdCB3aWxsIGJlIHVuZGVmaW5lZCBoZXJlLlxuICAgICAgICAgICAgdmFyIGNhcmRpbmFsaXR5ID0gY2FyZGluYWxpdHlFeHByKG1vZGVsLCBjaGFubmVsKTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nT3V0ZXIgPSBzY2FsZS5wYWRkaW5nT3V0ZXIgIT09IHVuZGVmaW5lZCA/IHNjYWxlLnBhZGRpbmdPdXRlciA6IHNjYWxlLnBhZGRpbmc7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ0lubmVyID0gc2NhbGUudHlwZSA9PT0gJ2JhbmQnID9cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGJhbmQgaGFzIHJlYWwgcGFkZGluZ0lubmVyXG4gICAgICAgICAgICAgICAgKHNjYWxlLnBhZGRpbmdJbm5lciAhPT0gdW5kZWZpbmVkID8gc2NhbGUucGFkZGluZ0lubmVyIDogc2NhbGUucGFkZGluZykgOlxuICAgICAgICAgICAgICAgIC8vIEZvciBwb2ludCwgYXMgY2FsY3VsYXRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLXNjYWxlL2Jsb2IvbWFzdGVyL3NyYy9iYW5kLmpzI0wxMjgsXG4gICAgICAgICAgICAgICAgLy8gaXQncyBlcXVpdmFsZW50IHRvIGhhdmUgcGFkZGluZ0lubmVyID0gMSBzaW5jZSB0aGVyZSBpcyBvbmx5IG4tMSBzdGVwcyBiZXR3ZWVuIG4gcG9pbnRzLlxuICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICB2YXIgc3BhY2UgPSBjYXJkaW5hbGl0eSArXG4gICAgICAgICAgICAgICAgKHBhZGRpbmdJbm5lciA/IFwiIC0gXCIgKyBwYWRkaW5nSW5uZXIgOiAnJykgK1xuICAgICAgICAgICAgICAgIChwYWRkaW5nT3V0ZXIgPyBcIiArIDIqXCIgKyBwYWRkaW5nT3V0ZXIgOiAnJyk7XG4gICAgICAgICAgICAvLyBUaGlzIGZvcm11bGEgaXMgZXF1aXZhbGVudCB0b1xuICAgICAgICAgICAgLy8gc3BhY2UgPSBjb3VudCAtIGlubmVyICsgb3V0ZXIgKiAyXG4gICAgICAgICAgICAvLyByYW5nZSA9IHJhbmdlU3RlcCAqIChzcGFjZSA+IDAgPyBzcGFjZSA6IDApXG4gICAgICAgICAgICAvLyBpbiBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWVuY29kZS9ibG9iL21hc3Rlci9zcmMvU2NhbGUuanMjTDExMlxuICAgICAgICAgICAgcmV0dXJuIFwibWF4KFwiICsgc3BhY2UgKyBcIiwgMCkgKiBcIiArIHNjYWxlLnJhbmdlU3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gbW9kZWwud2lkdGggOiBtb2RlbC5oZWlnaHQpICsgJyc7XG59XG5leHBvcnRzLnVuaXRTaXplRXhwciA9IHVuaXRTaXplRXhwcjtcbmZ1bmN0aW9uIHBhcnNlRmFjZXRMYXlvdXQobW9kZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcGFyc2VGYWNldFNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWxfMS5DT0xVTU4pLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlRmFjZXRTaXplTGF5b3V0KG1vZGVsLCBjaGFubmVsXzEuUk9XKVxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlRmFjZXRMYXlvdXQgPSBwYXJzZUZhY2V0TGF5b3V0O1xuZnVuY3Rpb24gcGFyc2VGYWNldFNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgY2hpbGRMYXlvdXRDb21wb25lbnQgPSBtb2RlbC5jaGlsZC5jb21wb25lbnQubGF5b3V0O1xuICAgIHZhciBzaXplVHlwZSA9IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ST1cgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIGNoaWxkU2l6ZUNvbXBvbmVudCA9IGNoaWxkTGF5b3V0Q29tcG9uZW50W3NpemVUeXBlXTtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICAvLyBGb3Igc2hhcmVkIHNjYWxlLCB3ZSBjYW4gc2ltcGx5IG1lcmdlIHRoZSBsYXlvdXQgaW50byBvbmUgZGF0YSBzb3VyY2VcbiAgICAgICAgdmFyIGRpc3RpbmN0ID0gdXRpbF8xLmV4dGVuZChnZXREaXN0aW5jdChtb2RlbCwgY2hhbm5lbCksIGNoaWxkU2l6ZUNvbXBvbmVudC5kaXN0aW5jdCk7XG4gICAgICAgIHZhciBmb3JtdWxhID0gY2hpbGRTaXplQ29tcG9uZW50LmZvcm11bGEuY29uY2F0KFt7XG4gICAgICAgICAgICAgICAgYXM6IG1vZGVsLmNoYW5uZWxTaXplTmFtZShjaGFubmVsKSxcbiAgICAgICAgICAgICAgICBleHByOiBmYWNldFNpemVGb3JtdWxhKG1vZGVsLCBjaGFubmVsLCBtb2RlbC5jaGlsZC5jaGFubmVsU2l6ZU5hbWUoY2hhbm5lbCkpXG4gICAgICAgICAgICB9XSk7XG4gICAgICAgIGRlbGV0ZSBjaGlsZExheW91dENvbXBvbmVudFtzaXplVHlwZV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IG1vZGVsLmdldERhdGFOYW1lKGRhdGFfMS5NQUlOKSxcbiAgICAgICAgICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICAgICAgICAgIGZvcm11bGE6IGZvcm11bGFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRklYTUUgaW1wbGVtZW50IGluZGVwZW5kZW50IHNjYWxlIGFzIHdlbGxcbiAgICAvLyBUT0RPOiAtIGFsc28gY29uc2lkZXIgd2hlbiBjaGlsZHJlbiBoYXZlIGRpZmZlcmVudCBkYXRhIHNvdXJjZVxufVxuZnVuY3Rpb24gZmFjZXRTaXplRm9ybXVsYShtb2RlbCwgY2hhbm5lbCwgaW5uZXJTaXplKSB7XG4gICAgaWYgKG1vZGVsLmNoYW5uZWxIYXNGaWVsZChjaGFubmVsKSkge1xuICAgICAgICByZXR1cm4gJyhkYXR1bVtcIicgKyBpbm5lclNpemUgKyAnXCJdICsgJyArIG1vZGVsLnNwYWNpbmcoY2hhbm5lbCkgKyAnKScgKyAnICogJyArIGNhcmRpbmFsaXR5RXhwcihtb2RlbCwgY2hhbm5lbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2RhdHVtW1wiJyArIGlubmVyU2l6ZSArICdcIl0gKyAnICsgbW9kZWwuY29uZmlnLnNjYWxlLmZhY2V0U3BhY2luZzsgLy8gbmVlZCB0byBhZGQgb3V0ZXIgcGFkZGluZyBmb3IgZmFjZXRcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUxheWVyTGF5b3V0KG1vZGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHBhcnNlTGF5ZXJTaXplTGF5b3V0KG1vZGVsLCBjaGFubmVsXzEuWCksXG4gICAgICAgIGhlaWdodDogcGFyc2VMYXllclNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWxfMS5ZKVxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlTGF5ZXJMYXlvdXQgPSBwYXJzZUxheWVyTGF5b3V0O1xuZnVuY3Rpb24gcGFyc2VMYXllclNpemVMYXlvdXQobW9kZWwsIGNoYW5uZWwpIHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgICAvLyBGb3Igc2hhcmVkIHNjYWxlLCB3ZSBjYW4gc2ltcGx5IG1lcmdlIHRoZSBsYXlvdXQgaW50byBvbmUgZGF0YSBzb3VyY2VcbiAgICAgICAgLy8gVE9ETzogZG9uJ3QganVzdCB0YWtlIHRoZSBsYXlvdXQgZnJvbSB0aGUgZmlyc3QgY2hpbGRcbiAgICAgICAgdmFyIGNoaWxkTGF5b3V0Q29tcG9uZW50ID0gbW9kZWwuY2hpbGRyZW5bMF0uY29tcG9uZW50LmxheW91dDtcbiAgICAgICAgdmFyIHNpemVUeXBlXzEgPSBjaGFubmVsID09PSBjaGFubmVsXzEuWSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgdmFyIGNoaWxkU2l6ZUNvbXBvbmVudCA9IGNoaWxkTGF5b3V0Q29tcG9uZW50W3NpemVUeXBlXzFdO1xuICAgICAgICB2YXIgZGlzdGluY3QgPSBjaGlsZFNpemVDb21wb25lbnQuZGlzdGluY3Q7XG4gICAgICAgIHZhciBmb3JtdWxhID0gW3tcbiAgICAgICAgICAgICAgICBhczogbW9kZWwuY2hhbm5lbFNpemVOYW1lKGNoYW5uZWwpLFxuICAgICAgICAgICAgICAgIGV4cHI6IGNoaWxkU2l6ZUNvbXBvbmVudC5mb3JtdWxhWzBdLmV4cHJcbiAgICAgICAgICAgIH1dO1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5sYXlvdXRbc2l6ZVR5cGVfMV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBtb2RlbC5nZXREYXRhTmFtZShkYXRhXzEuTUFJTiksXG4gICAgICAgICAgICBkaXN0aW5jdDogZGlzdGluY3QsXG4gICAgICAgICAgICBmb3JtdWxhOiBmb3JtdWxhXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGluY3QobW9kZWwsIGNoYW5uZWwpIHtcbiAgICBpZiAobW9kZWwuY2hhbm5lbEhhc0ZpZWxkKGNoYW5uZWwpICYmIG1vZGVsLmhhc0Rpc2NyZXRlU2NhbGUoY2hhbm5lbCkpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgICAgIGlmIChzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlLnR5cGUpICYmICEoc2NhbGUuZG9tYWluIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBpZiBleHBsaWNpdCBkb21haW4gaXMgZGVjbGFyZWQsIHVzZSBhcnJheSBsZW5ndGhcbiAgICAgICAgICAgIHZhciBkaXN0aW5jdEZpZWxkID0gbW9kZWwuZmllbGQoY2hhbm5lbCk7XG4gICAgICAgICAgICB2YXIgZGlzdGluY3QgPSB7fTtcbiAgICAgICAgICAgIGRpc3RpbmN0W2Rpc3RpbmN0RmllbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBkaXN0aW5jdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBjYXJkaW5hbGl0eUV4cHIobW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgc2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsKTtcbiAgICBpZiAoc2NhbGUuZG9tYWluIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbi5sZW5ndGggKyAnJztcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmZpZWxkKGNoYW5uZWwsIHsgZGF0dW06IHRydWUsIHByZWZpeDogJ2Rpc3RpbmN0JyB9KTtcbn1cbmV4cG9ydHMuY2FyZGluYWxpdHlFeHByID0gY2FyZGluYWxpdHlFeHByO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYkdGNWIzVjBMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZiR0Y1YjNWMExuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVOQkxITkRRVUZ6UkR0QlFVTjBSQ3huUTBGQmNVTTdRVUZEY2tNc2EwTkJRVEpETzBGQlF6TkRMR2REUVVGblJEdEJRU3RDYUVRc2QwSkJRU3RDTEV0QlFWa3NSVUZCUlN4VlFVRnZRanRKUVVNdlJDeEpRVUZOTEdWQlFXVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU12UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4bFFVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4wUkN4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zWVVGQllUdEpRVU5zUXl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTlVMRWxCUVUwc1kwRkJZeXhIUVVGSExGZEJRVWtzUTBGQlF5eGhRVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRXRCUVVzc1EwRkJReXhSUVVGUkxFVkJRVVVzWlVGQlpTeERRVUZETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM0pITEVsQlFVMHNUMEZCVHl4SFFVRkhMR1ZCUVdVc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4bFFVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dGhRVU5xUml4SFFVRkhMRU5CUVVNc1ZVRkJRU3hEUVVGRE8xbEJRMG9zVFVGQlRTeERRVUZETEcxQ1FVTk1MRWxCUVVrc1JVRkJSU3hUUVVGVExFbEJRMW9zUTBGQlF5eERRVU5wUWl4RFFVRkRPMUZCUXpGQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJVd3NUVUZCVFN4RFFVRkRPMWxCUTB3c1kwRkJZeXhEUVVGRExFMUJRVTBzUjBGQlJ5eERRVUZETEVkQlFVYzdaMEpCUXpGQ0xFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVUwc1EwRkJRenRuUWtGRE0wSXNUVUZCVFN4RlFVRkZMRXRCUVVzc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4bFFVRmxMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzU1VGQlNTeGxRVUZsTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJRenRuUWtGRE4wWXNVMEZCVXl4RlFVRkZMRU5CUVVNN2QwSkJRMVlzU1VGQlNTeEZRVUZGTEZkQlFWYzdkMEpCUTJwQ0xFMUJRVTBzUlVGQlJTeGpRVUZqTzNkQ1FVTjBRaXhIUVVGSExFVkJRVVVzWTBGQll5eERRVUZETEVkQlFVY3NRMEZCUXl4alFVRk5MRTlCUVVFc1ZVRkJWU3hGUVVGV0xFTkJRVlVzUTBGQlF6dHhRa0ZETTBJc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdZVUZEYkVNc1IwRkJSenRuUWtGRFJpeEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhoUVVGTkxFTkJRVU03WjBKQlF6TkNMRTFCUVUwc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF6dG5Ra0ZEV2l4VFFVRlRMRVZCUVVVc1QwRkJUenRoUVVOdVFqdFRRVU5HTEVOQlFVTTdTVUZEU2l4RFFVRkRPMGxCUTBRc2JVSkJRVzFDTzBsQlEyNUNMSE5FUVVGelJEdEJRVU40UkN4RFFVRkRPMEZCYkVORUxIZERRV3REUXp0QlFVVkVMRFJHUVVFMFJqdEJRVU0xUml3MFEwRkJORU03UVVGRE5VTXNlVUpCUVdkRExFdEJRV2RDTzBsQlF6bERMRTFCUVUwc1EwRkJRenRSUVVOTUxFdEJRVXNzUlVGQlJTeHRRa0ZCYlVJc1EwRkJReXhMUVVGTExFVkJRVVVzVjBGQlF5eERRVUZETzFGQlEzQkRMRTFCUVUwc1JVRkJSU3h0UWtGQmJVSXNRMEZCUXl4TFFVRkxMRVZCUVVVc1YwRkJReXhEUVVGRE8wdEJRM1JETEVOQlFVTTdRVUZEU2l4RFFVRkRPMEZCVEVRc01FTkJTME03UVVGRlJDdzJRa0ZCTmtJc1MwRkJaMElzUlVGQlJTeFBRVUZuUWp0SlFVTTNSQ3hKUVVGTkxGRkJRVkVzUjBGQlJ5eFhRVUZYTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJSVGRETEUxQlFVMHNRMEZCUXp0UlFVTk1MRTFCUVUwc1JVRkJSU3hYUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETEZkQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrN1VVRkRiRVVzVVVGQlVTeFZRVUZCTzFGQlExSXNUMEZCVHl4RlFVRkZMRU5CUVVNN1owSkJRMUlzUlVGQlJTeEZRVUZGTEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1QwRkJUeXhEUVVGRE8yZENRVU5zUXl4SlFVRkpMRVZCUVVVc1dVRkJXU3hEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTTdZVUZEYmtNc1EwRkJRenRMUVVOSUxFTkJRVU03UVVGRFNpeERRVUZETzBGQlJVUXNjMEpCUVRaQ0xFdEJRV2RDTEVWQlFVVXNUMEZCWjBJN1NVRkROMFFzU1VGQlRTeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU51UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJWWXNSVUZCUlN4RFFVRkRMRU5CUVVNc2VVSkJRV2xDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNKRUxEQkdRVUV3Ump0WlFVVXhSaXhKUVVGTkxGZEJRVmNzUjBGQlJ5eGxRVUZsTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xbEJRM0JFTEVsQlFVMHNXVUZCV1N4SFFVRkhMRXRCUVVzc1EwRkJReXhaUVVGWkxFdEJRVXNzVTBGQlV5eEhRVUZITEV0QlFVc3NRMEZCUXl4WlFVRlpMRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF6dFpRVU16Uml4SlFVRk5MRmxCUVZrc1IwRkJSeXhMUVVGTExFTkJRVU1zU1VGQlNTeExRVUZMTEUxQlFVMDdaMEpCUTNoRExHdERRVUZyUXp0blFrRkRiRU1zUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4TFFVRkxMRk5CUVZNc1IwRkJSeXhMUVVGTExFTkJRVU1zV1VGQldTeEhRVUZITEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNN1owSkJRM1pGTEN0R1FVRXJSanRuUWtGREwwWXNNa1pCUVRKR08yZENRVU16Uml4RFFVRkRMRU5CUVVNN1dVRkZTaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eFhRVUZYTzJkQ1FVTjJRaXhEUVVGRExGbEJRVmtzUjBGQlJ5eFJRVUZOTEZsQlFXTXNSMEZCUnl4RlFVRkZMRU5CUVVNN1owSkJRekZETEVOQlFVTXNXVUZCV1N4SFFVRkhMRlZCUVZFc1dVRkJZeXhIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFsQlJTOURMR2REUVVGblF6dFpRVU5vUXl4dlEwRkJiME03V1VGRGNFTXNPRU5CUVRoRE8xbEJRemxETEhWRlFVRjFSVHRaUVVOMlJTeE5RVUZOTEVOQlFVTXNVMEZCVHl4TFFVRkxMR1ZCUVZVc1MwRkJTeXhEUVVGRExGTkJRVmNzUTBGQlF6dFJRVU5xUkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExFdEJRVXNzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRE8wRkJRek5FTEVOQlFVTTdRVUUxUWtRc2IwTkJORUpETzBGQlJVUXNNRUpCUVdsRExFdEJRV2xDTzBsQlEyaEVMRTFCUVUwc1EwRkJRenRSUVVOTUxFdEJRVXNzUlVGQlJTeHZRa0ZCYjBJc1EwRkJReXhMUVVGTExFVkJRVVVzWjBKQlFVMHNRMEZCUXp0UlFVTXhReXhOUVVGTkxFVkJRVVVzYjBKQlFXOUNMRU5CUVVNc1MwRkJTeXhGUVVGRkxHRkJRVWNzUTBGQlF6dExRVU42UXl4RFFVRkRPMEZCUTBvc1EwRkJRenRCUVV4RUxEUkRRVXRETzBGQlJVUXNPRUpCUVRoQ0xFdEJRV2xDTEVWQlFVVXNUMEZCWjBJN1NVRkRMMFFzU1VGQlRTeHZRa0ZCYjBJc1IwRkJSeXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRNVVFzU1VGQlRTeFJRVUZSTEVkQlFVY3NUMEZCVHl4TFFVRkxMR0ZCUVVjc1IwRkJSeXhSUVVGUkxFZEJRVWNzVDBGQlR5eERRVUZETzBsQlEzUkVMRWxCUVUwc2EwSkJRV3RDTEVkQlFXdENMRzlDUVVGdlFpeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRPMGxCUlhwRkxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRWQ3gzUlVGQmQwVTdVVUZGZUVVc1NVRkJUU3hSUVVGUkxFZEJRVWNzWVVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRExFVkJRVVVzYTBKQlFXdENMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRGJFWXNTVUZCVFN4UFFVRlBMRWRCUVVjc2EwSkJRV3RDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRE8yZENRVU5xUkN4RlFVRkZMRVZCUVVVc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eFBRVUZQTEVOQlFVTTdaMEpCUTJ4RExFbEJRVWtzUlVGQlJTeG5Ra0ZCWjBJc1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1pVRkJaU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzJGQlF6ZEZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVW9zVDBGQlR5eHZRa0ZCYjBJc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU4wUXl4TlFVRk5MRU5CUVVNN1dVRkRUQ3hOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEZkQlFWY3NRMEZCUXl4WFFVRkpMRU5CUVVNN1dVRkRMMElzVVVGQlVTeEZRVUZGTEZGQlFWRTdXVUZEYkVJc1QwRkJUeXhGUVVGRkxFOUJRVTg3VTBGRGFrSXNRMEZCUXp0SlFVTktMRU5CUVVNN1NVRkRSQ3cwUTBGQk5FTTdTVUZETlVNc2FVVkJRV2xGTzBGQlEyNUZMRU5CUVVNN1FVRkZSQ3d3UWtGQk1FSXNTMEZCYVVJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEZOQlFXbENPMGxCUXpsRkxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4bFFVRmxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNURMRTFCUVUwc1EwRkJReXhWUVVGVkxFZEJRVWNzVTBGQlV5eEhRVUZITEU5QlFVOHNSMEZCUnl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEVkQlFVY3NSMEZCUnl4TFFVRkxMRWRCUVVjc1pVRkJaU3hEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTnVTQ3hEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4TlFVRk5MRU5CUVVNc1UwRkJVeXhIUVVGSExGTkJRVk1zUjBGQlJ5eFBRVUZQTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zV1VGQldTeERRVUZETEVOQlFVTXNjME5CUVhORE8wbEJRMnhJTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUlVRc01FSkJRV2xETEV0QlFXbENPMGxCUTJoRUxFMUJRVTBzUTBGQlF6dFJRVU5NTEV0QlFVc3NSVUZCUlN4dlFrRkJiMElzUTBGQlF5eExRVUZMTEVWQlFVVXNWMEZCUXl4RFFVRkRPMUZCUTNKRExFMUJRVTBzUlVGQlJTeHZRa0ZCYjBJc1EwRkJReXhMUVVGTExFVkJRVVVzVjBGQlF5eERRVUZETzB0QlEzWkRMRU5CUVVNN1FVRkRTaXhEUVVGRE8wRkJURVFzTkVOQlMwTTdRVUZGUkN3NFFrRkJPRUlzUzBGQmFVSXNSVUZCUlN4UFFVRm5RanRKUVVNdlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMVFzZDBWQlFYZEZPMUZCUTNoRkxIZEVRVUYzUkR0UlFVVjRSQ3hKUVVGTkxHOUNRVUZ2UWl4SFFVRkhMRXRCUVVzc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVOb1JTeEpRVUZOTEZWQlFWRXNSMEZCUnl4UFFVRlBMRXRCUVVzc1YwRkJReXhIUVVGSExGRkJRVkVzUjBGQlJ5eFBRVUZQTEVOQlFVTTdVVUZEY0VRc1NVRkJUU3hyUWtGQmEwSXNSMEZCYTBJc2IwSkJRVzlDTEVOQlFVTXNWVUZCVVN4RFFVRkRMRU5CUVVNN1VVRkZla1VzU1VGQlRTeFJRVUZSTEVkQlFVY3NhMEpCUVd0Q0xFTkJRVU1zVVVGQlVTeERRVUZETzFGQlF6ZERMRWxCUVUwc1QwRkJUeXhIUVVGakxFTkJRVU03WjBKQlF6RkNMRVZCUVVVc1JVRkJSU3hMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEU5QlFVOHNRMEZCUXp0blFrRkRiRU1zU1VGQlNTeEZRVUZGTEd0Q1FVRnJRaXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpPMkZCUTNwRExFTkJRVU1zUTBGQlF6dFJRVVZJTEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVU1zUzBGQlN6dFpRVU16UWl4UFFVRlBMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEZWQlFWRXNRMEZCUXl4RFFVRkRPMUZCUXpGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlJVZ3NUVUZCVFN4RFFVRkRPMWxCUTB3c1RVRkJUU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTXNWMEZCU1N4RFFVRkRPMWxCUXk5Q0xGRkJRVkVzUlVGQlJTeFJRVUZSTzFsQlEyeENMRTlCUVU4c1JVRkJSU3hQUVVGUE8xTkJRMnBDTEVOQlFVTTdTVUZEU2l4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxIRkNRVUZ4UWl4TFFVRlpMRVZCUVVVc1QwRkJaMEk3U1VGRGFrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JGTEVsQlFVMHNTMEZCU3l4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdVVUZEYmtNc1JVRkJSU3hEUVVGRExFTkJRVU1zZVVKQlFXbENMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3haUVVGWkxFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBSU3h0UkVGQmJVUTdXVUZEYmtRc1NVRkJUU3hoUVVGaExFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVNelF5eEpRVUZOTEZGQlFWRXNSMEZCWXl4RlFVRkZMRU5CUVVNN1dVRkRMMElzVVVGQlVTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRPMUZCUTJ4Q0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJRenRCUVVOYUxFTkJRVU03UVVGRlJDeDVRa0ZCWjBNc1MwRkJXU3hGUVVGRkxFOUJRV2RDTzBsQlF6VkVMRWxCUVUwc1MwRkJTeXhIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRia01zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1dVRkJXU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeERMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkRiRU1zUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVVc1RVRkJUU3hGUVVGRkxGVkJRVlVzUlVGQlF5eERRVUZETEVOQlFVTTdRVUZEYWtVc1EwRkJRenRCUVZCRUxEQkRRVTlESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4uLy4uL21hcmtcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gc3ltYm9scyhmaWVsZERlZiwgc3ltYm9sc1NwZWMsIG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIHN5bWJvbHMgPSB7fTtcbiAgICB2YXIgbWFyayA9IG1vZGVsLm1hcmsoKTtcbiAgICBzd2l0Y2ggKG1hcmspIHtcbiAgICAgICAgY2FzZSBtYXJrXzEuQkFSOlxuICAgICAgICBjYXNlIG1hcmtfMS5USUNLOlxuICAgICAgICBjYXNlIG1hcmtfMS5URVhUOlxuICAgICAgICAgICAgc3ltYm9scy5zaGFwZSA9IHsgdmFsdWU6ICdzcXVhcmUnIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBtYXJrXzEuQ0lSQ0xFOlxuICAgICAgICBjYXNlIG1hcmtfMS5TUVVBUkU6XG4gICAgICAgICAgICBzeW1ib2xzLnNoYXBlID0geyB2YWx1ZTogbWFyayB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbWFya18xLlBPSU5UOlxuICAgICAgICBjYXNlIG1hcmtfMS5MSU5FOlxuICAgICAgICBjYXNlIG1hcmtfMS5BUkVBOlxuICAgICAgICAgICAgLy8gdXNlIGRlZmF1bHQgY2lyY2xlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGNmZyA9IG1vZGVsLmNvbmZpZztcbiAgICB2YXIgZmlsbGVkID0gbW9kZWwubWFya0RlZi5maWxsZWQ7XG4gICAgdmFyIGNvbmZpZyA9IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5DT0xPUiA/XG4gICAgICAgIC8qIEZvciBjb2xvcidzIGxlZ2VuZCwgZG8gbm90IHNldCBmaWxsICh3aGVuIGZpbGxlZCkgb3Igc3Ryb2tlICh3aGVuIHVuZmlsbGVkKSBwcm9wZXJ0eSBmcm9tIGNvbmZpZyBiZWNhdXNlIHRoZSBsZWdlbmQncyBgZmlsbGAgb3IgYHN0cm9rZWAgc2NhbGUgc2hvdWxkIGhhdmUgcHJlY2VkZW5jZSAqL1xuICAgICAgICB1dGlsXzEud2l0aG91dChtYXJrXzEuRklMTF9TVFJPS0VfQ09ORklHLCBbZmlsbGVkID8gJ2ZpbGwnIDogJ3N0cm9rZScsICdzdHJva2VEYXNoJywgJ3N0cm9rZURhc2hPZmZzZXQnXSkgOlxuICAgICAgICAvKiBGb3Igb3RoZXIgbGVnZW5kLCBubyBuZWVkIHRvIG9taXQuICovXG4gICAgICAgIG1hcmtfMS5GSUxMX1NUUk9LRV9DT05GSUc7XG4gICAgY29uZmlnID0gdXRpbF8xLndpdGhvdXQoY29uZmlnLCBbJ3N0cm9rZURhc2gnLCAnc3Ryb2tlRGFzaE9mZnNldCddKTtcbiAgICBjb21tb25fMS5hcHBseU1hcmtDb25maWcoc3ltYm9scywgbW9kZWwsIGNvbmZpZyk7XG4gICAgaWYgKGZpbGxlZCkge1xuICAgICAgICBzeW1ib2xzLnN0cm9rZVdpZHRoID0geyB2YWx1ZTogMCB9O1xuICAgIH1cbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIGNvbG9yRGVmID0gbW9kZWwuZW5jb2RpbmcuY29sb3I7XG4gICAgaWYgKGZpZWxkZGVmXzEuaXNWYWx1ZURlZihjb2xvckRlZikpIHtcbiAgICAgICAgdmFsdWUgPSB7IHZhbHVlOiBjb2xvckRlZi52YWx1ZSB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhcHBseSB0aGUgdmFsdWVcbiAgICAgICAgaWYgKGZpbGxlZCkge1xuICAgICAgICAgICAgc3ltYm9scy5maWxsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzeW1ib2xzLnN0cm9rZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWwgIT09IGNoYW5uZWxfMS5DT0xPUikge1xuICAgICAgICAvLyBGb3Igbm9uLWNvbG9yIGxlZ2VuZCwgYXBwbHkgY29sb3IgY29uZmlnIGlmIHRoZXJlIGlzIG5vIGZpbGwgLyBzdHJva2UgY29uZmlnLlxuICAgICAgICAvLyAoRm9yIGNvbG9yLCBkbyBub3Qgb3ZlcnJpZGUgc2NhbGUgc3BlY2lmaWVkISlcbiAgICAgICAgc3ltYm9sc1tmaWxsZWQgPyAnZmlsbCcgOiAnc3Ryb2tlJ10gPSBzeW1ib2xzW2ZpbGxlZCA/ICdmaWxsJyA6ICdzdHJva2UnXSB8fFxuICAgICAgICAgICAgeyB2YWx1ZTogY2ZnLm1hcmsuY29sb3IgfTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbHMuZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayB0byBtYXJrIGNvbmZpZyBjb2xvcnMgZm9yIGxlZ2VuZCBmaWxsXG4gICAgICAgIGlmIChjZmcubWFyay5maWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bWJvbHMuZmlsbCA9IHsgdmFsdWU6IGNmZy5tYXJrLmZpbGwgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjZmcubWFyay5zdHJva2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3ltYm9scy5zdHJva2UgPSB7IHZhbHVlOiBjZmcubWFyay5zdHJva2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2hhcGVEZWYgPSBtb2RlbC5lbmNvZGluZy5zaGFwZTtcbiAgICBpZiAoY2hhbm5lbCAhPT0gY2hhbm5lbF8xLlNIQVBFKSB7XG4gICAgICAgIGlmIChmaWVsZGRlZl8xLmlzVmFsdWVEZWYoc2hhcGVEZWYpKSB7XG4gICAgICAgICAgICBzeW1ib2xzLnNoYXBlID0geyB2YWx1ZTogc2hhcGVEZWYudmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW1ib2xzID0gdXRpbF8xLmV4dGVuZChzeW1ib2xzLCBzeW1ib2xzU3BlYyB8fCB7fSk7XG4gICAgcmV0dXJuIHV0aWxfMS5rZXlzKHN5bWJvbHMpLmxlbmd0aCA+IDAgPyBzeW1ib2xzIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcbmZ1bmN0aW9uIGxhYmVscyhmaWVsZERlZiwgbGFiZWxzU3BlYywgbW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgbGVnZW5kID0gbW9kZWwubGVnZW5kKGNoYW5uZWwpO1xuICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWc7XG4gICAgdmFyIGxhYmVscyA9IHt9O1xuICAgIGlmIChmaWVsZERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUwpIHtcbiAgICAgICAgbGFiZWxzU3BlYyA9IHV0aWxfMS5leHRlbmQoe1xuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgIHNpZ25hbDogY29tbW9uXzEudGltZUZvcm1hdEV4cHJlc3Npb24oJ2RhdHVtLnZhbHVlJywgZmllbGREZWYudGltZVVuaXQsIGxlZ2VuZC5mb3JtYXQsIGNvbmZpZy5sZWdlbmQuc2hvcnRUaW1lTGFiZWxzLCBjb25maWcudGltZUZvcm1hdClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgbGFiZWxzU3BlYyB8fCB7fSk7XG4gICAgfVxuICAgIGxhYmVscyA9IHV0aWxfMS5leHRlbmQobGFiZWxzLCBsYWJlbHNTcGVjIHx8IHt9KTtcbiAgICByZXR1cm4gdXRpbF8xLmtleXMobGFiZWxzKS5sZW5ndGggPiAwID8gbGFiZWxzIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5sYWJlbHMgPSBsYWJlbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laVzVqYjJSbExtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZiR1ZuWlc1a0wyVnVZMjlrWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEhsRFFVRnZSRHRCUVVOd1JDd3lRMEZCYjBRN1FVRkRjRVFzYlVOQlFXdEhPMEZCUTJ4SExHMURRVUZ2UXp0QlFVTndReXh0UTBGQmFVUTdRVUZKYWtRc2IwTkJRV2RGTzBGQlIyaEZMR2xDUVVGM1FpeFJRVUZyUWl4RlFVRkZMRmRCUVdkQ0xFVkJRVVVzUzBGQlowSXNSVUZCUlN4UFFVRm5RanRKUVVNNVJpeEpRVUZKTEU5QlFVOHNSMEZCVHl4RlFVRkZMRU5CUVVNN1NVRkRja0lzU1VGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1JVRkJSU3hEUVVGRE8wbEJSVEZDTEUxQlFVMHNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFlpeExRVUZMTEZWQlFVY3NRMEZCUXp0UlFVTlVMRXRCUVVzc1YwRkJTU3hEUVVGRE8xRkJRMVlzUzBGQlN5eFhRVUZKTzFsQlExQXNUMEZCVHl4RFFVRkRMRXRCUVVzc1IwRkJSeXhGUVVGRExFdEJRVXNzUlVGQlJTeFJRVUZSTEVWQlFVTXNRMEZCUXp0WlFVTnNReXhMUVVGTExFTkJRVU03VVVGRFVpeExRVUZMTEdGQlFVMHNRMEZCUXp0UlFVTmFMRXRCUVVzc1lVRkJUVHRaUVVOVUxFOUJRVThzUTBGQlF5eExRVUZMTEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hGUVVGRExFTkJRVU03V1VGRE9VSXNTMEZCU3l4RFFVRkRPMUZCUTFJc1MwRkJTeXhaUVVGTExFTkJRVU03VVVGRFdDeExRVUZMTEZkQlFVa3NRMEZCUXp0UlFVTldMRXRCUVVzc1YwRkJTVHRaUVVOUUxIRkNRVUZ4UWp0WlFVTnlRaXhMUVVGTExFTkJRVU03U1VGRFZpeERRVUZETzBsQlJVUXNTVUZCVFN4SFFVRkhMRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU42UWl4SlFVRk5MRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXp0SlFVVndReXhKUVVGSkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEV0QlFVc3NaVUZCU3p0UlFVTXhRaXd5UzBGQk1rczdVVUZETTBzc1kwRkJUeXhEUVVGRExIbENRVUZyUWl4RlFVRkZMRU5CUVVVc1RVRkJUU3hIUVVGSExFMUJRVTBzUjBGQlJ5eFJRVUZSTEVWQlFVVXNXVUZCV1N4RlFVRkZMR3RDUVVGclFpeERRVUZETEVOQlFVTTdVVUZETlVZc2QwTkJRWGRETzFGQlEzaERMSGxDUVVGclFpeERRVUZETzBsQlJYWkNMRTFCUVUwc1IwRkJSeXhqUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZGTEVOQlFVTXNXVUZCV1N4RlFVRkZMR3RDUVVGclFpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVVTNSQ3gzUWtGQlpTeERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRmVFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5ZTEU5QlFVOHNRMEZCUXl4WFFVRlhMRWRCUVVjc1JVRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eEZRVUZETEVOQlFVTTdTVUZEYmtNc1EwRkJRenRKUVVWRUxFbEJRVWtzUzBGQmFVSXNRMEZCUXp0SlFVTjBRaXhKUVVGTkxGRkJRVkVzUjBGQlJ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVOMFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhMUVVGTExFZEJRVWNzUlVGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RFFVRkRMRXRCUVVzc1JVRkJReXhEUVVGRE8wbEJRMnhETEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRRaXhyUWtGQmEwSTdVVUZEYkVJc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRTlCUVU4c1EwRkJReXhKUVVGSkxFZEJRVWNzUzBGQlN5eERRVUZETzFGQlEzWkNMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRE8xRkJRM3BDTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4bFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemRDTEdkR1FVRm5SanRSUVVOb1JpeG5SRUZCWjBRN1VVRkRhRVFzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRWRCUVVjc1VVRkJVU3hEUVVGRExFZEJRVWNzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRWRCUVVjc1VVRkJVU3hEUVVGRE8xbEJRM1pGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZETEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UWl4clJFRkJhMFE3VVVGRGJFUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eFBRVUZQTEVOQlFVTXNTVUZCU1N4SFFVRkhMRVZCUVVNc1MwRkJTeXhGUVVGRkxFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RlFVRkRMRU5CUVVNN1VVRkRlRU1zUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM3BETEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJReXhMUVVGTExFVkJRVVVzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4TlFVRk5MRVZCUVVNc1EwRkJRenRSUVVNMVF5eERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRWxCUVUwc1VVRkJVU3hIUVVGSExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTNSRExFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4bFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEVWQlFVVXNRMEZCUXl4RFFVRkRMSEZDUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwQ0xFOUJRVThzUTBGQlF5eExRVUZMTEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1VVRkJVU3hEUVVGRExFdEJRVXNzUlVGQlF5eERRVUZETzFGQlF6RkRMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJSVVFzVDBGQlR5eEhRVUZITEdGQlFVMHNRMEZCUXl4UFFVRlBMRVZCUVVVc1YwRkJWeXhKUVVGSkxFVkJRVVVzUTBGQlF5eERRVUZETzBsQlJUZERMRTFCUVUwc1EwRkJReXhYUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1IwRkJSeXhQUVVGUExFZEJRVWNzVTBGQlV5eERRVUZETzBGQlEzaEVMRU5CUVVNN1FVRTNSVVFzTUVKQk5rVkRPMEZCUlVRc1owSkJRWFZDTEZGQlFXdENMRVZCUVVVc1ZVRkJaU3hGUVVGRkxFdEJRV2RDTEVWQlFVVXNUMEZCWjBJN1NVRkROVVlzU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU55UXl4SlFVRk5MRTFCUVUwc1IwRkJSeXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETzBsQlJUVkNMRWxCUVVrc1RVRkJUU3hIUVVGUExFVkJRVVVzUTBGQlF6dEpRVVZ3UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zU1VGQlNTeExRVUZMTEdWQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMElzVlVGQlZTeEhRVUZITEdGQlFVMHNRMEZCUXp0WlFVTnNRaXhKUVVGSkxFVkJRVVU3WjBKQlEwb3NUVUZCVFN4RlFVRkZMRFpDUVVGdlFpeERRVUZETEdGQlFXRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1VVRkJVU3hGUVVGRkxFMUJRVTBzUTBGQlF5eE5RVUZOTEVWQlFVVXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhsUVVGbExFVkJRVVVzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0aFFVTm9TVHRUUVVOR0xFVkJRVVVzVlVGQlZTeEpRVUZKTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTNaQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVkQlFVY3NZVUZCVFN4RFFVRkRMRTFCUVUwc1JVRkJSU3hWUVVGVkxFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZGTVVNc1RVRkJUU3hEUVVGRExGZEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhIUVVGSExFMUJRVTBzUjBGQlJ5eFRRVUZUTEVOQlFVTTdRVUZEZEVRc1EwRkJRenRCUVdwQ1JDeDNRa0ZwUWtNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBsZWdlbmRfMSA9IHJlcXVpcmUoXCIuLi8uLi9sZWdlbmRcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGVuY29kZSA9IHJlcXVpcmUoXCIuL2VuY29kZVwiKTtcbnZhciBydWxlcyA9IHJlcXVpcmUoXCIuL3J1bGVzXCIpO1xuZnVuY3Rpb24gcGFyc2VMZWdlbmRDb21wb25lbnQobW9kZWwpIHtcbiAgICByZXR1cm4gW2NoYW5uZWxfMS5DT0xPUiwgY2hhbm5lbF8xLlNJWkUsIGNoYW5uZWxfMS5TSEFQRSwgY2hhbm5lbF8xLk9QQUNJVFldLnJlZHVjZShmdW5jdGlvbiAobGVnZW5kQ29tcG9uZW50LCBjaGFubmVsKSB7XG4gICAgICAgIGlmIChtb2RlbC5sZWdlbmQoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbXBvbmVudFtjaGFubmVsXSA9IHBhcnNlTGVnZW5kKG1vZGVsLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVnZW5kQ29tcG9uZW50O1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMucGFyc2VMZWdlbmRDb21wb25lbnQgPSBwYXJzZUxlZ2VuZENvbXBvbmVudDtcbmZ1bmN0aW9uIGdldExlZ2VuZERlZldpdGhTY2FsZShtb2RlbCwgY2hhbm5lbCkge1xuICAgIC8vIEZvciBiaW5uZWQgZmllbGQgd2l0aCBjb250aW51b3VzIHNjYWxlLCB1c2UgYSBzcGVjaWFsIHNjYWxlIHNvIHdlIGNhbiBvdmVycnJpZGUgdGhlIG1hcmsgcHJvcHMgYW5kIGxhYmVsc1xuICAgIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgICAgICBjYXNlIGNoYW5uZWxfMS5DT0xPUjpcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuQ09MT1IpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLm1hcmtEZWYuZmlsbGVkID8geyBmaWxsOiBzY2FsZSB9IDogeyBzdHJva2U6IHNjYWxlIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNJWkU6XG4gICAgICAgICAgICByZXR1cm4geyBzaXplOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlNJWkUpIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNIQVBFOlxuICAgICAgICAgICAgcmV0dXJuIHsgc2hhcGU6IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuU0hBUEUpIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLk9QQUNJVFk6XG4gICAgICAgICAgICByZXR1cm4geyBvcGFjaXR5OiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLk9QQUNJVFkpIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VMZWdlbmQobW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcbiAgICB2YXIgbGVnZW5kID0gbW9kZWwubGVnZW5kKGNoYW5uZWwpO1xuICAgIHZhciBkZWYgPSBnZXRMZWdlbmREZWZXaXRoU2NhbGUobW9kZWwsIGNoYW5uZWwpO1xuICAgIGxlZ2VuZF8xLkxFR0VORF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKHByb3BlcnR5LCBsZWdlbmQsIGNoYW5uZWwsIG1vZGVsKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlZltwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIDIpIEFkZCBtYXJrIHByb3BlcnR5IGRlZmluaXRpb24gZ3JvdXBzXG4gICAgdmFyIGVuY29kZVNwZWMgPSBsZWdlbmQuZW5jb2RlIHx8IHt9O1xuICAgIFsnbGFiZWxzJywgJ2xlZ2VuZCcsICd0aXRsZScsICdzeW1ib2xzJ10uZm9yRWFjaChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBlbmNvZGVbcGFydF0gP1xuICAgICAgICAgICAgZW5jb2RlW3BhcnRdKGZpZWxkRGVmLCBlbmNvZGVTcGVjW3BhcnRdLCBtb2RlbCwgY2hhbm5lbCkgOlxuICAgICAgICAgICAgZW5jb2RlU3BlY1twYXJ0XTsgLy8gbm8gcnVsZSAtLSBqdXN0IGRlZmF1bHQgdmFsdWVzXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHV0aWxfMS5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWYuZW5jb2RlID0gZGVmLmVuY29kZSB8fCB7fTtcbiAgICAgICAgICAgIGRlZi5lbmNvZGVbcGFydF0gPSB7IHVwZGF0ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWY7XG59XG5leHBvcnRzLnBhcnNlTGVnZW5kID0gcGFyc2VMZWdlbmQ7XG5mdW5jdGlvbiBnZXRTcGVjaWZpZWRPckRlZmF1bHRWYWx1ZShwcm9wZXJ0eSwgc3BlY2lmaWVkTGVnZW5kLCBjaGFubmVsLCBtb2RlbCkge1xuICAgIHZhciBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5udW1iZXJGb3JtYXQoZmllbGREZWYsIHNwZWNpZmllZExlZ2VuZC5mb3JtYXQsIG1vZGVsLmNvbmZpZywgY2hhbm5lbCk7XG4gICAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy50aXRsZShzcGVjaWZpZWRMZWdlbmQsIGZpZWxkRGVmLCBtb2RlbC5jb25maWcpO1xuICAgICAgICBjYXNlICd2YWx1ZXMnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnZhbHVlcyhzcGVjaWZpZWRMZWdlbmQpO1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy50eXBlKHNwZWNpZmllZExlZ2VuZCwgZmllbGREZWYudHlwZSwgY2hhbm5lbCwgbW9kZWwuc2NhbGUoY2hhbm5lbCkudHlwZSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgICByZXR1cm4gc3BlY2lmaWVkTGVnZW5kW3Byb3BlcnR5XTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNHRnljMlV1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk4dUxpOHVMaTl6Y21NdlkyOXRjR2xzWlM5c1pXZGxibVF2Y0dGeWMyVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeDVRMEZCYlVVN1FVRkRia1VzZFVOQlFYVkVPMEZCUTNaRUxHMURRVUZ6UXp0QlFVZDBReXh2UTBGQmRVTTdRVUZKZGtNc2FVTkJRVzFETzBGQlEyNURMQ3RDUVVGcFF6dEJRVVZxUXl3NFFrRkJjVU1zUzBGQlowSTdTVUZEYmtRc1RVRkJUU3hEUVVGRExFTkJRVU1zWlVGQlN5eEZRVUZGTEdOQlFVa3NSVUZCUlN4bFFVRkxMRVZCUVVVc2FVSkJRVThzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRlRMR1ZCUVdVc1JVRkJSU3hQUVVGUE8xRkJRek5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGQ0xHVkJRV1VzUTBGQlF5eFBRVUZQTEVOQlFVTXNSMEZCUnl4WFFVRlhMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEzcEVMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zWlVGQlpTeERRVUZETzBsQlEzcENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZRUkN4dlJFRlBRenRCUVVWRUxDdENRVUVyUWl4TFFVRm5RaXhGUVVGRkxFOUJRV2RDTzBsQlF5OUVMRFJIUVVFMFJ6dEpRVU0xUnl4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRXRCUVVzc1pVRkJTenRaUVVOU0xFbEJRVTBzUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1pVRkJTeXhEUVVGRExFTkJRVU03V1VGRGNrTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEhRVUZITEVWQlFVTXNTVUZCU1N4RlFVRkZMRXRCUVVzc1JVRkJReXhIUVVGSExFVkJRVU1zVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUXl4RFFVRkRPMUZCUTJoRkxFdEJRVXNzWTBGQlNUdFpRVU5RTEUxQlFVMHNRMEZCUXl4RlFVRkRMRWxCUVVrc1JVRkJSU3hMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETEdOQlFVa3NRMEZCUXl4RlFVRkRMRU5CUVVNN1VVRkRka01zUzBGQlN5eGxRVUZMTzFsQlExSXNUVUZCVFN4RFFVRkRMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNaVUZCU3l4RFFVRkRMRVZCUVVNc1EwRkJRenRSUVVONlF5eExRVUZMTEdsQ1FVRlBPMWxCUTFZc1RVRkJUU3hEUVVGRExFVkJRVU1zVDBGQlR5eEZRVUZGTEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc2FVSkJRVThzUTBGQlF5eEZRVUZETEVOQlFVTTdTVUZETDBNc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEWkN4RFFVRkRPMEZCUlVRc2NVSkJRVFJDTEV0QlFXZENMRVZCUVVVc1QwRkJaMEk3U1VGRE5VUXNTVUZCVFN4UlFVRlJMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTjZReXhKUVVGTkxFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJSWEpETEVsQlFVMHNSMEZCUnl4SFFVRmhMSEZDUVVGeFFpeERRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVVMVJDd3dRa0ZCYVVJc1EwRkJReXhQUVVGUExFTkJRVU1zVlVGQlV5eFJRVUZSTzFGQlEzcERMRWxCUVUwc1MwRkJTeXhIUVVGSExEQkNRVUV3UWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hOUVVGTkxFVkJRVVVzVDBGQlR5eEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUXpORkxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hDTEVkQlFVY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhMUVVGTExFTkJRVU03VVVGRGVFSXNRMEZCUXp0SlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJSVWdzZVVOQlFYbERPMGxCUTNwRExFbEJRVTBzVlVGQlZTeEhRVUZITEUxQlFVMHNRMEZCUXl4TlFVRk5MRWxCUVVrc1JVRkJSU3hEUVVGRE8wbEJRM1pETEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hQUVVGUExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1NVRkJTVHRSUVVNMVJDeEpRVUZOTEV0QlFVc3NSMEZCUnl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRM2hDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhSUVVGUkxFVkJRVVVzVlVGQlZTeERRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU03V1VGRGVFUXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zYVVOQlFXbERPMUZCUTNKRUxFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTMEZCU3l4VFFVRlRMRWxCUVVrc1YwRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEUxQlFVMHNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnhFTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1IwRkJSeXhEUVVGRExFMUJRVTBzU1VGQlNTeEZRVUZGTEVOQlFVTTdXVUZET1VJc1IwRkJSeXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RlFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVU1zUTBGQlF6dFJRVU55UXl4RFFVRkRPMGxCUTBnc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRlNDeE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRPMEZCUTJJc1EwRkJRenRCUVRGQ1JDeHJRMEV3UWtNN1FVRkZSQ3h2UTBGQmIwTXNVVUZCZDBJc1JVRkJSU3hsUVVGMVFpeEZRVUZGTEU5QlFXZENMRVZCUVVVc1MwRkJXVHRKUVVOdVNDeEpRVUZOTEZGQlFWRXNSMEZCUnl4TFFVRkxMRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlJYcERMRTFCUVUwc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYWtJc1MwRkJTeXhSUVVGUk8xbEJRMWdzVFVGQlRTeERRVUZETEhGQ1FVRlpMRU5CUVVNc1VVRkJVU3hGUVVGRkxHVkJRV1VzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTFCUVUwc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU12UlN4TFFVRkxMRTlCUVU4N1dVRkRWaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4bFFVRmxMRVZCUVVVc1VVRkJVU3hGUVVGRkxFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTTVSQ3hMUVVGTExGRkJRVkU3V1VGRFdDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF6dFJRVU4yUXl4TFFVRkxMRTFCUVUwN1dVRkRWQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NRMEZCUXl4bFFVRmxMRVZCUVVVc1VVRkJVU3hEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTXhSaXhEUVVGRE8wbEJSVVFzZDBOQlFYZERPMGxCUTNoRExFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRia01zUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBkYXRldGltZV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGV0aW1lXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbmZ1bmN0aW9uIHRpdGxlKGxlZ2VuZCwgZmllbGREZWYsIGNvbmZpZykge1xuICAgIGlmIChsZWdlbmQudGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVnZW5kLnRpdGxlO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRkZWZfMS50aXRsZShmaWVsZERlZiwgY29uZmlnKTtcbn1cbmV4cG9ydHMudGl0bGUgPSB0aXRsZTtcbmZ1bmN0aW9uIHZhbHVlcyhsZWdlbmQpIHtcbiAgICB2YXIgdmFscyA9IGxlZ2VuZC52YWx1ZXM7XG4gICAgaWYgKHZhbHMgJiYgZGF0ZXRpbWVfMS5pc0RhdGVUaW1lKHZhbHNbMF0pKSB7XG4gICAgICAgIHJldHVybiB2YWxzLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSA9IHRydWUgYXMgZW5kIHVzZXIgd29uJ3QgcHV0IDAgPSBKYW51YXJ5XG4gICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS50aW1lc3RhbXAoZHQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHM7XG59XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmZ1bmN0aW9uIHR5cGUobGVnZW5kLCB0eXBlLCBjaGFubmVsLCBzY2FsZVR5cGUpIHtcbiAgICBpZiAobGVnZW5kLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGxlZ2VuZC50eXBlO1xuICAgIH1cbiAgICBpZiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLkNPTE9SICYmICgodHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScgJiYgIXNjYWxlXzEuaXNCaW5TY2FsZShzY2FsZVR5cGUpKSB8fCAodHlwZSA9PT0gJ3RlbXBvcmFsJyAmJiB1dGlsXzEuY29udGFpbnMoWyd0aW1lJywgJ3V0YyddLCBzY2FsZVR5cGUpKSkpIHtcbiAgICAgICAgcmV0dXJuICdncmFkaWVudCc7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnR5cGUgPSB0eXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY25Wc1pYTXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzlzWldkbGJtUXZjblZzWlhNdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4NVEwRkJOa003UVVGRk4wTXNNa05CUVN0RU8wRkJSUzlFTERKRFFVRnRSRHRCUVVWdVJDeHhRMEZCYTBRN1FVRkZiRVFzYlVOQlFXOURPMEZCUlhCRExHVkJRWE5DTEUxQlFXTXNSVUZCUlN4UlFVRnJRaXhGUVVGRkxFMUJRV003U1VGRGRFVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTNSQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVZVc1EwRkJReXhSUVVGUkxFVkJRVVVzVFVGQlRTeERRVUZETEVOQlFVTTdRVUZEZEVNc1EwRkJRenRCUVU1RUxITkNRVTFETzBGQlJVUXNaMEpCUVhWQ0xFMUJRV003U1VGRGJrTXNTVUZCVFN4SlFVRkpMRWRCUVVjc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU16UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFbEJRVWtzY1VKQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVNc1RVRkJUU3hEUVVGRkxFbEJRVzFDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1JVRkJSVHRaUVVOcVF5eHhSRUZCY1VRN1dVRkRja1FzVFVGQlRTeERRVUZETEc5Q1FVRlRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlF6ZENMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJWRVFzZDBKQlUwTTdRVUZGUkN4alFVRnhRaXhOUVVGakxFVkJRVVVzU1VGQlZTeEZRVUZGTEU5QlFXZENMRVZCUVVVc1UwRkJiMEk3U1VGRGNrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYUVJc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEY2tJc1EwRkJRenRKUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4bFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eGpRVUZqTEVsQlFVa3NRMEZCUXl4clFrRkJWU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1ZVRkJWU3hKUVVGSkxHVkJRVkVzUTBGQldTeERRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkJSU3hUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpOS0xFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdTVUZEY0VJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVZKRUxHOUNRVkZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xuZXhwb3J0cy5hcmVhID0ge1xuICAgIHZnTWFyazogJ2FyZWEnLFxuICAgIGRlZmF1bHRSb2xlOiB1bmRlZmluZWQsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCAnemVyb09yTWluJyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ29wYWNpdHknLCBtb2RlbCksIG1peGlucy5tYXJrRGVmUHJvcGVydGllcyhtb2RlbC5tYXJrRGVmLCBbJ29yaWVudCcsICdpbnRlcnBvbGF0ZScsICd0ZW5zaW9uJ10pKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWVhKbFlTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMMjFoY21zdllYSmxZUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3pzN1FVRkRRU3hwUTBGQmJVTTdRVUZKZEVJc1VVRkJRU3hKUVVGSkxFZEJRV2xDTzBsQlEyaERMRTFCUVUwc1JVRkJSU3hOUVVGTk8wbEJRMlFzVjBGQlZ5eEZRVUZGTEZOQlFWTTdTVUZEZEVJc1YwRkJWeXhGUVVGRkxGVkJRVU1zUzBGQlowSTdVVUZETlVJc1RVRkJUU3h6UWtGRFJDeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRWRCUVVjc1JVRkJSU3hMUVVGTExFVkJRVVVzVjBGQlZ5eERRVUZETEVWQlF6ZERMRTFCUVUwc1EwRkJReXhoUVVGaExFTkJRVU1zUjBGQlJ5eEZRVUZGTEV0QlFVc3NSVUZCUlN4WFFVRlhMRU5CUVVNc1JVRkROME1zVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1YwRkJWeXhEUVVGRExFVkJSWHBETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMjVDTEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVU53UXl4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRExGRkJRVkVzUlVGQlJTeGhRVUZoTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1JVRkRhRVk3U1VGRFNpeERRVUZETzBOQlEwWXNRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vLi4vbG9nXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIHJlZiA9IHJlcXVpcmUoXCIuL3ZhbHVlcmVmXCIpO1xuZXhwb3J0cy5iYXIgPSB7XG4gICAgdmdNYXJrOiAncmVjdCcsXG4gICAgZGVmYXVsdFJvbGU6ICdiYXInLFxuICAgIGVuY29kZUVudHJ5OiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gbW9kZWwuc3RhY2s7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCB4KG1vZGVsLCBzdGFjayksIHkobW9kZWwsIHN0YWNrKSwgbWl4aW5zLmNvbG9yKG1vZGVsKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpKTtcbiAgICB9XG59O1xuZnVuY3Rpb24geChtb2RlbCwgc3RhY2spIHtcbiAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnLCB3aWR0aCA9IG1vZGVsLndpZHRoO1xuICAgIHZhciBvcmllbnQgPSBtb2RlbC5tYXJrRGVmLm9yaWVudDtcbiAgICB2YXIgc2l6ZURlZiA9IG1vZGVsLmVuY29kaW5nLnNpemU7XG4gICAgdmFyIHhEZWYgPSBtb2RlbC5lbmNvZGluZy54O1xuICAgIHZhciB4U2NhbGVOYW1lID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5YKTtcbiAgICB2YXIgeFNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlgpO1xuICAgIC8vIHgsIHgyLCBhbmQgd2lkdGggLS0gd2UgbXVzdCBzcGVjaWZ5IHR3byBvZiB0aGVzZSBpbiBhbGwgY29uZGl0aW9uc1xuICAgIGlmIChvcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMucG9pbnRQb3NpdGlvbjIobW9kZWwsICd6ZXJvT3JNaW4nKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKHhEZWYpKSB7XG4gICAgICAgICAgICBpZiAoIXNpemVEZWYgJiYgc2NhbGVfMS5pc0JpblNjYWxlKHhTY2FsZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3gnLCBtb2RlbCwgY29uZmlnLmJhci5iaW5TcGFjaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhTY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3gnLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2l6ZWQgYmluLCBub3JtYWwgcG9pbnQtb3JkaW5hbCBheGlzLCBxdWFudGl0YXRpdmUgeC1heGlzLCBvciBubyB4XG4gICAgICAgIHJldHVybiBtaXhpbnMuY2VudGVyZWRCYW5kUG9zaXRpb24oJ3gnLCBtb2RlbCwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVmLm1pZFgod2lkdGgsIGNvbmZpZykpLCBkZWZhdWx0U2l6ZVJlZih4U2NhbGVOYW1lLCBtb2RlbC5zY2FsZShjaGFubmVsXzEuWCksIGNvbmZpZykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHkobW9kZWwsIHN0YWNrKSB7XG4gICAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZywgZW5jb2RpbmcgPSBtb2RlbC5lbmNvZGluZywgaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xuICAgIHZhciBvcmllbnQgPSBtb2RlbC5tYXJrRGVmLm9yaWVudDtcbiAgICB2YXIgc2l6ZURlZiA9IGVuY29kaW5nLnNpemU7XG4gICAgdmFyIHlEZWYgPSBlbmNvZGluZy55O1xuICAgIHZhciB5U2NhbGVOYW1lID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKTtcbiAgICB2YXIgeVNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbF8xLlkpO1xuICAgIC8vIHksIHkyICYgaGVpZ2h0IC0tIHdlIG11c3Qgc3BlY2lmeSB0d28gb2YgdGhlc2UgaW4gYWxsIGNvbmRpdGlvbnNcbiAgICBpZiAob3JpZW50ID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCAnemVyb09yTWluJyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoeURlZikpIHtcbiAgICAgICAgICAgIGlmICh5RGVmLmJpbiAmJiAhc2l6ZURlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbnMuYmlubmVkUG9zaXRpb24oJ3knLCBtb2RlbCwgY29uZmlnLmJhci5iaW5TcGFjaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHlTY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3knLCBtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1peGlucy5jZW50ZXJlZEJhbmRQb3NpdGlvbigneScsIG1vZGVsLCByZWYubWlkWShoZWlnaHQsIGNvbmZpZyksIGRlZmF1bHRTaXplUmVmKHlTY2FsZU5hbWUsIG1vZGVsLnNjYWxlKGNoYW5uZWxfMS5ZKSwgY29uZmlnKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdFNpemVSZWYoc2NhbGVOYW1lLCBzY2FsZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5iYXIuZGlzY3JldGVCYW5kU2l6ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogY29uZmlnLmJhci5kaXNjcmV0ZUJhbmRTaXplIH07XG4gICAgfVxuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuUE9JTlQpIHtcbiAgICAgICAgICAgIGlmIChzY2FsZS5yYW5nZVN0ZXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc2NhbGUucmFuZ2VTdGVwIC0gMSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuQkFSX1dJVEhfUE9JTlRfU0NBTEVfQU5EX1JBTkdFU1RFUF9OVUxMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2FsZS50eXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLmJhbmQoc2NhbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjb25maWcuYmFyLmNvbnRpbnVvdXNCYW5kU2l6ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcuc2NhbGUucmFuZ2VTdGVwICYmIGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgLSAxIH07XG4gICAgfVxuICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGRlcGVuZHMgb24gY2VsbCdzIHdpZHRoIC8gaGVpZ2h0P1xuICAgIHJldHVybiB7IHZhbHVlOiAyMCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWW1GeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZiV0Z5YXk5aVlYSXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3TzBGQlFVRXNlVU5CUVcxRE8wRkJSVzVETERKRFFVRXdRenRCUVVNeFF5d3JRa0ZCYVVNN1FVRkRha01zY1VOQlFYbEVPMEZCVFhwRUxHbERRVUZ0UXp0QlFVZHVReXhuUTBGQmEwTTdRVUZGY2tJc1VVRkJRU3hIUVVGSExFZEJRV2xDTzBsQlF5OUNMRTFCUVUwc1JVRkJSU3hOUVVGTk8wbEJRMlFzVjBGQlZ5eEZRVUZGTEV0QlFVczdTVUZEYkVJc1YwRkJWeXhGUVVGRkxGVkJRVU1zUzBGQlowSTdVVUZETlVJc1NVRkJUU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTXhRaXhOUVVGTkxITkNRVU5FTEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRMllzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkRaaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4RlFVTnVRaXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEZOQlFWTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1JVRkRka003U1VGRFNpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVkdMRmRCUVZjc1MwRkJaMElzUlVGQlJTeExRVUZ6UWp0SlFVTXhReXhKUVVGQkxIRkNRVUZOTEVWQlFVVXNiVUpCUVVzc1EwRkJWVHRKUVVNNVFpeEpRVUZOTEUxQlFVMHNSMEZCUnl4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU53UXl4SlFVRk5MRTlCUVU4c1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVVndReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNNVFpeEpRVUZOTEZWQlFWVXNSMEZCUnl4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExGZEJRVU1zUTBGQlF5eERRVUZETzBsQlEzUkRMRWxCUVUwc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRPVUlzY1VWQlFYRkZPMGxCUTNKRkxFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNTMEZCU3l4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZDTEUxQlFVMHNjMEpCUTBRc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRmRCUVZjc1EwRkJReXhGUVVNM1F5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hYUVVGWExFTkJRVU1zUlVGRE5VTTdTVUZEU2l4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnlRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNTVUZCU1N4clFrRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM2hETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRExFZEJRVWNzUlVGQlJTeExRVUZMTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFpRVU5zUlN4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4SlFVRkpMRXRCUVVzc2FVSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNeFF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdXVUZEZWtNc1EwRkJRenRSUVVOSUxFTkJRVU03VVVGRFJDeHhSVUZCY1VVN1VVRkZja1VzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4dlFrRkJiMElzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4MVFrRkRka01zUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hEUVVGRExFZEJRek5DTEdOQlFXTXNRMEZCUXl4VlFVRlZMRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZETEVOQlFVTXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkRia1FzUTBGQlF6dEpRVU5LTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUlVRc1YwRkJWeXhMUVVGblFpeEZRVUZGTEV0QlFYTkNPMGxCUXpGRExFbEJRVUVzY1VKQlFVMHNSVUZCUlN4NVFrRkJVU3hGUVVGRkxIRkNRVUZOTEVOQlFWVTdTVUZEZWtNc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNN1NVRkRjRU1zU1VGQlRTeFBRVUZQTEVkQlFVY3NVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVVNVFpeEpRVUZOTEVsQlFVa3NSMEZCUnl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hDTEVsQlFVMHNWVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVjBGQlF5eERRVUZETEVOQlFVTTdTVUZEZEVNc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4WFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNNVFpeHRSVUZCYlVVN1NVRkRia1VzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4TFFVRkxMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE1VSXNUVUZCVFN4elFrRkRSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1YwRkJWeXhEUVVGRExFVkJRemRETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1MwRkJTeXhGUVVGRkxGZEJRVmNzUTBGQlF5eEZRVU0xUXp0SlFVTktMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEVWQlFVVXNRMEZCUXl4RFFVRkRMSEZDUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNKQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjZRaXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNN1dVRkRiRVVzUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeExRVUZMTEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xbEJRM3BETEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eHZRa0ZCYjBJc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEdOQlFXTXNRMEZCUXl4VlFVRlZMRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZETEVOQlFVTXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJReTlJTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUlVRc2QwSkJRWGRDTEZOQlFXbENMRVZCUVVVc1MwRkJXU3hGUVVGRkxFMUJRV003U1VGRGNrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFTXNUVUZCVFN4RFFVRkRMRVZCUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNaMEpCUVdkQ0xFVkJRVU1zUTBGQlF6dEpRVU01UXl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTldMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NhVUpCUVZNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFRRVUZUTEV0QlFVc3NTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE4wSXNUVUZCVFN4RFFVRkRMRVZCUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFRRVUZUTEVkQlFVY3NRMEZCUXl4RlFVRkRMRU5CUVVNN1dVRkRkRU1zUTBGQlF6dFpRVU5FTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eDFRMEZCZFVNc1EwRkJReXhEUVVGRE8xRkJRMmhGTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NTMEZCU3l4cFFrRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEZWtNc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNN1VVRkROMElzUTBGQlF6dFJRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUTA0c1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc2EwSkJRV3RDTEVWQlFVTXNRMEZCUXp0UlFVTm9SQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eEpRVUZKTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhMUVVGTExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VRc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1UwRkJVeXhIUVVGSExFTkJRVU1zUlVGQlF5eERRVUZETzBsQlF6ZERMRU5CUVVNN1NVRkRSQ3h6UkVGQmMwUTdTVUZEZEVRc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVVXNSVUZCUXl4RFFVRkRPMEZCUTNKQ0xFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbmNvZGluZ1wiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uLy4uL2ZpZWxkZGVmXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4uLy4uL21hcmtcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBpbml0TWFya0RlZihtYXJrLCBlbmNvZGluZywgc2NhbGUsIGNvbmZpZykge1xuICAgIHZhciBtYXJrRGVmID0gbWFya18xLmlzTWFya0RlZihtYXJrKSA/IHRzbGliXzEuX19hc3NpZ24oe30sIG1hcmspIDogeyB0eXBlOiBtYXJrIH07XG4gICAgdmFyIHNwZWNpZmllZE9yaWVudCA9IG1hcmtEZWYub3JpZW50IHx8IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ29yaWVudCcsIG1hcmtEZWYudHlwZSwgY29uZmlnKTtcbiAgICBtYXJrRGVmLm9yaWVudCA9IG9yaWVudChtYXJrRGVmLnR5cGUsIGVuY29kaW5nLCBzY2FsZSwgc3BlY2lmaWVkT3JpZW50KTtcbiAgICBpZiAoc3BlY2lmaWVkT3JpZW50ICE9PSB1bmRlZmluZWQgJiYgc3BlY2lmaWVkT3JpZW50ICE9PSBtYXJrRGVmLm9yaWVudCkge1xuICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5vcmllbnRPdmVycmlkZGVuKG1hcmtEZWYub3JpZW50LCBzcGVjaWZpZWRPcmllbnQpKTtcbiAgICB9XG4gICAgdmFyIHNwZWNpZmllZEZpbGxlZCA9IG1hcmtEZWYuZmlsbGVkO1xuICAgIGlmIChzcGVjaWZpZWRGaWxsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXJrRGVmLmZpbGxlZCA9IGZpbGxlZChtYXJrRGVmLnR5cGUsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrRGVmO1xufVxuZXhwb3J0cy5pbml0TWFya0RlZiA9IGluaXRNYXJrRGVmO1xuLyoqXG4gKiBJbml0aWFsaXplIGVuY29kaW5nJ3MgdmFsdWUgd2l0aCBzb21lIHNwZWNpYWwgZGVmYXVsdCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gaW5pdEVuY29kaW5nKG1hcmssIGVuY29kaW5nLCBzdGFja2VkLCBjb25maWcpIHtcbiAgICB2YXIgb3BhY2l0eUNvbmZpZyA9IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ29wYWNpdHknLCBtYXJrLCBjb25maWcpO1xuICAgIGlmICghZW5jb2Rpbmcub3BhY2l0eSAmJiBvcGFjaXR5Q29uZmlnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBkZWZhdWx0T3BhY2l0eShtYXJrLCBlbmNvZGluZywgc3RhY2tlZCk7XG4gICAgICAgIGlmIChvcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVuY29kaW5nLm9wYWNpdHkgPSB7IHZhbHVlOiBvcGFjaXR5IH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5nO1xufVxuZXhwb3J0cy5pbml0RW5jb2RpbmcgPSBpbml0RW5jb2Rpbmc7XG5mdW5jdGlvbiBkZWZhdWx0T3BhY2l0eShtYXJrLCBlbmNvZGluZywgc3RhY2tlZCkge1xuICAgIGlmICh1dGlsXzEuY29udGFpbnMoW21hcmtfMS5QT0lOVCwgbWFya18xLlRJQ0ssIG1hcmtfMS5DSVJDTEUsIG1hcmtfMS5TUVVBUkVdLCBtYXJrKSkge1xuICAgICAgICAvLyBwb2ludC1iYXNlZCBtYXJrc1xuICAgICAgICBpZiAoIWVuY29kaW5nXzEuaXNBZ2dyZWdhdGUoZW5jb2RpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gMC43O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBmaWxsZWQobWFyaywgY29uZmlnKSB7XG4gICAgdmFyIGZpbGxlZENvbmZpZyA9IGNvbW1vbl8xLmdldE1hcmtDb25maWcoJ2ZpbGxlZCcsIG1hcmssIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZpbGxlZENvbmZpZyAhPT0gdW5kZWZpbmVkID8gZmlsbGVkQ29uZmlnIDogbWFyayAhPT0gbWFya18xLlBPSU5UICYmIG1hcmsgIT09IG1hcmtfMS5MSU5FICYmIG1hcmsgIT09IG1hcmtfMS5SVUxFO1xufVxuZnVuY3Rpb24gb3JpZW50KG1hcmssIGVuY29kaW5nLCBzY2FsZSwgc3BlY2lmaWVkT3JpZW50KSB7XG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgbWFya18xLlBPSU5UOlxuICAgICAgICBjYXNlIG1hcmtfMS5DSVJDTEU6XG4gICAgICAgIGNhc2UgbWFya18xLlNRVUFSRTpcbiAgICAgICAgY2FzZSBtYXJrXzEuVEVYVDpcbiAgICAgICAgY2FzZSBtYXJrXzEuUkVDVDpcbiAgICAgICAgICAgIC8vIG9yaWVudCBpcyBtZWFuaW5nbGVzcyBmb3IgdGhlc2UgbWFya3MuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgeUlzUmFuZ2UgPSBlbmNvZGluZy55ICYmIGVuY29kaW5nLnkyO1xuICAgIHZhciB4SXNSYW5nZSA9IGVuY29kaW5nLnggJiYgZW5jb2RpbmcueDI7XG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgbWFya18xLlRJQ0s6XG4gICAgICAgICAgICB2YXIgeFNjYWxlVHlwZSA9IHNjYWxlWyd4J10gPyBzY2FsZVsneCddLnR5cGUgOiBudWxsO1xuICAgICAgICAgICAgdmFyIHlTY2FsZVR5cGUgPSBzY2FsZVsneSddID8gc2NhbGVbJ3knXS50eXBlIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFRpY2sgaXMgb3Bwb3NpdGUgdG8gYmFyLCBsaW5lLCBhcmVhIGFuZCBuZXZlciBoYXZlIHJhbmdlZCBtYXJrLlxuICAgICAgICAgICAgaWYgKCFzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHhTY2FsZVR5cGUpICYmICghZW5jb2RpbmcueSB8fFxuICAgICAgICAgICAgICAgIHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oeVNjYWxlVHlwZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLnkpICYmIGVuY29kaW5nLnkuYmluKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHk6USBvciBBbWJpZ3VvdXMgY2FzZSwgcmV0dXJuIGhvcml6b250YWxcbiAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgIGNhc2UgbWFya18xLlJVTEU6XG4gICAgICAgIGNhc2UgbWFya18xLkJBUjpcbiAgICAgICAgY2FzZSBtYXJrXzEuQVJFQTpcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSByYW5nZSBmb3IgYm90aCB4IGFuZCB5LCB5ICh2ZXJ0aWNhbCkgaGFzIGhpZ2hlciBwcmVjZWRlbmNlLlxuICAgICAgICAgICAgaWYgKHlJc1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4SXNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXJrID09PSBtYXJrXzEuUlVMRSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy54ICYmICFlbmNvZGluZy55KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZy55ICYmICFlbmNvZGluZy54KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgICAgICBjYXNlIG1hcmtfMS5MSU5FOlxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICAgICAgdmFyIHhJc0NvbnRpbnVvdXMgPSBmaWVsZGRlZl8xLmlzRmllbGREZWYoZW5jb2RpbmcueCkgJiYgZmllbGRkZWZfMS5pc0NvbnRpbnVvdXMoZW5jb2RpbmcueCk7XG4gICAgICAgICAgICB2YXIgeUlzQ29udGludW91cyA9IGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy55KSAmJiBmaWVsZGRlZl8xLmlzQ29udGludW91cyhlbmNvZGluZy55KTtcbiAgICAgICAgICAgIGlmICh4SXNDb250aW51b3VzICYmICF5SXNDb250aW51b3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF4SXNDb250aW51b3VzICYmIHlJc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhJc0NvbnRpbnVvdXMgJiYgeUlzQ29udGludW91cykge1xuICAgICAgICAgICAgICAgIHZhciB4RGVmID0gZW5jb2RpbmcueDsgLy8gd2UgY2FuIGNhc3QgaGVyZSBzaW5jZSB0aGV5IGFyZSBzdXJlbHkgZmllbGREZWZcbiAgICAgICAgICAgICAgICB2YXIgeURlZiA9IGVuY29kaW5nLnk7XG4gICAgICAgICAgICAgICAgdmFyIHhJc1RlbXBvcmFsID0geERlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUw7XG4gICAgICAgICAgICAgICAgdmFyIHlJc1RlbXBvcmFsID0geURlZi50eXBlID09PSB0eXBlXzEuVEVNUE9SQUw7XG4gICAgICAgICAgICAgICAgLy8gdGVtcG9yYWwgd2l0aG91dCB0aW1lVW5pdCBpcyBjb25zaWRlcmVkIGNvbnRpbnVvdXMsIGJ1dCBiZXR0ZXIgc2VydmVzIGFzIGRpbWVuc2lvblxuICAgICAgICAgICAgICAgIGlmICh4SXNUZW1wb3JhbCAmJiAheUlzVGVtcG9yYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF4SXNUZW1wb3JhbCAmJiB5SXNUZW1wb3JhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXhEZWYuYWdncmVnYXRlICYmIHlEZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4RGVmLmFnZ3JlZ2F0ZSAmJiAheURlZi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllZE9yaWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGFtYmlndW91cywgdXNlIHVzZXIgc3BlY2lmaWVkIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWNpZmllZE9yaWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEobWFyayA9PT0gbWFya18xLkxJTkUgJiYgZW5jb2Rpbmcub3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCBmb3IgY29ubmVjdGVkIHNjYXR0ZXJwbG90LCB3ZSBzaG91bGQgbG9nIHdhcm5pbmcgZm9yIHVuY2xlYXIgb3JpZW50YXRpb24gb2YgUXhRIHBsb3RzLlxuICAgICAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS51bmNsZWFyT3JpZW50Q29udGludW91cyhtYXJrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAndmVydGljYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIERpc2NyZXRlIHggRGlzY3JldGUgY2FzZSwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS51bmNsZWFyT3JpZW50RGlzY3JldGVPckVtcHR5KG1hcmspKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3ZlcnRpY2FsJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXBkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZhVzVwZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZEUVN3eVEwRkJjVVE3UVVGRGNrUXNNa05CUVd0Rk8wRkJRMnhGTEN0Q1FVRnBRenRCUVVOcVF5eHRRMEZCTkVnN1FVRkROVWdzY1VOQlFYRkVPMEZCUlhKRUxHMURRVUZ2UXp0QlFVTndReXh0UTBGQk1FTTdRVUZETVVNc2IwTkJRWGRETzBGQlJYaERMSEZDUVVFMFFpeEpRVUZ2UWl4RlFVRkZMRkZCUVd0Q0xFVkJRVVVzUzBGQmEwSXNSVUZCUlN4TlFVRmpPMGxCUTNSSExFbEJRVTBzVDBGQlR5eEhRVUZITEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExIZENRVUZQTEVsQlFVa3NTVUZCU1N4RlFVRkRMRWxCUVVrc1JVRkJSU3hKUVVGSkxFVkJRVU1zUTBGQlF6dEpRVVV6UkN4SlFVRk5MR1ZCUVdVc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeEpRVUZKTEhOQ1FVRmhMRU5CUVVNc1VVRkJVU3hGUVVGRkxFOUJRVThzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRlRVlzVDBGQlR5eERRVUZETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUlVGQlJTeFJRVUZSTEVWQlFVVXNTMEZCU3l4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8wbEJRM2hGTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1MwRkJTeXhUUVVGVExFbEJRVWtzWlVGQlpTeExRVUZMTEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM2hGTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEZRVUZETEdWQlFXVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla1VzUTBGQlF6dEpRVVZFTEVsQlFVMHNaVUZCWlN4SFFVRkhMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGRrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1pVRkJaU3hMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUlVRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dEJRVU5xUWl4RFFVRkRPMEZCWmtRc2EwTkJaVU03UVVGRlJEczdSMEZGUnp0QlFVTklMSE5DUVVFMlFpeEpRVUZWTEVWQlFVVXNVVUZCYTBJc1JVRkJSU3hQUVVGM1FpeEZRVUZGTEUxQlFXTTdTVUZEYmtjc1NVRkJUU3hoUVVGaExFZEJRVWNzYzBKQlFXRXNRMEZCUXl4VFFVRlRMRVZCUVVVc1NVRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eERRVUZETzBsQlF6ZEVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNTVUZCU1N4aFFVRmhMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UkN4SlFVRk5MRTlCUVU4c1IwRkJSeXhqUVVGakxFTkJRVU1zU1VGQlNTeEZRVUZGTEZGQlFWRXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRSUVVONFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU14UWl4UlFVRlJMRU5CUVVNc1QwRkJUeXhIUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUXl4RFFVRkRPMUZCUTNSRExFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRCUVVOc1FpeERRVUZETzBGQlZFUXNiME5CVTBNN1FVRkhSQ3gzUWtGQmQwSXNTVUZCVlN4RlFVRkZMRkZCUVd0Q0xFVkJRVVVzVDBGQmQwSTdTVUZET1VVc1JVRkJSU3hEUVVGRExFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNXVUZCU3l4RlFVRkZMRmRCUVVrc1JVRkJSU3hoUVVGTkxFVkJRVVVzWVVGQlRTeERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnhFTEc5Q1FVRnZRanRSUVVOd1FpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMSE5DUVVGWExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpOQ0xFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTTdVVUZEWWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVVWRUxHZENRVUZuUWl4SlFVRlZMRVZCUVVVc1RVRkJZenRKUVVONFF5eEpRVUZOTEZsQlFWa3NSMEZCUnl4elFrRkJZU3hEUVVGRExGRkJRVkVzUlVGQlJTeEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNN1NVRkRNMFFzVFVGQlRTeERRVUZETEZsQlFWa3NTMEZCU3l4VFFVRlRMRWRCUVVjc1dVRkJXU3hIUVVGSExFbEJRVWtzUzBGQlN5eFpRVUZMTEVsQlFVa3NTVUZCU1N4TFFVRkxMRmRCUVVrc1NVRkJTU3hKUVVGSkxFdEJRVXNzVjBGQlNTeERRVUZETzBGQlEzUkhMRU5CUVVNN1FVRkZSQ3huUWtGQlowSXNTVUZCVlN4RlFVRkZMRkZCUVd0Q0xFVkJRVVVzUzBGQmEwSXNSVUZCUlN4bFFVRjFRanRKUVVONlJpeE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMklzUzBGQlN5eFpRVUZMTEVOQlFVTTdVVUZEV0N4TFFVRkxMR0ZCUVUwc1EwRkJRenRSUVVOYUxFdEJRVXNzWVVGQlRTeERRVUZETzFGQlExb3NTMEZCU3l4WFFVRkpMRU5CUVVNN1VVRkRWaXhMUVVGTExGZEJRVWs3V1VGRFVDeDVRMEZCZVVNN1dVRkRla01zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnlRaXhEUVVGRE8wbEJSVVFzU1VGQlRTeFJRVUZSTEVkQlFVY3NVVUZCVVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlF6TkRMRWxCUVUwc1VVRkJVU3hIUVVGSExGRkJRVkVzUTBGQlF5eERRVUZETEVsQlFVa3NVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJRenRKUVVVelF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMklzUzBGQlN5eFhRVUZKTzFsQlExQXNTVUZCVFN4VlFVRlZMRWRCUVVjc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETzFsQlEzWkVMRWxCUVUwc1ZVRkJWU3hIUVVGSExFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXp0WlFVVjJSQ3hyUlVGQmEwVTdXVUZEYkVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eDVRa0ZCYVVJc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVU5vUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8yZENRVU5ZTEhsQ1FVRnBRaXhEUVVGRExGVkJRVlVzUTBGQlF6dG5Ra0ZETjBJc1EwRkJReXh4UWtGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVTTNReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEU2l4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8xbEJRM0JDTEVOQlFVTTdXVUZEUkN3eVEwRkJNa003V1VGRE0wTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJRenRSUVVWMFFpeExRVUZMTEZkQlFVa3NRMEZCUXp0UlFVTldMRXRCUVVzc1ZVRkJSeXhEUVVGRE8xRkJRMVFzUzBGQlN5eFhRVUZKTzFsQlExQXNNa1ZCUVRKRk8xbEJRek5GTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEySXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRaUVVOd1FpeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNCQ0xFMUJRVTBzUTBGQlF5eFpRVUZaTEVOQlFVTTdXVUZEZEVJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1YwRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTVRaXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETzJkQ1FVTndRaXhEUVVGRE8yZENRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEzSkRMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU03WjBKQlEzUkNMRU5CUVVNN1dVRkRTQ3hEUVVGRE8xRkJSVVFzYjBKQlFXOUNPMUZCUTNSQ0xFdEJRVXNzVjBGQlNUdFpRVU5RTEcxQ1FVRnRRanRaUVVOdVFpeEpRVUZOTEdGQlFXRXNSMEZCUnl4eFFrRkJWU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4MVFrRkJXU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSU3hKUVVGTkxHRkJRV0VzUjBGQlJ5eHhRa0ZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeDFRa0ZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU42UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhoUVVGaExFbEJRVWtzUTBGQlF5eGhRVUZoTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOd1F5eE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRPMWxCUTNSQ0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhoUVVGaExFbEJRVWtzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNME1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0WlFVTndRaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMR0ZCUVdFc1NVRkJTU3hoUVVGaExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTXhReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCWVN4RFFVRkRMRU5CUVVNc2EwUkJRV3RFTzJkQ1FVTjJSaXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFJRVUZSTEVOQlFVTXNRMEZCWVN4RFFVRkRPMmRDUVVWd1F5eEpRVUZOTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hMUVVGTExHVkJRVkVzUTBGQlF6dG5Ra0ZETTBNc1NVRkJUU3hYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZETEVsQlFVa3NTMEZCU3l4bFFVRlJMRU5CUVVNN1owSkJSVE5ETEhGR1FVRnhSanRuUWtGRGNrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1YwRkJWeXhKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkRhRU1zVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0blFrRkRjRUlzUTBGQlF6dG5Ra0ZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFhRVUZYTEVsQlFVa3NWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGRrTXNUVUZCVFN4RFFVRkRMRmxCUVZrc1EwRkJRenRuUWtGRGRFSXNRMEZCUXp0blFrRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4VFFVRlRMRWxCUVVrc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTNSRExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTTdaMEpCUTNCQ0xFTkJRVU03WjBKQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFRRVUZUTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETjBNc1RVRkJUU3hEUVVGRExGbEJRVmtzUTBGQlF6dG5Ra0ZEZEVJc1EwRkJRenRuUWtGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU53UWl3d1EwRkJNRU03YjBKQlF6RkRMRTFCUVUwc1EwRkJReXhsUVVGbExFTkJRVU03WjBKQlEzcENMRU5CUVVNN1owSkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhYUVVGSkxFbEJRVWtzVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGRrTXNaMGRCUVdkSE8yOUNRVU5vUnl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNkVUpCUVhWQ0xFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRVFzUTBGQlF6dG5Ra0ZEUkN4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8xbEJRM0JDTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeHJSRUZCYTBRN1owSkJRMnhFTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5dzBRa0ZCTkVJc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjZSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzFsQlEyNUNMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEZWQlFWVXNRMEZCUXp0QlFVTndRaXhEUVVGREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1peGlucyA9IHJlcXVpcmUoXCIuL21peGluc1wiKTtcbmV4cG9ydHMubGluZSA9IHtcbiAgICB2Z01hcms6ICdsaW5lJyxcbiAgICBkZWZhdWx0Um9sZTogdW5kZWZpbmVkLFxuICAgIGVuY29kZUVudHJ5OiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIG1peGlucy5wb2ludFBvc2l0aW9uKCd4JywgbW9kZWwsICd6ZXJvT3JNaW4nKSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3knLCBtb2RlbCwgJ3plcm9Pck1pbicpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ29wYWNpdHknLCBtb2RlbCksIG1peGlucy5ub25Qb3NpdGlvbignc2l6ZScsIG1vZGVsLCB7XG4gICAgICAgICAgICB2Z0NoYW5uZWw6ICdzdHJva2VXaWR0aCcgLy8gVkwncyBsaW5lIHNpemUgaXMgc3Ryb2tlV2lkdGhcbiAgICAgICAgfSksIG1peGlucy5tYXJrRGVmUHJvcGVydGllcyhtb2RlbC5tYXJrRGVmLCBbJ2ludGVycG9sYXRlJywgJ3RlbnNpb24nXSkpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liR2x1WlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2YkdsdVpTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGRFFTeHBRMEZCYlVNN1FVRkpkRUlzVVVGQlFTeEpRVUZKTEVkQlFXbENPMGxCUTJoRExFMUJRVTBzUlVGQlJTeE5RVUZOTzBsQlEyUXNWMEZCVnl4RlFVRkZMRk5CUVZNN1NVRkRkRUlzVjBGQlZ5eEZRVUZGTEZWQlFVTXNTMEZCWjBJN1VVRkROVUlzVFVGQlRTeHpRa0ZEUkN4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExFZEJRVWNzUlVGQlJTeExRVUZMTEVWQlFVVXNWMEZCVnl4RFFVRkRMRVZCUXpkRExFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hYUVVGWExFTkJRVU1zUlVGRE4wTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGRGJrSXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eERRVUZETEVWQlEzQkRMRTFCUVUwc1EwRkJReXhYUVVGWExFTkJRVU1zVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUlR0WlFVTnVReXhUUVVGVExFVkJRVVVzWVVGQllTeERRVUZGTEdkRFFVRm5RenRUUVVNelJDeERRVUZETEVWQlEwTXNUVUZCVFN4RFFVRkRMR2xDUVVGcFFpeERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhoUVVGaExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNSVUZEZEVVN1NVRkRTaXhEUVVGRE8wTkJRMFlzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXJrXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGFyZWFfMSA9IHJlcXVpcmUoXCIuL2FyZWFcIik7XG52YXIgYmFyXzEgPSByZXF1aXJlKFwiLi9iYXJcIik7XG52YXIgbGluZV8xID0gcmVxdWlyZShcIi4vbGluZVwiKTtcbnZhciBwb2ludF8xID0gcmVxdWlyZShcIi4vcG9pbnRcIik7XG52YXIgcmVjdF8xID0gcmVxdWlyZShcIi4vcmVjdFwiKTtcbnZhciBydWxlXzEgPSByZXF1aXJlKFwiLi9ydWxlXCIpO1xudmFyIHRleHRfMSA9IHJlcXVpcmUoXCIuL3RleHRcIik7XG52YXIgdGlja18xID0gcmVxdWlyZShcIi4vdGlja1wiKTtcbnZhciBkYXRhXzEgPSByZXF1aXJlKFwiLi4vLi4vZGF0YVwiKTtcbnZhciBtYXJrQ29tcGlsZXIgPSB7XG4gICAgYXJlYTogYXJlYV8xLmFyZWEsXG4gICAgYmFyOiBiYXJfMS5iYXIsXG4gICAgbGluZTogbGluZV8xLmxpbmUsXG4gICAgcG9pbnQ6IHBvaW50XzEucG9pbnQsXG4gICAgdGV4dDogdGV4dF8xLnRleHQsXG4gICAgdGljazogdGlja18xLnRpY2ssXG4gICAgcmVjdDogcmVjdF8xLnJlY3QsXG4gICAgcnVsZTogcnVsZV8xLnJ1bGUsXG4gICAgY2lyY2xlOiBwb2ludF8xLmNpcmNsZSxcbiAgICBzcXVhcmU6IHBvaW50XzEuc3F1YXJlXG59O1xuZnVuY3Rpb24gcGFyc2VNYXJrKG1vZGVsKSB7XG4gICAgaWYgKHV0aWxfMS5jb250YWlucyhbbWFya18xLkxJTkUsIG1hcmtfMS5BUkVBXSwgbW9kZWwubWFyaygpKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VQYXRoTWFyayhtb2RlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VOb25QYXRoTWFyayhtb2RlbCk7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZU1hcmsgPSBwYXJzZU1hcms7XG52YXIgRkFDRVRFRF9QQVRIX1BSRUZJWCA9ICdmYWNldGVkLXBhdGgtJztcbmZ1bmN0aW9uIHBhcnNlUGF0aE1hcmsobW9kZWwpIHtcbiAgICB2YXIgbWFyayA9IG1vZGVsLm1hcmsoKTtcbiAgICAvLyBGSVhNRTogcmVwbGFjZSB0aGlzIHdpdGggbW9yZSBnZW5lcmFsIGNhc2UgZm9yIGNvbXBvc2l0aW9uXG4gICAgdmFyIGRldGFpbHMgPSBkZXRhaWxGaWVsZHMobW9kZWwpO1xuICAgIHZhciBwYXRoTWFya3MgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IG1vZGVsLmdldE5hbWUoJ21hcmtzJyksXG4gICAgICAgICAgICB0eXBlOiBtYXJrQ29tcGlsZXJbbWFya10udmdNYXJrLFxuICAgICAgICAgICAgLy8gSWYgaGFzIHN1YmZhY2V0IGZvciBsaW5lL2FyZWEgZ3JvdXAsIG5lZWQgdG8gdXNlIGZhY2V0ZWQgZGF0YSBmcm9tIGJlbG93LlxuICAgICAgICAgICAgLy8gRklYTUU6IHN1cHBvcnQgc29ydGluZyBwYXRoIG9yZGVyIChpbiBjb25uZWN0ZWQgc2NhdHRlcnBsb3QpXG4gICAgICAgICAgICBmcm9tOiB7IGRhdGE6IChkZXRhaWxzLmxlbmd0aCA+IDAgPyBGQUNFVEVEX1BBVEhfUFJFRklYIDogJycpICsgbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pIH0sXG4gICAgICAgICAgICBlbmNvZGU6IHsgdXBkYXRlOiBtYXJrQ29tcGlsZXJbbWFya10uZW5jb2RlRW50cnkobW9kZWwpIH1cbiAgICAgICAgfVxuICAgIF07XG4gICAgaWYgKGRldGFpbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUT0RPOiBmb3Igbm9uLXN0YWNrZWQgcGxvdCwgbWFwIG9yZGVyIHRvIHppbmRleC4gKE1heWJlIHJlbmFtZSBvcmRlciBmb3IgbGF5ZXIgdG8gemluZGV4PylcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgbmFtZTogbW9kZWwuZ2V0TmFtZSgncGF0aGdyb3VwJyksXG4gICAgICAgICAgICAgICAgdHlwZTogJ2dyb3VwJyxcbiAgICAgICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGZhY2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBGQUNFVEVEX1BBVEhfUFJFRklYICsgbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBieTogZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHsgZmllbGQ6IHsgZ3JvdXA6ICd3aWR0aCcgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB7IGZpZWxkOiB7IGdyb3VwOiAnaGVpZ2h0JyB9IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWFya3M6IHBhdGhNYXJrc1xuICAgICAgICAgICAgfV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGF0aE1hcmtzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlTm9uUGF0aE1hcmsobW9kZWwpIHtcbiAgICB2YXIgbWFyayA9IG1vZGVsLm1hcmsoKTtcbiAgICB2YXIgcm9sZSA9IG1vZGVsLm1hcmtEZWYucm9sZSB8fCBtYXJrQ29tcGlsZXJbbWFya10uZGVmYXVsdFJvbGU7XG4gICAgdmFyIG1hcmtzID0gW107IC8vIFRPRE86IHZnTWFya3NcbiAgICAvLyBUT0RPOiBmb3Igbm9uLXN0YWNrZWQgcGxvdCwgbWFwIG9yZGVyIHRvIHppbmRleC4gKE1heWJlIHJlbmFtZSBvcmRlciBmb3IgbGF5ZXIgdG8gemluZGV4PylcbiAgICBtYXJrcy5wdXNoKHRzbGliXzEuX19hc3NpZ24oeyBuYW1lOiBtb2RlbC5nZXROYW1lKCdtYXJrcycpLCB0eXBlOiBtYXJrQ29tcGlsZXJbbWFya10udmdNYXJrIH0sIChyb2xlID8geyByb2xlOiByb2xlIH0gOiB7fSksIHsgZnJvbTogeyBkYXRhOiBtb2RlbC5nZXREYXRhTmFtZShkYXRhXzEuTUFJTikgfSwgZW5jb2RlOiB7IHVwZGF0ZTogbWFya0NvbXBpbGVyW21hcmtdLmVuY29kZUVudHJ5KG1vZGVsKSB9IH0pKTtcbiAgICByZXR1cm4gbWFya3M7XG59XG4vKipcbiAqIFJldHVybnMgbGlzdCBvZiBkZXRhaWwgKGdyb3VwLWJ5KSBmaWVsZHNcbiAqIHRoYXQgdGhlIG1vZGVsJ3Mgc3BlYyBjb250YWlucy5cbiAqL1xuZnVuY3Rpb24gZGV0YWlsRmllbGRzKG1vZGVsKSB7XG4gICAgcmV0dXJuIGNoYW5uZWxfMS5MRVZFTF9PRl9ERVRBSUxfQ0hBTk5FTFMucmVkdWNlKGZ1bmN0aW9uIChkZXRhaWxzLCBjaGFubmVsKSB7XG4gICAgICAgIGlmIChtb2RlbC5jaGFubmVsSGFzRmllbGQoY2hhbm5lbCkgJiYgIW1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgZGV0YWlscy5wdXNoKG1vZGVsLmZpZWxkKGNoYW5uZWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICB9LCBbXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV0Z5YXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2YldGeWF5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDVRMEZCZFVRN1FVRkRka1FzYlVOQlFYTkRPMEZCUTNSRExHMURRVUZ2UXp0QlFVVndReXdyUWtGQk5FSTdRVUZETlVJc05rSkJRVEJDTzBGQlJURkNMQ3RDUVVFMFFqdEJRVU0xUWl4cFEwRkJPRU03UVVGRE9VTXNLMEpCUVRSQ08wRkJRelZDTEN0Q1FVRTBRanRCUVVNMVFpd3JRa0ZCTkVJN1FVRkROVUlzSzBKQlFUUkNPMEZCUlRWQ0xHMURRVUZuUXp0QlFVbG9ReXhKUVVGTkxGbEJRVmtzUjBGQmJVTTdTVUZEYmtRc1NVRkJTU3hGUVVGRkxGZEJRVWs3U1VGRFZpeEhRVUZITEVWQlFVVXNVMEZCUnp0SlFVTlNMRWxCUVVrc1JVRkJSU3hYUVVGSk8wbEJRMVlzUzBGQlN5eEZRVUZGTEdGQlFVczdTVUZEV2l4SlFVRkpMRVZCUVVVc1YwRkJTVHRKUVVOV0xFbEJRVWtzUlVGQlJTeFhRVUZKTzBsQlExWXNTVUZCU1N4RlFVRkZMRmRCUVVrN1NVRkRWaXhKUVVGSkxFVkJRVVVzVjBGQlNUdEpRVU5XTEUxQlFVMHNSVUZCUlN4alFVRk5PMGxCUTJRc1RVRkJUU3hGUVVGRkxHTkJRVTA3UTBGRFppeERRVUZETzBGQlJVWXNiVUpCUVRCQ0xFdEJRV2RDTzBsQlEzaERMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRVkVzUTBGQlF5eERRVUZETEZkQlFVa3NSVUZCUlN4WFFVRkpMRU5CUVVNc1JVRkJSU3hMUVVGTExFTkJRVU1zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRla01zVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVNNVFpeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRGFrTXNRMEZCUXp0QlFVTklMRU5CUVVNN1FVRk9SQ3c0UWtGTlF6dEJRVVZFTEVsQlFVMHNiVUpCUVcxQ0xFZEJRVWNzWlVGQlpTeERRVUZETzBGQlJUVkRMSFZDUVVGMVFpeExRVUZuUWp0SlFVTnlReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1NVRkRNVUlzTmtSQlFUWkVPMGxCUXpkRUxFbEJRVTBzVDBGQlR5eEhRVUZITEZsQlFWa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVWd1F5eEpRVUZOTEZOQlFWTXNSMEZCVVR0UlFVTnlRanRaUVVORkxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJRenRaUVVNMVFpeEpRVUZKTEVWQlFVVXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFMUJRVTA3V1VGREwwSXNORVZCUVRSRk8xbEJRelZGTEN0RVFVRXJSRHRaUVVNdlJDeEpRVUZKTEVWQlFVVXNSVUZCUXl4SlFVRkpMRVZCUVVVc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNSMEZCUnl4dFFrRkJiVUlzUjBGQlJ5eEZRVUZGTEVOQlFVTXNSMEZCUnl4TFFVRkxMRU5CUVVNc1YwRkJWeXhEUVVGRExGZEJRVWtzUTBGQlF5eEZRVUZETzFsQlEzWkdMRTFCUVUwc1JVRkJSU3hGUVVGRExFMUJRVTBzUlVGQlJTeFpRVUZaTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1YwRkJWeXhEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZETzFOQlEzaEVPMHRCUTBZc1EwRkJRenRKUVVWR0xFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4yUWl3MlJrRkJOa1k3VVVGRk4wWXNUVUZCVFN4RFFVRkRMRU5CUVVNN1owSkJRMDRzU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1YwRkJWeXhEUVVGRE8yZENRVU5vUXl4SlFVRkpMRVZCUVVVc1QwRkJUenRuUWtGRFlpeEpRVUZKTEVWQlFVVTdiMEpCUTBvc1MwRkJTeXhGUVVGRk8zZENRVU5NTEVsQlFVa3NSVUZCUlN4dFFrRkJiVUlzUjBGQlJ5eExRVUZMTEVOQlFVTXNWMEZCVnl4RFFVRkRMRmRCUVVrc1EwRkJRenQzUWtGRGJrUXNTVUZCU1N4RlFVRkZMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU1zVjBGQlNTeERRVUZETzNkQ1FVTTNRaXhQUVVGUExFVkJRVVVzVDBGQlR6dHhRa0ZEYWtJN2FVSkJRMFk3WjBKQlEwUXNUVUZCVFN4RlFVRkZPMjlDUVVOT0xFMUJRVTBzUlVGQlJUdDNRa0ZEVGl4TFFVRkxMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkRMRVZCUVVNN2QwSkJRMmhETEUxQlFVMHNSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeFJRVUZSTEVWQlFVTXNSVUZCUXp0eFFrRkRia003YVVKQlEwWTdaMEpCUTBRc1MwRkJTeXhGUVVGRkxGTkJRVk03WVVGRGFrSXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRKUVVOdVFpeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFVVkVMREJDUVVFd1FpeExRVUZuUWp0SlFVTjRReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eExRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNN1NVRkZNVUlzU1VGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFbEJRVWtzV1VGQldTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJRenRKUVVWc1JTeEpRVUZOTEV0QlFVc3NSMEZCVlN4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlowSTdTVUZGZWtNc05rWkJRVFpHTzBsQlJUZEdMRXRCUVVzc1EwRkJReXhKUVVGSkxHOUNRVU5TTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eEZRVU0xUWl4SlFVRkpMRVZCUVVVc1dVRkJXU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNTVUZETlVJc1EwRkJReXhKUVVGSkxFZEJRVVVzUlVGQlF5eEpRVUZKTEUxQlFVRXNSVUZCUXl4SFFVRkhMRVZCUVVVc1EwRkJReXhKUVVOMFFpeEpRVUZKTEVWQlFVVXNSVUZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExGZEJRVmNzUTBGQlF5eFhRVUZKTEVOQlFVTXNSVUZCUXl4RlFVTnlReXhOUVVGTkxFVkJRVVVzUlVGQlF5eE5RVUZOTEVWQlFVVXNXVUZCV1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExGZEJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZCUXl4SlFVTjJSQ3hEUVVGRE8wbEJSVWdzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNN1FVRkpSRHM3TzBkQlIwYzdRVUZEU0N4elFrRkJjMElzUzBGQlowSTdTVUZEY0VNc1RVRkJUU3hEUVVGRExHdERRVUYzUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhWUVVGVExFOUJRVThzUlVGQlJTeFBRVUZQTzFGQlF6bEVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eGxRVUZsTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRja01zUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1NVRkRha0lzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMEZCUTFRc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIHJlZiA9IHJlcXVpcmUoXCIuL3ZhbHVlcmVmXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvbi9zZWxlY3Rpb25cIik7XG5mdW5jdGlvbiBjb2xvcihtb2RlbCkge1xuICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWc7XG4gICAgdmFyIGZpbGxlZCA9IG1vZGVsLm1hcmtEZWYuZmlsbGVkO1xuICAgIHZhciBlID0gbm9uUG9zaXRpb24oJ2NvbG9yJywgbW9kZWwsIHtcbiAgICAgICAgdmdDaGFubmVsOiBmaWxsZWQgPyAnZmlsbCcgOiAnc3Ryb2tlJyxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBjb21tb25fMS5nZXRNYXJrQ29uZmlnKCdjb2xvcicsIG1vZGVsLm1hcmsoKSwgY29uZmlnKVxuICAgIH0pO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGZpbGwsIGFsd2F5cyBmaWxsIHN5bWJvbHNcbiAgICAvLyB3aXRoIHRyYW5zcGFyZW50IGZpbGxzIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9pc3N1ZXMvMTMxNlxuICAgIGlmICghZS5maWxsICYmIHV0aWwuY29udGFpbnMoWydiYXInLCAncG9pbnQnLCAnY2lyY2xlJywgJ3NxdWFyZSddLCBtb2RlbC5tYXJrKCkpKSB7XG4gICAgICAgIGUuZmlsbCA9IHsgdmFsdWU6ICd0cmFuc3BhcmVudCcgfTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG59XG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5mdW5jdGlvbiBtYXJrRGVmUHJvcGVydGllcyhtYXJrLCBwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5yZWR1Y2UoZnVuY3Rpb24gKG0sIHByb3ApIHtcbiAgICAgICAgaWYgKG1hcmtbcHJvcF0pIHtcbiAgICAgICAgICAgIG1bcHJvcF0gPSB7IHZhbHVlOiBtYXJrW3Byb3BdIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5tYXJrRGVmUHJvcGVydGllcyA9IG1hcmtEZWZQcm9wZXJ0aWVzO1xuZnVuY3Rpb24gdmFsdWVJZkRlZmluZWQocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX2EgPSB7fSwgX2FbcHJvcF0gPSB7IHZhbHVlOiB2YWx1ZSB9LCBfYTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgX2E7XG59XG5leHBvcnRzLnZhbHVlSWZEZWZpbmVkID0gdmFsdWVJZkRlZmluZWQ7XG4vKipcbiAqIFJldHVybiBtaXhpbnMgZm9yIG5vbi1wb3NpdGlvbmFsIGNoYW5uZWxzIHdpdGggc2NhbGVzLiAgKFRleHQgZG9lc24ndCBoYXZlIHNjYWxlLilcbiAqL1xuZnVuY3Rpb24gbm9uUG9zaXRpb24oY2hhbm5lbCwgbW9kZWwsIG9wdCkge1xuICAgIC8vIFRPRE86IHJlZmFjdG9yIGhvdyByZWZlciB0byBzY2FsZSBhcyBkaXNjdXNzZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL3B1bGwvMTYxM1xuICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB7fTsgfVxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBvcHQuZGVmYXVsdFZhbHVlLCB2Z0NoYW5uZWwgPSBvcHQudmdDaGFubmVsO1xuICAgIHZhciBkZWZhdWx0UmVmID0gb3B0LmRlZmF1bHRSZWYgfHwgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8geyB2YWx1ZTogZGVmYXVsdFZhbHVlIH0gOiB1bmRlZmluZWQpO1xuICAgIHZhciBjaGFubmVsRGVmID0gbW9kZWwuZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgdmFyIHZhbHVlUmVmID0gcmVmLm1pZFBvaW50KGNoYW5uZWwsIGNoYW5uZWxEZWYsIG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKSwgbW9kZWwuc2NhbGUoY2hhbm5lbCksIGRlZmF1bHRSZWYpO1xuICAgIHJldHVybiB3cmFwQ29uZGl0aW9uKG1vZGVsLCBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYuY29uZGl0aW9uLCB2Z0NoYW5uZWwgfHwgY2hhbm5lbCwgdmFsdWVSZWYpO1xufVxuZXhwb3J0cy5ub25Qb3NpdGlvbiA9IG5vblBvc2l0aW9uO1xuLyoqXG4gKiBSZXR1cm4gYSBtaXhpbiB0aGF0IGluY2x1ZGUgYSBWZWdhIHByb2R1Y3Rpb24gcnVsZSBmb3IgYSBWZWdhLUxpdGUgY29uZGl0aW9uYWwgY2hhbm5lbCBkZWZpbml0aW9uLlxuICogb3IgYSBzaW1wbGUgbWl4aW4gaWYgY2hhbm5lbCBkZWYgaGFzIG5vIGNvbmRpdGlvbi5cbiAqL1xuZnVuY3Rpb24gd3JhcENvbmRpdGlvbihtb2RlbCwgY29uZGl0aW9uLCB2Z0NoYW5uZWwsIHZhbHVlUmVmKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gY29uZGl0aW9uLnNlbGVjdGlvbiwgdmFsdWUgPSBjb25kaXRpb24udmFsdWU7XG4gICAgICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICAgICAgX2FbdmdDaGFubmVsXSA9IFtcbiAgICAgICAgICAgICAgICB7IHRlc3Q6IHNlbGVjdGlvblRlc3QobW9kZWwsIHNlbGVjdGlvbiksIHZhbHVlOiB2YWx1ZSB9XG4gICAgICAgICAgICBdLmNvbmNhdCgodmFsdWVSZWYgIT09IHVuZGVmaW5lZCA/IFt2YWx1ZVJlZl0gOiBbXSkpLFxuICAgICAgICAgICAgX2E7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWVSZWYgIT09IHVuZGVmaW5lZCA/IChfYiA9IHt9LCBfYlt2Z0NoYW5uZWxdID0gdmFsdWVSZWYsIF9iKSA6IHt9O1xuICAgIH1cbiAgICB2YXIgX2EsIF9iO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVGVzdChtb2RlbCwgc2VsZWN0aW9uTmFtZSkge1xuICAgIHZhciBuZWdhdGUgPSBzZWxlY3Rpb25OYW1lLmNoYXJBdCgwKSA9PT0gJyEnLCBuYW1lID0gbmVnYXRlID8gc2VsZWN0aW9uTmFtZS5zbGljZSgxKSA6IHNlbGVjdGlvbk5hbWU7XG4gICAgcmV0dXJuIChuZWdhdGUgPyAnIScgOiAnJykgKyBzZWxlY3Rpb25fMS5wcmVkaWNhdGUobW9kZWwuY29tcG9uZW50LnNlbGVjdGlvbltuYW1lXSk7XG59XG5mdW5jdGlvbiB0ZXh0KG1vZGVsKSB7XG4gICAgdmFyIGNoYW5uZWxEZWYgPSBtb2RlbC5lbmNvZGluZy50ZXh0O1xuICAgIHJldHVybiB3cmFwQ29uZGl0aW9uKG1vZGVsLCBjaGFubmVsRGVmICYmIGNoYW5uZWxEZWYuY29uZGl0aW9uLCAndGV4dCcsIHJlZi50ZXh0KGNoYW5uZWxEZWYsIG1vZGVsLmNvbmZpZykpO1xufVxuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmZ1bmN0aW9uIGJhbmRQb3NpdGlvbihjaGFubmVsLCBtb2RlbCkge1xuICAgIC8vIFRPRE86IGJhbmQgc2NhbGUgZG9lc24ndCBzdXBwb3J0IHNpemUgeWV0XG4gICAgdmFyIGZpZWxkRGVmID0gbW9kZWwuZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgdmFyIHNjYWxlTmFtZSA9IG1vZGVsLnNjYWxlTmFtZShjaGFubmVsKTtcbiAgICB2YXIgc2l6ZUNoYW5uZWwgPSBjaGFubmVsID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgcmV0dXJuIF9hID0ge30sXG4gICAgICAgIF9hW2NoYW5uZWxdID0gcmVmLmZpZWxkUmVmKGZpZWxkRGVmLCBzY2FsZU5hbWUsIHt9KSxcbiAgICAgICAgX2Fbc2l6ZUNoYW5uZWxdID0gcmVmLmJhbmQoc2NhbGVOYW1lKSxcbiAgICAgICAgX2E7XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy5iYW5kUG9zaXRpb24gPSBiYW5kUG9zaXRpb247XG5mdW5jdGlvbiBjZW50ZXJlZEJhbmRQb3NpdGlvbihjaGFubmVsLCBtb2RlbCwgZGVmYXVsdFBvc1JlZiwgZGVmYXVsdFNpemVSZWYpIHtcbiAgICB2YXIgY2VudGVyQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICd4JyA/ICd4YycgOiAneWMnO1xuICAgIHZhciBzaXplQ2hhbm5lbCA9IGNoYW5uZWwgPT09ICd4JyA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgcG9pbnRQb3NpdGlvbihjaGFubmVsLCBtb2RlbCwgZGVmYXVsdFBvc1JlZiwgY2VudGVyQ2hhbm5lbCksIG5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwsIHsgZGVmYXVsdFJlZjogZGVmYXVsdFNpemVSZWYsIHZnQ2hhbm5lbDogc2l6ZUNoYW5uZWwgfSkpO1xufVxuZXhwb3J0cy5jZW50ZXJlZEJhbmRQb3NpdGlvbiA9IGNlbnRlcmVkQmFuZFBvc2l0aW9uO1xuZnVuY3Rpb24gYmlubmVkUG9zaXRpb24oY2hhbm5lbCwgbW9kZWwsIHNwYWNpbmcpIHtcbiAgICB2YXIgZmllbGREZWYgPSBtb2RlbC5lbmNvZGluZ1tjaGFubmVsXTtcbiAgICB2YXIgc2NhbGVOYW1lID0gbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpO1xuICAgIGlmIChjaGFubmVsID09PSAneCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgyOiByZWYuYmluKGZpZWxkRGVmLCBzY2FsZU5hbWUsICdzdGFydCcsIHNwYWNpbmcpLFxuICAgICAgICAgICAgeDogcmVmLmJpbihmaWVsZERlZiwgc2NhbGVOYW1lLCAnZW5kJylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5MjogcmVmLmJpbihmaWVsZERlZiwgc2NhbGVOYW1lLCAnc3RhcnQnKSxcbiAgICAgICAgICAgIHk6IHJlZi5iaW4oZmllbGREZWYsIHNjYWxlTmFtZSwgJ2VuZCcsIHNwYWNpbmcpXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5iaW5uZWRQb3NpdGlvbiA9IGJpbm5lZFBvc2l0aW9uO1xuLyoqXG4gKiBSZXR1cm4gbWl4aW5zIGZvciBwb2ludCAobm9uLWJhbmQpIHBvc2l0aW9uIGNoYW5uZWxzLlxuICovXG5mdW5jdGlvbiBwb2ludFBvc2l0aW9uKGNoYW5uZWwsIG1vZGVsLCBkZWZhdWx0UmVmLCB2Z0NoYW5uZWwpIHtcbiAgICAvLyBUT0RPOiByZWZhY3RvciBob3cgcmVmZXIgdG8gc2NhbGUgYXMgZGlzY3Vzc2VkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EtbGl0ZS9wdWxsLzE2MTNcbiAgICB2YXIgZW5jb2RpbmcgPSBtb2RlbC5lbmNvZGluZywgc3RhY2sgPSBtb2RlbC5zdGFjaztcbiAgICB2YXIgdmFsdWVSZWYgPSByZWYuc3RhY2thYmxlKGNoYW5uZWwsIGVuY29kaW5nW2NoYW5uZWxdLCBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbCksIG1vZGVsLnNjYWxlKGNoYW5uZWwpLCBzdGFjaywgZGVmYXVsdFJlZik7XG4gICAgcmV0dXJuIF9hID0ge30sXG4gICAgICAgIF9hW3ZnQ2hhbm5lbCB8fCBjaGFubmVsXSA9IHZhbHVlUmVmLFxuICAgICAgICBfYTtcbiAgICB2YXIgX2E7XG59XG5leHBvcnRzLnBvaW50UG9zaXRpb24gPSBwb2ludFBvc2l0aW9uO1xuLyoqXG4gKiBSZXR1cm4gbWl4aW5zIGZvciB4MiwgeTIuXG4gKiBJZiBjaGFubmVsIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybiBvbmUgY2hhbm5lbCBiYXNlZCBvbiBvcmllbnRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcG9pbnRQb3NpdGlvbjIobW9kZWwsIGRlZmF1bHRSZWYsIGNoYW5uZWwpIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBtb2RlbC5lbmNvZGluZywgbWFya0RlZiA9IG1vZGVsLm1hcmtEZWYsIHN0YWNrID0gbW9kZWwuc3RhY2s7XG4gICAgY2hhbm5lbCA9IGNoYW5uZWwgfHwgKG1hcmtEZWYub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAneDInIDogJ3kyJyk7XG4gICAgdmFyIGJhc2VDaGFubmVsID0gY2hhbm5lbCA9PT0gJ3gyJyA/ICd4JyA6ICd5JztcbiAgICB2YXIgdmFsdWVSZWYgPSByZWYuc3RhY2thYmxlMihjaGFubmVsLCBlbmNvZGluZ1tiYXNlQ2hhbm5lbF0sIGVuY29kaW5nW2NoYW5uZWxdLCBtb2RlbC5zY2FsZU5hbWUoYmFzZUNoYW5uZWwpLCBtb2RlbC5zY2FsZShiYXNlQ2hhbm5lbCksIHN0YWNrLCBkZWZhdWx0UmVmKTtcbiAgICByZXR1cm4gX2EgPSB7fSwgX2FbY2hhbm5lbF0gPSB2YWx1ZVJlZiwgX2E7XG4gICAgdmFyIF9hO1xufVxuZXhwb3J0cy5wb2ludFBvc2l0aW9uMiA9IHBvaW50UG9zaXRpb24yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYldsNGFXNXpMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YldGeWF5OXRhWGhwYm5NdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUTBFc2FVTkJRVzFETzBGQlJXNURMRzlEUVVGM1F6dEJRVWQ0UXl4blEwRkJhME03UVVGSmJFTXNiMFJCUVdsRU8wRkJSV3BFTEdWQlFYTkNMRXRCUVdkQ08wbEJRM0JETEVsQlFVMHNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRE5VSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZGY0VNc1NVRkJUU3hEUVVGRExFZEJRVWNzVjBGQlZ5eERRVUZETEU5QlFVOHNSVUZCUlN4TFFVRkxMRVZCUVVVN1VVRkRjRU1zVTBGQlV5eEZRVUZGTEUxQlFVMHNSMEZCUnl4TlFVRk5MRWRCUVVjc1VVRkJVVHRSUVVOeVF5eFpRVUZaTEVWQlFVVXNjMEpCUVdFc1EwRkJReXhQUVVGUExFVkJRVVVzUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4RlFVRkZMRTFCUVUwc1EwRkJWenRMUVVOeVJTeERRVUZETEVOQlFVTTdTVUZGU0N3eVEwRkJNa003U1VGRE0wTXNkVVZCUVhWRk8wbEJRM1pGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwR0xFTkJRVU1zUTBGQlF5eEpRVUZKTEVkQlFVY3NSVUZCUXl4TFFVRkxMRVZCUVVVc1lVRkJZU3hGUVVGRExFTkJRVU03U1VGRGJFTXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03UVVGRFdDeERRVUZETzBGQlprUXNjMEpCWlVNN1FVRkZSQ3d5UWtGQmEwTXNTVUZCWVN4RlFVRkZMRXRCUVhkQ08wbEJRM1pGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEZRVUZGTEVsQlFVazdVVUZETVVJc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVObUxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RlFVRkRMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFVTXNRMEZCUXp0UlFVTm9ReXhEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTllMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZRUkN3NFEwRlBRenRCUVVWRUxIZENRVUVyUWl4SlFVRlpMRVZCUVVVc1MwRkJhVUk3U1VGRE5VUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVJc1RVRkJUU3hWUVVGRkxFZEJRVU1zU1VGQlNTeEpRVUZITEVWQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJReXhMUVVGRk8wbEJRMnhETEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRE96dEJRVU51UWl4RFFVRkRPMEZCVEVRc2QwTkJTME03UVVGRlJEczdSMEZGUnp0QlFVTklMSEZDUVVFMFFpeFBRVUUwUXl4RlFVRkZMRXRCUVdkQ0xFVkJRVVVzUjBGQmFVYzdTVUZETTB3c1owZEJRV2RITzBsQlJFNHNiMEpCUVVFc1JVRkJRU3hSUVVGcFJ6dEpRVWR3VEN4SlFVRkJMQ3RDUVVGWkxFVkJRVVVzZVVKQlFWTXNRMEZCVVR0SlFVTjBReXhKUVVGTkxGVkJRVlVzUjBGQlJ5eEhRVUZITEVOQlFVTXNWVUZCVlN4SlFVRkpMRU5CUVVNc1dVRkJXU3hMUVVGTExGTkJRVk1zUjBGQlJ5eEZRVUZETEV0QlFVc3NSVUZCUlN4WlFVRlpMRVZCUVVNc1IwRkJSeXhUUVVGVExFTkJRVU1zUTBGQlF6dEpRVVYwUnl4SlFVRk5MRlZCUVZVc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXpORExFbEJRVTBzVVVGQlVTeEhRVUZITEVkQlFVY3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhGUVVGRkxGVkJRVlVzUlVGQlJTeExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03U1VGRkwwY3NUVUZCVFN4RFFVRkRMR0ZCUVdFc1EwRkJReXhMUVVGTExFVkJRVVVzVlVGQlZTeEpRVUZKTEZWQlFWVXNRMEZCUXl4VFFVRlRMRVZCUVVVc1UwRkJVeXhKUVVGSkxFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0QlFVTnNSeXhEUVVGRE8wRkJWa1FzYTBOQlZVTTdRVUZGUkRzN08wZEJSMGM3UVVGRFNDeDFRa0ZCZFVJc1MwRkJaMElzUlVGQlJTeFRRVUY1UWl4RlFVRkZMRk5CUVdsQ0xFVkJRVVVzVVVGQmIwSTdTVUZEZWtjc1JVRkJSU3hEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTlFMRWxCUVVFc0swSkJRVk1zUlVGQlJTeDFRa0ZCU3l4RFFVRmpPMUZCUTNKRExFMUJRVTA3V1VGRFNpeEhRVUZETEZOQlFWTTdaMEpCUTFJc1JVRkJReXhKUVVGSkxFVkJRVVVzWVVGQllTeERRVUZETEV0QlFVc3NSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkJSU3hMUVVGTExFOUJRVUVzUlVGQlF6dHhRa0ZETTBNc1EwRkJReXhSUVVGUkxFdEJRVXNzVTBGQlV5eEhRVUZITEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRemxETzJWQlEwUTdTVUZEU2l4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRFRpeE5RVUZOTEVOQlFVTXNVVUZCVVN4TFFVRkxMRk5CUVZNc1lVRkJTU3hIUVVGRExGTkJRVk1zU1VGQlJ5eFJRVUZSTEZGQlFVa3NSVUZCUlN4RFFVRkRPMGxCUXk5RUxFTkJRVU03TzBGQlEwZ3NRMEZCUXp0QlFVVkVMSFZDUVVGMVFpeExRVUZuUWl4RlFVRkZMR0ZCUVhGQ08wbEJRelZFTEVsQlFVMHNUVUZCVFN4SFFVRkhMR0ZCUVdFc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NSMEZCUnl4RlFVTTFReXhKUVVGSkxFZEJRVWNzVFVGQlRTeEhRVUZITEdGQlFXRXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzWVVGQllTeERRVUZETzBsQlEzcEVMRTFCUVUwc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eEhRVUZITEVkQlFVY3NSVUZCUlN4RFFVRkRMRWRCUVVjc2NVSkJRVk1zUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlF6RkZMRU5CUVVNN1FVRkZSQ3hqUVVGeFFpeExRVUZuUWp0SlFVTnVReXhKUVVGTkxGVkJRVlVzUjBGQlJ5eExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJRenRKUVVOMlF5eE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRMRXRCUVVzc1JVRkJSU3hWUVVGVkxFbEJRVWtzVlVGQlZTeERRVUZETEZOQlFWTXNSVUZCUlN4TlFVRk5MRVZCUVVVc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03UVVGRE9VY3NRMEZCUXp0QlFVaEVMRzlDUVVkRE8wRkJSVVFzYzBKQlFUWkNMRTlCUVdkQ0xFVkJRVVVzUzBGQlowSTdTVUZETjBRc05FTkJRVFJETzBsQlF6VkRMRWxCUVUwc1VVRkJVU3hIUVVGSExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkRla01zU1VGQlRTeFRRVUZUTEVkQlFVY3NTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UXl4SlFVRk5MRmRCUVZjc1IwRkJSeXhQUVVGUExFdEJRVXNzUjBGQlJ5eEhRVUZITEU5QlFVOHNSMEZCUnl4UlFVRlJMRU5CUVVNN1NVRkRla1FzVFVGQlRUdFJRVU5LTEVkQlFVTXNUMEZCVHl4SlFVRkhMRWRCUVVjc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeEZRVUZGTEZOQlFWTXNSVUZCUlN4RlFVRkZMRU5CUVVNN1VVRkRhRVFzUjBGQlF5eFhRVUZYTEVsQlFVY3NSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU03VjBGRGJFTTdPMEZCUTBvc1EwRkJRenRCUVZSRUxHOURRVk5ETzBGQlJVUXNPRUpCUVhGRExFOUJRV3RDTEVWQlFVVXNTMEZCWjBJc1JVRkJSU3hoUVVGNVFpeEZRVUZGTEdOQlFUQkNPMGxCUXpsSUxFbEJRVTBzWVVGQllTeEhRVUZuUWl4UFFVRlBMRXRCUVVzc1IwRkJSeXhIUVVGSExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTTdTVUZEYWtVc1NVRkJUU3hYUVVGWExFZEJRVWNzVDBGQlR5eExRVUZMTEVkQlFVY3NSMEZCUnl4UFFVRlBMRWRCUVVjc1VVRkJVU3hEUVVGRE8wbEJRM3BFTEUxQlFVMHNjMEpCUTBRc1lVRkJZU3hEUVVGRExFOUJRVThzUlVGQlJTeExRVUZMTEVWQlFVVXNZVUZCWVN4RlFVRkZMR0ZCUVdFc1EwRkJReXhGUVVNelJDeFhRVUZYTEVOQlFVTXNUVUZCVFN4RlFVRkZMRXRCUVVzc1JVRkJSU3hGUVVGRExGVkJRVlVzUlVGQlJTeGpRVUZqTEVWQlFVVXNVMEZCVXl4RlFVRkZMRmRCUVZjc1JVRkJReXhEUVVGRExFVkJRMjVHTzBGQlEwb3NRMEZCUXp0QlFWQkVMRzlFUVU5RE8wRkJSVVFzZDBKQlFTdENMRTlCUVdkQ0xFVkJRVVVzUzBGQlowSXNSVUZCUlN4UFFVRmxPMGxCUTJoR0xFbEJRVTBzVVVGQlVTeEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGVrTXNTVUZCVFN4VFFVRlRMRWRCUVVjc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTXpReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEV0QlFVc3NSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1FpeE5RVUZOTEVOQlFVTTdXVUZEVEN4RlFVRkZMRVZCUVVVc1IwRkJSeXhEUVVGRExFZEJRVWNzUTBGQlF5eFJRVUZSTEVWQlFVVXNVMEZCVXl4RlFVRkZMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU03V1VGRGJFUXNRMEZCUXl4RlFVRkZMRWRCUVVjc1EwRkJReXhIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEZOQlFWTXNSVUZCUlN4TFFVRkxMRU5CUVVNN1UwRkRka01zUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFMUJRVTBzUTBGQlF6dFpRVU5NTEVWQlFVVXNSVUZCUlN4SFFVRkhMRU5CUVVNc1IwRkJSeXhEUVVGRExGRkJRVkVzUlVGQlJTeFRRVUZUTEVWQlFVVXNUMEZCVHl4RFFVRkRPMWxCUTNwRExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRkZCUVZFc1JVRkJSU3hUUVVGVExFVkJRVVVzUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXp0VFFVTm9SQ3hEUVVGRE8wbEJRMG9zUTBGQlF6dEJRVU5JTEVOQlFVTTdRVUZrUkN4M1EwRmpRenRCUVVWRU96dEhRVVZITzBGQlEwZ3NkVUpCUVRoQ0xFOUJRV2RDTEVWQlFVVXNTMEZCWjBJc1JVRkJSU3hWUVVGclJDeEZRVUZGTEZOQlFUWkNPMGxCUTJwS0xHZEhRVUZuUnp0SlFVVjZSaXhKUVVGQkxIbENRVUZSTEVWQlFVVXNiVUpCUVVzc1EwRkJWVHRKUVVOb1F5eEpRVUZOTEZGQlFWRXNSMEZCUnl4SFFVRkhMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRKUVVVNVNDeE5RVUZOTzFGQlEwb3NSMEZCUXl4VFFVRlRMRWxCUVVrc1QwRkJUeXhKUVVGSExGRkJRVkU3VjBGRGFFTTdPMEZCUTBvc1EwRkJRenRCUVZSRUxITkRRVk5ETzBGQlJVUTdPenRIUVVkSE8wRkJRMGdzZDBKQlFTdENMRXRCUVdkQ0xFVkJRVVVzVlVGQmNVTXNSVUZCUlN4UFFVRnhRanRKUVVOd1J5eEpRVUZCTEhsQ1FVRlJMRVZCUVVVc2RVSkJRVThzUlVGQlJTeHRRa0ZCU3l4RFFVRlZPMGxCUTNwRExFOUJRVThzUjBGQlJ5eFBRVUZQTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hMUVVGTExGbEJRVmtzUjBGQlJ5eEpRVUZKTEVkQlFVY3NTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRja1VzU1VGQlRTeFhRVUZYTEVkQlFVY3NUMEZCVHl4TFFVRkxMRWxCUVVrc1IwRkJSeXhIUVVGSExFZEJRVWNzUjBGQlJ5eERRVUZETzBsQlJXcEVMRWxCUVUwc1VVRkJVU3hIUVVGSExFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNUMEZCVHl4RlFVRkZMRkZCUVZFc1EwRkJReXhYUVVGWExFTkJRVU1zUlVGQlJTeFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFhRVUZYTEVOQlFVTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExGZEJRVmNzUTBGQlF5eEZRVUZGTEV0QlFVc3NSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRKUVVNNVNpeE5RVUZOTEZWQlFVVXNSMEZCUXl4UFFVRlBMRWxCUVVjc1VVRkJVU3hMUVVGRk96dEJRVU12UWl4RFFVRkRPMEZCVUVRc2QwTkJUME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciByZWYgPSByZXF1aXJlKFwiLi92YWx1ZXJlZlwiKTtcbmZ1bmN0aW9uIGVuY29kZUVudHJ5KG1vZGVsLCBmaXhlZFNoYXBlKSB7XG4gICAgdmFyIGNvbmZpZyA9IG1vZGVsLmNvbmZpZywgd2lkdGggPSBtb2RlbC53aWR0aCwgaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneCcsIG1vZGVsLCByZWYubWlkWCh3aWR0aCwgY29uZmlnKSksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsIHJlZi5taWRZKGhlaWdodCwgY29uZmlnKSksIG1peGlucy5jb2xvcihtb2RlbCksIG1peGlucy5ub25Qb3NpdGlvbignc2l6ZScsIG1vZGVsKSwgc2hhcGVNaXhpbnMobW9kZWwsIGNvbmZpZywgZml4ZWRTaGFwZSksIG1peGlucy5ub25Qb3NpdGlvbignb3BhY2l0eScsIG1vZGVsKSk7XG59XG5mdW5jdGlvbiBzaGFwZU1peGlucyhtb2RlbCwgY29uZmlnLCBmaXhlZFNoYXBlKSB7XG4gICAgaWYgKGZpeGVkU2hhcGUpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hhcGU6IHsgdmFsdWU6IGZpeGVkU2hhcGUgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbWl4aW5zLm5vblBvc2l0aW9uKCdzaGFwZScsIG1vZGVsLCB7IGRlZmF1bHRWYWx1ZTogY29tbW9uXzEuZ2V0TWFya0NvbmZpZygnc2hhcGUnLCAncG9pbnQnLCBjb25maWcpIH0pO1xufVxuZXhwb3J0cy5zaGFwZU1peGlucyA9IHNoYXBlTWl4aW5zO1xuZXhwb3J0cy5wb2ludCA9IHtcbiAgICB2Z01hcms6ICdzeW1ib2wnLFxuICAgIGRlZmF1bHRSb2xlOiAncG9pbnQnLFxuICAgIGVuY29kZUVudHJ5OiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUVudHJ5KG1vZGVsKTtcbiAgICB9XG59O1xuZXhwb3J0cy5jaXJjbGUgPSB7XG4gICAgdmdNYXJrOiAnc3ltYm9sJyxcbiAgICBkZWZhdWx0Um9sZTogJ2NpcmNsZScsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlRW50cnkobW9kZWwsICdjaXJjbGUnKTtcbiAgICB9XG59O1xuZXhwb3J0cy5zcXVhcmUgPSB7XG4gICAgdmdNYXJrOiAnc3ltYm9sJyxcbiAgICBkZWZhdWx0Um9sZTogJ3NxdWFyZScsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gZW5jb2RlRW50cnkobW9kZWwsICdzcXVhcmUnKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0c5cGJuUXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl0WVhKckwzQnZhVzUwTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVWRCTEdsRFFVRnRRenRCUVVkdVF5eHZRMEZCZDBNN1FVRkZlRU1zWjBOQlFXdERPMEZCUld4RExIRkNRVUZ4UWl4TFFVRm5RaXhGUVVGRkxGVkJRV2RETzBsQlF6bEVMRWxCUVVFc2NVSkJRVTBzUlVGQlJTeHRRa0ZCU3l4RlFVRkZMSEZDUVVGTkxFTkJRVlU3U1VGRmRFTXNUVUZCVFN4elFrRkRSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1JVRkRla1FzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJSVEZFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMjVDTEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVU5xUXl4WFFVRlhMRU5CUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUlVGQlJTeFZRVUZWTEVOQlFVTXNSVUZEZEVNc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eFRRVUZUTEVWQlFVVXNTMEZCU3l4RFFVRkRMRVZCUTNaRE8wRkJRMG9zUTBGQlF6dEJRVVZFTEhGQ1FVRTBRaXhMUVVGblFpeEZRVUZGTEUxQlFXTXNSVUZCUlN4VlFVRm5RenRKUVVNMVJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMllzVFVGQlRTeERRVUZETEVWQlFVTXNTMEZCU3l4RlFVRkZMRVZCUVVNc1MwRkJTeXhGUVVGRkxGVkJRVlVzUlVGQlF5eEZRVUZETEVOQlFVTTdTVUZEZEVNc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTlCUVU4c1JVRkJSU3hMUVVGTExFVkJRVVVzUlVGQlF5eFpRVUZaTEVWQlFVVXNjMEpCUVdFc1EwRkJReXhQUVVGUExFVkJRVVVzVDBGQlR5eEZRVUZGTEUxQlFVMHNRMEZCVnl4RlFVRkRMRU5CUVVNc1EwRkJRenRCUVVNdlJ5eERRVUZETzBGQlRFUXNhME5CUzBNN1FVRkZXU3hSUVVGQkxFdEJRVXNzUjBGQmFVSTdTVUZEYWtNc1RVRkJUU3hGUVVGRkxGRkJRVkU3U1VGRGFFSXNWMEZCVnl4RlFVRkZMRTlCUVU4N1NVRkRjRUlzVjBGQlZ5eEZRVUZGTEZWQlFVTXNTMEZCWjBJN1VVRkROVUlzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJRenRKUVVNMVFpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVlhMRkZCUVVFc1RVRkJUU3hIUVVGcFFqdEpRVU5zUXl4TlFVRk5MRVZCUVVVc1VVRkJVVHRKUVVOb1FpeFhRVUZYTEVWQlFVVXNVVUZCVVR0SlFVTnlRaXhYUVVGWExFVkJRVVVzVlVGQlF5eExRVUZuUWp0UlFVTTFRaXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEV0QlFVc3NSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOMFF5eERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVlhMRkZCUVVFc1RVRkJUU3hIUVVGcFFqdEpRVU5zUXl4TlFVRk5MRVZCUVVVc1VVRkJVVHRKUVVOb1FpeFhRVUZYTEVWQlFVVXNVVUZCVVR0SlFVTnlRaXhYUVVGWExFVkJRVVVzVlVGQlF5eExRVUZuUWp0UlFVTTFRaXhOUVVGTkxFTkJRVU1zVjBGQlZ5eERRVUZETEV0QlFVc3NSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOMFF5eERRVUZETzBOQlEwWXNRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuLi8uLi9maWVsZGRlZlwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi4vLi4vbG9nXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi8uLi9tYXJrXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xuZXhwb3J0cy5yZWN0ID0ge1xuICAgIHZnTWFyazogJ3JlY3QnLFxuICAgIGRlZmF1bHRSb2xlOiB1bmRlZmluZWQsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgeChtb2RlbCksIHkobW9kZWwpLCBtaXhpbnMuY29sb3IobW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ29wYWNpdHknLCBtb2RlbCkpO1xuICAgIH1cbn07XG5mdW5jdGlvbiB4KG1vZGVsKSB7XG4gICAgdmFyIHhEZWYgPSBtb2RlbC5lbmNvZGluZy54O1xuICAgIHZhciB4MkRlZiA9IG1vZGVsLmVuY29kaW5nLngyO1xuICAgIHZhciB4U2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsXzEuWCk7XG4gICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZih4RGVmKSAmJiB4RGVmLmJpbiAmJiAheDJEZWYpIHtcbiAgICAgICAgcmV0dXJuIG1peGlucy5iaW5uZWRQb3NpdGlvbigneCcsIG1vZGVsLCAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeFNjYWxlICYmIHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oeFNjYWxlLnR5cGUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh4U2NhbGUudHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuQkFORCkge1xuICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3gnLCBtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlY3QgbWFyayB3aXRoIHBvaW50L29yZGluYWwgc2NhbGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aE1hcmsobWFya18xLlJFQ1QsIHhTY2FsZS50eXBlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneCcsIG1vZGVsLCAnemVyb09yTWF4JyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicsICd4MicpKTtcbiAgICB9XG59XG5mdW5jdGlvbiB5KG1vZGVsKSB7XG4gICAgdmFyIHlEZWYgPSBtb2RlbC5lbmNvZGluZy55O1xuICAgIHZhciB5MkRlZiA9IG1vZGVsLmVuY29kaW5nLnkyO1xuICAgIHZhciB5U2NhbGUgPSBtb2RlbC5zY2FsZShjaGFubmVsXzEuWSk7XG4gICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZih5RGVmKSAmJiB5RGVmLmJpbiAmJiAheTJEZWYpIHtcbiAgICAgICAgcmV0dXJuIG1peGlucy5iaW5uZWRQb3NpdGlvbigneScsIG1vZGVsLCAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeVNjYWxlICYmIHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oeVNjYWxlLnR5cGUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh5U2NhbGUudHlwZSA9PT0gc2NhbGVfMS5TY2FsZVR5cGUuQkFORCkge1xuICAgICAgICAgICAgcmV0dXJuIG1peGlucy5iYW5kUG9zaXRpb24oJ3knLCBtb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlY3QgbWFyayB3aXRoIHBvaW50L29yZGluYWwgc2NhbGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aE1hcmsobWFya18xLlJFQ1QsIHlTY2FsZS50eXBlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBtaXhpbnMucG9pbnRQb3NpdGlvbigneScsIG1vZGVsLCAnemVyb09yTWF4JyksIG1peGlucy5wb2ludFBvc2l0aW9uMihtb2RlbCwgJ3plcm9Pck1pbicsICd5MicpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljbVZqZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2Y21WamRDNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGQlFTeDVRMEZCYlVNN1FVRkRia01zTWtOQlFUQkRPMEZCUXpGRExDdENRVUZwUXp0QlFVTnFReXh0UTBGQlowTTdRVUZEYUVNc2NVTkJRWGxFTzBGQlIzcEVMR2xEUVVGdFF6dEJRVWwwUWl4UlFVRkJMRWxCUVVrc1IwRkJhVUk3U1VGRGFFTXNUVUZCVFN4RlFVRkZMRTFCUVUwN1NVRkRaQ3hYUVVGWExFVkJRVVVzVTBGQlV6dEpRVU4wUWl4WFFVRlhMRVZCUVVVc1ZVRkJReXhMUVVGblFqdFJRVU0xUWl4TlFVRk5MSE5DUVVORUxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZEVWl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMUlzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1JVRkRia0lzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4VFFVRlRMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRM1pETzBsQlEwb3NRMEZCUXp0RFFVTkdMRU5CUVVNN1FVRkZSaXhYUVVGWExFdEJRV2RDTzBsQlEzcENMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFbEJRVTBzUzBGQlN5eEhRVUZITEV0QlFVc3NRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMmhETEVsQlFVMHNUVUZCVFN4SFFVRkhMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVjBGQlF5eERRVUZETEVOQlFVTTdTVUZGT1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zY1VKQlFWVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hKUVVGSkxFTkJRVU1zUjBGQlJ5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNelF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhIUVVGSExFVkJRVVVzUzBGQlN5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpsRExFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hKUVVGSkxIbENRVUZwUWl4RFFVRkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY0VRc01FSkJRVEJDTzFGQlF6RkNMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEV0QlFVc3NhVUpCUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNURMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVONlF5eERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXh6UkVGQmMwUTdXVUZEZEVRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZkQlFVa3NSVUZCUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU16UlN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNUVUZCVFN4elFrRkRSQ3hOUVVGTkxFTkJRVU1zWVVGQllTeERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1YwRkJWeXhEUVVGRExFVkJRemRETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1MwRkJTeXhGUVVGRkxGZEJRVmNzUlVGQlJTeEpRVUZKTEVOQlFVTXNSVUZEYkVRN1NVRkRTaXhEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTEZkQlFWY3NTMEZCWjBJN1NVRkRla0lzU1VGQlRTeEpRVUZKTEVkQlFVY3NTMEZCU3l4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE9VSXNTVUZCVFN4TFFVRkxMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEYUVNc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4WFFVRkRMRU5CUVVNc1EwRkJRenRKUVVVNVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVsQlFVa3NRMEZCUXl4SFFVRkhMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6TkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEVkQlFVY3NSVUZCUlN4TFFVRkxMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE9VTXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVsQlFVa3NlVUpCUVdsQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1JDd3dRa0ZCTUVJN1VVRkRNVUlzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1MwRkJTeXhwUWtGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRia01zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzFGQlEzcERMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEhORVFVRnpSRHRaUVVOMFJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1YwRkJTU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpORkxFTkJRVU03U1VGRFNDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxITkNRVU5FTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFhRVUZYTEVOQlFVTXNSVUZETjBNc1RVRkJUU3hEUVVGRExHTkJRV01zUTBGQlF5eExRVUZMTEVWQlFVVXNWMEZCVnl4RlFVRkZMRWxCUVVrc1EwRkJReXhGUVVOc1JEdEpRVU5LTEVOQlFVTTdRVUZEU0N4RFFVRkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtaXhpbnMgPSByZXF1aXJlKFwiLi9taXhpbnNcIik7XG52YXIgcmVmID0gcmVxdWlyZShcIi4vdmFsdWVyZWZcIik7XG5leHBvcnRzLnJ1bGUgPSB7XG4gICAgdmdNYXJrOiAncnVsZScsXG4gICAgZGVmYXVsdFJvbGU6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcsIG1hcmtEZWYgPSBtb2RlbC5tYXJrRGVmLCB3aWR0aCA9IG1vZGVsLndpZHRoLCBoZWlnaHQgPSBtb2RlbC5oZWlnaHQ7XG4gICAgICAgIHZhciBvcmllbnQgPSBtYXJrRGVmLm9yaWVudDtcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIG1peGlucy5wb2ludFBvc2l0aW9uKCd4JywgbW9kZWwsIG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ3plcm9Pck1pbicgOiByZWYubWlkWCh3aWR0aCwgY29uZmlnKSksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICd6ZXJvT3JNaW4nIDogcmVmLm1pZFkoaGVpZ2h0LCBjb25maWcpKSwgbWl4aW5zLnBvaW50UG9zaXRpb24yKG1vZGVsLCAnemVyb09yTWF4JyksIG1peGlucy5jb2xvcihtb2RlbCksIG1peGlucy5ub25Qb3NpdGlvbignb3BhY2l0eScsIG1vZGVsKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwsIHtcbiAgICAgICAgICAgIHZnQ2hhbm5lbDogJ3N0cm9rZVdpZHRoJyAvLyBWTCdzIHJ1bGUgc2l6ZSBpcyBzdHJva2VXaWR0aFxuICAgICAgICB9KSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWNuVnNaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZjblZzWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZGUVN4cFEwRkJiVU03UVVGRGJrTXNaME5CUVd0RE8wRkJSWEpDTEZGQlFVRXNTVUZCU1N4SFFVRnBRanRKUVVOb1F5eE5RVUZOTEVWQlFVVXNUVUZCVFR0SlFVTmtMRmRCUVZjc1JVRkJSU3hUUVVGVE8wbEJRM1JDTEZkQlFWY3NSVUZCUlN4VlFVRkRMRXRCUVdkQ08xRkJRM0pDTEVsQlFVRXNjVUpCUVUwc1JVRkJSU3gxUWtGQlR5eEZRVUZGTEcxQ1FVRkxMRVZCUVVVc2NVSkJRVTBzUTBGQlZUdFJRVU12UXl4SlFVRk5MRTFCUVUwc1IwRkJSeXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETzFGQlJUbENMRTFCUVUwc2MwSkJRMFFzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxFMUJRVTBzUzBGQlN5eFpRVUZaTEVkQlFVY3NWMEZCVnl4SFFVRkhMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRVZCUTJwSExFMUJRVTBzUTBGQlF5eGhRVUZoTEVOQlFVTXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hOUVVGTkxFdEJRVXNzVlVGQlZTeEhRVUZITEZkQlFWY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFMUJRVTBzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4RlFVTm9SeXhOUVVGTkxFTkJRVU1zWTBGQll5eERRVUZETEV0QlFVc3NSVUZCUlN4WFFVRlhMRU5CUVVNc1JVRkZla01zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRU5CUVVNc1JVRkRia0lzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4VFFVRlRMRVZCUVVVc1MwRkJTeXhEUVVGRExFVkJRM0JETEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFdEJRVXNzUlVGQlJUdFpRVU51UXl4VFFVRlRMRVZCUVVVc1lVRkJZU3hEUVVGRkxHZERRVUZuUXp0VFFVTXpSQ3hEUVVGRExFVkJRMFk3U1VGRFNpeERRVUZETzBOQlEwWXNRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vZW5jb2RpbmdcIik7XG52YXIgcmVmID0gcmVxdWlyZShcIi4vdmFsdWVyZWZcIik7XG5leHBvcnRzLnRleHQgPSB7XG4gICAgdmdNYXJrOiAndGV4dCcsXG4gICAgZGVmYXVsdFJvbGU6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVFbnRyeTogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBtb2RlbC5jb25maWcsIGVuY29kaW5nID0gbW9kZWwuZW5jb2RpbmcsIGhlaWdodCA9IG1vZGVsLmhlaWdodDtcbiAgICAgICAgdmFyIHRleHREZWYgPSBlbmNvZGluZy50ZXh0O1xuICAgICAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7fSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3gnLCBtb2RlbCwgeERlZmF1bHQoY29uZmlnLCB0ZXh0RGVmKSksIG1peGlucy5wb2ludFBvc2l0aW9uKCd5JywgbW9kZWwsIHJlZi5taWRZKGhlaWdodCwgY29uZmlnKSksIG1peGlucy50ZXh0KG1vZGVsKSwgbWl4aW5zLmNvbG9yKG1vZGVsKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdvcGFjaXR5JywgbW9kZWwpLCBtaXhpbnMubm9uUG9zaXRpb24oJ3NpemUnLCBtb2RlbCwge1xuICAgICAgICAgICAgdmdDaGFubmVsOiAnZm9udFNpemUnIC8vIFZMJ3MgdGV4dCBzaXplIGlzIGZvbnRTaXplXG4gICAgICAgIH0pLCBtaXhpbnMudmFsdWVJZkRlZmluZWQoJ2FsaWduJywgYWxpZ24oZW5jb2RpbmcsIGNvbmZpZykpKTtcbiAgICB9XG59O1xuZnVuY3Rpb24geERlZmF1bHQoY29uZmlnLCB0ZXh0RGVmKSB7XG4gICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZih0ZXh0RGVmKSAmJiB0ZXh0RGVmLnR5cGUgPT09IHR5cGVfMS5RVUFOVElUQVRJVkUpIHtcbiAgICAgICAgcmV0dXJuIHsgZmllbGQ6IHsgZ3JvdXA6ICd3aWR0aCcgfSwgb2Zmc2V0OiAtNSB9O1xuICAgIH1cbiAgICAvLyBUT0RPOiBhbGxvdyB0aGlzIHRvIGZpdCAoQmUgY29uc2lzdGVudCB3aXRoIHJlZi5taWRYKCkpXG4gICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy5zY2FsZS50ZXh0WFJhbmdlU3RlcCAvIDIgfTtcbn1cbmZ1bmN0aW9uIGFsaWduKGVuY29kaW5nLCBjb25maWcpIHtcbiAgICB2YXIgYWxpZ25Db25maWcgPSBjb21tb25fMS5nZXRNYXJrQ29uZmlnKCdhbGlnbicsICd0ZXh0JywgY29uZmlnKTtcbiAgICBpZiAoYWxpZ25Db25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWxfMS5YKSA/ICdjZW50ZXInIDogJ3JpZ2h0JztcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgaXMgYSBjb25maWcsIFZlZ2EtcGFyc2VyIHdpbGwgcHJvY2VzcyB0aGlzIGFscmVhZHkuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHVjRkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDIxaGNtc3ZkR1Y0ZEM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZCUVN4NVEwRkJaME03UVVGRGFFTXNiME5CUVhkRE8wRkJSM2hETERKRFFVRnpSRHRCUVVOMFJDeHRRMEZCZDBNN1FVRkhlRU1zYVVOQlFXMURPMEZCUlc1RExESkRRVUY1UkR0QlFVVjZSQ3huUTBGQmEwTTdRVUZGY2tJc1VVRkJRU3hKUVVGSkxFZEJRV2xDTzBsQlEyaERMRTFCUVUwc1JVRkJSU3hOUVVGTk8wbEJRMlFzVjBGQlZ5eEZRVUZGTEZOQlFWTTdTVUZGZEVJc1YwRkJWeXhGUVVGRkxGVkJRVU1zUzBGQlowSTdVVUZEY2tJc1NVRkJRU3h4UWtGQlRTeEZRVUZGTEhsQ1FVRlJMRVZCUVVVc2NVSkJRVTBzUTBGQlZUdFJRVU42UXl4SlFVRk5MRTlCUVU4c1IwRkJSeXhSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJUbENMRTFCUVUwc2MwSkJRMFFzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxGRkJRVkVzUTBGQlF5eE5RVUZOTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNc1JVRkRNMFFzVFVGQlRTeERRVUZETEdGQlFXRXNRMEZCUXl4SFFVRkhMRVZCUVVVc1MwRkJTeXhGUVVGRkxFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRExFVkJRekZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMnhDTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMjVDTEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVU53UXl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVVTdXVUZEYmtNc1UwRkJVeXhGUVVGRkxGVkJRVlVzUTBGQlJTdzJRa0ZCTmtJN1UwRkRja1FzUTBGQlF5eEZRVU5ETEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFdEJRVXNzUTBGQlF5eFJRVUZSTEVWQlFVVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1JVRkRNVVE3U1VGRFNpeERRVUZETzBOQlEwWXNRMEZCUXp0QlFVVkdMR3RDUVVGclFpeE5RVUZqTEVWQlFVVXNUMEZCYlVJN1NVRkRia1FzUlVGQlJTeERRVUZETEVOQlFVTXNjVUpCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRzFDUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzcEVMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVNc1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eERRVUZETEVWQlFVTXNRMEZCUXp0SlFVTXZReXhEUVVGRE8wbEJRMFFzTUVSQlFUQkVPMGxCUXpGRUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExHTkJRV01zUjBGQlJ5eERRVUZETEVWQlFVTXNRMEZCUXp0QlFVTnNSQ3hEUVVGRE8wRkJSVVFzWlVGQlpTeFJRVUZyUWl4RlFVRkZMRTFCUVdNN1NVRkRMME1zU1VGQlRTeFhRVUZYTEVkQlFVY3NjMEpCUVdFc1EwRkJReXhQUVVGUExFVkJRVVVzVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUXpORUxFVkJRVVVzUTBGQlF5eERRVUZETEZkQlFWY3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRemxDTEUxQlFVMHNRMEZCUXl3d1FrRkJaU3hEUVVGRExGRkJRVkVzUlVGQlJTeFhRVUZETEVOQlFVTXNSMEZCUnl4UlFVRlJMRWRCUVVjc1QwRkJUeXhEUVVGRE8wbEJRek5FTEVOQlFVTTdTVUZEUkN3clJFRkJLMFE3U1VGREwwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRCUVVOdVFpeERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWl4aW5zID0gcmVxdWlyZShcIi4vbWl4aW5zXCIpO1xudmFyIHJlZiA9IHJlcXVpcmUoXCIuL3ZhbHVlcmVmXCIpO1xuZXhwb3J0cy50aWNrID0ge1xuICAgIHZnTWFyazogJ3JlY3QnLFxuICAgIGRlZmF1bHRSb2xlOiAndGljaycsXG4gICAgZW5jb2RlRW50cnk6IGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnLCBtYXJrRGVmID0gbW9kZWwubWFya0RlZiwgd2lkdGggPSBtb2RlbC53aWR0aCwgaGVpZ2h0ID0gbW9kZWwuaGVpZ2h0O1xuICAgICAgICB2YXIgb3JpZW50ID0gbWFya0RlZi5vcmllbnQ7XG4gICAgICAgIHZhciB2Z1NpemVDaGFubmVsID0gb3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIHZhciB2Z1RoaWNrbmVzc0NoYW5uZWwgPSBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIG1peGlucy5wb2ludFBvc2l0aW9uKCd4JywgbW9kZWwsIHJlZi5taWRYKHdpZHRoLCBjb25maWcpLCAneGMnKSwgbWl4aW5zLnBvaW50UG9zaXRpb24oJ3knLCBtb2RlbCwgcmVmLm1pZFkoaGVpZ2h0LCBjb25maWcpLCAneWMnKSwgbWl4aW5zLm5vblBvc2l0aW9uKCdzaXplJywgbW9kZWwsIHtcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFNpemUobW9kZWwpLFxuICAgICAgICAgICAgdmdDaGFubmVsOiB2Z1NpemVDaGFubmVsXG4gICAgICAgIH0pLCAoX2EgPSB7fSwgX2FbdmdUaGlja25lc3NDaGFubmVsXSA9IHsgdmFsdWU6IGNvbmZpZy50aWNrLnRoaWNrbmVzcyB9LCBfYSksIG1peGlucy5jb2xvcihtb2RlbCksIG1peGlucy5ub25Qb3NpdGlvbignb3BhY2l0eScsIG1vZGVsKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZGVmYXVsdFNpemUobW9kZWwpIHtcbiAgICB2YXIgY29uZmlnID0gbW9kZWwuY29uZmlnO1xuICAgIHZhciBvcmllbnQgPSBtb2RlbC5tYXJrRGVmLm9yaWVudDtcbiAgICB2YXIgc2NhbGVSYW5nZVN0ZXAgPSAobW9kZWwuc2NhbGUob3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAneCcgOiAneScpIHx8IHt9KS5yYW5nZVN0ZXA7XG4gICAgaWYgKGNvbmZpZy50aWNrLmJhbmRTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy50aWNrLmJhbmRTaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJhbmdlU3RlcCA9IHNjYWxlUmFuZ2VTdGVwICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgc2NhbGVSYW5nZVN0ZXAgOlxuICAgICAgICAgICAgY29uZmlnLnNjYWxlLnJhbmdlU3RlcDtcbiAgICAgICAgaWYgKHR5cGVvZiByYW5nZVN0ZXAgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBGSVhNRSBjb25zb2xpZGF0ZSB0aGlzIGxvZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBkb2VzIG5vdCBoYW5kbGUgbm9uLW51bWVyaWMgcmFuZ2VTdGVwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlU3RlcCAvIDEuNTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkR2xqYXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwyMWhjbXN2ZEdsamF5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3UVVGSFFTeHBRMEZCYlVNN1FVRkhia01zWjBOQlFXdERPMEZCUlhKQ0xGRkJRVUVzU1VGQlNTeEhRVUZwUWp0SlFVTm9ReXhOUVVGTkxFVkJRVVVzVFVGQlRUdEpRVU5rTEZkQlFWY3NSVUZCUlN4TlFVRk5PMGxCUlc1Q0xGZEJRVmNzUlVGQlJTeFZRVUZETEV0QlFXZENPMUZCUTNKQ0xFbEJRVUVzY1VKQlFVMHNSVUZCUlN4MVFrRkJUeXhGUVVGRkxHMUNRVUZMTEVWQlFVVXNjVUpCUVUwc1EwRkJWVHRSUVVNdlF5eEpRVUZOTEUxQlFVMHNSMEZCUnl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJSVGxDTEVsQlFVMHNZVUZCWVN4SFFVRkhMRTFCUVUwc1MwRkJTeXhaUVVGWkxFZEJRVWNzVDBGQlR5eEhRVUZITEZGQlFWRXNRMEZCUXp0UlFVTnVSU3hKUVVGTkxHdENRVUZyUWl4SFFVRkhMRTFCUVUwc1MwRkJTeXhaUVVGWkxFZEJRVWNzVVVGQlVTeEhRVUZITEU5QlFVOHNRMEZCUXp0UlFVVjRSU3hOUVVGTkxITkNRVU5FTEUxQlFVMHNRMEZCUXl4aFFVRmhMRU5CUVVNc1IwRkJSeXhGUVVGRkxFdEJRVXNzUlVGQlJTeEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1JVRkJSU3hOUVVGTkxFTkJRVU1zUlVGQlJTeEpRVUZKTEVOQlFVTXNSVUZETDBRc1RVRkJUU3hEUVVGRExHRkJRV0VzUTBGQlF5eEhRVUZITEVWQlFVVXNTMEZCU3l4RlFVRkZMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4RlFVRkZMRWxCUVVrc1EwRkJReXhGUVVkb1JTeE5RVUZOTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVVU3V1VGRGJrTXNXVUZCV1N4RlFVRkZMRmRCUVZjc1EwRkJReXhMUVVGTExFTkJRVU03V1VGRGFFTXNVMEZCVXl4RlFVRkZMR0ZCUVdFN1UwRkRla0lzUTBGQlF5eGxRVU5FTEd0Q1FVRnJRaXhKUVVGSExFVkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhGUVVGRExFOUJSV3BFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRMjVDTEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eEZRVU4yUXpzN1NVRkRTaXhEUVVGRE8wTkJRMFlzUTBGQlF6dEJRVVZHTEhGQ1FVRnhRaXhMUVVGblFqdEpRVU0xUWl4SlFVRkJMSEZDUVVGTkxFTkJRVlU3U1VGRGRrSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZGY0VNc1NVRkJUU3hqUVVGakxFZEJRV3RDTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGTkxFdEJRVXNzV1VGQldTeEhRVUZITEVkQlFVY3NSMEZCUnl4SFFVRkhMRU5CUVVNc1NVRkJTU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZGZWtjc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU4yUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTTdTVUZET1VJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNTVUZCVFN4VFFVRlRMRWRCUVVjc1kwRkJZeXhMUVVGTExGTkJRVk03V1VGRE5VTXNZMEZCWXp0WlFVTmtMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVTBGQlV5eERRVUZETzFGQlEzcENMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzVTBGQlV5eExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRiRU1zTmtKQlFUWkNPMWxCUXpkQ0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNaMFJCUVdkRUxFTkJRVU1zUTBGQlF6dFJRVU53UlN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExGTkJRVk1zUjBGQlJ5eEhRVUZITEVOQlFVTTdTVUZEZWtJc1EwRkJRenRCUVVOSUxFTkJRVU1pZlE9PSIsIi8qKlxuICogVXRpbGl0eSBmaWxlcyBmb3IgcHJvZHVjaW5nIFZlZ2EgVmFsdWVSZWYgZm9yIG1hcmtzXG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vLi4vZmllbGRkZWZcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vLyBUT0RPOiB3ZSBuZWVkIHRvIGZpbmQgYSB3YXkgdG8gcmVmYWN0b3IgdGhlc2Ugc28gdGhhdCBzY2FsZU5hbWUgaXMgYSBwYXJ0IG9mIHNjYWxlXG4vLyBidXQgdGhhdCdzIGNvbXBsaWNhdGVkLiAgRm9yIG5vdywgdGhpcyBpcyBhIGh1Z2Ugc3RlcCBtb3ZpbmcgZm9yd2FyZC5cbi8qKlxuICogQHJldHVybiBWZWdhIFZhbHVlUmVmIGZvciBzdGFja2FibGUgeCBvciB5XG4gKi9cbmZ1bmN0aW9uIHN0YWNrYWJsZShjaGFubmVsLCBjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHNjYWxlLCBzdGFjaywgZGVmYXVsdFJlZikge1xuICAgIGlmIChjaGFubmVsRGVmICYmIHN0YWNrICYmIGNoYW5uZWwgPT09IHN0YWNrLmZpZWxkQ2hhbm5lbCkge1xuICAgICAgICAvLyB4IG9yIHkgdXNlIHN0YWNrX2VuZCBzbyB0aGF0IHN0YWNrZWQgbGluZSdzIHBvaW50IG1hcmsgdXNlIHN0YWNrX2VuZCB0b28uXG4gICAgICAgIHJldHVybiBmaWVsZFJlZihjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHsgc3VmZml4OiAnZW5kJyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1pZFBvaW50KGNoYW5uZWwsIGNoYW5uZWxEZWYsIHNjYWxlTmFtZSwgc2NhbGUsIGRlZmF1bHRSZWYpO1xufVxuZXhwb3J0cy5zdGFja2FibGUgPSBzdGFja2FibGU7XG4vKipcbiAqIEByZXR1cm4gVmVnYSBWYWx1ZVJlZiBmb3Igc3RhY2thYmxlIHgyIG9yIHkyXG4gKi9cbmZ1bmN0aW9uIHN0YWNrYWJsZTIoY2hhbm5lbCwgYUZpZWxkRGVmLCBhMmZpZWxkRGVmLCBzY2FsZU5hbWUsIHNjYWxlLCBzdGFjaywgZGVmYXVsdFJlZikge1xuICAgIGlmIChhRmllbGREZWYgJiYgc3RhY2sgJiZcbiAgICAgICAgLy8gSWYgZmllbGRDaGFubmVsIGlzIFggYW5kIGNoYW5uZWwgaXMgWDIgKG9yIFkgYW5kIFkyKVxuICAgICAgICBjaGFubmVsLmNoYXJBdCgwKSA9PT0gc3RhY2suZmllbGRDaGFubmVsLmNoYXJBdCgwKSkge1xuICAgICAgICByZXR1cm4gZmllbGRSZWYoYUZpZWxkRGVmLCBzY2FsZU5hbWUsIHsgc3VmZml4OiAnc3RhcnQnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWlkUG9pbnQoY2hhbm5lbCwgYTJmaWVsZERlZiwgc2NhbGVOYW1lLCBzY2FsZSwgZGVmYXVsdFJlZik7XG59XG5leHBvcnRzLnN0YWNrYWJsZTIgPSBzdGFja2FibGUyO1xuLyoqXG4gKiBWYWx1ZSBSZWYgZm9yIGJpbm5lZCBmaWVsZHNcbiAqL1xuZnVuY3Rpb24gYmluKGZpZWxkRGVmLCBzY2FsZU5hbWUsIHNpZGUsIG9mZnNldCkge1xuICAgIHJldHVybiBmaWVsZFJlZihmaWVsZERlZiwgc2NhbGVOYW1lLCB7IGJpblN1ZmZpeDogc2lkZSB9LCBvZmZzZXQpO1xufVxuZXhwb3J0cy5iaW4gPSBiaW47XG5mdW5jdGlvbiBmaWVsZFJlZihmaWVsZERlZiwgc2NhbGVOYW1lLCBvcHQsIG9mZnNldCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICAgIHNjYWxlOiBzY2FsZU5hbWUsXG4gICAgICAgIGZpZWxkOiBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCBvcHQpLFxuICAgIH07XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgICByZWYub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5maWVsZFJlZiA9IGZpZWxkUmVmO1xuZnVuY3Rpb24gYmFuZChzY2FsZU5hbWUsIGJhbmQpIHtcbiAgICBpZiAoYmFuZCA9PT0gdm9pZCAwKSB7IGJhbmQgPSB0cnVlOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlTmFtZSxcbiAgICAgICAgYmFuZDogYmFuZFxuICAgIH07XG59XG5leHBvcnRzLmJhbmQgPSBiYW5kO1xuLyoqXG4gKiBTaWduYWwgdGhhdCByZXR1cm5zIHRoZSBtaWRkbGUgb2YgYSBiaW4uIFNob3VsZCBvbmx5IGJlIHVzZWQgd2l0aCB4IGFuZCB5LlxuICovXG5mdW5jdGlvbiBiaW5NaWRTaWduYWwoZmllbGREZWYsIHNjYWxlTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpZ25hbDogXCIoXCIgK1xuICAgICAgICAgICAgKFwic2NhbGUoXFxcIlwiICsgc2NhbGVOYW1lICsgXCJcXFwiLCBcIiArIGZpZWxkZGVmXzEuZmllbGQoZmllbGREZWYsIHsgYmluU3VmZml4OiAnc3RhcnQnLCBkYXR1bTogdHJ1ZSB9KSArIFwiKVwiKSArXG4gICAgICAgICAgICBcIiArIFwiICtcbiAgICAgICAgICAgIChcInNjYWxlKFxcXCJcIiArIHNjYWxlTmFtZSArIFwiXFxcIiwgXCIgKyBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCB7IGJpblN1ZmZpeDogJ2VuZCcsIGRhdHVtOiB0cnVlIH0pICsgXCIpXCIpICtcbiAgICAgICAgICAgIFwiKS8yXCJcbiAgICB9O1xufVxuLyoqXG4gKiBAcmV0dXJucyB7VmdWYWx1ZVJlZn0gVmFsdWUgUmVmIGZvciB4YyAvIHljIG9yIG1pZCBwb2ludCBmb3Igb3RoZXIgY2hhbm5lbHMuXG4gKi9cbmZ1bmN0aW9uIG1pZFBvaW50KGNoYW5uZWwsIGNoYW5uZWxEZWYsIHNjYWxlTmFtZSwgc2NhbGUsIGRlZmF1bHRSZWYpIHtcbiAgICAvLyBUT0RPOiBkYXR1bSBzdXBwb3J0XG4gICAgaWYgKGNoYW5uZWxEZWYpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZihjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgaWYgKHNjYWxlXzEuaXNCaW5TY2FsZShzY2FsZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBtaWRkbGUgb25seSBmb3IgeCBhbiB5IHRvIHBsYWNlIG1hcmtzIGluIHRoZSBjZW50ZXIgYmV0d2VlbiBzdGFydCBhbmQgZW5kIG9mIHRoZSBiaW4gcmFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gbm90IHVzZSB0aGUgbWlkIHBvaW50IGZvciBvdGhlciBjaGFubmVscyAoZS5nLiBzaXplKSBzbyB0aGF0IHByb3BlcnRpZXMgb2YgbGVnZW5kcyBhbmQgbWFya3MgbWF0Y2guXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxfMS5jb250YWlucyhbJ3gnLCAneSddLCBjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluTWlkU2lnbmFsKGNoYW5uZWxEZWYsIHNjYWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFJlZihjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4oc2NhbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2JhbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBiYW5kLCB0byBnZXQgbWlkIHBvaW50LCBuZWVkIHRvIG9mZnNldCBieSBoYWxmIG9mIHRoZSBiYW5kXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZFJlZihjaGFubmVsRGVmLCBzY2FsZU5hbWUsIHsgYmluU3VmZml4OiAncmFuZ2UnIH0sIGJhbmQoc2NhbGVOYW1lLCAwLjUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkUmVmKGNoYW5uZWxEZWYsIHNjYWxlTmFtZSwgeyBiaW5TdWZmaXg6ICdyYW5nZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGRSZWYoY2hhbm5lbERlZiwgc2NhbGVOYW1lLCB7fSk7IC8vIG5vIG5lZWQgZm9yIGJpbiBzdWZmaXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFubmVsRGVmLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjaGFubmVsRGVmLnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkRGVmIHdpdGhvdXQgZmllbGQgb3IgdmFsdWUuJyk7IC8vIEZJWE1FIGFkZCB0aGlzIHRvIGxvZy5tZXNzYWdlXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRSZWYgPT09ICd6ZXJvT3JNaW4nKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuWDIpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvT3JNaW5YKHNjYWxlTmFtZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZMikge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Pck1pblkoc2NhbGVOYW1lLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGZvciBiYXNlIGZ1bmN0aW9uXCIpOyAvLyBGSVhNRSBhZGQgdGhpcyB0byBsb2cubWVzc2FnZVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZmF1bHRSZWYgPT09ICd6ZXJvT3JNYXgnKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuWDIpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvT3JNYXhYKHNjYWxlTmFtZSwgc2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZIHx8IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5ZMikge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9Pck1heFkoc2NhbGVOYW1lLCBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIGZvciBiYXNlIGZ1bmN0aW9uXCIpOyAvLyBGSVhNRSBhZGQgdGhpcyB0byBsb2cubWVzc2FnZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVmO1xufVxuZXhwb3J0cy5taWRQb2ludCA9IG1pZFBvaW50O1xuZnVuY3Rpb24gdGV4dCh0ZXh0RGVmLCBjb25maWcpIHtcbiAgICAvLyB0ZXh0XG4gICAgaWYgKHRleHREZWYpIHtcbiAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZih0ZXh0RGVmKSkge1xuICAgICAgICAgICAgaWYgKHRleHREZWYudHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogd2hhdCBoYXBwZW5zIGlmIHdlIGhhdmUgYmluP1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBjb21tb25fMS5udW1iZXJGb3JtYXQodGV4dERlZiwgdGV4dERlZi5mb3JtYXQsIGNvbmZpZywgJ3RleHQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IFwiZm9ybWF0KFwiICsgZmllbGRkZWZfMS5maWVsZCh0ZXh0RGVmLCB7IGRhdHVtOiB0cnVlIH0pICsgXCIsICdcIiArIGZvcm1hdCArIFwiJylcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0RGVmLnR5cGUgPT09ICd0ZW1wb3JhbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbW1vbl8xLnRpbWVGb3JtYXRFeHByZXNzaW9uKGZpZWxkZGVmXzEuZmllbGQodGV4dERlZiwgeyBkYXR1bTogdHJ1ZSB9KSwgdGV4dERlZi50aW1lVW5pdCwgdGV4dERlZi5mb3JtYXQsIGNvbmZpZy50ZXh0LnNob3J0VGltZUxhYmVscywgY29uZmlnLnRpbWVGb3JtYXQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGZpZWxkOiB0ZXh0RGVmLmZpZWxkIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dERlZi52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRleHREZWYudmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZTogY29uZmlnLnRleHQudGV4dCB9O1xufVxuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmZ1bmN0aW9uIG1pZFgod2lkdGgsIGNvbmZpZykge1xuICAgIGlmICh3aWR0aCkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogd2lkdGggLyAyIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uZmlnLnNjYWxlLnJhbmdlU3RlcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gVE9ETzogRm9yIGZpdC1tb2RlLCB1c2UgbWlkZGxlIG9mIHRoZSB3aWR0aFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pZFggY2FuIG5vdCBoYW5kbGUgc3RyaW5nIHJhbmdlU3RlcHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWU6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgLyAyIH07XG59XG5leHBvcnRzLm1pZFggPSBtaWRYO1xuZnVuY3Rpb24gbWlkWShoZWlnaHQsIGNvbmZpZykge1xuICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGhlaWdodCAvIDIgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25maWcuc2NhbGUucmFuZ2VTdGVwID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBUT0RPOiBGb3IgZml0LW1vZGUsIHVzZSBtaWRkbGUgb2YgdGhlIHdpZHRoXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlkWCBjYW4gbm90IGhhbmRsZSBzdHJpbmcgcmFuZ2VTdGVwcycpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWx1ZTogY29uZmlnLnNjYWxlLnJhbmdlU3RlcCAvIDIgfTtcbn1cbmV4cG9ydHMubWlkWSA9IG1pZFk7XG5mdW5jdGlvbiB6ZXJvT3JNaW5YKHNjYWxlTmFtZSwgc2NhbGUpIHtcbiAgICBpZiAoc2NhbGVOYW1lKSB7XG4gICAgICAgIC8vIExvZyAvIFRpbWUgLyBVVEMgc2NhbGUgZG8gbm90IHN1cHBvcnQgemVyb1xuICAgICAgICBpZiAoIXV0aWxfMS5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuTE9HLCBzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVENdLCBzY2FsZS50eXBlKSAmJlxuICAgICAgICAgICAgc2NhbGUuemVybyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdXQgdGhlIG1hcmsgb24gdGhlIHgtYXhpc1xuICAgIHJldHVybiB7IHZhbHVlOiAwIH07XG59XG4vKipcbiAqIEByZXR1cm5zIHtWZ1ZhbHVlUmVmfSBiYXNlIHZhbHVlIGlmIHNjYWxlIGV4aXN0cyBhbmQgcmV0dXJuIG1heCB2YWx1ZSBpZiBzY2FsZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiB6ZXJvT3JNYXhYKHNjYWxlTmFtZSwgc2NhbGUpIHtcbiAgICBpZiAoc2NhbGVOYW1lKSB7XG4gICAgICAgIC8vIExvZyAvIFRpbWUgLyBVVEMgc2NhbGUgZG8gbm90IHN1cHBvcnQgemVyb1xuICAgICAgICBpZiAoIXV0aWxfMS5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuTE9HLCBzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVENdLCBzY2FsZS50eXBlKSAmJlxuICAgICAgICAgICAgc2NhbGUuemVybyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmaWVsZDogeyBncm91cDogJ3dpZHRoJyB9IH07XG59XG5mdW5jdGlvbiB6ZXJvT3JNaW5ZKHNjYWxlTmFtZSwgc2NhbGUpIHtcbiAgICBpZiAoc2NhbGVOYW1lKSB7XG4gICAgICAgIC8vIExvZyAvIFRpbWUgLyBVVEMgc2NhbGUgZG8gbm90IHN1cHBvcnQgemVyb1xuICAgICAgICBpZiAoIXV0aWxfMS5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuTE9HLCBzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVENdLCBzY2FsZS50eXBlKSAmJlxuICAgICAgICAgICAgc2NhbGUuemVybyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdXQgdGhlIG1hcmsgb24gdGhlIHktYXhpc1xuICAgIHJldHVybiB7IGZpZWxkOiB7IGdyb3VwOiAnaGVpZ2h0JyB9IH07XG59XG4vKipcbiAqIEByZXR1cm5zIHtWZ1ZhbHVlUmVmfSBiYXNlIHZhbHVlIGlmIHNjYWxlIGV4aXN0cyBhbmQgcmV0dXJuIG1heCB2YWx1ZSBpZiBzY2FsZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiB6ZXJvT3JNYXhZKHNjYWxlTmFtZSwgc2NhbGUpIHtcbiAgICBpZiAoc2NhbGVOYW1lKSB7XG4gICAgICAgIC8vIExvZyAvIFRpbWUgLyBVVEMgc2NhbGUgZG8gbm90IHN1cHBvcnQgemVyb1xuICAgICAgICBpZiAoIXV0aWxfMS5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuTE9HLCBzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVENdLCBzY2FsZS50eXBlKSAmJlxuICAgICAgICAgICAgc2NhbGUuemVybyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IHNjYWxlTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQdXQgdGhlIG1hcmsgb24gdGhlIHktYXhpc1xuICAgIHJldHVybiB7IHZhbHVlOiAwIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkbUZzZFdWeVpXWXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl0WVhKckwzWmhiSFZsY21WbUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSkJRVUZCT3p0SFFVVkhPenM3UVVGRlNDeDVRMEZCYjBRN1FVRkZjRVFzTWtOQlFTdEhPMEZCUXk5SExIRkRRVUUwUlR0QlFVVTFSU3h0UTBGQmIwTTdRVUZGY0VNc2IwTkJRVFpFTzBGQlJUZEVMSEZHUVVGeFJqdEJRVU55Uml4M1JVRkJkMFU3UVVGRmVFVTdPMGRCUlVjN1FVRkRTQ3h0UWtGQk1FSXNUMEZCYTBJc1JVRkJSU3hWUVVGelFpeEZRVUZGTEZOQlFXbENMRVZCUVVVc1MwRkJXU3hGUVVOcVJ5eExRVUZ6UWl4RlFVRkZMRlZCUVhOQ08wbEJRMmhFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1NVRkJTU3hMUVVGTExFbEJRVWtzVDBGQlR5eExRVUZMTEV0QlFVc3NRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZFTERSRlFVRTBSVHRSUVVNMVJTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRlZCUVZVc1JVRkJSU3hUUVVGVExFVkJRVVVzUlVGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNc1EwRkJRenRKUVVNeFJDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhQUVVGUExFVkJRVVVzVlVGQlZTeEZRVUZGTEZOQlFWTXNSVUZCUlN4TFFVRkxMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03UVVGRGNrVXNRMEZCUXp0QlFWQkVMRGhDUVU5RE8wRkJSVVE3TzBkQlJVYzdRVUZEU0N4dlFrRkJNa0lzVDBGQmIwSXNSVUZCUlN4VFFVRnRRaXhGUVVGRkxGVkJRVzlDTEVWQlFVVXNVMEZCYVVJc1JVRkJSU3hMUVVGWkxFVkJRM1pJTEV0QlFYTkNMRVZCUVVVc1ZVRkJjMEk3U1VGRGFFUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1UwRkJVeXhKUVVGSkxFdEJRVXM3VVVGRGJFSXNkVVJCUVhWRU8xRkJRM1pFTEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eERRVUZETEZsQlFWa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVOcVJDeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTk1MRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zVTBGQlV5eEZRVUZGTEZOQlFWTXNSVUZCUlN4RlFVRkRMRTFCUVUwc1JVRkJSU3hQUVVGUExFVkJRVU1zUTBGQlF5eERRVUZETzBsQlF6TkVMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRlZMRVZCUVVVc1UwRkJVeXhGUVVGRkxFdEJRVXNzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXp0QlFVTnlSU3hEUVVGRE8wRkJWRVFzWjBOQlUwTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxHRkJRVzlDTEZGQlFXdENMRVZCUVVVc1UwRkJhVUlzUlVGQlJTeEpRVUZ4UWl4RlFVRkhMRTFCUVdVN1NVRkRhRWNzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRVZCUVVVc1UwRkJVeXhGUVVGRkxFVkJRVU1zVTBGQlV5eEZRVUZGTEVsQlFVa3NSVUZCUXl4RlFVRkZMRTFCUVUwc1EwRkJReXhEUVVGRE8wRkJRMnhGTEVOQlFVTTdRVUZHUkN4clFrRkZRenRCUVVWRUxHdENRVUY1UWl4UlFVRnJRaXhGUVVGRkxGTkJRV2xDTEVWQlFVVXNSMEZCYlVJc1JVRkJSU3hOUVVFMFFqdEpRVU12Unl4SlFVRk5MRWRCUVVjc1IwRkJaVHRSUVVOMFFpeExRVUZMTEVWQlFVVXNVMEZCVXp0UlFVTm9RaXhMUVVGTExFVkJRVVVzWjBKQlFVc3NRMEZCUXl4UlFVRlJMRVZCUVVVc1IwRkJSeXhEUVVGRE8wdEJRelZDTEVOQlFVTTdTVUZEUml4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExZ3NSMEZCUnl4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU03U1VGRGRFSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU03UVVGRFlpeERRVUZETzBGQlZFUXNORUpCVTBNN1FVRkZSQ3hqUVVGeFFpeFRRVUZwUWl4RlFVRkZMRWxCUVRKQ08wbEJRVE5DTEhGQ1FVRkJMRVZCUVVFc1YwRkJNa0k3U1VGRGFrVXNUVUZCVFN4RFFVRkRPMUZCUTB3c1MwRkJTeXhGUVVGRkxGTkJRVk03VVVGRGFFSXNTVUZCU1N4RlFVRkZMRWxCUVVrN1MwRkRXQ3hEUVVGRE8wRkJRMG9zUTBGQlF6dEJRVXhFTEc5Q1FVdERPMEZCUlVRN08wZEJSVWM3UVVGRFNDeHpRa0ZCYzBJc1VVRkJhMElzUlVGQlJTeFRRVUZwUWp0SlFVTjZSQ3hOUVVGTkxFTkJRVU03VVVGRFRDeE5RVUZOTEVWQlFVVXNSMEZCUnp0aFFVTlVMR0ZCUVZVc1UwRkJVeXhaUVVGTkxHZENRVUZMTEVOQlFVTXNVVUZCVVN4RlFVRkZMRVZCUVVNc1UwRkJVeXhGUVVGRkxFOUJRVThzUlVGQlJTeExRVUZMTEVWQlFVVXNTVUZCU1N4RlFVRkRMRU5CUVVNc1RVRkJSeXhEUVVGQk8xbEJRemxGTEV0QlFVczdZVUZEVEN4aFFVRlZMRk5CUVZNc1dVRkJUU3huUWtGQlN5eERRVUZETEZGQlFWRXNSVUZCUlN4RlFVRkRMRk5CUVZNc1JVRkJSU3hMUVVGTExFVkJRVVVzUzBGQlN5eEZRVUZGTEVsQlFVa3NSVUZCUXl4RFFVRkRMRTFCUVVjc1EwRkJRVHRaUVVNNVJTeExRVUZMTzB0QlEwNHNRMEZCUXp0QlFVTktMRU5CUVVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEd0Q1FVRjVRaXhQUVVGblFpeEZRVUZGTEZWQlFYTkNMRVZCUVVVc1UwRkJhVUlzUlVGQlJTeExRVUZaTEVWQlEyaEhMRlZCUVd0RU8wbEJRMnhFTEhOQ1FVRnpRanRKUVVWMFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMllzTUVKQlFUQkNPMUZCUXpGQ0xFVkJRVVVzUTBGQlF5eERRVUZETEhGQ1FVRlZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkNMRVZCUVVVc1EwRkJReXhEUVVGRExHdENRVUZWTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETTBJc2EwZEJRV3RITzJkQ1FVTnNSeXcwUjBGQk5FYzdaMEpCUXpWSExFVkJRVVVzUTBGQlF5eERRVUZETEdWQlFWRXNRMEZCUXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRMnhETEUxQlFVMHNRMEZCUXl4WlFVRlpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzJkQ1FVTTNReXhEUVVGRE8yZENRVU5FTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1ZVRkJWU3hGUVVGRkxGTkJRVk1zUlVGQlJTeEZRVUZETEZOQlFWTXNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJReXhEUVVGRE8xbEJReTlFTEVOQlFVTTdXVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXg1UWtGQmFVSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTnNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4TFFVRkxMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlF6RkNMR2xGUVVGcFJUdHZRa0ZEYWtVc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFZRVUZWTEVWQlFVVXNVMEZCVXl4RlFVRkZMRVZCUVVNc1UwRkJVeXhGUVVGRkxFOUJRVThzUlVGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4VFFVRlRMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEY2tZc1EwRkJRenRuUWtGRFJDeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRlZCUVZVc1JVRkJSU3hUUVVGVExFVkJRVVVzUlVGQlF5eFRRVUZUTEVWQlFVVXNUMEZCVHl4RlFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlJDeERRVUZETzFsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1owSkJRMDRzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXl4VlFVRlZMRVZCUVVVc1UwRkJVeXhGUVVGRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNlVUpCUVhsQ08xbEJRM1pGTEVOQlFVTTdVVUZEU0N4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZWQlFWVXNRMEZCUXl4TFFVRkxMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU14UXl4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzVlVGQlZTeERRVUZETEV0QlFVc3NSVUZCUXl4RFFVRkRPMUZCUTI1RExFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zYTBOQlFXdERMRU5CUVVNc1EwRkJReXhEUVVGRExHZERRVUZuUXp0UlFVTjJSaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1MwRkJTeXhYUVVGWExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF5OUNMREJDUVVFd1FqdFJRVU14UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzVjBGQlF5eEpRVUZKTEU5QlFVOHNTMEZCU3l4WlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1UwRkJVeXhGUVVGRkxFdEJRVXNzUTBGQlF5eERRVUZETzFGQlEzUkRMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRmRCUVVNc1NVRkJTU3hQUVVGUExFdEJRVXNzV1VGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTXpReXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETEZOQlFWTXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRSUVVOMFF5eERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETEhsQ1FVRjFRaXhQUVVGUExIVkNRVUZ2UWl4RFFVRkRMRU5CUVVNc1EwRkJReXhuUTBGQlowTTdVVUZEZGtjc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hMUVVGTExGZEJRVmNzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVNc01FSkJRVEJDTzFGQlF6RkNMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eFhRVUZETEVsQlFVa3NUMEZCVHl4TFFVRkxMRmxCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGNFTXNUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdVVUZEZEVNc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhKUVVGSkxFOUJRVThzUzBGQlN5eFpRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpORExFMUJRVTBzUTBGQlF5eFZRVUZWTEVOQlFVTXNVMEZCVXl4RlFVRkZMRXRCUVVzc1EwRkJReXhEUVVGRE8xRkJRM1JETEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNlVUpCUVhWQ0xFOUJRVThzZFVKQlFXOUNMRU5CUVVNc1EwRkJReXhEUVVGRExHZERRVUZuUXp0UlFVTjJSeXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1FVRkRjRUlzUTBGQlF6dEJRWEJFUkN3MFFrRnZSRU03UVVGRlJDeGpRVUZ4UWl4UFFVRnhReXhGUVVGRkxFMUJRV003U1VGRGVFVXNUMEZCVHp0SlFVTlFMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEV2l4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hMUVVGTExHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNCRExITkRRVUZ6UXp0blFrRkRkRU1zU1VGQlRTeE5RVUZOTEVkQlFVY3NjVUpCUVZrc1EwRkJReXhQUVVGUExFVkJRVVVzVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUlN4TlFVRk5MRVZCUVVVc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEzSkZMRTFCUVUwc1EwRkJRenR2UWtGRFRDeE5RVUZOTEVWQlFVVXNXVUZCVlN4blFrRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVNc1EwRkJReXhYUVVGTkxFMUJRVTBzVDBGQlNUdHBRa0ZEYUVVc1EwRkJRenRaUVVOS0xFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUzBGQlN5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOMlF5eE5RVUZOTEVOQlFVTTdiMEpCUTB3c1RVRkJUU3hGUVVGRkxEWkNRVUZ2UWl4RFFVRkRMR2RDUVVGTExFTkJRVU1zVDBGQlR5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRWxCUVVrc1JVRkJReXhEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEZGQlFWRXNSVUZCUlN4UFFVRlBMRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNaVUZCWlN4RlFVRkZMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU03YVVKQlF6bEpMRU5CUVVNN1dVRkRTaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdaMEpCUTA0c1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVNc1EwRkJRenRaUVVOb1F5eERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONlFpeE5RVUZOTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlF5eERRVUZETzFGQlEyaERMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEVWQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEZRVUZETEVOQlFVTTdRVUZEYmtNc1EwRkJRenRCUVhSQ1JDeHZRa0Z6UWtNN1FVRkZSQ3hqUVVGeFFpeExRVUZoTEVWQlFVVXNUVUZCWXp0SlFVTm9SQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTFZc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVc3NSMEZCUnl4RFFVRkRMRVZCUVVNc1EwRkJRenRKUVVNMVFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlETERoRFFVRTRRenRSUVVNNVF5eE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSFZEUVVGMVF5eERRVUZETEVOQlFVTTdTVUZETTBRc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUjBGQlJ5eERRVUZETEVWQlFVTXNRMEZCUXp0QlFVTTNReXhEUVVGRE8wRkJWa1FzYjBKQlZVTTdRVUZGUkN4alFVRnhRaXhOUVVGakxFVkJRVVVzVFVGQll6dEpRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlExZ3NUVUZCVFN4RFFVRkRMRVZCUVVNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUjBGQlJ5eERRVUZETEVWQlFVTXNRMEZCUXp0SlFVTTNRaXhEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RExEaERRVUU0UXp0UlFVTTVReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETEhWRFFVRjFReXhEUVVGRExFTkJRVU03U1VGRE0wUXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1IwRkJSeXhEUVVGRExFVkJRVU1zUTBGQlF6dEJRVU0zUXl4RFFVRkRPMEZCVmtRc2IwSkJWVU03UVVGRlJDeHZRa0ZCYjBJc1UwRkJhVUlzUlVGQlJTeExRVUZaTzBsQlEycEVMRVZCUVVVc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEWkN3MlEwRkJOa003VVVGRE4wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eHBRa0ZCVXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hwUWtGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRka1VzUzBGQlN5eERRVUZETEVsQlFVa3NTMEZCU3l4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSWFpDTEUxQlFVMHNRMEZCUXp0blFrRkRUQ3hMUVVGTExFVkJRVVVzVTBGQlV6dG5Ra0ZEYUVJc1MwRkJTeXhGUVVGRkxFTkJRVU03WVVGRFZDeERRVUZETzFGQlEwb3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkRSQ3cyUWtGQk5rSTdTVUZETjBJc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEVOQlFVTXNSVUZCUXl4RFFVRkRPMEZCUTNCQ0xFTkJRVU03UVVGRlJEczdSMEZGUnp0QlFVTklMRzlDUVVGdlFpeFRRVUZwUWl4RlFVRkZMRXRCUVZrN1NVRkRha1FzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOa0xEWkRRVUUyUXp0UlFVTTNReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdWQlFWRXNRMEZCUXl4RFFVRkRMR2xDUVVGVExFTkJRVU1zUjBGQlJ5eEZRVUZGTEdsQ1FVRlRMRU5CUVVNc1NVRkJTU3hGUVVGRkxHbENRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF6dFpRVU4yUlN4TFFVRkxMRU5CUVVNc1NVRkJTU3hMUVVGTExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZGZGtJc1RVRkJUU3hEUVVGRE8yZENRVU5NTEV0QlFVc3NSVUZCUlN4VFFVRlRPMmRDUVVOb1FpeExRVUZMTEVWQlFVVXNRMEZCUXp0aFFVTlVMRU5CUVVNN1VVRkRTaXhEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4RlFVRkRMRXRCUVVzc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVTXNSVUZCUXl4RFFVRkRPMEZCUTI1RExFTkJRVU03UVVGRlJDeHZRa0ZCYjBJc1UwRkJhVUlzUlVGQlJTeExRVUZaTzBsQlEycEVMRVZCUVVVc1EwRkJReXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEWkN3MlEwRkJOa003VVVGRE4wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eHBRa0ZCVXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hwUWtGQlV5eERRVUZETEVsQlFVa3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRka1VzUzBGQlN5eERRVUZETEVsQlFVa3NTMEZCU3l4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJSWFpDTEUxQlFVMHNRMEZCUXp0blFrRkRUQ3hMUVVGTExFVkJRVVVzVTBGQlV6dG5Ra0ZEYUVJc1MwRkJTeXhGUVVGRkxFTkJRVU03WVVGRFZDeERRVUZETzFGQlEwb3NRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkRSQ3cyUWtGQk5rSTdTVUZETjBJc1RVRkJUU3hEUVVGRExFVkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJReXhGUVVGRExFTkJRVU03UVVGRGNFTXNRMEZCUXp0QlFVVkVPenRIUVVWSE8wRkJRMGdzYjBKQlFXOUNMRk5CUVdsQ0xFVkJRVVVzUzBGQldUdEpRVU5xUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyUXNOa05CUVRaRE8xRkJRemRETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1pVRkJVU3hEUVVGRExFTkJRVU1zYVVKQlFWTXNRMEZCUXl4SFFVRkhMRVZCUVVVc2FVSkJRVk1zUTBGQlF5eEpRVUZKTEVWQlFVVXNhVUpCUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zUlVGQlJTeExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRPMWxCUTNaRkxFdEJRVXNzUTBGQlF5eEpRVUZKTEV0QlFVc3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVWMlFpeE5RVUZOTEVOQlFVTTdaMEpCUTB3c1MwRkJTeXhGUVVGRkxGTkJRVk03WjBKQlEyaENMRXRCUVVzc1JVRkJSU3hEUVVGRE8yRkJRMVFzUTBGQlF6dFJRVU5LTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc05rSkJRVFpDTzBsQlF6ZENMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeERRVUZETEVWQlFVTXNRMEZCUXp0QlFVTndRaXhEUVVGREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vY2hhbm5lbFwiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi4vZmllbGRkZWZcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBhc3NlbWJsZV8xID0gcmVxdWlyZShcIi4vc2NhbGUvYXNzZW1ibGVcIik7XG52YXIgTmFtZU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmFtZU1hcCgpIHtcbiAgICAgICAgdGhpcy5uYW1lTWFwID0ge307XG4gICAgfVxuICAgIE5hbWVNYXAucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uIChvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZU1hcFtvbGROYW1lXSA9IG5ld05hbWU7XG4gICAgfTtcbiAgICBOYW1lTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lTWFwW25hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBOYW1lTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgbmFtZSBhcHBlYXJzIGluIHRoZSBfbmFtZU1hcCwgd2UgbmVlZCB0byByZWFkIGl0cyBuZXcgbmFtZS5cbiAgICAgICAgLy8gV2UgaGF2ZSB0byBsb29wIG92ZXIgdGhlIGRpY3QganVzdCBpbiBjYXNlIHRoZSBuZXcgbmFtZSBhbHNvIGdldHMgcmVuYW1lZC5cbiAgICAgICAgd2hpbGUgKHRoaXMubmFtZU1hcFtuYW1lXSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMubmFtZU1hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBOYW1lTWFwO1xufSgpKTtcbmV4cG9ydHMuTmFtZU1hcCA9IE5hbWVNYXA7XG52YXIgTW9kZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5heGVzID0ge307XG4gICAgICAgIHRoaXMubGVnZW5kcyA9IHt9O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3JyZWN0cyB0aGUgZGF0YSByZWZlcmVuY2VzIGluIG1hcmtzIGFmdGVyIGFzc2VtYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb3JyZWN0RGF0YU5hbWVzID0gZnVuY3Rpb24gKG1hcmspIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBjb3JyZWN0XG4gICAgICAgICAgICAvLyBmb3Igbm9ybWFsIGRhdGEgcmVmZXJlbmNlc1xuICAgICAgICAgICAgaWYgKG1hcmsuZnJvbSAmJiBtYXJrLmZyb20uZGF0YSkge1xuICAgICAgICAgICAgICAgIG1hcmsuZnJvbS5kYXRhID0gX3RoaXMubG9va3VwRGF0YVNvdXJjZShtYXJrLmZyb20uZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgYWNjZXNzIHRvIGZhY2V0IGRhdGFcbiAgICAgICAgICAgIGlmIChtYXJrLmZyb20gJiYgbWFyay5mcm9tLmZhY2V0ICYmIG1hcmsuZnJvbS5mYWNldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgbWFyay5mcm9tLmZhY2V0LmRhdGEgPSBfdGhpcy5sb29rdXBEYXRhU291cmNlKG1hcmsuZnJvbS5mYWNldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXJrO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIElmIG5hbWUgaXMgbm90IHByb3ZpZGVkLCBhbHdheXMgdXNlIHBhcmVudCdzIGdpdmVuTmFtZSB0byBhdm9pZCBuYW1lIGNvbmZsaWN0cy5cbiAgICAgICAgdGhpcy5uYW1lID0gc3BlYy5uYW1lIHx8IHBhcmVudEdpdmVuTmFtZTtcbiAgICAgICAgLy8gU2hhcmVkIG5hbWUgbWFwc1xuICAgICAgICB0aGlzLnNjYWxlTmFtZU1hcCA9IHBhcmVudCA/IHBhcmVudC5zY2FsZU5hbWVNYXAgOiBuZXcgTmFtZU1hcCgpO1xuICAgICAgICB0aGlzLnNpemVOYW1lTWFwID0gcGFyZW50ID8gcGFyZW50LnNpemVOYW1lTWFwIDogbmV3IE5hbWVNYXAoKTtcbiAgICAgICAgdGhpcy5kYXRhID0gc3BlYy5kYXRhO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gc3BlYy5kZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1zID0gc3BlYy50cmFuc2Zvcm0gfHwgW107XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHNvdXJjZXM6IHBhcmVudCA/IHBhcmVudC5jb21wb25lbnQuZGF0YS5zb3VyY2VzIDoge30sXG4gICAgICAgICAgICAgICAgb3V0cHV0Tm9kZXM6IHBhcmVudCA/IHBhcmVudC5jb21wb25lbnQuZGF0YS5vdXRwdXROb2RlcyA6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGF5b3V0OiBudWxsLCBtYXJrOiBudWxsLCBzY2FsZXM6IG51bGwsIGF4ZXM6IG51bGwsXG4gICAgICAgICAgICBheGlzR3JvdXBzOiBudWxsLCBncmlkR3JvdXBzOiBudWxsLCBsZWdlbmRzOiBudWxsLCBzZWxlY3Rpb246IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcnNlRGF0YSgpO1xuICAgICAgICB0aGlzLnBhcnNlTGF5b3V0RGF0YSgpO1xuICAgICAgICB0aGlzLnBhcnNlU2NhbGUoKTsgLy8gZGVwZW5kcyBvbiBkYXRhIG5hbWVcbiAgICAgICAgdGhpcy5wYXJzZVNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnBhcnNlQXhpcygpOyAvLyBkZXBlbmRzIG9uIHNjYWxlIG5hbWVcbiAgICAgICAgdGhpcy5wYXJzZUxlZ2VuZCgpOyAvLyBkZXBlbmRzIG9uIHNjYWxlIG5hbWVcbiAgICAgICAgdGhpcy5wYXJzZUF4aXNHcm91cCgpOyAvLyBkZXBlbmRzIG9uIGNoaWxkIGF4aXNcbiAgICAgICAgdGhpcy5wYXJzZUdyaWRHcm91cCgpO1xuICAgICAgICB0aGlzLnBhcnNlTWFyaygpOyAvLyBkZXBlbmRzIG9uIGRhdGEgbmFtZSBhbmQgc2NhbGUgbmFtZSwgYXhpc0dyb3VwLCBncmlkR3JvdXAgYW5kIGNoaWxkcmVuJ3Mgc2NhbGUsIGF4aXMsIGxlZ2VuZCBhbmQgbWFyay5cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZVNjYWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VtYmxlXzEuYXNzZW1ibGVTY2FsZSh0aGlzKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmF4ZXMpKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxlZ2VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEudmFscyh0aGlzLmNvbXBvbmVudC5sZWdlbmRzKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ3JvdXAgPSB7fTtcbiAgICAgICAgdmFyIHNpZ25hbHMgPSB0aGlzLmFzc2VtYmxlU2lnbmFscyhncm91cC5zaWduYWxzIHx8IFtdKTtcbiAgICAgICAgaWYgKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ3JvdXAuc2lnbmFscyA9IHNpZ25hbHM7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAubWFya3MgPSB0aGlzLmFzc2VtYmxlTWFya3MoKTtcbiAgICAgICAgdmFyIHNjYWxlcyA9IHRoaXMuYXNzZW1ibGVTY2FsZXMoKTtcbiAgICAgICAgaWYgKHNjYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBncm91cC5zY2FsZXMgPSBzY2FsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSB0aGlzLmFzc2VtYmxlQXhlcygpO1xuICAgICAgICBpZiAoYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBncm91cC5heGVzID0gYXhlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVnZW5kcyA9IHRoaXMuYXNzZW1ibGVMZWdlbmRzKCk7XG4gICAgICAgIGlmIChsZWdlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5yZWR1Y2VGaWVsZERlZiA9IGZ1bmN0aW9uIChmLCBpbml0LCB0KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGluZ18xLnJlZHVjZSh0aGlzLmdldE1hcHBpbmcoKSwgZnVuY3Rpb24gKGFjYywgY2QsIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZGRlZl8xLmlzRmllbGREZWYoY2QpID8gZihhY2MsIGNkLCBjKSA6IGFjYztcbiAgICAgICAgfSwgaW5pdCwgdCk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZm9yRWFjaEZpZWxkRGVmID0gZnVuY3Rpb24gKGYsIHQpIHtcbiAgICAgICAgZW5jb2RpbmdfMS5mb3JFYWNoKHRoaXMuZ2V0TWFwcGluZygpLCBmdW5jdGlvbiAoY2QsIGMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoY2QpKSB7XG4gICAgICAgICAgICAgICAgZihjZCwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHQpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmhhc0Rlc2NlbmRhbnRXaXRoRmllbGRPbkNoYW5uZWwgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jaGlsZHJlbjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5pc1VuaXQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jaGFubmVsSGFzRmllbGQoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhhc0Rlc2NlbmRhbnRXaXRoRmllbGRPbkNoYW5uZWwoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKHRleHQsIGRlbGltaXRlcikge1xuICAgICAgICBpZiAoZGVsaW1pdGVyID09PSB2b2lkIDApIHsgZGVsaW1pdGVyID0gJ18nOyB9XG4gICAgICAgIHJldHVybiAodGhpcy5uYW1lID8gdGhpcy5uYW1lICsgZGVsaW1pdGVyIDogJycpICsgdGV4dDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGF0YSBzb3VyY2UgbmFtZSBmb3IgdGhlIGdpdmVuIGRhdGEgc291cmNlIHR5cGUuIFlvdSBwcm9iYWJseSB3YW50IHRvIGNhbGwgdGhpcyBpbiBwYXJzZS5cbiAgICAgKi9cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0RGF0YU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZnVsbE5hbWUgPSB0aGlzLmdldE5hbWUobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cERhdGFTb3VyY2UoZnVsbE5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9va3VwIHRoZSBuYW1lIG9mIHRoZSBkYXRhc291cmNlIGZvciBhbiBvdXRwdXQgbm9kZS4gWW91IHByb2JhYmx5IHdhbnQgdG8gY2FsbCB0aGlzIGluIGFzc2VtYmxlLlxuICAgICAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5sb29rdXBEYXRhU291cmNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNvbXBvbmVudC5kYXRhLm91dHB1dE5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIC8vIG5hbWUgbm90IGZvdW5kIGluIG1hcCBzbyBsZXQncyBqdXN0IHJldHVybiB3aGF0IHdlIGdvdFxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuc291cmNlO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnJlbmFtZVNpemUgPSBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICB0aGlzLnNpemVOYW1lTWFwLnJlbmFtZShvbGROYW1lLCBuZXdOYW1lKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jaGFubmVsU2l6ZU5hbWUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplTmFtZShjaGFubmVsID09PSBjaGFubmVsXzEuWCB8fCBjaGFubmVsID09PSBjaGFubmVsXzEuQ09MVU1OID8gJ3dpZHRoJyA6ICdoZWlnaHQnKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zaXplTmFtZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVOYW1lTWFwLmdldCh0aGlzLmdldE5hbWUoc2l6ZSwgJ18nKSk7XG4gICAgfTtcbiAgICAvKiogR2V0IFwiZmllbGRcIiByZWZlcmVuY2UgZm9yIHZlZ2EgKi9cbiAgICBNb2RlbC5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbiAoY2hhbm5lbCwgb3B0KSB7XG4gICAgICAgIGlmIChvcHQgPT09IHZvaWQgMCkgeyBvcHQgPSB7fTsgfVxuICAgICAgICB2YXIgZmllbGREZWYgPSB0aGlzLmZpZWxkRGVmKGNoYW5uZWwpO1xuICAgICAgICBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgICAgICBvcHQgPSB1dGlsXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBiaW5TdWZmaXg6IHNjYWxlXzEuaGFzRGlzY3JldGVEb21haW4odGhpcy5zY2FsZShjaGFubmVsKS50eXBlKSA/ICdyYW5nZScgOiAnc3RhcnQnXG4gICAgICAgICAgICB9LCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZGRlZl8xLmZpZWxkKGZpZWxkRGVmLCBvcHQpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVzW2NoYW5uZWxdO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmhhc0Rpc2NyZXRlU2NhbGUgPSBmdW5jdGlvbiAoY2hhbm5lbCkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlKGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gc2NhbGUgJiYgc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZS50eXBlKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5yZW5hbWVTY2FsZSA9IGZ1bmN0aW9uIChvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIHRoaXMuc2NhbGVOYW1lTWFwLnJlbmFtZShvbGROYW1lLCBuZXdOYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gc2NhbGUgbmFtZSBmb3IgYSBnaXZlbiBjaGFubmVsIGFmdGVyIHRoZSBzY2FsZSBoYXMgYmVlbiBwYXJzZWQgYW5kIG5hbWVkLlxuICAgICAqL1xuICAgIE1vZGVsLnByb3RvdHlwZS5zY2FsZU5hbWUgPSBmdW5jdGlvbiAob3JpZ2luYWxTY2FsZU5hbWUsIHBhcnNlKSB7XG4gICAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHRoZSBwYXJzZSBwaGFzZSBhbHdheXMgcmV0dXJuIGEgdmFsdWVcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gcmVmZXIgdG8gcmVuYW1lIG1hcCBiZWNhdXNlIGEgc2NhbGUgY2FuJ3QgYmUgcmVuYW1lZFxuICAgICAgICAgICAgLy8gYmVmb3JlIGl0IGhhcyB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5hbWUob3JpZ2luYWxTY2FsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2NhbGUgZm9yIHRoZSBjaGFubmVsLCBpdCBzaG91bGQgZWl0aGVyXG4gICAgICAgIC8vIGJlIGluIHRoZSBfc2NhbGUgbWFwcGluZyBvciBleGlzdCBpbiB0aGUgbmFtZSBtYXBcbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBpbiB0aGUgc2NhbGUgbWFwICh0aGUgc2NhbGUgaXMgbm90IG1lcmdlZCBieSBpdHMgcGFyZW50KVxuICAgICAgICAodGhpcy5zY2FsZSAmJiB0aGlzLnNjYWxlc1tvcmlnaW5hbFNjYWxlTmFtZV0pIHx8XG4gICAgICAgICAgICAvLyBpbiB0aGUgc2NhbGUgbmFtZSBtYXAgKHRoZSB0aGUgc2NhbGUgZ2V0IG1lcmdlZCBieSBpdHMgcGFyZW50KVxuICAgICAgICAgICAgdGhpcy5zY2FsZU5hbWVNYXAuaGFzKHRoaXMuZ2V0TmFtZShvcmlnaW5hbFNjYWxlTmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZU5hbWVNYXAuZ2V0KHRoaXMuZ2V0TmFtZShvcmlnaW5hbFNjYWxlTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRNYXBwaW5nKClbY2hhbm5lbF0gfHwge30pLnNvcnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXhpcyA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF4ZXNbY2hhbm5lbF07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUubGVnZW5kID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kc1tjaGFubmVsXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFR5cGUgY2hlY2tzXG4gICAgICovXG4gICAgTW9kZWwucHJvdG90eXBlLmlzVW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmlzRmFjZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5pc0xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gTW9kZWw7XG59KCkpO1xuZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYlc5a1pXd3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXRiMlJsYkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEhORFFVRTRRenRCUVVjNVF5eDNRMEZCTkVNN1FVRkROVU1zZDBOQlFXOUdPMEZCUlhCR0xHdERRVUZyUkR0QlFVdHNSQ3huUTBGQk1rTTdRVUZMTTBNc05rTkJRU3RETzBGQmJVTXZRenRKUVVkRk8xRkJRMFVzU1VGQlNTeERRVUZETEU5QlFVOHNSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkRjRUlzUTBGQlF6dEpRVVZOTEhkQ1FVRk5MRWRCUVdJc1ZVRkJZeXhQUVVGbExFVkJRVVVzVDBGQlpUdFJRVU0xUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEU5QlFVOHNRMEZCUXp0SlFVTnNReXhEUVVGRE8wbEJSMDBzY1VKQlFVY3NSMEZCVml4VlFVRlhMRWxCUVZrN1VVRkRja0lzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZUU3h4UWtGQlJ5eEhRVUZXTEZWQlFWY3NTVUZCV1R0UlFVTnlRaXh4UlVGQmNVVTdVVUZEY2tVc05rVkJRVFpGTzFGQlF6ZEZMRTlCUVU4c1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRPMWxCUXpGQ0xFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRelZDTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVU5JTEdOQlFVTTdRVUZCUkN4RFFVRkRMRUZCZWtKRUxFbEJlVUpETzBGQmVrSlpMREJDUVVGUE8wRkJNa0p3UWp0SlFUWkNSU3hsUVVGWkxFbEJRV01zUlVGQlJTeE5RVUZoTEVWQlFVVXNaVUZCZFVJc1JVRkJSU3hOUVVGak8xRkJRV3hHTEdsQ1FYZENRenRSUVhSRGEwSXNWMEZCVFN4SFFVRm5RaXhGUVVGRkxFTkJRVU03VVVGRmVrSXNVMEZCU1N4SFFVRmxMRVZCUVVVc1EwRkJRenRSUVVWMFFpeFpRVUZQTEVkQlFXbENMRVZCUVVVc1EwRkJRenRSUVUxeVFpeGhRVUZSTEVkQlFWa3NSVUZCUlN4RFFVRkRPMUZCZVZCb1JEczdWMEZGUnp0UlFVTkpMSEZDUVVGblFpeEhRVUZITEZWQlFVTXNTVUZCYlVJN1dVRkROVU1zTUVKQlFUQkNPMWxCUlRGQ0xEWkNRVUUyUWp0WlFVTTNRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRhRU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1MwRkJTU3hEUVVGRExHZENRVUZuUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEZWtRc1EwRkJRenRaUVVWRUxESkNRVUV5UWp0WlFVTXpRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwRUxFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWxCUVVrc1IwRkJSeXhMUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRja1VzUTBGQlF6dFpRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRExFTkJRVUU3VVVGeVVVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRGNrSXNTVUZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmNrSXNhMFpCUVd0R08xRkJRMnhHTEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzU1VGQlNTeGxRVUZsTEVOQlFVTTdVVUZGZWtNc2JVSkJRVzFDTzFGQlEyNUNMRWxCUVVrc1EwRkJReXhaUVVGWkxFZEJRVWNzVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4WlFVRlpMRWRCUVVjc1NVRkJTU3hQUVVGUExFVkJRVVVzUTBGQlF6dFJRVU5xUlN4SlFVRkpMRU5CUVVNc1YwRkJWeXhIUVVGSExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNWMEZCVnl4SFFVRkhMRWxCUVVrc1QwRkJUeXhGUVVGRkxFTkJRVU03VVVGRkwwUXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJYUkNMRWxCUVVrc1EwRkJReXhYUVVGWExFZEJRVWNzU1VGQlNTeERRVUZETEZkQlFWY3NRMEZCUXp0UlFVTndReXhKUVVGSkxFTkJRVU1zVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4VFFVRlRMRWxCUVVrc1JVRkJSU3hEUVVGRE8xRkJSWFpETEVsQlFVa3NRMEZCUXl4VFFVRlRMRWRCUVVjN1dVRkRaaXhKUVVGSkxFVkJRVVU3WjBKQlEwb3NUMEZCVHl4RlFVRkZMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRWRCUVVjc1JVRkJSVHRuUWtGRGNFUXNWMEZCVnl4RlFVRkZMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4WFFVRlhMRWRCUVVjc1JVRkJSVHRoUVVNM1JEdFpRVU5FTEUxQlFVMHNSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxFbEJRVWtzUlVGQlJTeE5RVUZOTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWxCUVVrc1JVRkJSU3hKUVVGSk8xbEJRMnhFTEZWQlFWVXNSVUZCUlN4SlFVRkpMRVZCUVVVc1ZVRkJWU3hGUVVGRkxFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RlFVRkZMRk5CUVZNc1JVRkJSU3hKUVVGSk8xTkJRMjVGTEVOQlFVTTdTVUZEU2l4RFFVRkRPMGxCUlUwc2NVSkJRVXNzUjBGQldqdFJRVU5GTEVsQlFVa3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRSUVVOcVFpeEpRVUZKTEVOQlFVTXNaVUZCWlN4RlFVRkZMRU5CUVVNN1VVRkRka0lzU1VGQlNTeERRVUZETEZWQlFWVXNSVUZCUlN4RFFVRkRMRU5CUVVNc2RVSkJRWFZDTzFGQlF6RkRMRWxCUVVrc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF6dFJRVU4wUWl4SlFVRkpMRU5CUVVNc1UwRkJVeXhGUVVGRkxFTkJRVU1zUTBGQlF5eDNRa0ZCZDBJN1VVRkRNVU1zU1VGQlNTeERRVUZETEZkQlFWY3NSVUZCUlN4RFFVRkRMRU5CUVVNc2QwSkJRWGRDTzFGQlF6VkRMRWxCUVVrc1EwRkJReXhqUVVGakxFVkJRVVVzUTBGQlF5eERRVUZETEhkQ1FVRjNRanRSUVVNdlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RlFVRkZMRU5CUVVNN1VVRkRkRUlzU1VGQlNTeERRVUZETEZOQlFWTXNSVUZCUlN4RFFVRkRMRU5CUVVNc2VVZEJRWGxITzBsQlF6ZElMRU5CUVVNN1NVRXlRazBzT0VKQlFXTXNSMEZCY2tJN1VVRkRSU3hOUVVGTkxFTkJRVU1zZDBKQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNM1FpeERRVUZETzBsQlNVMHNORUpCUVZrc1IwRkJia0k3VVVGRFJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUlVGQlJTeEZRVUZGTEZkQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZUVRc1EwRkJRenRKUVVWTkxDdENRVUZsTEVkQlFYUkNPMUZCUTBVc1RVRkJUU3hEUVVGRExGZEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRM1JETEVOQlFVTTdTVUZGVFN3MlFrRkJZU3hIUVVGd1FqdFJRVU5GTEVsQlFVMHNTMEZCU3l4SFFVRnJRaXhGUVVGRkxFTkJRVU03VVVGRmFFTXNTVUZCVFN4UFFVRlBMRWRCUVVjc1NVRkJTU3hEUVVGRExHVkJRV1VzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4SlFVRkpMRVZCUVVVc1EwRkJReXhEUVVGRE8xRkJRekZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhOUVVGTkxFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJRaXhMUVVGTExFTkJRVU1zVDBGQlR5eEhRVUZITEU5QlFVOHNRMEZCUXp0UlFVTXhRaXhEUVVGRE8xRkJSVVFzUzBGQlN5eERRVUZETEV0QlFVc3NSMEZCUnl4SlFVRkpMRU5CUVVNc1lVRkJZU3hGUVVGRkxFTkJRVU03VVVGRGJrTXNTVUZCVFN4TlFVRk5MRWRCUVVjc1NVRkJTU3hEUVVGRExHTkJRV01zUlVGQlJTeERRVUZETzFGQlEzSkRMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMFFpeExRVUZMTEVOQlFVTXNUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJRenRSUVVONFFpeERRVUZETzFGQlJVUXNTVUZCVFN4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExGbEJRVmtzUlVGQlJTeERRVUZETzFGQlEycERMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOd1FpeExRVUZMTEVOQlFVTXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJRenRSUVVOd1FpeERRVUZETzFGQlJVUXNTVUZCVFN4UFFVRlBMRWRCUVVjc1NVRkJTU3hEUVVGRExHVkJRV1VzUlVGQlJTeERRVUZETzFGQlEzWkRMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlFpeExRVUZMTEVOQlFVTXNUMEZCVHl4SFFVRkhMRTlCUVU4c1EwRkJRenRSUVVNeFFpeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVObUxFTkJRVU03U1VGUlRTdzRRa0ZCWXl4SFFVRnlRaXhWUVVFMFFpeERRVUV3UXl4RlFVRkZMRWxCUVU4c1JVRkJSU3hEUVVGUE8xRkJRM1JHTEUxQlFVMHNRMEZCUXl4cFFrRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNSVUZCUlN4VlFVRkRMRWRCUVVzc1JVRkJSeXhGUVVGakxFVkJRVVVzUTBGQlZUdFpRVU5zUlN4TlFVRk5MRU5CUVVNc2NVSkJRVlVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1IwRkJSeXhGUVVGRkxFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNN1VVRkRPVU1zUTBGQlF5eEZRVUZGTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOa0xFTkJRVU03U1VGRlRTd3JRa0ZCWlN4SFFVRjBRaXhWUVVGMVFpeERRVUZ4UXl4RlFVRkZMRU5CUVU4N1VVRkRia1VzYTBKQlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFVkJRVVVzVlVGQlF5eEZRVUZqTEVWQlFVVXNRMEZCVlR0WlFVTndSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtJc1EwRkJReXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNN1VVRkRTQ3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEVWl4RFFVRkRPMGxCUlUwc0swTkJRU3RDTEVkQlFYUkRMRlZCUVhWRExFOUJRV2RDTzFGQlEzSkVMRWRCUVVjc1EwRkJReXhEUVVGblFpeFZRVUZoTEVWQlFXSXNTMEZCUVN4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGaUxHTkJRV0VzUlVGQllpeEpRVUZoTzFsQlFUVkNMRWxCUVUwc1MwRkJTeXhUUVVGQk8xbEJRMlFzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYmtJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03YjBKQlEyNURMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03WjBKQlEyUXNRMEZCUXp0WlFVTklMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dG5Ra0ZEVGl4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zSzBKQlFTdENMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTnVSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVTmtMRU5CUVVNN1dVRkRTQ3hEUVVGRE8xTkJRMFk3VVVGRFJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJZc1EwRkJRenRKUVVsTkxIVkNRVUZQTEVkQlFXUXNWVUZCWlN4SlFVRlpMRVZCUVVVc1UwRkJkVUk3VVVGQmRrSXNNRUpCUVVFc1JVRkJRU3hsUVVGMVFqdFJRVU5zUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1UwRkJVeXhIUVVGSExFVkJRVVVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTjZSQ3hEUVVGRE8wbEJSVVE3TzA5QlJVYzdTVUZEU1N3eVFrRkJWeXhIUVVGc1FpeFZRVUZ0UWl4SlFVRnZRanRSUVVOeVF5eEpRVUZOTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlJYQkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03U1VGRGVrTXNRMEZCUXp0SlFVVkVPenRQUVVWSE8wbEJRMGtzWjBOQlFXZENMRWRCUVhaQ0xGVkJRWGRDTEVsQlFWazdVVUZEYkVNc1NVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlJXNUVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTldMSGxFUVVGNVJEdFpRVU42UkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dFJRVVZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRM0pDTEVOQlFVTTdTVUZGVFN3d1FrRkJWU3hIUVVGcVFpeFZRVUZyUWl4UFFVRmxMRVZCUVVVc1QwRkJaVHRSUVVOb1JDeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdTVUZETlVNc1EwRkJRenRKUVVWTkxDdENRVUZsTEVkQlFYUkNMRlZCUVhWQ0xFOUJRV2RDTzFGQlEzSkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWxCUVVrc1QwRkJUeXhMUVVGTExHZENRVUZOTEVkQlFVY3NUMEZCVHl4SFFVRkhMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJRMnBHTEVOQlFVTTdTVUZGVFN4M1FrRkJVU3hIUVVGbUxGVkJRV2RDTEVsQlFWazdVVUZEZWtJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFhRVUZYTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRlRVFzUTBGQlF6dEpRVVZFTEhGRFFVRnhRenRKUVVNNVFpeHhRa0ZCU3l4SFFVRmFMRlZCUVdFc1QwRkJaMElzUlVGQlJTeEhRVUYzUWp0UlFVRjRRaXh2UWtGQlFTeEZRVUZCTEZGQlFYZENPMUZCUTNKRUxFbEJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRmVFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtJc1IwRkJSeXhIUVVGSExHRkJRVTBzUTBGQlF6dG5Ra0ZEV0N4VFFVRlRMRVZCUVVVc2VVSkJRV2xDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4UFFVRlBMRWRCUVVjc1QwRkJUenRoUVVNelJTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMUZCUTFZc1EwRkJRenRSUVVWRUxFMUJRVTBzUTBGQlF5eG5Ra0ZCU3l4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU01UWl4RFFVRkRPMGxCU1Uwc2NVSkJRVXNzUjBGQldpeFZRVUZoTEU5QlFXZENPMUZCUXpOQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZGVFN4blEwRkJaMElzUjBGQmRrSXNWVUZCZDBJc1QwRkJaMEk3VVVGRGRFTXNTVUZCVFN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTnNReXhOUVVGTkxFTkJRVU1zUzBGQlN5eEpRVUZKTEhsQ1FVRnBRaXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wbEJSVTBzTWtKQlFWY3NSMEZCYkVJc1ZVRkJiVUlzVDBGQlpTeEZRVUZGTEU5QlFXVTdVVUZEYWtRc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRemRETEVOQlFVTTdTVUZIUkRzN1QwRkZSenRKUVVOSkxIbENRVUZUTEVkQlFXaENMRlZCUVRoQ0xHbENRVUZ0UXl4RlFVRkZMRXRCUVdVN1VVRkRhRVlzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOV0xDdERRVUVyUXp0WlFVTXZReXhyUlVGQmEwVTdXVUZEYkVVc2JVTkJRVzFETzFsQlEyNURMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03VVVGRGVrTXNRMEZCUXp0UlFVVkVMSGRFUVVGM1JEdFJRVU40UkN4dlJFRkJiMFE3VVVGRGNFUXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRRU3d5UkVGQk1rUTdVVUZETTBRc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNRMEZCUXp0WlFVTTVReXhwUlVGQmFVVTdXVUZEYWtVc1NVRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhwUWtGQmFVSXNRMEZCUXl4RFFVTjJSQ3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5JTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1dVRkJXU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMR2xDUVVGcFFpeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm9SU3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0SlFVTnVRaXhEUVVGRE8wbEJSVTBzYjBKQlFVa3NSMEZCV0N4VlFVRlpMRTlCUVdkQ08xRkJRekZDTEUxQlFVMHNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU03U1VGRGFrUXNRMEZCUXp0SlFVVk5MRzlDUVVGSkxFZEJRVmdzVlVGQldTeFBRVUZuUWp0UlFVTXhRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVNMVFpeERRVUZETzBsQlJVMHNjMEpCUVUwc1IwRkJZaXhWUVVGakxFOUJRV2RDTzFGQlF6VkNMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGeFFrUTdPMDlCUlVjN1NVRkRTU3h6UWtGQlRTeEhRVUZpTzFGQlEwVXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVObUxFTkJRVU03U1VGRFRTeDFRa0ZCVHl4SFFVRmtPMUZCUTBVc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU5tTEVOQlFVTTdTVUZEVFN4MVFrRkJUeXhIUVVGa08xRkJRMFVzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTm1MRU5CUVVNN1NVRkRTQ3haUVVGRE8wRkJRVVFzUTBGQlF5eEJRV3BVUkN4SlFXbFVRenRCUVdwVWNVSXNjMEpCUVVzaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHZlZ2FfdXRpbF8xID0gcmVxdWlyZShcInZlZ2EtdXRpbFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciB2ZWdhX3NjaGVtYV8xID0gcmVxdWlyZShcIi4uLy4uL3ZlZ2Euc2NoZW1hXCIpO1xuZnVuY3Rpb24gYXNzZW1ibGVTY2FsZShtb2RlbCkge1xuICAgIHJldHVybiB1dGlsXzEudmFscyhtb2RlbC5jb21wb25lbnQuc2NhbGVzKS5tYXAoZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgIC8vIGNvcnJlY3QgcmVmZXJlbmNlcyB0byBkYXRhXG4gICAgICAgIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG4gICAgICAgIGlmICh2ZWdhX3NjaGVtYV8xLmlzRGF0YVJlZkRvbWFpbihkb21haW4pIHx8IHZlZ2Ffc2NoZW1hXzEuaXNGaWVsZFJlZlVuaW9uRG9tYWluKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGRvbWFpbi5kYXRhID0gbW9kZWwubG9va3VwRGF0YVNvdXJjZShkb21haW4uZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVnYV9zY2hlbWFfMS5pc0RhdGFSZWZVbmlvbmVkRG9tYWluKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGRvbWFpbi5maWVsZHMgPSBkb21haW4uZmllbGRzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBmLCB7IGRhdGE6IG1vZGVsLmxvb2t1cERhdGFTb3VyY2UoZi5kYXRhKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNTaWduYWxSZWZEb21haW4oZG9tYWluKSB8fCB2ZWdhX3V0aWxfMS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsZSBkb21haW4nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hc3NlbWJsZVNjYWxlID0gYXNzZW1ibGVTY2FsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVlYTnpaVzFpYkdVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXpZMkZzWlM5aGMzTmxiV0pzWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZCUVN4MVEwRkJhME03UVVGRGJFTXNiVU5CUVdkRE8wRkJRMmhETEdsRVFVRXJTRHRCUVVjdlNDeDFRa0ZCT0VJc1MwRkJXVHRKUVVOMFF5eE5RVUZOTEVOQlFVTXNWMEZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVFc1MwRkJTenRSUVVNelF5dzJRa0ZCTmtJN1VVRkROMElzU1VGQlRTeE5RVUZOTEVkQlFVY3NTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVNMVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl3MlFrRkJaU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEcxRFFVRnhRaXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTNSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4blFrRkJaMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRiRVFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0UlFVTm1MRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNiME5CUVhOQ0xFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVkQlFVY3NUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlF5eERRVUZaTzJkQ1FVTTNReXhOUVVGTkxITkNRVU5FTEVOQlFVTXNTVUZEU2l4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGRGNFTTdXVUZEU2l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOSUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZEWml4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEN0Q1FVRnBRaXhEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEcxQ1FVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaEVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRFppeERRVUZETzFGQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1dVRkRUaXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETEhOQ1FVRnpRaXhEUVVGRExFTkJRVU03VVVGRE1VTXNRMEZCUXp0SlFVTklMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMUFzUTBGQlF6dEJRWEpDUkN4elEwRnhRa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgYWdncmVnYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vYWdncmVnYXRlXCIpO1xudmFyIGJpbl8xID0gcmVxdWlyZShcIi4uLy4uL2JpblwiKTtcbnZhciBkYXRldGltZV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGV0aW1lXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgc29ydF8xID0gcmVxdWlyZShcIi4uLy4uL3NvcnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHZlZ2Ffc2NoZW1hXzEgPSByZXF1aXJlKFwiLi4vLi4vdmVnYS5zY2hlbWFcIik7XG52YXIgZGF0YV8xID0gcmVxdWlyZShcIi4uLy4uL2RhdGFcIik7XG5mdW5jdGlvbiBpbml0RG9tYWluKGRvbWFpbiwgZmllbGREZWYsIHNjYWxlLCBzY2FsZUNvbmZpZykge1xuICAgIGlmIChkb21haW4gPT09ICd1bmFnZ3JlZ2F0ZWQnKSB7XG4gICAgICAgIHZhciBfYSA9IGNhblVzZVVuYWdncmVnYXRlZERvbWFpbihmaWVsZERlZiwgc2NhbGUpLCB2YWxpZCA9IF9hLnZhbGlkLCByZWFzb24gPSBfYS5yZWFzb247XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKHJlYXNvbik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbWFpbiA9PT0gdW5kZWZpbmVkICYmIHNjYWxlQ29uZmlnLnVzZVVuYWdncmVnYXRlZERvbWFpbikge1xuICAgICAgICAvLyBBcHBseSBjb25maWcgaWYgZG9tYWluIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgIHZhciB2YWxpZCA9IGNhblVzZVVuYWdncmVnYXRlZERvbWFpbihmaWVsZERlZiwgc2NhbGUpLnZhbGlkO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAndW5hZ2dyZWdhdGVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZG9tYWluO1xufVxuZXhwb3J0cy5pbml0RG9tYWluID0gaW5pdERvbWFpbjtcbmZ1bmN0aW9uIHBhcnNlRG9tYWluKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgLy8gSWYgY2hhbm5lbCBpcyBlaXRoZXIgWCBvciBZIHRoZW4gdW5pb24gdGhlbSB3aXRoIFgyICYgWTIgaWYgdGhleSBleGlzdFxuICAgIGlmIChjaGFubmVsID09PSAneCcgJiYgbW9kZWwuY2hhbm5lbEhhc0ZpZWxkKCd4MicpKSB7XG4gICAgICAgIGlmIChtb2RlbC5jaGFubmVsSGFzRmllbGQoJ3gnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaW9uRG9tYWlucyhwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCAneCcpLCBwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCAneDInKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTaW5nbGVDaGFubmVsRG9tYWluKHNjYWxlLCBtb2RlbCwgJ3gyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbm5lbCA9PT0gJ3knICYmIG1vZGVsLmNoYW5uZWxIYXNGaWVsZCgneTInKSkge1xuICAgICAgICBpZiAobW9kZWwuY2hhbm5lbEhhc0ZpZWxkKCd5JykpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmlvbkRvbWFpbnMocGFyc2VTaW5nbGVDaGFubmVsRG9tYWluKHNjYWxlLCBtb2RlbCwgJ3knKSwgcGFyc2VTaW5nbGVDaGFubmVsRG9tYWluKHNjYWxlLCBtb2RlbCwgJ3kyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2luZ2xlQ2hhbm5lbERvbWFpbihzY2FsZSwgbW9kZWwsICd5MicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZVNpbmdsZUNoYW5uZWxEb21haW4oc2NhbGUsIG1vZGVsLCBjaGFubmVsKTtcbn1cbmV4cG9ydHMucGFyc2VEb21haW4gPSBwYXJzZURvbWFpbjtcbmZ1bmN0aW9uIHBhcnNlU2luZ2xlQ2hhbm5lbERvbWFpbihzY2FsZSwgbW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcbiAgICBpZiAoc2NhbGUuZG9tYWluICYmIHNjYWxlLmRvbWFpbiAhPT0gJ3VuYWdncmVnYXRlZCcpIHtcbiAgICAgICAgaWYgKGRhdGV0aW1lXzEuaXNEYXRlVGltZShzY2FsZS5kb21haW5bMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGUuZG9tYWluLm1hcChmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS50aW1lc3RhbXAoZHQsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbjtcbiAgICB9XG4gICAgdmFyIHN0YWNrID0gbW9kZWwuc3RhY2s7XG4gICAgaWYgKHN0YWNrICYmIGNoYW5uZWwgPT09IHN0YWNrLmZpZWxkQ2hhbm5lbCkge1xuICAgICAgICBpZiAoc3RhY2sub2Zmc2V0ID09PSAnbm9ybWFsaXplJykge1xuICAgICAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBzdWZmaXg6ICdzdGFydCcgfSksXG4gICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBzdWZmaXg6ICdlbmQnIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBzb3J0ID0gZG9tYWluU29ydChtb2RlbCwgY2hhbm5lbCwgc2NhbGUudHlwZSk7XG4gICAgaWYgKHNjYWxlLmRvbWFpbiA9PT0gJ3VuYWdncmVnYXRlZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG1vZGVsLmdldERhdGFOYW1lKGRhdGFfMS5NQUlOKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkKGNoYW5uZWwsIHsgYWdncmVnYXRlOiAnbWluJyB9KSxcbiAgICAgICAgICAgICAgICBtb2RlbC5maWVsZChjaGFubmVsLCB7IGFnZ3JlZ2F0ZTogJ21heCcgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmllbGREZWYuYmluKSB7XG4gICAgICAgIGlmIChzY2FsZV8xLmlzQmluU2NhbGUoc2NhbGUudHlwZSkpIHtcbiAgICAgICAgICAgIHZhciBzaWduYWwgPSBtb2RlbC5nZXROYW1lKGJpbl8xLmJpblRvU3RyaW5nKGZpZWxkRGVmLmJpbikgKyBcIl9cIiArIGZpZWxkRGVmLmZpZWxkICsgXCJfYmluc1wiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNpZ25hbDogXCJzZXF1ZW5jZShcIiArIHNpZ25hbCArIFwiLnN0YXJ0LCBcIiArIHNpZ25hbCArIFwiLnN0b3AgKyBcIiArIHNpZ25hbCArIFwiLnN0ZXAsIFwiICsgc2lnbmFsICsgXCIuc3RlcClcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHNjYWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyBvcmRpbmFsIGJpbiBzY2FsZSB0YWtlcyBkb21haW4gZnJvbSBiaW5fcmFuZ2UsIG9yZGVyZWQgYnkgYmluX3N0YXJ0XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3IgYm90aCBheGlzLWJhc2VkIHNjYWxlICh4LCB5LCBjb2x1bW4sIGFuZCByb3cpIGFuZCBsZWdlbmQtYmFzZWQgc2NhbGUgKG90aGVyIGNoYW5uZWxzKS5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsLCB7IGJpblN1ZmZpeDogJ3JhbmdlJyB9KSxcbiAgICAgICAgICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsLCB7IGJpblN1ZmZpeDogJ3N0YXJ0JyB9KSxcbiAgICAgICAgICAgICAgICAgICAgb3A6ICdtaW4nIC8vIG1pbiBvciBtYXggZG9lc24ndCBtYXR0ZXIgc2luY2Ugc2FtZSBfcmFuZ2Ugd291bGQgaGF2ZSB0aGUgc2FtZSBfc3RhcnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwgPT09ICd4JyB8fCBjaGFubmVsID09PSAneScpIHtcbiAgICAgICAgICAgICAgICAvLyBYL1kgcG9zaXRpb24gaGF2ZSB0byBpbmNsdWRlIHN0YXJ0IGFuZCBlbmQgZm9yIG5vbi1vcmRpbmFsIHNjYWxlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkKGNoYW5uZWwsIHsgYmluU3VmZml4OiAnc3RhcnQnIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwuZmllbGQoY2hhbm5lbCwgeyBiaW5TdWZmaXg6ICdlbmQnIH0pXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdXNlIGJpbl9taWRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBtb2RlbC5nZXREYXRhTmFtZShkYXRhXzEuTUFJTiksXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBtb2RlbC5maWVsZChjaGFubmVsLCB7IGJpblN1ZmZpeDogJ3N0YXJ0JyB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc29ydCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gSWYgc29ydCBieSBhZ2dyZWdhdGlvbiBvZiBhIHNwZWNpZmllZCBzb3J0IGZpZWxkLCB3ZSBuZWVkIHRvIHVzZSBSQVcgdGFibGUsXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gYWdncmVnYXRlIHZhbHVlcyBmb3IgdGhlIHNjYWxlIGluZGVwZW5kZW50bHkgZnJvbSB0aGUgbWFpbiBhZ2dyZWdhdGlvbi5cbiAgICAgICAgICAgIGRhdGE6IHV0aWwuaXNCb29sZWFuKHNvcnQpID8gbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pIDogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLlJBVyksXG4gICAgICAgICAgICBmaWVsZDogbW9kZWwuZmllbGQoY2hhbm5lbCksXG4gICAgICAgICAgICBzb3J0OiBzb3J0XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbW9kZWwuZ2V0RGF0YU5hbWUoZGF0YV8xLk1BSU4pLFxuICAgICAgICAgICAgZmllbGQ6IG1vZGVsLmZpZWxkKGNoYW5uZWwpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvbWFpblNvcnQobW9kZWwsIGNoYW5uZWwsIHNjYWxlVHlwZSkge1xuICAgIGlmICghc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZVR5cGUpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBzb3J0ID0gbW9kZWwuc29ydChjaGFubmVsKTtcbiAgICAvLyBTb3J0ZWQgYmFzZWQgb24gYW4gYWdncmVnYXRlIGNhbGN1bGF0aW9uIG92ZXIgYSBzcGVjaWZpZWQgc29ydCBmaWVsZCAob25seSBmb3Igb3JkaW5hbCBzY2FsZSlcbiAgICBpZiAoc29ydF8xLmlzU29ydEZpZWxkKHNvcnQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcDogc29ydC5vcCxcbiAgICAgICAgICAgIGZpZWxkOiBzb3J0LmZpZWxkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh1dGlsLmNvbnRhaW5zKFsnYXNjZW5kaW5nJywgJ2Rlc2NlbmRpbmcnLCB1bmRlZmluZWQgLyogZGVmYXVsdCA9YXNjZW5kaW5nKi9dLCBzb3J0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gc29ydCA9PT0gJ25vbmUnXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZG9tYWluU29ydCA9IGRvbWFpblNvcnQ7XG4vKipcbiAqIERldGVybWluZSBpZiBhIHNjYWxlIGNhbiB1c2UgdW5hZ2dyZWdhdGVkIGRvbWFpbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRvbnMgYXBwbGllczpcbiAqIDEuIGBzY2FsZS5kb21haW5gIGlzIGB1bmFnZ3JlZ2F0ZWRgXG4gKiAyLiBBZ2dyZWdhdGlvbiBmdW5jdGlvbiBpcyBub3QgYGNvdW50YCBvciBgc3VtYFxuICogMy4gVGhlIHNjYWxlIGlzIHF1YW50aXRhdGl2ZSBvciB0aW1lIHNjYWxlLlxuICovXG5mdW5jdGlvbiBjYW5Vc2VVbmFnZ3JlZ2F0ZWREb21haW4oZmllbGREZWYsIHNjYWxlVHlwZSkge1xuICAgIGlmICghZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246IGxvZy5tZXNzYWdlLnVuYWdncmVnYXRlRG9tYWluSGFzTm9FZmZlY3RGb3JSYXdGaWVsZChmaWVsZERlZilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFnZ3JlZ2F0ZV8xLlNIQVJFRF9ET01BSU5fT1BTLmluZGV4T2YoZmllbGREZWYuYWdncmVnYXRlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgIHJlYXNvbjogbG9nLm1lc3NhZ2UudW5hZ2dyZWdhdGVEb21haW5XaXRoTm9uU2hhcmVkRG9tYWluT3AoZmllbGREZWYuYWdncmVnYXRlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoZmllbGREZWYudHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScpIHtcbiAgICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbG9nLm1lc3NhZ2UudW5hZ2dyZWdhdGVkRG9tYWluV2l0aExvZ1NjYWxlKGZpZWxkRGVmKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xufVxuZXhwb3J0cy5jYW5Vc2VVbmFnZ3JlZ2F0ZWREb21haW4gPSBjYW5Vc2VVbmFnZ3JlZ2F0ZWREb21haW47XG4vKipcbiAqIENvbnZlcnQgdGhlIGRvbWFpbiB0byBhbiBhcnJheSBvZiBkYXRhIHJlZnMgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLiBBbHNvLCB0aHJvd1xuICogYXdheSBzb3J0aW5nIGluZm9ybWF0aW9uIHNpbmNlIHdlIGFsd2F5cyBzb3J0IHRoZSBkb21haW4gd2hlbiB3ZSB1bmlvbiB0d28gZG9tYWlucy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRG9tYWluKGRvbWFpbikge1xuICAgIGlmICh1dGlsLmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gW2RvbWFpbl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNEYXRhUmVmRG9tYWluKGRvbWFpbikpIHtcbiAgICAgICAgZGVsZXRlIGRvbWFpbi5zb3J0O1xuICAgICAgICByZXR1cm4gW2RvbWFpbl07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNGaWVsZFJlZlVuaW9uRG9tYWluKGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbi5maWVsZHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IGRvbWFpbi5kYXRhLFxuICAgICAgICAgICAgICAgIGZpZWxkOiBkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmVnYV9zY2hlbWFfMS5pc0RhdGFSZWZVbmlvbmVkRG9tYWluKGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbi5maWVsZHMubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZpZWxkOiBkLmZpZWxkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uICovXG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLklOVkFJRF9ET01BSU4pO1xufVxuLyoqXG4gKiBVbmlvbiB0d28gZGF0YSBkb21haW5zLiBBIHVuaW9uZWQgZG9tYWluIGlzIGFsd2F5cyBzb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIHVuaW9uRG9tYWlucyhkb21haW4xLCBkb21haW4yKSB7XG4gICAgaWYgKHZlZ2Ffc2NoZW1hXzEuaXNTaWduYWxSZWZEb21haW4oZG9tYWluMSkgfHwgdmVnYV9zY2hlbWFfMS5pc1NpZ25hbFJlZkRvbWFpbihkb21haW4yKSkge1xuICAgICAgICBpZiAoIXZlZ2Ffc2NoZW1hXzEuaXNTaWduYWxSZWZEb21haW4oZG9tYWluMSkgfHwgIXZlZ2Ffc2NoZW1hXzEuaXNTaWduYWxSZWZEb21haW4oZG9tYWluMikgfHwgZG9tYWluMS5zaWduYWwgIT09IGRvbWFpbjIuc2lnbmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuVU5BQkxFX1RPX01FUkdFX0RPTUFJTlMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb21haW4xO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZERvbWFpbjEgPSBub3JtYWxpemVEb21haW4oZG9tYWluMSk7XG4gICAgdmFyIG5vcm1hbGl6ZWREb21haW4yID0gbm9ybWFsaXplRG9tYWluKGRvbWFpbjIpO1xuICAgIHZhciBkb21haW5zID0gbm9ybWFsaXplZERvbWFpbjEuY29uY2F0KG5vcm1hbGl6ZWREb21haW4yKTtcbiAgICBkb21haW5zID0gdXRpbC51bmlxdWUoZG9tYWlucywgdXRpbC5oYXNoKTtcbiAgICBpZiAoZG9tYWlucy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBhbGxEYXRhID0gZG9tYWlucy5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICh2ZWdhX3NjaGVtYV8xLmlzRGF0YVJlZkRvbWFpbihkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1dGlsLnVuaXF1ZShhbGxEYXRhLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSkubGVuZ3RoID09PSAxICYmIGFsbERhdGFbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogYWxsRGF0YVswXSxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGRvbWFpbnMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkOyB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmaWVsZHM6IGRvbWFpbnMsIHNvcnQ6IHRydWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkb21haW5zWzBdO1xuICAgIH1cbn1cbmV4cG9ydHMudW5pb25Eb21haW5zID0gdW5pb25Eb21haW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkc5dFlXbHVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YzJOaGJHVXZaRzl0WVdsdUxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc0swSkJRV2xETzBGQlJXcERMRFpEUVVGclJEdEJRVU5zUkN4cFEwRkJjME03UVVGRmRFTXNNa05CUVN0RU8wRkJSUzlFTEhGRFFVRnBSenRCUVVOcVJ5eHRRMEZCZFVNN1FVRkRka01zYVVOQlFXMURPMEZCUTI1RExHbEVRVlV5UWp0QlFVVXpRaXh0UTBGQmNVTTdRVUZKY2tNc2IwSkJRVEpDTEUxQlFXTXNSVUZCUlN4UlFVRnJRaXhGUVVGRkxFdEJRV2RDTEVWQlFVVXNWMEZCZDBJN1NVRkRka2NzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4TFFVRkxMR05CUVdNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFSXNTVUZCUVN3NFEwRkJNa1FzUlVGQk1VUXNaMEpCUVVzc1JVRkJSU3hyUWtGQlRTeERRVUU0UXp0UlFVTnNSU3hGUVVGRkxFTkJRVUVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRWaXhIUVVGSExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdVVUZEYmtJc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hMUVVGTExGTkJRVk1zU1VGQlNTeFhRVUZYTEVOQlFVTXNjVUpCUVhGQ0xFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkZMREpEUVVFeVF6dFJRVU53UXl4SlFVRkJMSFZFUVVGTExFTkJRVGhETzFGQlF6RkVMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEVml4TlFVRk5MRU5CUVVNc1kwRkJZeXhEUVVGRE8xRkJRM2hDTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlVRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEJRVU5vUWl4RFFVRkRPMEZCYUVKRUxHZERRV2RDUXp0QlFVZEVMSEZDUVVFMFFpeExRVUZaTEVWQlFVVXNUMEZCWjBJN1NVRkRlRVFzU1VGQlRTeExRVUZMTEVkQlFVY3NTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVVZ1UXl4NVJVRkJlVVU3U1VGRGVrVXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExFZEJRVWNzU1VGQlNTeExRVUZMTEVOQlFVTXNaVUZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU51UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zWlVGQlpTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNdlFpeE5RVUZOTEVOQlFVTXNXVUZCV1N4RFFVRkRMSGRDUVVGM1FpeERRVUZETEV0QlFVc3NSVUZCUlN4TFFVRkxMRVZCUVVVc1IwRkJSeXhEUVVGRExFVkJRVVVzZDBKQlFYZENMRU5CUVVNc1MwRkJTeXhGUVVGRkxFdEJRVXNzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwSUxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEzUkVMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhIUVVGSExFbEJRVWtzUzBGQlN5eERRVUZETEdWQlFXVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE1VUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExHVkJRV1VzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRMMElzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXl4M1FrRkJkMElzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRWRCUVVjc1EwRkJReXhGUVVGRkxIZENRVUYzUWl4RFFVRkRMRXRCUVVzc1JVRkJSU3hMUVVGTExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnFTQ3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4TlFVRk5MRU5CUVVNc2QwSkJRWGRDTEVOQlFVTXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU4wUkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eDNRa0ZCZDBJc1EwRkJReXhMUVVGTExFVkJRVVVzUzBGQlN5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMEZCUTNwRUxFTkJRVU03UVVGc1FrUXNhME5CYTBKRE8wRkJSVVFzYTBOQlFXdERMRXRCUVZrc1JVRkJSU3hMUVVGWkxFVkJRVVVzVDBGQlpUdEpRVU16UlN4SlFVRk5MRkZCUVZFc1IwRkJSeXhMUVVGTExFTkJRVU1zVVVGQlVTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMGxCUlhwRExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExFMUJRVTBzUzBGQlN5eGpRVUZqTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNCRUxFVkJRVVVzUTBGQlF5eERRVUZETEhGQ1FVRlZMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOb1F5eE5RVUZOTEVOQlFVVXNTMEZCU3l4RFFVRkRMRTFCUVhGQ0xFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNSVUZCUlR0blFrRkRla01zVFVGQlRTeERRVUZETEc5Q1FVRlRMRU5CUVVNc1JVRkJSU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzFsQlF6ZENMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMHdzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRM1JDTEVOQlFVTTdTVUZGUkN4SlFVRk5MRXRCUVVzc1IwRkJSeXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETzBsQlF6RkNMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeFBRVUZQTEV0QlFVc3NTMEZCU3l4RFFVRkRMRmxCUVZrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE5VTXNSVUZCUlN4RFFVRkJMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUzBGQlN5eFhRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOb1FpeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRPMWxCUTB3c1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTXNWMEZCU1N4RFFVRkRPMWxCUXpkQ0xFMUJRVTBzUlVGQlJUdG5Ra0ZEVGl4TFFVRkxMRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4UFFVRlBMRVZCUVVNc1EwRkJRenRuUWtGRGRrTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFVkJRVVVzUlVGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RlFVRkRMRU5CUVVNN1lVRkRkRU03VTBGRFJpeERRVUZETzBsQlEwb3NRMEZCUXp0SlFVVkVMRWxCUVUwc1NVRkJTU3hIUVVGSExGVkJRVlVzUTBGQlF5eExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVVZ3UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeExRVUZMTEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRU1zVFVGQlRTeERRVUZETzFsQlEwd3NTVUZCU1N4RlFVRkZMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU1zVjBGQlNTeERRVUZETzFsQlF6ZENMRTFCUVUwc1JVRkJSVHRuUWtGRFRpeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeExRVUZMTEVWQlFVTXNRMEZCUXp0blFrRkRlRU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eEZRVUZETEVOQlFVTTdZVUZEZWtNN1UwRkRSaXhEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjRRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eHJRa0ZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETTBJc1NVRkJUU3hOUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCU1N4cFFrRkJWeXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNVMEZCU1N4UlFVRlJMRU5CUVVNc1MwRkJTeXhWUVVGUExFTkJRVU1zUTBGQlF6dFpRVU53Uml4TlFVRk5MRU5CUVVNc1JVRkJReXhOUVVGTkxFVkJRVVVzWTBGQldTeE5RVUZOTEdkQ1FVRlhMRTFCUVUwc1owSkJRVmNzVFVGQlRTeGxRVUZWTEUxQlFVMHNWMEZCVVN4RlFVRkRMRU5CUVVNN1VVRkRhRWNzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMSGxDUVVGcFFpeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGJFTXNjMFZCUVhORk8xbEJRM1JGTERSSFFVRTBSenRaUVVNMVJ5eE5RVUZOTEVOQlFVTTdaMEpCUTB3c1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTXNWMEZCU1N4RFFVRkRPMmRDUVVNM1FpeExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFVkJRVVVzUlVGQlF5eFRRVUZUTEVWQlFVVXNUMEZCVHl4RlFVRkRMRU5CUVVNN1owSkJRMnBFTEVsQlFVa3NSVUZCUlR0dlFrRkRTaXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzVDBGQlR5eEZRVUZETEVOQlFVTTdiMEpCUTJwRUxFVkJRVVVzUlVGQlJTeExRVUZMTEVOQlFVTXNlVVZCUVhsRk8ybENRVU53Ump0aFFVTkdMRU5CUVVNN1VVRkRTaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzUjBGQlJ5eEpRVUZKTEU5QlFVOHNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU4yUXl4dFJVRkJiVVU3WjBKQlEyNUZMRTFCUVUwc1EwRkJRenR2UWtGRFRDeEpRVUZKTEVWQlFVVXNTMEZCU3l4RFFVRkRMRmRCUVZjc1EwRkJReXhYUVVGSkxFTkJRVU03YjBKQlF6ZENMRTFCUVUwc1JVRkJSVHQzUWtGRFRpeExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1JVRkJSU3hGUVVGRExGTkJRVk1zUlVGQlJTeFBRVUZQTEVWQlFVTXNRMEZCUXp0M1FrRkRNVU1zUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJReXhUUVVGVExFVkJRVVVzUzBGQlN5eEZRVUZETEVOQlFVTTdjVUpCUTNwRE8ybENRVU5HTEVOQlFVTTdXVUZEU2l4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03WjBKQlEwNHNiMEpCUVc5Q08yZENRVU53UWl4TlFVRk5MRU5CUVVNN2IwSkJRMHdzU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4WFFVRlhMRU5CUVVNc1YwRkJTU3hEUVVGRE8yOUNRVU0zUWl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNSVUZCUXl4VFFVRlRMRVZCUVVVc1QwRkJUeXhGUVVGRExFTkJRVU03YVVKQlEyeEVMRU5CUVVNN1dVRkRTaXhEUVVGRE8xRkJRMGdzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVm9RaXhOUVVGTkxFTkJRVU03V1VGRFRDdzRSVUZCT0VVN1dVRkRPVVVzYjBaQlFXOUdPMWxCUTNCR0xFbEJRVWtzUlVGQlJTeEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTXNWMEZCU1N4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExGZEJRVmNzUTBGQlF5eFZRVUZITEVOQlFVTTdXVUZETjBVc1MwRkJTeXhGUVVGRkxFdEJRVXNzUTBGQlF5eExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXpOQ0xFbEJRVWtzUlVGQlJTeEpRVUZKTzFOQlExZ3NRMEZCUXp0SlFVTktMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEUxQlFVMHNRMEZCUXp0WlFVTk1MRWxCUVVrc1JVRkJSU3hMUVVGTExFTkJRVU1zVjBGQlZ5eERRVUZETEZkQlFVa3NRMEZCUXp0WlFVTTNRaXhMUVVGTExFVkJRVVVzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNN1UwRkROVUlzUTBGQlF6dEpRVU5LTEVOQlFVTTdRVUZEU0N4RFFVRkRPMEZCUjBRc2IwSkJRVEpDTEV0QlFWa3NSVUZCUlN4UFFVRm5RaXhGUVVGRkxGTkJRVzlDTzBsQlF6ZEZMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zZVVKQlFXbENMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeERMRTFCUVUwc1EwRkJReXhUUVVGVExFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVVkVMRWxCUVUwc1NVRkJTU3hIUVVGSExFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkZha01zWjBkQlFXZEhPMGxCUTJoSExFVkJRVVVzUTBGQlF5eERRVUZETEd0Q1FVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRTFCUVUwc1EwRkJRenRaUVVOTUxFVkJRVVVzUlVGQlJTeEpRVUZKTEVOQlFVTXNSVUZCUlR0WlFVTllMRXRCUVVzc1JVRkJSU3hKUVVGSkxFTkJRVU1zUzBGQlN6dFRRVU5zUWl4RFFVRkRPMGxCUTBvc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhYUVVGWExFVkJRVVVzV1VGQldTeEZRVUZGTEZOQlFWTXNRMEZCUXl4MVFrRkJkVUlzUTBGQlF5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFJpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWRUxHdENRVUZyUWp0SlFVTnNRaXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzBGQlEyNUNMRU5CUVVNN1FVRnlRa1FzWjBOQmNVSkRPMEZCU1VRN096czdPenRIUVUxSE8wRkJRMGdzYTBOQlFYbERMRkZCUVd0Q0xFVkJRVVVzVTBGQmIwSTdTVUZETDBVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFFpeE5RVUZOTEVOQlFVTTdXVUZEVEN4TFFVRkxMRVZCUVVVc1MwRkJTenRaUVVOYUxFMUJRVTBzUlVGQlJTeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMSFZEUVVGMVF5eERRVUZETEZGQlFWRXNRMEZCUXp0VFFVTjBSU3hEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRFpDUVVGcFFpeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwRUxFMUJRVTBzUTBGQlF6dFpRVU5NTEV0QlFVc3NSVUZCUlN4TFFVRkxPMWxCUTFvc1RVRkJUU3hGUVVGRkxFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNjME5CUVhORExFTkJRVU1zVVVGQlVTeERRVUZETEZOQlFWTXNRMEZCUXp0VFFVTXZSU3hEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzWTBGQll5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFRRVUZUTEV0QlFVc3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFFpeE5RVUZOTEVOQlFVTTdaMEpCUTB3c1MwRkJTeXhGUVVGRkxFdEJRVXM3WjBKQlExb3NUVUZCVFN4RlFVRkZMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zT0VKQlFUaENMRU5CUVVNc1VVRkJVU3hEUVVGRE8yRkJRemRFTEVOQlFVTTdVVUZEU2l4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4SlFVRkpMRVZCUVVNc1EwRkJRenRCUVVOMlFpeERRVUZETzBGQmVrSkVMRFJFUVhsQ1F6dEJRVk5FT3pzN1IwRkhSenRCUVVOSUxIbENRVUY1UWl4TlFVRjFRanRKUVVNNVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjZRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRFpDUVVGbExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTI1RExFOUJRVThzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0UlFVTnVRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUVN4RFFVRkRMRzFEUVVGeFFpeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONFF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlFTeERRVUZETzFsQlEzaENMRTFCUVUwc1EwRkJRenRuUWtGRFRDeEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRWxCUVVrN1owSkJRMnBDTEV0QlFVc3NSVUZCUlN4RFFVRkRPMkZCUTFRc1EwRkJRenRSUVVOS0xFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHZRMEZCYzBJc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETVVNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVFc1EwRkJRenRaUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRjRUlzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTllMRU5CUVVNN1dVRkRSQ3hOUVVGTkxFTkJRVU03WjBKQlEwd3NTMEZCU3l4RlFVRkZMRU5CUVVNc1EwRkJReXhMUVVGTE8yZENRVU5rTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTVHRoUVVOaUxFTkJRVU03VVVGRFNpeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkRSQ3h4UkVGQmNVUTdTVUZEY2tRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR0ZCUVdFc1EwRkJReXhEUVVGRE8wRkJRemRETEVOQlFVTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxITkNRVUUyUWl4UFFVRnBRaXhGUVVGRkxFOUJRV2xDTzBsQlF5OUVMRVZCUVVVc1EwRkJReXhEUVVGRExDdENRVUZwUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxDdENRVUZwUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0zUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExDdENRVUZwUWl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zSzBKQlFXbENMRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzVDBGQlR5eERRVUZETEUxQlFVMHNTMEZCU3l4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU53Unl4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNkVUpCUVhWQ0xFTkJRVU1zUTBGQlF6dFJRVU4yUkN4RFFVRkRPMUZCUTBRc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dEpRVU5xUWl4RFFVRkRPMGxCUlVRc1NVRkJUU3hwUWtGQmFVSXNSMEZCUnl4bFFVRmxMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU03U1VGRGJrUXNTVUZCVFN4cFFrRkJhVUlzUjBGQlJ5eGxRVUZsTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkZia1FzU1VGQlNTeFBRVUZQTEVkQlFVY3NhVUpCUVdsQ0xFTkJRVU1zVFVGQlRTeERRVUZETEdsQ1FVRnBRaXhEUVVGRExFTkJRVU03U1VGRE1VUXNUMEZCVHl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVVeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZGtJc1NVRkJUU3hQUVVGUExFZEJRVWNzVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkJMRU5CUVVNN1dVRkRNMElzUlVGQlJTeERRVUZETEVOQlFVTXNOa0pCUVdVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNaQ0xFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRPMWxCUTJoQ0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJRc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRlNDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZCTEVOQlFVTXNTVUZCU1N4UFFVRkJMRU5CUVVNc1JVRkJSQ3hEUVVGRExFTkJRVU1zUTBGQlF5eE5RVUZOTEV0QlFVc3NRMEZCUXl4SlFVRkpMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNKRkxFMUJRVTBzUTBGQlF6dG5Ra0ZEVEN4SlFVRkpMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYUVJc1RVRkJUU3hGUVVGRkxFOUJRVThzUTBGQlF5eEhRVUZITEVOQlFVTXNWVUZCUVN4RFFVRkRMRWxCUVVrc1QwRkJReXhEUVVGbExFTkJRVU1zUzBGQlN5eEZRVUYwUWl4RFFVRnpRaXhEUVVGRE8yRkJRMnBFTEVOQlFVTTdVVUZEU2l4RFFVRkRPMUZCUlVRc1RVRkJUU3hEUVVGRExFVkJRVU1zVFVGQlRTeEZRVUZGTEU5QlFVOHNSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRExFTkJRVU03U1VGRGRrTXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOd1FpeERRVUZETzBGQlEwZ3NRMEZCUXp0QlFXcERSQ3h2UTBGcFEwTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBkb21haW5fMSA9IHJlcXVpcmUoXCIuL2RvbWFpblwiKTtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG52YXIgcnVsZXMgPSByZXF1aXJlKFwiLi9ydWxlc1wiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuLyoqXG4gKiBBbGwgc2NhbGUgcHJvcGVydGllcyBleGNlcHQgdHlwZSBhbmQgYWxsIHJhbmdlIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydHMuTk9OX1RZUEVfUkFOR0VfU0NBTEVfUFJPUEVSVElFUyA9IFtcbiAgICAvLyBnZW5lcmFsIHByb3BlcnRpZXNcbiAgICAnZG9tYWluJyxcbiAgICAncm91bmQnLFxuICAgIC8vIHF1YW50aXRhdGl2ZSAvIHRpbWVcbiAgICAnY2xhbXAnLCAnbmljZScsXG4gICAgLy8gcXVhbnRpdGF0aXZlXG4gICAgJ2V4cG9uZW50JywgJ3plcm8nLFxuICAgICdpbnRlcnBvbGF0ZScsXG4gICAgLy8gb3JkaW5hbFxuICAgICdwYWRkaW5nJywgJ3BhZGRpbmdJbm5lcicsICdwYWRkaW5nT3V0ZXInIC8vIHBhZGRpbmdcbl07XG4vKipcbiAqIEluaXRpYWxpemUgVmVnYS1MaXRlIFNjYWxlJ3MgcHJvcGVydGllc1xuICpcbiAqIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIGFwcGx5IHRoZXNlIHJ1bGVzIGhlcmUgYmVjYXVzZTpcbiAqIC0gbWFueSBvdGhlciBzY2FsZSBhbmQgbm9uLXNjYWxlIHByb3BlcnRpZXMgKGluY2x1ZGluZyBsYXlvdXQsIG1hcmspIGRlcGVuZCBvbiBzY2FsZSB0eXBlXG4gKiAtIGxheW91dCBkZXBlbmRzIG9uIHBhZGRpbmdcbiAqIC0gcmFuZ2UgZGVwZW5kcyBvbiB6ZXJvIGFuZCBzaXplICh3aWR0aCBhbmQgaGVpZ2h0KSBkZXBlbmRzIG9uIHJhbmdlXG4gKi9cbmZ1bmN0aW9uIGluaXQoY2hhbm5lbCwgZmllbGREZWYsIGNvbmZpZywgbWFyaywgdG9wTGV2ZWxTaXplLCB4eVJhbmdlU3RlcHMpIHtcbiAgICB2YXIgc3BlY2lmaWVkU2NhbGUgPSAoZmllbGREZWYgfHwge30pLnNjYWxlIHx8IHt9O1xuICAgIHZhciBzY2FsZSA9IHtcbiAgICAgICAgdHlwZTogdHlwZV8xLmRlZmF1bHQoc3BlY2lmaWVkU2NhbGUudHlwZSwgY2hhbm5lbCwgZmllbGREZWYsIG1hcmssIHRvcExldmVsU2l6ZSAhPT0gdW5kZWZpbmVkLCBzcGVjaWZpZWRTY2FsZS5yYW5nZVN0ZXAsIGNvbmZpZy5zY2FsZSlcbiAgICB9O1xuICAgIC8vIFVzZSBzcGVjaWZpZWQgdmFsdWUgaWYgY29tcGF0aWJsZSBvciBkZXRlcm1pbmUgZGVmYXVsdCB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICBleHBvcnRzLk5PTl9UWVBFX1JBTkdFX1NDQUxFX1BST1BFUlRJRVMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHNwZWNpZmllZFZhbHVlID0gc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldO1xuICAgICAgICB2YXIgc3VwcG9ydGVkQnlTY2FsZVR5cGUgPSBzY2FsZV8xLnNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZS50eXBlLCBwcm9wZXJ0eSk7XG4gICAgICAgIHZhciBjaGFubmVsSW5jb21wYXRhYmlsaXR5ID0gc2NhbGVfMS5jaGFubmVsU2NhbGVQcm9wZXJ0eUluY29tcGF0YWJpbGl0eShjaGFubmVsLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChzcGVjaWZpZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHNwZWNpZmllZCB2YWx1ZSwgY2hlY2sgaWYgaXQgaXMgY29tcGF0aWJsZSB3aXRoIHNjYWxlIHR5cGUgYW5kIGNoYW5uZWxcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGVkQnlTY2FsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5zY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGUoc2NhbGUudHlwZSwgcHJvcGVydHksIGNoYW5uZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihjaGFubmVsSW5jb21wYXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcG9ydGVkQnlTY2FsZVR5cGUgJiYgY2hhbm5lbEluY29tcGF0YWJpbGl0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShzcGVjaWZpZWRWYWx1ZSwgcHJvcGVydHksIHNjYWxlLCBjaGFubmVsLCBmaWVsZERlZiwgY29uZmlnLnNjYWxlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdXRpbC5leHRlbmQoc2NhbGUsIHJhbmdlXzEuZGVmYXVsdChjaGFubmVsLCBzY2FsZS50eXBlLCBmaWVsZERlZi50eXBlLCBzcGVjaWZpZWRTY2FsZSwgY29uZmlnLCBzY2FsZS56ZXJvLCBtYXJrLCB0b3BMZXZlbFNpemUsIHh5UmFuZ2VTdGVwcykpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gaW5pdDtcbmZ1bmN0aW9uIGdldFZhbHVlKHNwZWNpZmllZFZhbHVlLCBwcm9wZXJ0eSwgc2NhbGUsIGNoYW5uZWwsIGZpZWxkRGVmLCBzY2FsZUNvbmZpZykge1xuICAgIC8vIEZvciBkb21haW4sIHdlIG1pZ2h0IG92ZXJyaWRlIHNwZWNpZmllZCB2YWx1ZVxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2RvbWFpbicpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbl8xLmluaXREb21haW4oc3BlY2lmaWVkVmFsdWUsIGZpZWxkRGVmLCBzY2FsZS50eXBlLCBzY2FsZUNvbmZpZyk7XG4gICAgfVxuICAgIC8vIE90aGVyIHByb3BlcnRpZXMsIG5vIG92ZXJyaWRpbmcgZGVmYXVsdCB2YWx1ZXNcbiAgICBpZiAoc3BlY2lmaWVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVkVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBnZXREZWZhdWx0VmFsdWUocHJvcGVydHksIHNjYWxlLCBjaGFubmVsLCBmaWVsZERlZiwgc2NhbGVDb25maWcpO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZhbHVlKHByb3BlcnR5LCBzY2FsZSwgY2hhbm5lbCwgZmllbGREZWYsIHNjYWxlQ29uZmlnKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBkZWZhdWx0IHJ1bGUtYmFzZSwgZGV0ZXJtaW5lIGRlZmF1bHQgdmFsdWUgZmlyc3RcbiAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgIGNhc2UgJ25pY2UnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLm5pY2Uoc2NhbGUudHlwZSwgY2hhbm5lbCwgZmllbGREZWYpO1xuICAgICAgICBjYXNlICdwYWRkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5wYWRkaW5nKGNoYW5uZWwsIHNjYWxlLnR5cGUsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgY2FzZSAncGFkZGluZ0lubmVyJzpcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5wYWRkaW5nSW5uZXIoc2NhbGUucGFkZGluZywgY2hhbm5lbCwgc2NhbGVDb25maWcpO1xuICAgICAgICBjYXNlICdwYWRkaW5nT3V0ZXInOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnBhZGRpbmdPdXRlcihzY2FsZS5wYWRkaW5nLCBjaGFubmVsLCBzY2FsZS50eXBlLCBzY2FsZS5wYWRkaW5nSW5uZXIsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLnJvdW5kKGNoYW5uZWwsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICByZXR1cm4gcnVsZXMuemVybyhzY2FsZSwgY2hhbm5lbCwgZmllbGREZWYpO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBzY2FsZSBjb25maWdcbiAgICByZXR1cm4gc2NhbGVDb25maWdbcHJvcGVydHldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1cGRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMM05qWVd4bEwybHVhWFF1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3dyUWtGQmFVTTdRVUZOYWtNc2NVTkJRVGhITzBGQlF6bEhMR2xEUVVGdFF6dEJRVVZ1UXl4dFEwRkJiME03UVVGRGNFTXNhVU5CUVd0RE8wRkJRMnhETEN0Q1FVRnBRenRCUVVOcVF5d3JRa0ZCSzBJN1FVRkZMMEk3TzBkQlJVYzdRVUZEVlN4UlFVRkJMQ3RDUVVFclFpeEhRVUZ2UWp0SlFVTTVSQ3h4UWtGQmNVSTdTVUZEY2tJc1VVRkJVVHRKUVVOU0xFOUJRVTg3U1VGRFVDeHpRa0ZCYzBJN1NVRkRkRUlzVDBGQlR5eEZRVUZGTEUxQlFVMDdTVUZEWml4bFFVRmxPMGxCUTJZc1ZVRkJWU3hGUVVGRkxFMUJRVTA3U1VGRGJFSXNZVUZCWVR0SlFVTmlMRlZCUVZVN1NVRkRWaXhUUVVGVExFVkJRVVVzWTBGQll5eEZRVUZGTEdOQlFXTXNRMEZCUXl4VlFVRlZPME5CUTNKRUxFTkJRVU03UVVGRlJqczdPenM3T3p0SFFVOUhPMEZCUTBnc1kwRkRTU3hQUVVGblFpeEZRVUZGTEZGQlFYVkNMRVZCUVVVc1RVRkJZeXhGUVVONlJDeEpRVUZ6UWl4RlFVRkZMRmxCUVdkRExFVkJRVVVzV1VGQmMwSTdTVUZEYkVZc1NVRkJUU3hqUVVGakxFZEJRVWNzUTBGQlF5eFJRVUZSTEVsQlFVa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1MwRkJTeXhKUVVGSkxFVkJRVVVzUTBGQlF6dEpRVVZ3UkN4SlFVRk5MRXRCUVVzc1IwRkJWVHRSUVVOdVFpeEpRVUZKTEVWQlFVVXNZMEZCVXl4RFFVTmlMR05CUVdNc1EwRkJReXhKUVVGSkxFVkJRVVVzVDBGQlR5eEZRVUZGTEZGQlFWRXNSVUZCUlN4SlFVRkpMRVZCUVVVc1dVRkJXU3hMUVVGTExGTkJRVk1zUlVGRGVFVXNZMEZCWXl4RFFVRkRMRk5CUVZNc1JVRkJSU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVU4yUXp0TFFVTkdMRU5CUVVNN1NVRkZSaXhyUmtGQmEwWTdTVUZEYkVZc2RVTkJRU3RDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1VVRkJVVHRSUVVOMlJDeEpRVUZOTEdOQlFXTXNSMEZCUnl4alFVRmpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRmFFUXNTVUZCVFN4dlFrRkJiMElzUjBGQlJ5eG5RMEZCZDBJc1EwRkJReXhMUVVGTExFTkJRVU1zU1VGQlNTeEZRVUZGTEZGQlFWRXNRMEZCUXl4RFFVRkRPMUZCUXpWRkxFbEJRVTBzYzBKQlFYTkNMRWRCUVVjc01rTkJRVzFETEVOQlFVTXNUMEZCVHl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJSWFJHTEVWQlFVVXNRMEZCUXl4RFFVRkRMR05CUVdNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycERMSFZHUVVGMVJqdFpRVU4yUml4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHOUNRVUZ2UWl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE1VSXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdsRFFVRnBReXhEUVVGRExFdEJRVXNzUTBGQlF5eEpRVUZKTEVWQlFVVXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGVrWXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHpRa0ZCYzBJc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEyeERMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zYzBKQlFYTkNMRU5CUVVNc1EwRkJRenRaUVVOdVF5eERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExHOUNRVUZ2UWl4SlFVRkpMSE5DUVVGelFpeExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha1VzU1VGQlRTeExRVUZMTEVkQlFVY3NVVUZCVVN4RFFVRkRMR05CUVdNc1JVRkJSU3hSUVVGUkxFVkJRVVVzUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UlFVRlJMRVZCUVVVc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzFsQlEzcEdMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVONFFpeExRVUZMTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRE8xbEJRekZDTEVOQlFVTTdVVUZEU0N4RFFVRkRPMGxCUTBnc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRlNDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkRhRUlzUzBGQlN5eEZRVU5NTEdWQlFWY3NRMEZEVkN4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFJRVUZSTEVOQlFVTXNTVUZCU1N4RlFVRkZMR05CUVdNc1JVRkJSU3hOUVVGTkxFVkJRekZFTEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1NVRkJTU3hGUVVGRkxGbEJRVmtzUlVGQlJTeFpRVUZaTEVOQlF6ZERMRU5CUTBZc1EwRkJRenRCUVVOS0xFTkJRVU03UVVFeFEwUXNkVUpCTUVORE8wRkJSVVFzYTBKQlFXdENMR05CUVcxQ0xFVkJRVVVzVVVGQmNVSXNSVUZCUlN4TFFVRlpMRVZCUVVVc1QwRkJaMElzUlVGQlJTeFJRVUZyUWl4RlFVRkZMRmRCUVhkQ08wbEJRM2hKTEdkRVFVRm5SRHRKUVVOb1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UWl4TlFVRk5MRU5CUVVNc2JVSkJRVlVzUTBGQlF5eGpRVUZqTEVWQlFVVXNVVUZCVVN4RlFVRkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdTVUZEZGtVc1EwRkJRenRKUVVWRUxHbEVRVUZwUkR0SlFVTnFSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZqTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVF5eE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRPMGxCUTNoQ0xFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNaVUZCWlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEZGQlFWRXNSVUZCUlN4WFFVRlhMRU5CUVVNc1EwRkJRenRCUVVNeFJTeERRVUZETzBGQlJVUXNlVUpCUVhsQ0xGRkJRWEZDTEVWQlFVVXNTMEZCV1N4RlFVRkZMRTlCUVdkQ0xFVkJRVVVzVVVGQmEwSXNSVUZCUlN4WFFVRjNRanRKUVVVeFNDdzRSRUZCT0VRN1NVRkRPVVFzVFVGQlRTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVFpeExRVUZMTEUxQlFVMDdXVUZEVkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dFJRVU51UkN4TFFVRkxMRk5CUVZNN1dVRkRXaXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRVZCUVVVc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0UlFVTjZSQ3hMUVVGTExHTkJRV003V1VGRGFrSXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhaUVVGWkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4UFFVRlBMRVZCUVVVc1YwRkJWeXhEUVVGRExFTkJRVU03VVVGRGFrVXNTMEZCU3l4alFVRmpPMWxCUTJwQ0xFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNXVUZCV1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFVkJRVVVzVDBGQlR5eEZRVUZGTEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExGbEJRVmtzUlVGQlJTeFhRVUZYTEVOQlFVTXNRMEZCUXp0UlFVTnFSeXhMUVVGTExFOUJRVTg3V1VGRFZpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTTdVVUZETTBNc1MwRkJTeXhOUVVGTk8xbEJRMVFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wbEJRMFFzT0VKQlFUaENPMGxCUXpsQ0xFMUJRVTBzUTBGQlF5eFhRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRMMElzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzb3J0XzEgPSByZXF1aXJlKFwiLi4vLi4vc29ydFwiKTtcbnZhciBkb21haW5fMSA9IHJlcXVpcmUoXCIuL2RvbWFpblwiKTtcbnZhciByYW5nZV8xID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG4vKipcbiAqIFBhcnNlIHNjYWxlcyBmb3IgYWxsIGNoYW5uZWxzIG9mIGEgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2NhbGVDb21wb25lbnQobW9kZWwpIHtcbiAgICAvLyBUT0RPOiBzaG91bGQgbW9kZWwuY2hhbm5lbHMoKSBpbmxjdWRlIFgyL1kyP1xuICAgIHJldHVybiBtb2RlbC5jaGFubmVscygpLnJlZHVjZShmdW5jdGlvbiAoc2NhbGVDb21wb25lbnRzSW5kZXgsIGNoYW5uZWwpIHtcbiAgICAgICAgdmFyIHNjYWxlQ29tcG9uZW50cyA9IHBhcnNlU2NhbGUobW9kZWwsIGNoYW5uZWwpO1xuICAgICAgICBpZiAoc2NhbGVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBzY2FsZUNvbXBvbmVudHNJbmRleFtjaGFubmVsXSA9IHNjYWxlQ29tcG9uZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NhbGVDb21wb25lbnRzSW5kZXg7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VTY2FsZUNvbXBvbmVudDtcbmV4cG9ydHMuTk9OX1RZUEVfRE9NQUlOX1JBTkdFX1ZFR0FfU0NBTEVfUFJPUEVSVElFUyA9IFtcbiAgICAncm91bmQnLFxuICAgIC8vIHF1YW50aXRhdGl2ZSAvIHRpbWVcbiAgICAnY2xhbXAnLCAnbmljZScsXG4gICAgLy8gcXVhbnRpdGF0aXZlXG4gICAgJ2V4cG9uZW50JywgJ2ludGVycG9sYXRlJywgJ3plcm8nLFxuICAgIC8vIG9yZGluYWxcbiAgICAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJyxcbl07XG4vKipcbiAqIFBhcnNlIHNjYWxlcyBmb3IgYSBzaW5nbGUgY2hhbm5lbCBvZiBhIG1vZGVsLlxuICovXG5mdW5jdGlvbiBwYXJzZVNjYWxlKG1vZGVsLCBjaGFubmVsKSB7XG4gICAgaWYgKCFtb2RlbC5zY2FsZShjaGFubmVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHNjYWxlID0gbW9kZWwuc2NhbGUoY2hhbm5lbCk7XG4gICAgdmFyIHNvcnQgPSBtb2RlbC5zb3J0KGNoYW5uZWwpO1xuICAgIHZhciBzY2FsZUNvbXBvbmVudCA9IHtcbiAgICAgICAgbmFtZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwgKyAnJywgdHJ1ZSksXG4gICAgICAgIHR5cGU6IHNjYWxlLnR5cGUsXG4gICAgICAgIGRvbWFpbjogZG9tYWluXzEucGFyc2VEb21haW4obW9kZWwsIGNoYW5uZWwpLFxuICAgICAgICByYW5nZTogcmFuZ2VfMS5wYXJzZVJhbmdlKHNjYWxlKVxuICAgIH07XG4gICAgZXhwb3J0cy5OT05fVFlQRV9ET01BSU5fUkFOR0VfVkVHQV9TQ0FMRV9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHNjYWxlQ29tcG9uZW50W3Byb3BlcnR5XSA9IHNjYWxlW3Byb3BlcnR5XTtcbiAgICB9KTtcbiAgICBpZiAoc29ydCAmJiAoc29ydF8xLmlzU29ydEZpZWxkKHNvcnQpID8gc29ydC5vcmRlciA6IHNvcnQpID09PSAnZGVzY2VuZGluZycpIHtcbiAgICAgICAgc2NhbGVDb21wb25lbnQucmV2ZXJzZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZUNvbXBvbmVudDtcbn1cbmV4cG9ydHMucGFyc2VTY2FsZSA9IHBhcnNlU2NhbGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljR0Z5YzJVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXpZMkZzWlM5d1lYSnpaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVVkJMRzFEUVVGMVF6dEJRVTEyUXl4dFEwRkJjVU03UVVGRGNrTXNhVU5CUVcxRE8wRkJSVzVET3p0SFFVVkhPMEZCUTBnc05rSkJRVFJETEV0QlFWazdTVUZEZEVRc0swTkJRU3RETzBsQlF5OURMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZNc2IwSkJRVzFETEVWQlFVVXNUMEZCWjBJN1VVRkRNMFlzU1VGQlRTeGxRVUZsTEVkQlFVY3NWVUZCVlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU51UkN4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkNMRzlDUVVGdlFpeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMR1ZCUVdVc1EwRkJRenRSUVVOc1JDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMRzlDUVVGdlFpeERRVUZETzBsQlF6bENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZVUkN4elEwRlRRenRCUVVWWkxGRkJRVUVzTWtOQlFUSkRMRWRCUVc5Q08wbEJRekZGTEU5QlFVODdTVUZEVUN4elFrRkJjMEk3U1VGRGRFSXNUMEZCVHl4RlFVRkZMRTFCUVUwN1NVRkRaaXhsUVVGbE8wbEJRMllzVlVGQlZTeEZRVUZGTEdGQlFXRXNSVUZCUlN4TlFVRk5PMGxCUTJwRExGVkJRVlU3U1VGRFZpeFRRVUZUTEVWQlFVVXNZMEZCWXl4RlFVRkZMR05CUVdNN1EwRkRNVU1zUTBGQlF6dEJRVVZHT3p0SFFVVkhPMEZCUTBnc2IwSkJRVEpDTEV0QlFWa3NSVUZCUlN4UFFVRm5RanRKUVVOMlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpGQ0xFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZEWkN4RFFVRkRPMGxCUlVRc1NVRkJUU3hMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETEV0QlFVc3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRKUVVOdVF5eEpRVUZOTEVsQlFVa3NSMEZCUnl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETzBsQlJXcERMRWxCUVUwc1kwRkJZeXhIUVVGWk8xRkJRemxDTEVsQlFVa3NSVUZCUlN4TFFVRkxMRU5CUVVNc1UwRkJVeXhEUVVGRExFOUJRVThzUjBGQlJ5eEZRVUZGTEVWQlFVVXNTVUZCU1N4RFFVRkRPMUZCUTNwRExFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNTVUZCU1R0UlFVTm9RaXhOUVVGTkxFVkJRVVVzYjBKQlFWY3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhEUVVGRE8xRkJRMjVETEV0QlFVc3NSVUZCUlN4clFrRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF6dExRVU42UWl4RFFVRkRPMGxCUlVZc2JVUkJRVEpETEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVNc1VVRkJVVHRSUVVNelJDeGpRVUZqTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1MwRkJTeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETzBsQlF6ZERMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJSVWdzUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4SlFVRkpMRU5CUVVNc2EwSkJRVmNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eExRVUZMTEZsQlFWa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRja1VzWTBGQll5eERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRU5CUVVNN1NVRkRhRU1zUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNN1FVRkRlRUlzUTBGQlF6dEJRWFpDUkN4blEwRjFRa01pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uLy4uL2NoYW5uZWxcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5mdW5jdGlvbiBwYXJzZVJhbmdlKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlLnJhbmdlU3RlcCkge1xuICAgICAgICByZXR1cm4geyBzdGVwOiBzY2FsZS5yYW5nZVN0ZXAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NhbGUuc2NoZW1lKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBzY2FsZS5zY2hlbWU7XG4gICAgICAgIGlmIChzY2FsZV8xLmlzRXh0ZW5kZWRTY2hlbWUoc2NoZW1lKSkge1xuICAgICAgICAgICAgdmFyIHIgPSB7IHNjaGVtZTogc2NoZW1lLm5hbWUgfTtcbiAgICAgICAgICAgIGlmIChzY2hlbWUuY291bnQpIHtcbiAgICAgICAgICAgICAgICByLmNvdW50ID0gc2NoZW1lLmNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtZS5leHRlbnQpIHtcbiAgICAgICAgICAgICAgICByLmV4dGVudCA9IHNjaGVtZS5leHRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtZTogc2NoZW1lIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlLnJhbmdlO1xufVxuZXhwb3J0cy5wYXJzZVJhbmdlID0gcGFyc2VSYW5nZTtcbmV4cG9ydHMuUkFOR0VfUFJPUEVSVElFUyA9IFsncmFuZ2UnLCAncmFuZ2VTdGVwJywgJ3NjaGVtZSddO1xuLyoqXG4gKiBSZXR1cm4gbWl4aW5zIHRoYXQgaW5jbHVkZXMgb25lIG9mIHRoZSByYW5nZSBwcm9wZXJ0aWVzIChyYW5nZSwgcmFuZ2VTdGVwLCBzY2hlbWUpLlxuICovXG5mdW5jdGlvbiByYW5nZU1peGlucyhjaGFubmVsLCBzY2FsZVR5cGUsIHR5cGUsIHNwZWNpZmllZFNjYWxlLCBjb25maWcsIHplcm8sIG1hcmssIHRvcExldmVsU2l6ZSwgeHlSYW5nZVN0ZXBzKSB7XG4gICAgdmFyIHNwZWNpZmllZFJhbmdlU3RlcElzTnVsbCA9IGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcmFuZ2UgcHJvcGVydGllcyBpcyBzcGVjaWZpZWQuXG4gICAgLy8gSWYgc28sIGNoZWNrIGlmIGl0IGlzIGNvbXBhdGlibGUgYW5kIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgb3V0cHV0IG9uZSBvZiB0aGUgcHJvcGVydGllc1xuICAgIGZvciAodmFyIF9pID0gMCwgUkFOR0VfUFJPUEVSVElFU18xID0gZXhwb3J0cy5SQU5HRV9QUk9QRVJUSUVTOyBfaSA8IFJBTkdFX1BST1BFUlRJRVNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gUkFOR0VfUFJPUEVSVElFU18xW19pXTtcbiAgICAgICAgaWYgKHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3VwcG9ydGVkQnlTY2FsZVR5cGUgPSBzY2FsZV8xLnNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZVR5cGUsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIHZhciBjaGFubmVsSW5jb21wYXRhYmlsaXR5ID0gc2NhbGVfMS5jaGFubmVsU2NhbGVQcm9wZXJ0eUluY29tcGF0YWJpbGl0eShjaGFubmVsLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZEJ5U2NhbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2Uuc2NhbGVQcm9wZXJ0eU5vdFdvcmtXaXRoU2NhbGVUeXBlKHNjYWxlVHlwZSwgcHJvcGVydHksIGNoYW5uZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkpIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihjaGFubmVsSW5jb21wYXRhYmlsaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XSB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzY2hlbWUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1lOiBzcGVjaWZpZWRTY2FsZVtwcm9wZXJ0eV0gfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZ2VTdGVwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b3BMZXZlbFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGVwU2l6ZSA9IHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2VTdGVwOiBzdGVwU2l6ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkUmFuZ2VTdGVwSXNOdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0b3AtbGV2ZWwgc2l6ZSBpcyBzcGVjaWZpZWQsIHdlIGlnbm9yZSBzcGVjaWZpZWQgcmFuZ2VTdGVwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnJhbmdlU3RlcERyb3BwZWQoY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKGNoYW5uZWwpIHtcbiAgICAgICAgLy8gVE9ETzogcmV2aXNlIHJvdy9jb2x1bW4gd2hlbiBmYWNldFNwZWMgaGFzIHRvcC1sZXZlbCB3aWR0aC9oZWlnaHRcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuUk9XOlxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6ICdoZWlnaHQnIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLkNPTFVNTjpcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiAnd2lkdGgnIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlg6XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlk6XG4gICAgICAgICAgICBpZiAodG9wTGV2ZWxTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5jb250YWlucyhbJ3BvaW50JywgJ2JhbmQnXSwgc2NhbGVUeXBlKSAmJiAhc3BlY2lmaWVkUmFuZ2VTdGVwSXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVsID09PSBjaGFubmVsXzEuWCAmJiBtYXJrID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2NhbGUudGV4dFhSYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZVN0ZXA6IGNvbmZpZy5zY2FsZS50ZXh0WFJhbmdlU3RlcCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZVN0ZXA6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBzcGVjaWZpZWQgcmFuZ2Ugc3RlcCBpcyBudWxsIG9yIHRoZSByYW5nZSBzdGVwIGNvbmZpZyBpcyBudWxsLlxuICAgICAgICAgICAgICAgIC8vIFVzZSBkZWZhdWx0IHRvcExldmVsU2l6ZSBydWxlL2NvbmZpZ1xuICAgICAgICAgICAgICAgIHRvcExldmVsU2l6ZSA9IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gY29uZmlnLmNlbGwud2lkdGggOiBjb25maWcuY2VsbC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyBbMCwgdG9wTGV2ZWxTaXplXSA6IFt0b3BMZXZlbFNpemUsIDBdIH07XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNJWkU6XG4gICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGN1c3RvbSByYW5nZU1pbiwgcmFuZ2VNYXhcbiAgICAgICAgICAgIHZhciByYW5nZU1pbiA9IHNpemVSYW5nZU1pbihtYXJrLCB6ZXJvLCBjb25maWcpO1xuICAgICAgICAgICAgdmFyIHJhbmdlTWF4ID0gc2l6ZVJhbmdlTWF4KG1hcmssIHh5UmFuZ2VTdGVwcywgY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBbcmFuZ2VNaW4sIHJhbmdlTWF4XSB9O1xuICAgICAgICBjYXNlIGNoYW5uZWxfMS5TSEFQRTpcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuQ09MT1I6XG4gICAgICAgICAgICByZXR1cm4geyByYW5nZTogZGVmYXVsdFJhbmdlKGNoYW5uZWwsIHNjYWxlVHlwZSwgdHlwZSwgbWFyaykgfTtcbiAgICAgICAgY2FzZSBjaGFubmVsXzEuT1BBQ0lUWTpcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9tIHJhbmdlTWluLCByYW5nZU1heFxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IFtjb25maWcuc2NhbGUubWluT3BhY2l0eSwgY29uZmlnLnNjYWxlLm1heE9wYWNpdHldIH07XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNjYWxlIHJhbmdlIHVuZGVmaW5lZCBmb3IgY2hhbm5lbCBcIiArIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcmFuZ2VNaXhpbnM7XG5mdW5jdGlvbiBkZWZhdWx0UmFuZ2UoY2hhbm5lbCwgc2NhbGVUeXBlLCB0eXBlLCBtYXJrKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgY2hhbm5lbF8xLlNIQVBFOlxuICAgICAgICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgICAgICBjYXNlIGNoYW5uZWxfMS5DT0xPUjpcbiAgICAgICAgICAgIGlmIChzY2FsZVR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgbm9taW5hbCBkYXRhIHVzZXMgb3JkaW5hbCBzY2FsZSBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdub21pbmFsJyA/ICdjYXRlZ29yeScgOiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFyayA9PT0gJ3JlY3QnID8gJ2hlYXRtYXAnIDogJ3JhbXAnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpemVSYW5nZU1pbihtYXJrLCB6ZXJvLCBjb25maWcpIHtcbiAgICBpZiAoemVybykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc3dpdGNoIChtYXJrKSB7XG4gICAgICAgIGNhc2UgJ2Jhcic6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pbkJhbmRTaXplICE9PSB1bmRlZmluZWQgPyBjb25maWcuc2NhbGUubWluQmFuZFNpemUgOiBjb25maWcuYmFyLmNvbnRpbnVvdXNCYW5kU2l6ZTtcbiAgICAgICAgY2FzZSAndGljayc6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pbkJhbmRTaXplO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgY2FzZSAncnVsZSc6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pblN0cm9rZVdpZHRoO1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluRm9udFNpemU7XG4gICAgICAgIGNhc2UgJ3BvaW50JzpcbiAgICAgICAgY2FzZSAnc3F1YXJlJzpcbiAgICAgICAgY2FzZSAnY2lyY2xlJzpcbiAgICAgICAgICAgIGlmIChjb25maWcuc2NhbGUubWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gICAgLy8gc2l6ZVJhbmdlTWluIG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhlIG1hcmtcbiAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbCgnc2l6ZScsIG1hcmspKTtcbn1cbmZ1bmN0aW9uIHNpemVSYW5nZU1heChtYXJrLCB4eVJhbmdlU3RlcHMsIGNvbmZpZykge1xuICAgIHZhciBzY2FsZUNvbmZpZyA9IGNvbmZpZy5zY2FsZTtcbiAgICAvLyBUT0RPKCMxMTY4KTogbWFrZSBtYXggc2l6ZSBzY2FsZSBiYXNlZCBvbiByYW5nZVN0ZXAgLyBvdmVyYWxsIHBsb3Qgc2l6ZVxuICAgIHN3aXRjaCAobWFyaykge1xuICAgICAgICBjYXNlICdiYXInOlxuICAgICAgICBjYXNlICd0aWNrJzpcbiAgICAgICAgICAgIGlmIChjb25maWcuc2NhbGUubWF4QmFuZFNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4QmFuZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBjb25maWcuc2NhbGUpIC0gMTtcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgIGNhc2UgJ3J1bGUnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5tYXhTdHJva2VXaWR0aDtcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1heEZvbnRTaXplO1xuICAgICAgICBjYXNlICdwb2ludCc6XG4gICAgICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICAgICAgICBpZiAoY29uZmlnLnNjYWxlLm1heFNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1heFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRSB0aGlzIGNhc2UgdG90YWxseSBzaG91bGQgYmUgcmVmYWN0b3JlZFxuICAgICAgICAgICAgdmFyIHBvaW50U3RlcCA9IG1pblhZUmFuZ2VTdGVwKHh5UmFuZ2VTdGVwcywgc2NhbGVDb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIChwb2ludFN0ZXAgLSAyKSAqIChwb2ludFN0ZXAgLSAyKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gICAgLy8gc2l6ZVJhbmdlTWF4IG5vdCBpbXBsZW1lbnRlZCBmb3IgdGhlIG1hcmtcbiAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbCgnc2l6ZScsIG1hcmspKTtcbn1cbi8qKlxuICogQHJldHVybnMge251bWJlcn0gUmFuZ2Ugc3RlcCBvZiB4IG9yIHkgb3IgbWluaW11bSBiZXR3ZWVuIHRoZSB0d28gaWYgYm90aCBhcmUgb3JkaW5hbCBzY2FsZS5cbiAqL1xuZnVuY3Rpb24gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBzY2FsZUNvbmZpZykge1xuICAgIGlmICh4eVJhbmdlU3RlcHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgeHlSYW5nZVN0ZXBzKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZmlnLnJhbmdlU3RlcCkge1xuICAgICAgICByZXR1cm4gc2NhbGVDb25maWcucmFuZ2VTdGVwO1xuICAgIH1cbiAgICByZXR1cm4gMjE7IC8vIEZJWE1FOiByZS1ldmFsdWF0ZSB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY21GdVoyVXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl6WTJGc1pTOXlZVzVuWlM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTEN0Q1FVRnBRenRCUVVWcVF5eDVRMEZCYzBZN1FVRkhkRVlzY1VOQlFUQktPMEZCUlRGS0xHbERRVUZ0UXp0QlFVdHVReXh2UWtGQk1rSXNTMEZCV1R0SlFVTnlReXhGUVVGRkxFTkJRVU1zUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOd1FpeE5RVUZOTEVOQlFVTXNSVUZCUXl4SlFVRkpMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUlVGQlF5eERRVUZETzBsQlEycERMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVFSXNTVUZCVFN4TlFVRk5MRWRCUVVjc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF6dFJRVU0xUWl4RlFVRkZMRU5CUVVNc1EwRkJReXgzUWtGQlowSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE4wSXNTVUZCVFN4RFFVRkRMRWRCUVd0Q0xFVkJRVU1zVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRVZCUVVNc1EwRkJRenRaUVVNdlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYWtJc1EwRkJReXhEUVVGRExFdEJRVXNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMWxCUTNwQ0xFTkJRVU03V1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEYkVJc1EwRkJReXhEUVVGRExFMUJRVTBzUjBGQlJ5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMWxCUXpOQ0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTFnc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNUVUZCVFN4RFFVRkRMRVZCUVVNc1RVRkJUU3hSUVVGQkxFVkJRVU1zUTBGQlF6dFJRVU5zUWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNTMEZCU3l4RFFVRkRPMEZCUTNKQ0xFTkJRVU03UVVGdVFrUXNaME5CYlVKRE8wRkJSVmtzVVVGQlFTeG5Ra0ZCWjBJc1IwRkJiMElzUTBGQlF5eFBRVUZQTEVWQlFVVXNWMEZCVnl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wRkJSV3hHT3p0SFFVVkhPMEZCUTBnc2NVSkJRMFVzVDBGQlowSXNSVUZCUlN4VFFVRnZRaXhGUVVGRkxFbEJRVlVzUlVGQlJTeGpRVUZ4UWl4RlFVRkZMRTFCUVdNc1JVRkRla1lzU1VGQllTeEZRVUZGTEVsQlFWVXNSVUZCUlN4WlFVRm5ReXhGUVVGRkxGbEJRWE5DTzBsQlJXNUdMRWxCUVVrc2QwSkJRWGRDTEVkQlFVY3NTMEZCU3l4RFFVRkRPMGxCUlhKRExIRkVRVUZ4UkR0SlFVTnlSQ3d5UmtGQk1rWTdTVUZETTBZc1IwRkJSeXhEUVVGRExFTkJRVzFDTEZWQlFXZENMRVZCUVdoQ0xEWkRRVUZuUWl4RlFVRm9RaXc0UWtGQlowSXNSVUZCYUVJc1NVRkJaMEk3VVVGQmJFTXNTVUZCVFN4UlFVRlJMSGxDUVVGQk8xRkJRMnBDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR05CUVdNc1EwRkJReXhSUVVGUkxFTkJRVU1zUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpORExFbEJRVTBzYjBKQlFXOUNMRWRCUVVjc1owTkJRWGRDTEVOQlFVTXNVMEZCVXl4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8xbEJRek5GTEVsQlFVMHNjMEpCUVhOQ0xFZEJRVWNzTWtOQlFXMURMRU5CUVVNc1QwRkJUeXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETzFsQlEzUkdMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU14UWl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNhVU5CUVdsRExFTkJRVU1zVTBGQlV5eEZRVUZGTEZGQlFWRXNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM2hHTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zYzBKQlFYTkNMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5zUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExITkNRVUZ6UWl4RFFVRkRMRU5CUVVNN1dVRkRia01zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xFMUJRVTBzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRMnBDTEV0QlFVc3NUMEZCVHp0M1FrRkRWaXhOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNZMEZCWXl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRExFTkJRVU03YjBKQlF6TkRMRXRCUVVzc1VVRkJVVHQzUWtGRFdDeE5RVUZOTEVOQlFVTXNSVUZCUXl4TlFVRk5MRVZCUVVVc1kwRkJZeXhEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZETEVOQlFVTTdiMEpCUXpWRExFdEJRVXNzVjBGQlZ6dDNRa0ZEWkN4RlFVRkZMRU5CUVVNc1EwRkJReXhaUVVGWkxFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXpzMFFrRkRMMElzU1VGQlRTeFJRVUZSTEVkQlFVY3NZMEZCWXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE96UkNRVU14UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0blEwRkRkRUlzVFVGQlRTeERRVUZETEVWQlFVTXNVMEZCVXl4RlFVRkZMRkZCUVZFc1JVRkJReXhEUVVGRE96UkNRVU12UWl4RFFVRkRPelJDUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzJkRFFVTk9MSGRDUVVGM1FpeEhRVUZITEVsQlFVa3NRMEZCUXpzMFFrRkRiRU1zUTBGQlF6dDNRa0ZEU0N4RFFVRkRPM2RDUVVGRExFbEJRVWtzUTBGQlF5eERRVUZET3pSQ1FVTk9MR2xGUVVGcFJUczBRa0ZEYWtVc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR2RDUVVGblFpeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN2QwSkJRMnhFTEVOQlFVTTdaMEpCUTB3c1EwRkJRenRaUVVOSUxFTkJRVU03VVVGRFNDeERRVUZETzB0QlEwWTdTVUZGUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRzlGUVVGdlJUdFJRVU53UlN4TFFVRkxMR0ZCUVVjN1dVRkRUaXhOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RlFVRkRMRU5CUVVNN1VVRkRNMElzUzBGQlN5eG5Ra0ZCVFR0WlFVTlVMRTFCUVUwc1EwRkJReXhGUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVTXNRMEZCUXp0UlFVTXhRaXhMUVVGTExGZEJRVU1zUTBGQlF6dFJRVU5RTEV0QlFVc3NWMEZCUXp0WlFVTktMRVZCUVVVc1EwRkJReXhEUVVGRExGbEJRVmtzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNdlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVDBGQlR5eEZRVUZGTEUxQlFVMHNRMEZCUXl4RlFVRkZMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zZDBKQlFYZENMRU5CUVVNc1EwRkJReXhEUVVGRE8yOUNRVU0zUlN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzVjBGQlF5eEpRVUZKTEVsQlFVa3NTMEZCU3l4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8zZENRVU55UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEdOQlFXTXNRMEZCUXl4RFFVRkRMRU5CUVVNN05FSkJRMmhETEUxQlFVMHNRMEZCUXl4RlFVRkRMRk5CUVZNc1JVRkJSU3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEdOQlFXTXNSVUZCUXl4RFFVRkRPM2RDUVVOc1JDeERRVUZETzI5Q1FVTklMRU5CUVVNN2IwSkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdkMEpCUTA0c1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE96UkNRVU16UWl4TlFVRk5MRU5CUVVNc1JVRkJReXhUUVVGVExFVkJRVVVzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVNc1EwRkJRenQzUWtGRE4wTXNRMEZCUXp0dlFrRkRTQ3hEUVVGRE8yZENRVU5JTEVOQlFVTTdaMEpCUTBRc2IwVkJRVzlGTzJkQ1FVTndSU3gxUTBGQmRVTTdaMEpCUTNaRExGbEJRVmtzUjBGQlJ5eFBRVUZQTEV0QlFVc3NWMEZCUXl4SFFVRkhMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8xbEJRM2hGTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eExRVUZMTEZkQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1JVRkJSU3haUVVGWkxFTkJRVU1zUjBGQlJ5eERRVUZETEZsQlFWa3NSVUZCUlN4RFFVRkRMRU5CUVVNc1JVRkJReXhEUVVGRE8xRkJSWGhGTEV0QlFVc3NZMEZCU1R0WlFVTlFMREJEUVVFd1F6dFpRVU14UXl4SlFVRk5MRkZCUVZFc1IwRkJSeXhaUVVGWkxFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRaUVVOc1JDeEpRVUZOTEZGQlFWRXNSMEZCUnl4WlFVRlpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGbEJRVmtzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0WlFVTXhSQ3hOUVVGTkxFTkJRVU1zUlVGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFVkJRVU1zUTBGQlF6dFJRVU4yUXl4TFFVRkxMR1ZCUVVzc1EwRkJRenRSUVVOWUxFdEJRVXNzWlVGQlN6dFpRVU5TTEUxQlFVMHNRMEZCUXl4RlFVRkRMRXRCUVVzc1JVRkJSU3haUVVGWkxFTkJRVU1zVDBGQlR5eEZRVUZGTEZOQlFWTXNSVUZCUlN4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExFVkJRVU1zUTBGQlF6dFJRVWN2UkN4TFFVRkxMR2xDUVVGUE8xbEJRMVlzTUVOQlFUQkRPMWxCUXpGRExFMUJRVTBzUTBGQlF5eEZRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zVlVGQlZTeEZRVUZGTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1ZVRkJWU3hEUVVGRExFVkJRVU1zUTBGQlF6dEpRVU4yUlN4RFFVRkRPMGxCUTBRc2JVUkJRVzFFTzBsQlEyNUVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zZFVOQlFYRkRMRTlCUVZNc1EwRkJReXhEUVVGRE8wRkJRMnhGTEVOQlFVTTdRVUZxUmtRc09FSkJhVVpETzBGQlJVUXNjMEpCUVhOQ0xFOUJRVEJDTEVWQlFVVXNVMEZCYjBJc1JVRkJSU3hKUVVGVkxFVkJRVVVzU1VGQlZUdEpRVU0xUml4TlFVRk5MRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRXRCUVVzc1pVRkJTenRaUVVOU0xFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTTdVVUZEYkVJc1MwRkJTeXhsUVVGTE8xbEJRMUlzUlVGQlJTeERRVUZETEVOQlFVTXNVMEZCVXl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6VkNMR3RFUVVGclJEdG5Ra0ZEYkVRc1RVRkJUU3hEUVVGRExFbEJRVWtzUzBGQlN5eFRRVUZUTEVkQlFVY3NWVUZCVlN4SFFVRkhMRk5CUVZNc1EwRkJRenRaUVVOeVJDeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1MwRkJTeXhOUVVGTkxFZEJRVWNzVTBGQlV5eEhRVUZITEUxQlFVMHNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTEhOQ1FVRnpRaXhKUVVGVkxFVkJRVVVzU1VGQllTeEZRVUZGTEUxQlFXTTdTVUZETjBRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTlVMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRFdDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5pTEV0QlFVc3NTMEZCU3p0WlFVTlNMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZkQlFWY3NTMEZCU3l4VFFVRlRMRWRCUVVjc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZYTEVkQlFVY3NUVUZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhyUWtGQmEwSXNRMEZCUXp0UlFVTXpSeXhMUVVGTExFMUJRVTA3V1VGRFZDeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhYUVVGWExFTkJRVU03VVVGRGJFTXNTMEZCU3l4TlFVRk5MRU5CUVVNN1VVRkRXaXhMUVVGTExFMUJRVTA3V1VGRFZDeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhqUVVGakxFTkJRVU03VVVGRGNrTXNTMEZCU3l4TlFVRk5PMWxCUTFRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCVnl4RFFVRkRPMUZCUTJ4RExFdEJRVXNzVDBGQlR5eERRVUZETzFGQlEySXNTMEZCU3l4UlFVRlJMRU5CUVVNN1VVRkRaQ3hMUVVGTExGRkJRVkU3V1VGRFdDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwQ0xFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJRenRaUVVNNVFpeERRVUZETzBsQlEwd3NRMEZCUXp0SlFVTkVMRzFFUVVGdFJEdEpRVU51UkN3MFEwRkJORU03U1VGRE5VTXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEcxQ1FVRnRRaXhEUVVGRExFMUJRVTBzUlVGQlJTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTJwRkxFTkJRVU03UVVGRlJDeHpRa0ZCYzBJc1NVRkJWU3hGUVVGRkxGbEJRWE5DTEVWQlFVVXNUVUZCWXp0SlFVTjBSU3hKUVVGTkxGZEJRVmNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTJwRExEQkZRVUV3UlR0SlFVTXhSU3hOUVVGTkxFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJJc1MwRkJTeXhMUVVGTExFTkJRVU03VVVGRFdDeExRVUZMTEUxQlFVMDdXVUZEVkN4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEZkQlFWY3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU16UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZYTEVOQlFVTTdXVUZEYkVNc1EwRkJRenRaUVVORUxFMUJRVTBzUTBGQlF5eGpRVUZqTEVOQlFVTXNXVUZCV1N4RlFVRkZMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdVVUZEZUVRc1MwRkJTeXhOUVVGTkxFTkJRVU03VVVGRFdpeExRVUZMTEUxQlFVMDdXVUZEVkN4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF5eGpRVUZqTEVOQlFVTTdVVUZEY2tNc1MwRkJTeXhOUVVGTk8xbEJRMVFzVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJWeXhEUVVGRE8xRkJRMnhETEV0QlFVc3NUMEZCVHl4RFFVRkRPMUZCUTJJc1MwRkJTeXhSUVVGUkxFTkJRVU03VVVGRFpDeExRVUZMTEZGQlFWRTdXVUZEV0N4RlFVRkZMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM3BDTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF6dFpRVU01UWl4RFFVRkRPMWxCUlVRc0swTkJRU3RETzFsQlF5OURMRWxCUVUwc1UwRkJVeXhIUVVGSExHTkJRV01zUTBGQlF5eFpRVUZaTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNN1dVRkROVVFzVFVGQlRTeERRVUZETEVOQlFVTXNVMEZCVXl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zVTBGQlV5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUXpkRExFTkJRVU03U1VGRFJDeHRSRUZCYlVRN1NVRkRia1FzTkVOQlFUUkRPMGxCUXpWRExFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4TlFVRk5MRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU5xUlN4RFFVRkRPMEZCUlVRN08wZEJSVWM3UVVGRFNDeDNRa0ZCZDBJc1dVRkJjMElzUlVGQlJTeFhRVUYzUWp0SlFVTjBSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFpRVUZaTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE5VSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUzBGQlN5eERRVUZETEVsQlFVa3NSVUZCUlN4WlFVRlpMRU5CUVVNc1EwRkJRenRKUVVNMVF5eERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1YwRkJWeXhEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETVVJc1RVRkJUU3hEUVVGRExGZEJRVmNzUTBGQlF5eFRRVUZUTEVOQlFVTTdTVUZETDBJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl3MlEwRkJOa003UVVGRE1VUXNRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9jaGFubmVsXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2NhbGVcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuLi8uLi90aW1ldW5pdFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5mdW5jdGlvbiBuaWNlKHNjYWxlVHlwZSwgY2hhbm5lbCwgZmllbGREZWYpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhbc2NhbGVfMS5TY2FsZVR5cGUuVElNRSwgc2NhbGVfMS5TY2FsZVR5cGUuVVRDXSwgc2NhbGVUeXBlKSkge1xuICAgICAgICByZXR1cm4gdGltZXVuaXRfMS5zbWFsbGVzdFVuaXQoZmllbGREZWYudGltZVVuaXQpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbC5jb250YWlucyhbY2hhbm5lbF8xLlgsIGNoYW5uZWxfMS5ZXSwgY2hhbm5lbCk7IC8vIHJldHVybiB0cnVlIGZvciBxdWFudGl0YXRpdmUgWC9ZXG59XG5leHBvcnRzLm5pY2UgPSBuaWNlO1xuZnVuY3Rpb24gcGFkZGluZyhjaGFubmVsLCBzY2FsZVR5cGUsIHNjYWxlQ29uZmlnKSB7XG4gICAgaWYgKHV0aWwuY29udGFpbnMoW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0sIGNoYW5uZWwpKSB7XG4gICAgICAgIGlmIChzY2FsZVR5cGUgPT09IHNjYWxlXzEuU2NhbGVUeXBlLlBPSU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVDb25maWcucG9pbnRQYWRkaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnBhZGRpbmcgPSBwYWRkaW5nO1xuZnVuY3Rpb24gcGFkZGluZ0lubmVyKHBhZGRpbmcsIGNoYW5uZWwsIHNjYWxlQ29uZmlnKSB7XG4gICAgaWYgKHBhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiB1c2VyIGhhcyBhbHJlYWR5IG1hbnVhbGx5IHNwZWNpZmllZCBcInBhZGRpbmdcIiwgbm8gbmVlZCB0byBhZGQgZGVmYXVsdCBwYWRkaW5nSW5uZXIuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh1dGlsLmNvbnRhaW5zKFtjaGFubmVsXzEuWCwgY2hhbm5lbF8xLlldLCBjaGFubmVsKSkge1xuICAgICAgICAvLyBQYWRkaW5nIGlzIG9ubHkgc2V0IGZvciBYIGFuZCBZIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIEJhc2ljYWxseSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gYWRkIHBhZGRpbmcgZm9yIGNvbG9yIGFuZCBzaXplLlxuICAgICAgICAvLyBwYWRkaW5nT3V0ZXIgd291bGQgb25seSBiZSBjYWxsZWQgaWYgaXQncyBhIGJhbmQgc2NhbGUsIGp1c3QgcmV0dXJuIHRoZSBkZWZhdWx0IGZvciBiYW5kU2NhbGUuXG4gICAgICAgIHJldHVybiBzY2FsZUNvbmZpZy5iYW5kUGFkZGluZ0lubmVyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYWRkaW5nSW5uZXIgPSBwYWRkaW5nSW5uZXI7XG5mdW5jdGlvbiBwYWRkaW5nT3V0ZXIocGFkZGluZywgY2hhbm5lbCwgc2NhbGVUeXBlLCBwYWRkaW5nSW5uZXIsIHNjYWxlQ29uZmlnKSB7XG4gICAgaWYgKHBhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiB1c2VyIGhhcyBhbHJlYWR5IG1hbnVhbGx5IHNwZWNpZmllZCBcInBhZGRpbmdcIiwgbm8gbmVlZCB0byBhZGQgZGVmYXVsdCBwYWRkaW5nT3V0ZXIuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh1dGlsLmNvbnRhaW5zKFtjaGFubmVsXzEuWCwgY2hhbm5lbF8xLlldLCBjaGFubmVsKSkge1xuICAgICAgICAvLyBQYWRkaW5nIGlzIG9ubHkgc2V0IGZvciBYIGFuZCBZIGJ5IGRlZmF1bHQuXG4gICAgICAgIC8vIEJhc2ljYWxseSBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gYWRkIHBhZGRpbmcgZm9yIGNvbG9yIGFuZCBzaXplLlxuICAgICAgICBpZiAoc2NhbGVUeXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CQU5EKSB7XG4gICAgICAgICAgICBpZiAoc2NhbGVDb25maWcuYmFuZFBhZGRpbmdPdXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYWxlQ29uZmlnLmJhbmRQYWRkaW5nT3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBwYWRkaW5nT3V0ZXIgaXMgcGFkZGluZ0lubmVyIC8gMi4gVGhlIHJlYXNvbiBpcyB0aGF0XG4gICAgICAgICAgICAgICAgc2l6ZSAod2lkdGgvaGVpZ2h0KSA9IHN0ZXAgKiAoY2FyZGluYWxpdHkgLSBwYWRkaW5nSW5uZXIgKyAyICogcGFkZGluZ091dGVyKS5cbiAgICAgICAgICAgICAgICBhbmQgd2Ugd2FudCB0aGUgd2lkdGgvaGVpZ2h0IHRvIGJlIGludGVnZXIgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICBOb3RlIHRoYXQgc3RlcCAoYnkgZGVmYXVsdCkgYW5kIGNhcmRpbmFsaXR5IGFyZSBpbnRlZ2Vycy4pICovXG4gICAgICAgICAgICByZXR1cm4gcGFkZGluZ0lubmVyIC8gMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYWRkaW5nT3V0ZXIgPSBwYWRkaW5nT3V0ZXI7XG5mdW5jdGlvbiByb3VuZChjaGFubmVsLCBzY2FsZUNvbmZpZykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKFsneCcsICd5JywgJ3JvdycsICdjb2x1bW4nXSwgY2hhbm5lbCkpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQ29uZmlnLnJvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5yb3VuZCA9IHJvdW5kO1xuZnVuY3Rpb24gemVybyhzcGVjaWZpZWRTY2FsZSwgY2hhbm5lbCwgZmllbGREZWYpIHtcbiAgICAvLyBCeSBkZWZhdWx0LCByZXR1cm4gdHJ1ZSBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgIC8vIDEpIHVzaW5nIHF1YW50aXRhdGl2ZSBmaWVsZCB3aXRoIHNpemVcbiAgICAvLyBXaGlsZSB0aGlzIGNhbiBiZSBlaXRoZXIgcmF0aW8gb3IgaW50ZXJ2YWwgZmllbGRzLCBvdXIgYXNzdW1wdGlvbiBpcyB0aGF0XG4gICAgLy8gcmF0aW8gYXJlIG1vcmUgY29tbW9uLlxuICAgIGlmIChjaGFubmVsID09PSAnc2l6ZScgJiYgZmllbGREZWYudHlwZSA9PT0gJ3F1YW50aXRhdGl2ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIDIpIG5vbi1iaW5uZWQsIHF1YW50aXRhdGl2ZSB4LXNjYWxlIG9yIHktc2NhbGUgaWYgbm8gY3VzdG9tIGRvbWFpbiBpcyBwcm92aWRlZC5cbiAgICAvLyAoRm9yIGJpbm5pbmcsIHdlIHNob3VsZCBub3QgaW5jbHVkZSB6ZXJvIGJ5IGRlZmF1bHQgYmVjYXVzZSBiaW5uaW5nIGFyZSBjYWxjdWxhdGVkIHdpdGhvdXQgemVyby5cbiAgICAvLyBTaW1pbGFyLCBpZiB1c2VycyBleHBsaWNpdGx5IHByb3ZpZGUgYSBkb21haW4gcmFuZ2UsIHdlIHNob3VsZCBub3QgYXVnbWVudCB6ZXJvIGFzIHRoYXQgd2lsbCBiZSB1bmV4cGVjdGVkLilcbiAgICBpZiAoIXNwZWNpZmllZFNjYWxlLmRvbWFpbiAmJiAhZmllbGREZWYuYmluICYmIHV0aWwuY29udGFpbnMoW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0sIGNoYW5uZWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnplcm8gPSB6ZXJvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY25Wc1pYTXVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTh1TGk4dUxpOXpjbU12WTI5dGNHbHNaUzl6WTJGc1pTOXlkV3hsY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEhsRFFVRTBRenRCUVVVMVF5eHhRMEZCYjBVN1FVRkRjRVVzTWtOQlFUUkRPMEZCUXpWRExHbERRVUZ0UXp0QlFVVnVReXhqUVVGeFFpeFRRVUZ2UWl4RlFVRkZMRTlCUVdkQ0xFVkJRVVVzVVVGQmEwSTdTVUZETjBVc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMR2xDUVVGVExFTkJRVU1zU1VGQlNTeEZRVUZGTEdsQ1FVRlRMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpsRUxFMUJRVTBzUTBGQlF5eDFRa0ZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVkVzUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4WFFVRkRMRVZCUVVVc1YwRkJReXhEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4dFEwRkJiVU03UVVGRE5VVXNRMEZCUXp0QlFVeEVMRzlDUVV0RE8wRkJSVVFzYVVKQlFYZENMRTlCUVdkQ0xFVkJRVVVzVTBGQmIwSXNSVUZCUlN4WFFVRjNRanRKUVVOMFJpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zVjBGQlF5eEZRVUZGTEZkQlFVTXNRMEZCUXl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU51UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhUUVVGVExFdEJRVXNzYVVKQlFWTXNRMEZCUXl4TFFVRkxMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnhETEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1dVRkJXU3hEUVVGRE8xRkJRMnhETEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dEJRVU51UWl4RFFVRkRPMEZCVUVRc01FSkJUME03UVVGRlJDeHpRa0ZCTmtJc1QwRkJaU3hGUVVGRkxFOUJRV2RDTEVWQlFVY3NWMEZCZDBJN1NVRkRka1lzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE1VSXNlVVpCUVhsR08xRkJRM3BHTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1NVRkRia0lzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eFhRVUZETEVWQlFVVXNWMEZCUXl4RFFVRkRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyNURMRGhEUVVFNFF6dFJRVU01UXl4eFJVRkJjVVU3VVVGRmNrVXNhVWRCUVdsSE8xRkJRMnBITEUxQlFVMHNRMEZCUXl4WFFVRlhMRU5CUVVNc1owSkJRV2RDTEVOQlFVTTdTVUZEZEVNc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVdSRUxHOURRV05ETzBGQlJVUXNjMEpCUVRaQ0xFOUJRV1VzUlVGQlJTeFBRVUZuUWl4RlFVRkZMRk5CUVc5Q0xFVkJRVVVzV1VGQmIwSXNSVUZCUlN4WFFVRjNRanRKUVVOc1NTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU14UWl4NVJrRkJlVVk3VVVGRGVrWXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRKUVVOdVFpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEZkQlFVTXNSVUZCUlN4WFFVRkRMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYmtNc09FTkJRVGhETzFGQlF6bERMSEZGUVVGeFJUdFJRVU55UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhUUVVGVExFdEJRVXNzYVVKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEVWQlFVVXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhuUWtGQlowSXNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU12UXl4TlFVRk5MRU5CUVVNc1YwRkJWeXhEUVVGRExHZENRVUZuUWl4RFFVRkRPMWxCUTNSRExFTkJRVU03V1VGRFJEczdPelpGUVVkcFJUdFpRVU5xUlN4TlFVRk5MRU5CUVVNc1dVRkJXU3hIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU14UWl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVhKQ1JDeHZRMEZ4UWtNN1FVRkZSQ3hsUVVGelFpeFBRVUZuUWl4RlFVRkZMRmRCUVhkQ08wbEJRemxFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRlRVFzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4TFFVRkxMRU5CUVVNN1NVRkRNMElzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1FVRkRia0lzUTBGQlF6dEJRVXhFTEhOQ1FVdERPMEZCUlVRc1kwRkJjVUlzWTBGQmNVSXNSVUZCUlN4UFFVRm5RaXhGUVVGRkxGRkJRV3RDTzBsQlF6bEZMSGRFUVVGM1JEdEpRVVY0UkN4M1EwRkJkME03U1VGRGVFTXNORVZCUVRSRk8wbEJRelZGTEhsQ1FVRjVRanRKUVVONlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1RVRkJUU3hKUVVGSkxGRkJRVkVzUTBGQlF5eEpRVUZKTEV0QlFVc3NZMEZCWXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNelJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWRUxHdEdRVUZyUmp0SlFVTnNSaXh0UjBGQmJVYzdTVUZEYmtjc0swZEJRU3RITzBsQlF5OUhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zWTBGQll5eERRVUZETEUxQlFVMHNTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFbEJRVWtzU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRmRCUVVNc1JVRkJSU3hYUVVGRExFTkJRVU1zUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRPVVVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTmtMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBGQlEyWXNRMEZCUXp0QlFXcENSQ3h2UWtGcFFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4uLy4uL2xvZ1wiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4uLy4uL3NjYWxlXCIpO1xudmFyIHRpbWV1bml0XzEgPSByZXF1aXJlKFwiLi4vLi4vdGltZXVuaXRcIik7XG52YXIgc2NhbGVfMiA9IHJlcXVpcmUoXCIuLi8uLi9zY2FsZVwiKTtcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vdHlwZVwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vKipcbiAqIERldGVybWluZSBpZiB0aGVyZSBpcyBhIHNwZWNpZmllZCBzY2FsZSB0eXBlIGFuZCBpZiBpdCBpcyBhcHByb3ByaWF0ZSxcbiAqIG9yIGRldGVybWluZSBkZWZhdWx0IHR5cGUgaWYgdHlwZSBpcyB1bnNwZWNpZmllZCBvciBpbmFwcHJvcHJpYXRlLlxuICovXG4vLyBOT1RFOiBDb21wYXNzUUwgdXNlcyB0aGlzIG1ldGhvZC5cbmZ1bmN0aW9uIHR5cGUoc3BlY2lmaWVkVHlwZSwgY2hhbm5lbCwgZmllbGREZWYsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZykge1xuICAgIHZhciBkZWZhdWx0U2NhbGVUeXBlID0gZGVmYXVsdFR5cGUoY2hhbm5lbCwgZmllbGREZWYsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZyk7XG4gICAgaWYgKCFjaGFubmVsXzEuaGFzU2NhbGUoY2hhbm5lbCkpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gc2NhbGUgZm9yIHRoZXNlIGNoYW5uZWxzXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3BlY2lmaWVkVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHNjYWxlIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjaGFubmVsXG4gICAgICAgIGlmICghY2hhbm5lbF8xLnN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc3BlY2lmaWVkVHlwZSkpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnNjYWxlVHlwZU5vdFdvcmtXaXRoQ2hhbm5lbChjaGFubmVsLCBzcGVjaWZpZWRUeXBlLCBkZWZhdWx0U2NhbGVUeXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNjYWxlVHlwZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBleHBsaWNpdGx5IHNwZWNpZmllZCBzY2FsZSB0eXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgZGF0YSB0eXBlXG4gICAgICAgIGlmICghZmllbGREZWZNYXRjaFNjYWxlVHlwZShzcGVjaWZpZWRUeXBlLCBmaWVsZERlZikpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnNjYWxlVHlwZU5vdFdvcmtXaXRoRmllbGREZWYoc3BlY2lmaWVkVHlwZSwgZGVmYXVsdFNjYWxlVHlwZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTY2FsZVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWNpZmllZFR5cGU7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U2NhbGVUeXBlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZTtcbi8qKlxuICogRGV0ZXJtaW5lIGFwcHJvcHJpYXRlIGRlZmF1bHQgc2NhbGUgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdFR5cGUoY2hhbm5lbCwgZmllbGREZWYsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKFsncm93JywgJ2NvbHVtbiddLCBjaGFubmVsKSkge1xuICAgICAgICByZXR1cm4gJ2JhbmQnO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZpZWxkRGVmLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbm9taW5hbCc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ2NvbG9yJyB8fCBjaGFubmVsXzEucmFuZ2VUeXBlKGNoYW5uZWwpID09PSAnZGlzY3JldGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcmRpbmFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXNjcmV0ZVRvQ29udGludW91c1R5cGUoY2hhbm5lbCwgbWFyaywgaGFzVG9wTGV2ZWxTaXplLCBzcGVjaWZpZWRSYW5nZVN0ZXAsIHNjYWxlQ29uZmlnKTtcbiAgICAgICAgY2FzZSAnb3JkaW5hbCc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsXzEucmFuZ2VUeXBlKGNoYW5uZWwpID09PSAnZGlzY3JldGUnKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuZGlzY3JldGVDaGFubmVsQ2Fubm90RW5jb2RlKGNoYW5uZWwsICdvcmRpbmFsJykpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlzY3JldGVUb0NvbnRpbnVvdXNUeXBlKGNoYW5uZWwsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZyk7XG4gICAgICAgIGNhc2UgJ3RlbXBvcmFsJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBgc2VxdWVudGlhbGAgYXMgdGhlIGRlZmF1bHQgY29sb3Igc2NhbGUgZm9yIGNvbnRpbnVvdXMgZGF0YVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IHN1cHBvcnRzIGJvdGggYXJyYXkgcmFuZ2UgYW5kIHNjaGVtZSByYW5nZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NlcXVlbnRpYWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbm5lbF8xLnJhbmdlVHlwZShjaGFubmVsKSA9PT0gJ2Rpc2NyZXRlJykge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZShjaGFubmVsLCAndGVtcG9yYWwnKSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgcXVhbnRpemUgKGVxdWl2YWxlbnQgdG8gYmlubmluZykgb25jZSB3ZSBoYXZlIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcmRpbmFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1ldW5pdF8xLmlzRGlzY3JldGVCeURlZmF1bHQoZmllbGREZWYudGltZVVuaXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc2NyZXRlVG9Db250aW51b3VzVHlwZShjaGFubmVsLCBtYXJrLCBoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICd0aW1lJztcbiAgICAgICAgY2FzZSAncXVhbnRpdGF0aXZlJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Jpbi1vcmRpbmFsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXNlIGBzZXF1ZW50aWFsYCBhcyB0aGUgZGVmYXVsdCBjb2xvciBzY2FsZSBmb3IgY29udGludW91cyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgc3VwcG9ydHMgYm90aCBhcnJheSByYW5nZSBhbmQgc2NoZW1lIHJhbmdlLlxuICAgICAgICAgICAgICAgIHJldHVybiAnc2VxdWVudGlhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFubmVsXzEucmFuZ2VUeXBlKGNoYW5uZWwpID09PSAnZGlzY3JldGUnKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuZGlzY3JldGVDaGFubmVsQ2Fubm90RW5jb2RlKGNoYW5uZWwsICdxdWFudGl0YXRpdmUnKSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgdXNpbmcgcXVhbnRpemUgKGVxdWl2YWxlbnQgdG8gYmlubmluZykgb25jZSB3ZSBoYXZlIGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcmRpbmFsJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Jpbi1saW5lYXInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdsaW5lYXInO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW52YWxpZEZpZWxkVHlwZShmaWVsZERlZi50eXBlKSk7XG59XG4vKipcbiAqIERldGVybWluZXMgZGVmYXVsdCBzY2FsZSB0eXBlIGZvciBub21pbmFsL29yZGluYWwgZmllbGQuXG4gKiBAcmV0dXJucyBCQU5EIG9yIFBPSU5UIHNjYWxlIGJhc2VkIG9uIGNoYW5uZWwsIG1hcmssIGFuZCByYW5nZVN0ZXBcbiAqL1xuZnVuY3Rpb24gZGlzY3JldGVUb0NvbnRpbnVvdXNUeXBlKGNoYW5uZWwsIG1hcmssIGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKFsneCcsICd5J10sIGNoYW5uZWwpKSB7XG4gICAgICAgIGlmIChtYXJrID09PSAncmVjdCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSByZWN0IG1hcmsgc2hvdWxkIGZpdCBpbnRvIGEgYmFuZC5cbiAgICAgICAgICAgIHJldHVybiAnYmFuZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmsgPT09ICdiYXInKSB7XG4gICAgICAgICAgICAvLyBGb3IgYmFyLCB1c2UgYmFuZCBvbmx5IGlmIHRoZXJlIGlzIG5vIHJhbmdlU3RlcCBzaW5jZSB3ZSBuZWVkIHRvIHVzZSBiYW5kIGZvciBmaXQgbW9kZS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGZvciBub24tZml0IG1vZGUsIHBvaW50IHNjYWxlIHByb3ZpZGVzIGJldHRlciBjZW50ZXIgcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoaGF2ZVJhbmdlU3RlcChoYXNUb3BMZXZlbFNpemUsIHNwZWNpZmllZFJhbmdlU3RlcCwgc2NhbGVDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwb2ludCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2JhbmQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgdXNlIG9yZGluYWwgcG9pbnQgc2NhbGUgc28gd2UgY2FuIGVhc2lseSBnZXQgY2VudGVyIHBvc2l0aW9ucyBvZiB0aGUgbWFya3MuXG4gICAgcmV0dXJuICdwb2ludCc7XG59XG5mdW5jdGlvbiBoYXZlUmFuZ2VTdGVwKGhhc1RvcExldmVsU2l6ZSwgc3BlY2lmaWVkUmFuZ2VTdGVwLCBzY2FsZUNvbmZpZykge1xuICAgIGlmIChoYXNUb3BMZXZlbFNpemUpIHtcbiAgICAgICAgLy8gaWYgdG9wTGV2ZWxTaXplIGlzIHByb3ZpZGVkLCByYW5nZVN0ZXAgd2lsbCBiZSBkcm9wcGVkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzcGVjaWZpZWRSYW5nZVN0ZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVkUmFuZ2VTdGVwICE9PSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gISFzY2FsZUNvbmZpZy5yYW5nZVN0ZXA7XG59XG5mdW5jdGlvbiBmaWVsZERlZk1hdGNoU2NhbGVUeXBlKHNwZWNpZmllZFR5cGUsIGZpZWxkRGVmKSB7XG4gICAgdmFyIHR5cGUgPSBmaWVsZERlZi50eXBlO1xuICAgIGlmICh1dGlsXzEuY29udGFpbnMoW3R5cGVfMS5UeXBlLk9SRElOQUwsIHR5cGVfMS5UeXBlLk5PTUlOQUxdLCB0eXBlKSkge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWVkVHlwZSA9PT0gdW5kZWZpbmVkIHx8IHNjYWxlXzIuaGFzRGlzY3JldGVEb21haW4oc3BlY2lmaWVkVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IHR5cGVfMS5UeXBlLlRFTVBPUkFMKSB7XG4gICAgICAgIGlmICghZmllbGREZWYudGltZVVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLlRJTUUsIHNjYWxlXzEuU2NhbGVUeXBlLlVUQywgdW5kZWZpbmVkXSwgc3BlY2lmaWVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKFtzY2FsZV8xLlNjYWxlVHlwZS5USU1FLCBzY2FsZV8xLlNjYWxlVHlwZS5VVEMsIHVuZGVmaW5lZF0sIHNwZWNpZmllZFR5cGUpIHx8IHNjYWxlXzIuaGFzRGlzY3JldGVEb21haW4oc3BlY2lmaWVkVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gdHlwZV8xLlR5cGUuUVVBTlRJVEFUSVZFKSB7XG4gICAgICAgIGlmIChmaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBzcGVjaWZpZWRUeXBlID09PSBzY2FsZV8xLlNjYWxlVHlwZS5CSU5fTElORUFSIHx8IHNwZWNpZmllZFR5cGUgPT09IHNjYWxlXzEuU2NhbGVUeXBlLkJJTl9PUkRJTkFMO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsXzEuY29udGFpbnMoW3NjYWxlXzEuU2NhbGVUeXBlLkxPRywgc2NhbGVfMS5TY2FsZVR5cGUuUE9XLCBzY2FsZV8xLlNjYWxlVHlwZS5TUVJULCBzY2FsZV8xLlNjYWxlVHlwZS5RVUFOVElMRSwgc2NhbGVfMS5TY2FsZVR5cGUuUVVBTlRJWkUsIHNjYWxlXzEuU2NhbGVUeXBlLkxJTkVBUiwgdW5kZWZpbmVkXSwgc3BlY2lmaWVkVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5maWVsZERlZk1hdGNoU2NhbGVUeXBlID0gZmllbGREZWZNYXRjaFNjYWxlVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRIbHdaUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNOallXeGxMM1I1Y0dVdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN3clFrRkJhVU03UVVGRmFrTXNlVU5CUVRaRk8wRkJSVGRGTEhGRFFVRnRSRHRCUVVOdVJDd3lRMEZCYlVRN1FVRkhia1FzY1VOQlFUaERPMEZCUXpsRExHMURRVUZuUXp0QlFVTm9ReXhwUTBGQmJVTTdRVUZEYmtNc2JVTkJRVzlETzBGQlNYQkRPenM3UjBGSFJ6dEJRVU5JTEc5RFFVRnZRenRCUVVOd1F5eGpRVU5GTEdGQlFYZENMRVZCUVVVc1QwRkJaMElzUlVGQlJTeFJRVUZyUWl4RlFVRkZMRWxCUVZVc1JVRkRNVVVzWlVGQmQwSXNSVUZCUlN4clFrRkJNRUlzUlVGQlJTeFhRVUYzUWp0SlFVVTVSU3hKUVVGTkxHZENRVUZuUWl4SFFVRkhMRmRCUVZjc1EwRkJReXhQUVVGUExFVkJRVVVzVVVGQlVTeEZRVUZGTEVsQlFVa3NSVUZCUlN4bFFVRmxMRVZCUVVVc2EwSkJRV3RDTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNN1NVRkZhRWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4clFrRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjJRaXgxUTBGQmRVTTdVVUZEZGtNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhoUVVGaExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTm9ReXgxUlVGQmRVVTdVVUZEZGtVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5d3dRa0ZCWjBJc1EwRkJReXhQUVVGUExFVkJRVVVzWVVGQllTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpsRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXd5UWtGQk1rSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1lVRkJZU3hGUVVGRkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNMVJpeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03VVVGRE1VSXNRMEZCUXp0UlFVVkVMSGxGUVVGNVJUdFJRVU42UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExITkNRVUZ6UWl4RFFVRkRMR0ZCUVdFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tRc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRFJDUVVFMFFpeERRVUZETEdGQlFXRXNSVUZCUlN4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VZc1RVRkJUU3hEUVVGRExHZENRVUZuUWl4RFFVRkRPMUZCUXpGQ0xFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRPMGxCUTNaQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU03UVVGRE1VSXNRMEZCUXp0QlFUTkNSQ3gxUWtFeVFrTTdRVUZGUkRzN1IwRkZSenRCUVVOSUxIRkNRVUZ4UWl4UFFVRm5RaXhGUVVGRkxGRkJRV3RDTEVWQlFVVXNTVUZCVlN4RlFVTnVSU3hsUVVGM1FpeEZRVUZGTEd0Q1FVRXdRaXhGUVVGRkxGZEJRWGRDTzBsQlJUbEZMRVZCUVVVc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4TFFVRkxMRVZCUVVVc1VVRkJVU3hEUVVGRExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpsRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdTVUZEYUVJc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JDTEV0QlFVc3NVMEZCVXp0WlFVTmFMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eFBRVUZQTEVsQlFVa3NiVUpCUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNM1JDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMWxCUTI1Q0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNkMEpCUVhkQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NSVUZCUlN4bFFVRmxMRVZCUVVVc2EwSkJRV3RDTEVWQlFVVXNWMEZCVnl4RFFVRkRMRU5CUVVNN1VVRkZia2NzUzBGQlN5eFRRVUZUTzFsQlExb3NSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoQ0xFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZEYmtJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4dFFrRkJVeXhEUVVGRExFOUJRVThzUTBGQlF5eExRVUZMTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRemRETEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5d3lRa0ZCTWtJc1EwRkJReXhQUVVGUExFVkJRVVVzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRVVzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0WlFVTnVRaXhEUVVGRE8xbEJRMFFzVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExFOUJRVThzUlVGQlJTeEpRVUZKTEVWQlFVVXNaVUZCWlN4RlFVRkZMR3RDUVVGclFpeEZRVUZGTEZkQlFWY3NRMEZCUXl4RFFVRkRPMUZCUlc1SExFdEJRVXNzVlVGQlZUdFpRVU5pTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjRRaXg1UlVGQmVVVTdaMEpCUTNwRkxIVkVRVUYxUkR0blFrRkRka1FzVFVGQlRTeERRVUZETEZsQlFWa3NRMEZCUXp0WlFVTjBRaXhEUVVGRE8xbEJRVU1zU1VGQlNTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRzFDUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEV0QlFVc3NWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE4wTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETERKQ1FVRXlRaXhEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOMlJTeDNSVUZCZDBVN1owSkJRM2hGTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRia0lzUTBGQlF6dFpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMRGhDUVVGdFFpeERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF6TkRMRTFCUVUwc1EwRkJReXgzUWtGQmQwSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1NVRkJTU3hGUVVGRkxHVkJRV1VzUlVGQlJTeHJRa0ZCYTBJc1JVRkJSU3hYUVVGWExFTkJRVU1zUTBGQlF6dFpRVU51Unl4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dFJRVVZvUWl4TFFVRkxMR05CUVdNN1dVRkRha0lzUlVGQlJTeERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzaENMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMjlDUVVOcVFpeE5RVUZOTEVOQlFVTXNZVUZCWVN4RFFVRkRPMmRDUVVOMlFpeERRVUZETzJkQ1FVTkVMR3RGUVVGclJUdG5Ra0ZEYkVVc2RVUkJRWFZFTzJkQ1FVTjJSQ3hOUVVGTkxFTkJRVU1zV1VGQldTeERRVUZETzFsQlEzUkNMRU5CUVVNN1dVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNiVUpCUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNM1F5eEhRVUZITEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zTWtKQlFUSkNMRU5CUVVNc1QwRkJUeXhGUVVGRkxHTkJRV01zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpORkxIZEZRVUYzUlR0blFrRkRlRVVzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0WlFVTnVRaXhEUVVGRE8xbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEycENMRTFCUVUwc1EwRkJReXhaUVVGWkxFTkJRVU03V1VGRGRFSXNRMEZCUXp0WlFVTkVMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU03U1VGRGNFSXNRMEZCUXp0SlFVVkVMRzFFUVVGdFJEdEpRVU51UkN4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRMMFFzUTBGQlF6dEJRVVZFT3pzN1IwRkhSenRCUVVOSUxHdERRVU5KTEU5QlFXZENMRVZCUVVVc1NVRkJWU3hGUVVGRkxHVkJRWGRDTEVWQlEzUkVMR3RDUVVFd1FpeEZRVUZGTEZkQlFYZENPMGxCUlhSRUxFVkJRVVVzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1pETEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkNMSGREUVVGM1F6dFpRVU40UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRMmhDTEVOQlFVTTdVVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFdEJRVXNzUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnVRaXd3UmtGQk1FWTdXVUZETVVZc01FVkJRVEJGTzFsQlF6RkZMRVZCUVVVc1EwRkJReXhEUVVGRExHRkJRV0VzUTBGQlF5eGxRVUZsTEVWQlFVVXNhMEpCUVd0Q0xFVkJRVVVzVjBGQlZ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOd1JTeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUTJwQ0xFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTJoQ0xFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNlVVpCUVhsR08wbEJRM3BHTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1FVRkRha0lzUTBGQlF6dEJRVVZFTEhWQ1FVRjFRaXhsUVVGM1FpeEZRVUZGTEd0Q1FVRXdRaXhGUVVGRkxGZEJRWGRDTzBsQlEyNUhMRVZCUVVVc1EwRkJReXhEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY0VJc01FUkJRVEJFTzFGQlF6RkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRFppeERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc2EwSkJRV3RDTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVF5eE5RVUZOTEVOQlFVTXNhMEpCUVd0Q0xFdEJRVXNzU1VGQlNTeERRVUZETzBsQlEzSkRMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4VFFVRlRMRU5CUVVNN1FVRkRha01zUTBGQlF6dEJRVVZFTEdkRFFVRjFReXhoUVVGM1FpeEZRVUZGTEZGQlFXdENPMGxCUTJwR0xFbEJRVTBzU1VGQlNTeEhRVUZUTEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRha01zUlVGQlJTeERRVUZETEVOQlFVTXNaVUZCVVN4RFFVRkRMRU5CUVVNc1YwRkJTU3hEUVVGRExFOUJRVThzUlVGQlJTeFhRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycEVMRTFCUVUwc1EwRkJReXhoUVVGaExFdEJRVXNzVTBGQlV5eEpRVUZKTEhsQ1FVRnBRaXhEUVVGRExHRkJRV0VzUTBGQlF5eERRVUZETzBsQlEzcEZMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNTVUZCU1N4TFFVRkxMRmRCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyeERMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka0lzVFVGQlRTeERRVUZETEdWQlFWRXNRMEZCUXl4RFFVRkRMR2xDUVVGVExFTkJRVU1zU1VGQlNTeEZRVUZGTEdsQ1FVRlRMRU5CUVVNc1IwRkJSeXhGUVVGRkxGTkJRVk1zUTBGQlF5eEZRVUZGTEdGQlFXRXNRMEZCUXl4RFFVRkRPMUZCUXpkRkxFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0WlFVTk9MRTFCUVUwc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eHBRa0ZCVXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hwUWtGQlV5eERRVUZETEVkQlFVY3NSVUZCUlN4VFFVRlRMRU5CUVVNc1JVRkJSU3hoUVVGaExFTkJRVU1zU1VGQlNTeDVRa0ZCYVVJc1EwRkJReXhoUVVGaExFTkJRVU1zUTBGQlF6dFJRVU5xU0N4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc1YwRkJTU3hEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRha0lzVFVGQlRTeERRVUZETEdGQlFXRXNTMEZCU3l4cFFrRkJVeXhEUVVGRExGVkJRVlVzU1VGQlNTeGhRVUZoTEV0QlFVc3NhVUpCUVZNc1EwRkJReXhYUVVGWExFTkJRVU03VVVGRE0wWXNRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eHBRa0ZCVXl4RFFVRkRMRWRCUVVjc1JVRkJSU3hwUWtGQlV5eERRVUZETEVkQlFVY3NSVUZCUlN4cFFrRkJVeXhEUVVGRExFbEJRVWtzUlVGQlJTeHBRa0ZCVXl4RFFVRkRMRkZCUVZFc1JVRkJSU3hwUWtGQlV5eERRVUZETEZGQlFWRXNSVUZCUlN4cFFrRkJVeXhEUVVGRExFMUJRVTBzUlVGQlJTeFRRVUZUTEVOQlFVTXNSVUZCUlN4aFFVRmhMRU5CUVVNc1EwRkJRenRKUVVOMFNpeERRVUZETzBsQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGc1FrUXNkMFJCYTBKREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi4vLi4vY2hhbm5lbFwiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuLi8uLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25cIik7XG52YXIgc2NhbGVzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zL3NjYWxlc1wiKTtcbmV4cG9ydHMuQlJVU0ggPSAnX2JydXNoJywgZXhwb3J0cy5TSVpFID0gJ19zaXplJztcbnZhciBpbnRlcnZhbCA9IHtcbiAgICBwcmVkaWNhdGU6ICd2bEludGVydmFsJyxcbiAgICBzaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHNpZ25hbHMgPSBbXSwgaW50ZXJ2YWxzID0gW10sIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHNpemUgPSBuYW1lICsgZXhwb3J0cy5TSVpFO1xuICAgICAgICBpZiAoc2VsQ21wdC50cmFuc2xhdGUgJiYgIShzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSkpIHtcbiAgICAgICAgICAgIGV2ZW50cyhzZWxDbXB0LCBmdW5jdGlvbiAoXywgZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBldnQuYmV0d2VlblswXS5maWx0ZXIgfHwgKGV2dC5iZXR3ZWVuWzBdLmZpbHRlciA9IFtdKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJyFldmVudC5pdGVtIHx8IChldmVudC5pdGVtICYmICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJldmVudC5pdGVtLm1hcmsubmFtZSAhPT0gXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUobmFtZSArIGV4cG9ydHMuQlJVU0gpICsgXCIpXCIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbENtcHQucHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBpZiAocC5lbmNvZGluZyAhPT0gY2hhbm5lbF8xLlggJiYgcC5lbmNvZGluZyAhPT0gY2hhbm5lbF8xLlkpIHtcbiAgICAgICAgICAgICAgICBsb2dfMS53YXJuKCdJbnRlcnZhbCBzZWxlY3Rpb25zIG9ubHkgc3VwcG9ydCB4IGFuZCB5IGVuY29kaW5nIGNoYW5uZWxzLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjcyA9IGNoYW5uZWxTaWduYWwobW9kZWwsIHNlbENtcHQsIHAuZW5jb2RpbmcpO1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKGNzKTtcbiAgICAgICAgICAgIGludGVydmFscy5wdXNoKFwie2ZpZWxkOiBcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShwLmZpZWxkKSArIFwiLCBleHRlbnQ6IFwiICsgY3MubmFtZSArIFwifVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ25hbHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBzaXplLFxuICAgICAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICAgICAgb246IGV2ZW50cyhzZWxDbXB0LCBmdW5jdGlvbiAob24sIGV2dCkge1xuICAgICAgICAgICAgICAgIG9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2dC5iZXR3ZWVuWzBdLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6ICd7eDogeCh1bml0KSwgeTogeSh1bml0KSwgd2lkdGg6IDAsIGhlaWdodDogMH0nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZ0LFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3g6IFwiICsgc2l6ZSArIFwiLngsIHk6IFwiICsgc2l6ZSArIFwiLnksIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIndpZHRoOiBhYnMoeCh1bml0KSAtIFwiICsgc2l6ZSArIFwiLngpLCBoZWlnaHQ6IGFicyh5KHVuaXQpIC0gXCIgKyBzaXplICsgXCIueSl9XCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHVwZGF0ZTogXCJbXCIgKyBpbnRlcnZhbHMuam9pbignLCAnKSArIFwiXVwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9LFxuICAgIHR1cGxlRXhwcjogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBcImludGVydmFsczogXCIgKyBzZWxDbXB0Lm5hbWU7XG4gICAgfSxcbiAgICBtb2RpZnlFeHByOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHRwbCA9IHNlbENtcHQubmFtZSArIHNlbGVjdGlvbl8xLlRVUExFO1xuICAgICAgICByZXR1cm4gdHBsICsgXCIsIHt1bml0OiBcIiArIHRwbCArIFwiLnVuaXR9XCI7XG4gICAgfSxcbiAgICBtYXJrczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBtYXJrcykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgX2EgPSBwcm9qZWN0aW9ucyhzZWxDbXB0KSwgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAvLyBEbyBub3QgYWRkIGEgYnJ1c2ggaWYgd2UncmUgYmluZGluZyB0byBzY2FsZXMuXG4gICAgICAgIGlmIChzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgICAgICB4OiB1dGlsXzEuZXh0ZW5kKHt9LCB4ICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICB7IHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlgpLCBzaWduYWw6IG5hbWUgKyBcIltcIiArIHggKyBcIl0uZXh0ZW50WzBdXCIgfSA6XG4gICAgICAgICAgICAgICAgeyB2YWx1ZTogMCB9KSxcbiAgICAgICAgICAgIHgyOiB1dGlsXzEuZXh0ZW5kKHt9LCB4ICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICB7IHNjYWxlOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlgpLCBzaWduYWw6IG5hbWUgKyBcIltcIiArIHggKyBcIl0uZXh0ZW50WzFdXCIgfSA6XG4gICAgICAgICAgICAgICAgeyBmaWVsZDogeyBncm91cDogJ3dpZHRoJyB9IH0pLFxuICAgICAgICAgICAgeTogdXRpbF8xLmV4dGVuZCh7fSwgeSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgeyBzY2FsZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKSwgc2lnbmFsOiBuYW1lICsgXCJbXCIgKyB5ICsgXCJdLmV4dGVudFswXVwiIH0gOlxuICAgICAgICAgICAgICAgIHsgdmFsdWU6IDAgfSksXG4gICAgICAgICAgICB5MjogdXRpbF8xLmV4dGVuZCh7fSwgeSAhPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgeyBzY2FsZTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWxfMS5ZKSwgc2lnbmFsOiBuYW1lICsgXCJbXCIgKyB5ICsgXCJdLmV4dGVudFsxXVwiIH0gOlxuICAgICAgICAgICAgICAgIHsgZmllbGQ6IHsgZ3JvdXA6ICdoZWlnaHQnIH0gfSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyOiB7IGZpbGw6IHsgdmFsdWU6ICcjZWVlJyB9IH0sXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0uY29uY2F0KG1hcmtzLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lICsgZXhwb3J0cy5CUlVTSCxcbiAgICAgICAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgIGVudGVyOiB7IGZpbGw6IHsgdmFsdWU6ICd0cmFuc3BhcmVudCcgfSB9LFxuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpbnRlcnZhbDtcbmZ1bmN0aW9uIHByb2plY3Rpb25zKHNlbENtcHQpIHtcbiAgICB2YXIgeCA9IG51bGwsIHkgPSBudWxsO1xuICAgIHNlbENtcHQucHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgIGlmIChwLmVuY29kaW5nID09PSBjaGFubmVsXzEuWCkge1xuICAgICAgICAgICAgeCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocC5lbmNvZGluZyA9PT0gY2hhbm5lbF8xLlkpIHtcbiAgICAgICAgICAgIHkgPSBpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufVxuZXhwb3J0cy5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuZnVuY3Rpb24gY2hhbm5lbFNpZ25hbChtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbCkge1xuICAgIHZhciBuYW1lID0gc2VsZWN0aW9uXzEuY2hhbm5lbFNpZ25hbE5hbWUoc2VsQ21wdCwgY2hhbm5lbCksIHNpemUgPSAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyAnd2lkdGgnIDogJ2hlaWdodCcpLCBjb29yZCA9IGNoYW5uZWwgKyBcIih1bml0KVwiLCBpbnZlcnQgPSBzZWxlY3Rpb25fMS5pbnZlcnQuYmluZChudWxsLCBtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IFtdLFxuICAgICAgICBvbjogc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCkgPyBbXSA6IGV2ZW50cyhzZWxDbXB0LCBmdW5jdGlvbiAob24sIGV2dCkge1xuICAgICAgICAgICAgb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnRzOiBldnQuYmV0d2VlblswXSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IGludmVydChcIltcIiArIGNvb3JkICsgXCIsIFwiICsgY29vcmQgKyBcIl1cIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnRzOiBldnQsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiBcIltcIiArIG5hbWUgKyBcIlswXSwgXCIgKyBpbnZlcnQoXCJjbGFtcChcIiArIGNvb3JkICsgXCIsIDAsIFwiICsgc2l6ZSArIFwiKVwiKSArICddJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb247XG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV2ZW50cyhzZWxDbXB0LCBjYikge1xuICAgIHJldHVybiBzZWxDbXB0LmV2ZW50cy5yZWR1Y2UoZnVuY3Rpb24gKG9uLCBldnQpIHtcbiAgICAgICAgaWYgKCFldnQuYmV0d2Vlbikge1xuICAgICAgICAgICAgbG9nXzEud2FybihldnQgKyBcIiBpcyBub3QgYW4gb3JkZXJlZCBldmVudCBzdHJlYW0gZm9yIGludGVydmFsIHNlbGVjdGlvbnNcIik7XG4gICAgICAgICAgICByZXR1cm4gb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKG9uLCBldnQpO1xuICAgIH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNTBaWEoyWVd3dWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXpaV3hsWTNScGIyNHZhVzUwWlhKMllXd3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeDVRMEZCTkVNN1FVRkROVU1zYVVOQlFTdENPMEZCUXk5Q0xHMURRVUVyUXp0QlFVVXZReXg1UTBGQlowZzdRVUZEYUVnc09FTkJRWGxETzBGQlJUVkNMRkZCUVVFc1MwRkJTeXhIUVVGSExGRkJRVkVzUlVGRE0wSXNVVUZCUVN4SlFVRkpMRWRCUVVjc1QwRkJUeXhEUVVGRE8wRkJSV3BDTEVsQlFVMHNVVUZCVVN4SFFVRnhRanRKUVVOcVF5eFRRVUZUTEVWQlFVVXNXVUZCV1R0SlFVVjJRaXhQUVVGUExFVkJRVVVzVlVGQlV5eExRVUZMTEVWQlFVVXNUMEZCVHp0UlFVTTVRaXhKUVVGTkxFOUJRVThzUjBGQlZTeEZRVUZGTEVWQlEzSkNMRk5CUVZNc1IwRkJVeXhGUVVGRkxFVkJRM0JDTEVsQlFVa3NSMEZCUnl4UFFVRlBMRU5CUVVNc1NVRkJTU3hGUVVOdVFpeEpRVUZKTEVkQlFVY3NTVUZCU1N4SFFVRkhMRmxCUVVrc1EwRkJRenRSUVVWMlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1UwRkJVeXhKUVVGSkxFTkJRVU1zUTBGQlF5eG5Ra0ZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9SQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eEZRVUZGTEZWQlFWTXNRMEZCVVN4RlFVRkZMRWRCUVZFN1owSkJRM3BETEVsQlFVMHNUMEZCVHl4SFFVRkhMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU03WjBKQlEzUkZMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zWjBOQlFXZERPM0ZDUVVNelF5dzRRa0ZCTkVJc2EwSkJRVmNzUTBGQlF5eEpRVUZKTEVkQlFVY3NZVUZCU3l4RFFVRkRMRTFCUVVjc1EwRkJRU3hEUVVGRExFTkJRVU03V1VGRE9VUXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRUQ3hEUVVGRE8xRkJSVVFzVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJVeXhEUVVGRE8xbEJRMmhETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhSUVVGUkxFdEJRVXNzVjBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1YwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZWtNc1ZVRkJTU3hEUVVGRExEWkVRVUUyUkN4RFFVRkRMRU5CUVVNN1owSkJRM0JGTEUxQlFVMHNRMEZCUXp0WlFVTlVMRU5CUVVNN1dVRkZSQ3hKUVVGTkxFVkJRVVVzUjBGQlJ5eGhRVUZoTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdXVUZEY2tRc1QwRkJUeXhEUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXp0WlFVTnFRaXhUUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEdGQlFWY3NhMEpCUVZjc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEd0Q1FVRmhMRVZCUVVVc1EwRkJReXhKUVVGSkxFMUJRVWNzUTBGQlF5eERRVUZETzFGQlEzcEZMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXp0WlFVTllMRWxCUVVrc1JVRkJSU3hKUVVGSk8xbEJRMVlzUzBGQlN5eEZRVUZGTEVWQlFVVTdXVUZEVkN4RlFVRkZMRVZCUVVVc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZUTEVWQlFWTXNSVUZCUlN4SFFVRlJPMmRDUVVNNVF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRPMjlDUVVOT0xFMUJRVTBzUlVGQlJTeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGRFSXNUVUZCVFN4RlFVRkZMQ3REUVVFclF6dHBRa0ZEZUVRc1EwRkJReXhEUVVGRE8yZENRVVZJTEVWQlFVVXNRMEZCUXl4SlFVRkpMRU5CUVVNN2IwSkJRMDRzVFVGQlRTeEZRVUZGTEVkQlFVYzdiMEpCUTFnc1RVRkJUU3hGUVVGRkxGTkJRVThzU1VGQlNTeGxRVUZWTEVsQlFVa3NVMEZCVFR0NVFrRkRkRU1zTUVKQlFYZENMRWxCUVVrc2JVTkJRVGhDTEVsQlFVa3NVMEZCVFN4RFFVRkJPMmxDUVVOMFJTeERRVUZETEVOQlFVTTdaMEpCUlVnc1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dFpRVU5hTEVOQlFVTXNRMEZCUXp0VFFVTklMRVZCUVVVN1dVRkRSQ3hKUVVGSkxFVkJRVVVzU1VGQlNUdFpRVU5XTEUxQlFVMHNSVUZCUlN4TlFVRkpMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVYzdVMEZEY0VNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVVFzVTBGQlV5eEZRVUZGTEZWQlFWTXNTMEZCU3l4RlFVRkZMRTlCUVU4N1VVRkRhRU1zVFVGQlRTeERRVUZETEdkQ1FVRmpMRTlCUVU4c1EwRkJReXhKUVVGTkxFTkJRVU03U1VGRGRFTXNRMEZCUXp0SlFVVkVMRlZCUVZVc1JVRkJSU3hWUVVGVExFdEJRVXNzUlVGQlJTeFBRVUZQTzFGQlEycERMRWxCUVUwc1IwRkJSeXhIUVVGSExFOUJRVThzUTBGQlF5eEpRVUZKTEVkQlFVY3NhVUpCUVVzc1EwRkJRenRSUVVOcVF5eE5RVUZOTEVOQlFVa3NSMEZCUnl4cFFrRkJXU3hIUVVGSExGZEJRVkVzUTBGQlF6dEpRVU4yUXl4RFFVRkRPMGxCUlVRc1MwRkJTeXhGUVVGRkxGVkJRVk1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4TFFVRkxPMUZCUXpkQ0xFbEJRVUVzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUTNKQ0xIbENRVUUyUWl4RlFVRTFRaXhSUVVGRExFVkJRVVVzVVVGQlF5eERRVUY1UWp0UlFVVnNReXhwUkVGQmFVUTdVVUZEYWtRc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRFppeERRVUZETzFGQlJVUXNTVUZCVFN4TlFVRk5MRWRCUVVjN1dVRkRZaXhEUVVGRExFVkJRVVVzWVVGQlRTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRXRCUVVzc1NVRkJTVHRuUWtGRGRFSXNSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFhRVUZETEVOQlFVTXNSVUZCUlN4TlFVRk5MRVZCUVVzc1NVRkJTU3hUUVVGSkxFTkJRVU1zWjBKQlFXRXNSVUZCUXp0blFrRkRPVVFzUlVGQlF5eExRVUZMTEVWQlFVVXNRMEZCUXl4RlFVRkRMRU5CUVVNN1dVRkZZaXhGUVVGRkxFVkJRVVVzWVVGQlRTeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRXRCUVVzc1NVRkJTVHRuUWtGRGRrSXNSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFhRVUZETEVOQlFVTXNSVUZCUlN4TlFVRk5MRVZCUVVzc1NVRkJTU3hUUVVGSkxFTkJRVU1zWjBKQlFXRXNSVUZCUXp0blFrRkRPVVFzUlVGQlF5eExRVUZMTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRExFVkJRVU1zUTBGQlF6dFpRVVUxUWl4RFFVRkRMRVZCUVVVc1lVRkJUU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEV0QlFVc3NTVUZCU1R0blFrRkRkRUlzUlVGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhYUVVGRExFTkJRVU1zUlVGQlJTeE5RVUZOTEVWQlFVc3NTVUZCU1N4VFFVRkpMRU5CUVVNc1owSkJRV0VzUlVGQlF6dG5Ra0ZET1VRc1JVRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eEZRVUZETEVOQlFVTTdXVUZGWWl4RlFVRkZMRVZCUVVVc1lVRkJUU3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEV0QlFVc3NTVUZCU1R0blFrRkRka0lzUlVGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhYUVVGRExFTkJRVU1zUlVGQlJTeE5RVUZOTEVWQlFVc3NTVUZCU1N4VFFVRkpMRU5CUVVNc1owSkJRV0VzUlVGQlF6dG5Ra0ZET1VRc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RlFVRkRMRVZCUVVNc1EwRkJRenRUUVVNNVFpeERRVUZETzFGQlJVWXNUVUZCVFN4RFFVRkRMRU5CUVVNN1owSkJRMDRzU1VGQlNTeEZRVUZGTEZOQlFWTTdaMEpCUTJZc1NVRkJTU3hGUVVGRkxFMUJRVTA3WjBKQlExb3NUVUZCVFN4RlFVRkZPMjlDUVVOT0xFdEJRVXNzUlVGQlJTeEZRVUZETEVsQlFVa3NSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hOUVVGTkxFVkJRVU1zUlVGQlF6dHZRa0ZET1VJc1RVRkJUU3hGUVVGRkxFMUJRVTA3YVVKQlEyWTdZVUZEUml4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJUdFpRVU5tTEVsQlFVa3NSVUZCUlN4SlFVRkpMRWRCUVVjc1lVRkJTenRaUVVOc1FpeEpRVUZKTEVWQlFVVXNUVUZCVFR0WlFVTmFMRTFCUVUwc1JVRkJSVHRuUWtGRFRpeExRVUZMTEVWQlFVVXNSVUZCUXl4SlFVRkpMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzWVVGQllTeEZRVUZETEVWQlFVTTdaMEpCUTNKRExFMUJRVTBzUlVGQlJTeE5RVUZOTzJGQlEyWTdVMEZEUml4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wTkJRMFlzUTBGQlF6dEJRVU5yUWl3eVFrRkJUenRCUVVVelFpeHhRa0ZCTkVJc1QwRkJNa0k3U1VGRGNrUXNTVUZCU1N4RFFVRkRMRWRCUVZVc1NVRkJTU3hGUVVGRkxFTkJRVU1zUjBGQlZTeEpRVUZKTEVOQlFVTTdTVUZEY2tNc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eFBRVUZQTEVOQlFVTXNWVUZCVXl4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVOdVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExGZEJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY2tJc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dFJRVU5TTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNTMEZCU3l4WFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRelZDTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1VVRkRVaXhEUVVGRE8wbEJRMGdzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEU0N4TlFVRk5MRU5CUVVNc1JVRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVNc1EwRkJRenRCUVVOMFFpeERRVUZETzBGQlZrUXNhME5CVlVNN1FVRkZSQ3gxUWtGQmRVSXNTMEZCWjBJc1JVRkJSU3hQUVVFeVFpeEZRVUZGTEU5QlFXZENPMGxCUTNCR0xFbEJRVTBzU1VGQlNTeEhRVUZKTERaQ1FVRnBRaXhEUVVGRExFOUJRVThzUlVGQlJTeFBRVUZQTEVOQlFVTXNSVUZETjBNc1NVRkJTU3hIUVVGSkxFTkJRVU1zVDBGQlR5eExRVUZMTEZkQlFVTXNSMEZCUnl4UFFVRlBMRWRCUVVjc1VVRkJVU3hEUVVGRExFVkJRelZETEV0QlFVc3NSMEZCVFN4UFFVRlBMRmRCUVZFc1JVRkRNVUlzVFVGQlRTeEhRVUZITEd0Q1FVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUlVGQlJTeExRVUZMTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJSVEZFTEUxQlFVMHNRMEZCUXp0UlFVTk1MRWxCUVVrc1JVRkJSU3hKUVVGSk8xRkJRMVlzUzBGQlN5eEZRVUZGTEVWQlFVVTdVVUZEVkN4RlFVRkZMRVZCUVVVc1owSkJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRWRCUVVjc1JVRkJSU3hIUVVGSExFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNWVUZCVXl4RlFVRlRMRVZCUVVVc1IwRkJVVHRaUVVONlJTeEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRPMmRDUVVOT0xFMUJRVTBzUlVGQlJTeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGRFSXNUVUZCVFN4RlFVRkZMRTFCUVUwc1EwRkJReXhOUVVGSkxFdEJRVXNzVlVGQlN5eExRVUZMTEUxQlFVY3NRMEZCUXp0aFFVTjJReXhEUVVGRExFTkJRVU03V1VGRlNDeEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRPMmRDUVVOT0xFMUJRVTBzUlVGQlJTeEhRVUZITzJkQ1FVTllMRTFCUVUwc1JVRkJSU3hOUVVGSkxFbEJRVWtzVlVGQlR5eEhRVUZITEUxQlFVMHNRMEZCUXl4WFFVRlRMRXRCUVVzc1lVRkJVU3hKUVVGSkxFMUJRVWNzUTBGQlF5eEhRVUZITEVkQlFVYzdZVUZEZEVVc1EwRkJReXhEUVVGRE8xbEJSVWdzVFVGQlRTeERRVUZETEVWQlFVVXNRMEZCUXp0UlFVTmFMRU5CUVVNc1EwRkJRenRMUVVOSUxFTkJRVU03UVVGRFNpeERRVUZETzBGQlJVUXNaMEpCUVdkQ0xFOUJRVEpDTEVWQlFVVXNSVUZCV1R0SlFVTjJSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJVeXhGUVVGVExFVkJRVVVzUjBGQlVUdFJRVU4yUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xGVkJRVWtzUTBGQlNTeEhRVUZITERSRVFVRjVSQ3hEUVVGRExFTkJRVU03V1VGRGRFVXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJRenRSUVVOYUxFTkJRVU03VVVGRFJDeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU55UWl4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03UVVGRFZDeERRVUZESW4wPSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vc2VsZWN0aW9uXCIpO1xudmFyIG11bHRpID0ge1xuICAgIHByZWRpY2F0ZTogJ3ZsUG9pbnQnLFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgcHJvaiA9IHNlbENtcHQucHJvamVjdCwgZGF0dW0gPSAnKGl0ZW0oKS5pc1Zvcm9ub2kgPyBkYXR1bS5kYXR1bSA6IGRhdHVtKScsIGZpZWxkcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB1dGlsXzEuc3RyaW5nVmFsdWUocC5maWVsZCk7IH0pLmpvaW4oJywgJyksIHZhbHVlcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBkYXR1bSArIFwiW1wiICsgdXRpbF8xLnN0cmluZ1ZhbHVlKHAuZmllbGQpICsgXCJdXCI7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlbENtcHQubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge30sXG4gICAgICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IHNlbENtcHQuZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBcIntmaWVsZHM6IFtcIiArIGZpZWxkcyArIFwiXSwgdmFsdWVzOiBbXCIgKyB2YWx1ZXMgKyBcIl19XCJcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dO1xuICAgIH0sXG4gICAgdHVwbGVFeHByOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWU7XG4gICAgICAgIHJldHVybiBcImZpZWxkczogXCIgKyBuYW1lICsgXCIuZmllbGRzLCB2YWx1ZXM6IFwiICsgbmFtZSArIFwiLnZhbHVlc1wiO1xuICAgIH0sXG4gICAgbW9kaWZ5RXhwcjogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0Lm5hbWUgKyBzZWxlY3Rpb25fMS5UVVBMRTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbXVsdGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liWFZzZEdrdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOHVMaTh1TGk5emNtTXZZMjl0Y0dsc1pTOXpaV3hsWTNScGIyNHZiWFZzZEdrdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN4dFEwRkJkVU03UVVGRGRrTXNlVU5CUVhGRU8wRkJSWEpFTEVsQlFVMHNTMEZCU3l4SFFVRnhRanRKUVVNNVFpeFRRVUZUTEVWQlFVVXNVMEZCVXp0SlFVVndRaXhQUVVGUExFVkJRVVVzVlVGQlV5eExRVUZMTEVWQlFVVXNUMEZCVHp0UlFVTTVRaXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVTjRRaXhMUVVGTExFZEJRVWtzTUVOQlFUQkRMRVZCUTI1RUxFMUJRVTBzUjBGQlJ5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRlZCUVVNc1EwRkJReXhKUVVGTExFOUJRVUVzYTBKQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRWEJDTEVOQlFXOUNMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVWQlEzcEVMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNRMEZCUXl4SlFVRkxMRTlCUVVjc1MwRkJTeXhUUVVGSkxHdENRVUZYTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhOUVVGSExFVkJRVzVETEVOQlFXMURMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZETjBVc1RVRkJUU3hEUVVGRExFTkJRVU03WjBKQlEwNHNTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhKUVVGSk8yZENRVU5zUWl4TFFVRkxMRVZCUVVVc1JVRkJSVHRuUWtGRFZDeEZRVUZGTEVWQlFVVXNRMEZCUXp0M1FrRkRTQ3hOUVVGTkxFVkJRVVVzVDBGQlR5eERRVUZETEUxQlFVMDdkMEpCUTNSQ0xFMUJRVTBzUlVGQlJTeGxRVUZoTEUxQlFVMHNiMEpCUVdVc1RVRkJUU3hQUVVGSk8zRkNRVU55UkN4RFFVRkRPMkZCUTBnc1EwRkJReXhEUVVGRE8wbEJRMHdzUTBGQlF6dEpRVVZFTEZOQlFWTXNSVUZCUlN4VlFVRlRMRXRCUVVzc1JVRkJSU3hQUVVGUE8xRkJRMmhETEVsQlFVMHNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRE1VSXNUVUZCVFN4RFFVRkRMR0ZCUVZjc1NVRkJTU3g1UWtGQmIwSXNTVUZCU1N4WlFVRlRMRU5CUVVNN1NVRkRNVVFzUTBGQlF6dEpRVVZFTEZWQlFWVXNSVUZCUlN4VlFVRlRMRXRCUVVzc1JVRkJSU3hQUVVGUE8xRkJRMnBETEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hIUVVGSExHbENRVUZMTEVOQlFVTTdTVUZET1VJc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRlpTeDNRa0ZCVHlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlZ2FfZXZlbnRfc2VsZWN0b3JfMSA9IHJlcXVpcmUoXCJ2ZWdhLWV2ZW50LXNlbGVjdG9yXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGludGVydmFsXzEgPSByZXF1aXJlKFwiLi9pbnRlcnZhbFwiKTtcbnZhciBtdWx0aV8xID0gcmVxdWlyZShcIi4vbXVsdGlcIik7XG52YXIgc2luZ2xlXzEgPSByZXF1aXJlKFwiLi9zaW5nbGVcIik7XG52YXIgdHJhbnNmb3Jtc18xID0gcmVxdWlyZShcIi4vdHJhbnNmb3Jtcy90cmFuc2Zvcm1zXCIpO1xuZXhwb3J0cy5TVE9SRSA9ICdfc3RvcmUnLCBleHBvcnRzLlRVUExFID0gJ190dXBsZScsIGV4cG9ydHMuTU9ESUZZID0gJ19tb2RpZnknO1xuZnVuY3Rpb24gcGFyc2VVbml0U2VsZWN0aW9uKG1vZGVsLCBzZWxEZWZzKSB7XG4gICAgdmFyIHNlbENtcHRzID0ge30sIHNlbGVjdGlvbkNvbmZpZyA9IG1vZGVsLmNvbmZpZy5zZWxlY3Rpb247XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAobmFtZV8xKSB7XG4gICAgICAgIGlmICghc2VsRGVmcy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxEZWYgPSBzZWxEZWZzW25hbWVfMV0sIGNmZyA9IHNlbGVjdGlvbkNvbmZpZ1tzZWxEZWYudHlwZV07XG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBmcm9tIGNvbmZpZyBpZiBhIHByb3BlcnR5IGhhc24ndCBiZWVuIHNwZWNpZmllZCxcbiAgICAgICAgLy8gb3IgaWYgaXQgaXMgdHJ1ZS4gRS5nLiwgXCJ0cmFuc2xhdGVcIjogdHJ1ZSBzaG91bGQgdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGV2ZW50IGhhbmRsZXJzIGZvciB0cmFuc2xhdGUuIEhvd2V2ZXIsIHRydWUgbWF5IGJlIGEgdmFsaWQgdmFsdWUgZm9yXG4gICAgICAgIC8vIGEgcHJvcGVydHkgKGUuZy4sIFwibmVhcmVzdFwiOiB0cnVlKS5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNmZykge1xuICAgICAgICAgICAgLy8gQSBzZWxlY3Rpb24gc2hvdWxkIGNvbnRhaW4gZWl0aGVyIGBlbmNvZGluZ3NgIG9yIGBmaWVsZHNgLCBvbmx5IHVzZVxuICAgICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZXNlIHR3byB2YWx1ZXMgaWYgbmVpdGhlciBvZiB0aGVtIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgIGlmICgoa2V5ID09PSAnZW5jb2RpbmdzJyAmJiBzZWxEZWYuZmllbGRzKSB8fCAoa2V5ID09PSAnZmllbGRzJyAmJiBzZWxEZWYuZW5jb2RpbmdzKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbERlZltrZXldID09PSB1bmRlZmluZWQgfHwgc2VsRGVmW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxEZWZba2V5XSA9IGNmZ1trZXldIHx8IHNlbERlZltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxDbXB0ID0gc2VsQ21wdHNbbmFtZV8xXSA9IHV0aWxfMS5leHRlbmQoe30sIHNlbERlZiwge1xuICAgICAgICAgICAgbmFtZTogbW9kZWwuZ2V0TmFtZShuYW1lXzEpLFxuICAgICAgICAgICAgZXZlbnRzOiB1dGlsXzEuaXNTdHJpbmcoc2VsRGVmLm9uKSA/IHZlZ2FfZXZlbnRfc2VsZWN0b3JfMS5zZWxlY3RvcihzZWxEZWYub24sICdzY29wZScpIDogc2VsRGVmLm9uLFxuICAgICAgICAgICAgZG9tYWluOiAnZGF0YScsXG4gICAgICAgICAgICByZXNvbHZlOiAndW5pb24nXG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc2Zvcm1zXzEuZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCBmdW5jdGlvbiAodHhDb21waWxlcikge1xuICAgICAgICAgICAgaWYgKHR4Q29tcGlsZXIucGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0eENvbXBpbGVyLnBhcnNlKG1vZGVsLCBzZWxEZWYsIHNlbENtcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIG5hbWVfMSBpbiBzZWxEZWZzKSB7XG4gICAgICAgIF9sb29wXzEobmFtZV8xKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbENtcHRzO1xufVxuZXhwb3J0cy5wYXJzZVVuaXRTZWxlY3Rpb24gPSBwYXJzZVVuaXRTZWxlY3Rpb247XG5mdW5jdGlvbiBhc3NlbWJsZVVuaXRTaWduYWxzKG1vZGVsLCBzaWduYWxzKSB7XG4gICAgZm9yRWFjaFNlbGVjdGlvbihtb2RlbCwgZnVuY3Rpb24gKHNlbENtcHQsIHNlbENvbXBpbGVyKSB7XG4gICAgICAgIHZhciBuYW1lID0gc2VsQ21wdC5uYW1lLCB0dXBsZUV4cHIgPSBzZWxDb21waWxlci50dXBsZUV4cHIobW9kZWwsIHNlbENtcHQpO1xuICAgICAgICB2YXIgbW9kaWZ5RXhwciA9IHNlbENvbXBpbGVyLm1vZGlmeUV4cHIobW9kZWwsIHNlbENtcHQpO1xuICAgICAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgc2VsQ29tcGlsZXIuc2lnbmFscyhtb2RlbCwgc2VsQ21wdCkpO1xuICAgICAgICB0cmFuc2Zvcm1zXzEuZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCBmdW5jdGlvbiAodHhDb21waWxlcikge1xuICAgICAgICAgICAgaWYgKHR4Q29tcGlsZXIuc2lnbmFscykge1xuICAgICAgICAgICAgICAgIHNpZ25hbHMgPSB0eENvbXBpbGVyLnNpZ25hbHMobW9kZWwsIHNlbENtcHQsIHNpZ25hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Q29tcGlsZXIubW9kaWZ5RXhwcikge1xuICAgICAgICAgICAgICAgIG1vZGlmeUV4cHIgPSB0eENvbXBpbGVyLm1vZGlmeUV4cHIobW9kZWwsIHNlbENtcHQsIG1vZGlmeUV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2lnbmFscy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBleHBvcnRzLlRVUExFLFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogeyBzaWduYWw6IG5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBcInt1bml0OiB1bml0LmRhdHVtICYmIHVuaXQuZGF0dW0uX2lkLCBcIiArIHR1cGxlRXhwciArIFwifVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogbmFtZSArIGV4cG9ydHMuTU9ESUZZLFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogeyBzaWduYWw6IG5hbWUgfSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBcIm1vZGlmeShcIiArIHV0aWxfMS5zdHJpbmdWYWx1ZShuYW1lICsgZXhwb3J0cy5TVE9SRSkgKyBcIiwgXCIgKyBtb2RpZnlFeHByICsgXCIpXCJcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbmFscztcbn1cbmV4cG9ydHMuYXNzZW1ibGVVbml0U2lnbmFscyA9IGFzc2VtYmxlVW5pdFNpZ25hbHM7XG5mdW5jdGlvbiBhc3NlbWJsZVRvcExldmVsU2lnbmFscyhtb2RlbCkge1xuICAgIHZhciBzaWduYWxzID0gW3tcbiAgICAgICAgICAgIG5hbWU6ICd1bml0JyxcbiAgICAgICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgICAgIG9uOiBbeyBldmVudHM6ICdtb3VzZW1vdmUnLCB1cGRhdGU6ICdncm91cCgpLl9pZCA/IGdyb3VwKCkgOiB1bml0JyB9XVxuICAgICAgICB9XTtcbiAgICBmb3JFYWNoU2VsZWN0aW9uKG1vZGVsLCBmdW5jdGlvbiAoc2VsQ21wdCwgc2VsQ29tcGlsZXIpIHtcbiAgICAgICAgaWYgKHNlbENvbXBpbGVyLnRvcExldmVsU2lnbmFscykge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIHNlbENvbXBpbGVyLnRvcExldmVsU2lnbmFscyhtb2RlbCwgc2VsQ21wdCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybXNfMS5mb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIGZ1bmN0aW9uICh0eENvbXBpbGVyKSB7XG4gICAgICAgICAgICBpZiAodHhDb21waWxlci50b3BMZXZlbFNpZ25hbHMpIHtcbiAgICAgICAgICAgICAgICBzaWduYWxzID0gdHhDb21waWxlci50b3BMZXZlbFNpZ25hbHMobW9kZWwsIHNlbENtcHQsIHNpZ25hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbmFscztcbn1cbmV4cG9ydHMuYXNzZW1ibGVUb3BMZXZlbFNpZ25hbHMgPSBhc3NlbWJsZVRvcExldmVsU2lnbmFscztcbmZ1bmN0aW9uIGFzc2VtYmxlVW5pdERhdGEobW9kZWwsIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YVxuICAgICAgICAuY29uY2F0KE9iamVjdC5rZXlzKG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb24pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogayArIGV4cG9ydHMuU1RPUkUgfTtcbiAgICB9KSk7XG59XG5leHBvcnRzLmFzc2VtYmxlVW5pdERhdGEgPSBhc3NlbWJsZVVuaXREYXRhO1xuZnVuY3Rpb24gYXNzZW1ibGVVbml0TWFya3MobW9kZWwsIG1hcmtzKSB7XG4gICAgdmFyIGNsaXBwZWRHcm91cCA9IGZhbHNlLCBzZWxNYXJrcyA9IG1hcmtzO1xuICAgIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIGZ1bmN0aW9uIChzZWxDbXB0LCBzZWxDb21waWxlcikge1xuICAgICAgICBzZWxNYXJrcyA9IHNlbENvbXBpbGVyLm1hcmtzID8gc2VsQ29tcGlsZXIubWFya3MobW9kZWwsIHNlbENtcHQsIHNlbE1hcmtzKSA6IHNlbE1hcmtzO1xuICAgICAgICB0cmFuc2Zvcm1zXzEuZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCBmdW5jdGlvbiAodHhDb21waWxlcikge1xuICAgICAgICAgICAgY2xpcHBlZEdyb3VwID0gY2xpcHBlZEdyb3VwIHx8IHR4Q29tcGlsZXIuY2xpcHBlZEdyb3VwO1xuICAgICAgICAgICAgaWYgKHR4Q29tcGlsZXIubWFya3MpIHtcbiAgICAgICAgICAgICAgICBzZWxNYXJrcyA9IHR4Q29tcGlsZXIubWFya3MobW9kZWwsIHNlbENtcHQsIG1hcmtzLCBzZWxNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChjbGlwcGVkR3JvdXApIHtcbiAgICAgICAgc2VsTWFya3MgPSBbe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdncm91cCcsXG4gICAgICAgICAgICAgICAgZW5jb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogeyBmaWVsZDogeyBncm91cDogJ3dpZHRoJyB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHsgZmllbGQ6IHsgZ3JvdXA6ICdoZWlnaHQnIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IHsgdmFsdWU6ICd0cmFuc3BhcmVudCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXA6IHsgdmFsdWU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXJrczogc2VsTWFya3MubWFwKG1vZGVsLmNvcnJlY3REYXRhTmFtZXMpXG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbE1hcmtzO1xufVxuZXhwb3J0cy5hc3NlbWJsZVVuaXRNYXJrcyA9IGFzc2VtYmxlVW5pdE1hcmtzO1xudmFyIFBSRURJQ0FURVNfT1BTID0ge1xuICAgICdzaW5nbGUnOiAnXCJpbnRlcnNlY3RcIiwgXCJhbGxcIicsXG4gICAgJ2luZGVwZW5kZW50JzogJ1wiaW50ZXJzZWN0XCIsIFwidW5pdFwiJyxcbiAgICAndW5pb24nOiAnXCJ1bmlvblwiLCBcImFsbFwiJyxcbiAgICAndW5pb25fb3RoZXJzJzogJ1widW5pb25cIiwgXCJvdGhlcnNcIicsXG4gICAgJ2ludGVyc2VjdCc6ICdcImludGVyc2VjdFwiLCBcImFsbFwiJyxcbiAgICAnaW50ZXJzZWN0X290aGVycyc6ICdcImludGVyc2VjdFwiLCBcIm90aGVycydcbn07XG5mdW5jdGlvbiBwcmVkaWNhdGUoc2VsQ21wdCwgZGF0dW0pIHtcbiAgICB2YXIgc3RvcmUgPSB1dGlsXzEuc3RyaW5nVmFsdWUoc2VsQ21wdC5uYW1lICsgZXhwb3J0cy5TVE9SRSksIG9wID0gUFJFRElDQVRFU19PUFNbc2VsQ21wdC5yZXNvbHZlXTtcbiAgICBkYXR1bSA9IGRhdHVtIHx8ICdkYXR1bSc7XG4gICAgcmV0dXJuIGNvbXBpbGVyKHNlbENtcHQpLnByZWRpY2F0ZSArIChcIihcIiArIHN0b3JlICsgXCIsIHBhcmVudC5faWQsIFwiICsgZGF0dW0gKyBcIiwgXCIgKyBvcCArIFwiKVwiKTtcbn1cbmV4cG9ydHMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuLy8gVXRpbGl0eSBmdW5jdGlvbnNcbmZ1bmN0aW9uIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIGNiKSB7XG4gICAgdmFyIHNlbGVjdGlvbnMgPSBtb2RlbC5jb21wb25lbnQuc2VsZWN0aW9uO1xuICAgIGZvciAodmFyIG5hbWVfMiBpbiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmhhc093blByb3BlcnR5KG5hbWVfMikpIHtcbiAgICAgICAgICAgIHZhciBzZWwgPSBzZWxlY3Rpb25zW25hbWVfMl07XG4gICAgICAgICAgICBjYihzZWwsIGNvbXBpbGVyKHNlbCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZXIoc2VsQ21wdCkge1xuICAgIHN3aXRjaCAoc2VsQ21wdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlXzEuZGVmYXVsdDtcbiAgICAgICAgY2FzZSAnbXVsdGknOlxuICAgICAgICAgICAgcmV0dXJuIG11bHRpXzEuZGVmYXVsdDtcbiAgICAgICAgY2FzZSAnaW50ZXJ2YWwnOlxuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsXzEuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpbnZlcnQobW9kZWwsIHNlbENtcHQsIGNoYW5uZWwsIGV4cHIpIHtcbiAgICB2YXIgc2NhbGUgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpKTtcbiAgICByZXR1cm4gc2VsQ21wdC5kb21haW4gPT09ICdkYXRhJyA/IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyBcIiwgXCIgKyBleHByICsgXCIpXCIgOiBleHByO1xufVxuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5mdW5jdGlvbiBjaGFubmVsU2lnbmFsTmFtZShzZWxDbXB0LCBjaGFubmVsKSB7XG4gICAgcmV0dXJuIHNlbENtcHQubmFtZSArICdfJyArIGNoYW5uZWw7XG59XG5leHBvcnRzLmNoYW5uZWxTaWduYWxOYW1lID0gY2hhbm5lbFNpZ25hbE5hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMlZzWldOMGFXOXVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YzJWc1pXTjBhVzl1TDNObGJHVmpkR2x2Ymk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVUZCTERKRVFVRTRSRHRCUVVjNVJDeHRRMEZCSzBRN1FVRkpMMFFzZFVOQlFUQkRPMEZCUXpGRExHbERRVUZ2UXp0QlFVVndReXh0UTBGQmMwTTdRVUZEZEVNc2MwUkJRWGxFTzBGQlJUVkRMRkZCUVVFc1MwRkJTeXhIUVVGSExGRkJRVkVzUlVGRE0wSXNVVUZCUVN4TFFVRkxMRWRCUVVrc1VVRkJVU3hGUVVOcVFpeFJRVUZCTEUxQlFVMHNSMEZCUnl4VFFVRlRMRU5CUVVNN1FVRnJRM0pDTERSQ1FVRnRReXhMUVVGblFpeEZRVUZGTEU5QlFUSkNPMGxCUXpsRkxFbEJRVTBzVVVGQlVTeEhRVUUyUWl4RlFVRkZMRVZCUTNwRExHVkJRV1VzUjBGQlJ5eExRVUZMTEVOQlFVTXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenMwUWtGRmJFTXNUVUZCU1R0UlFVTmlMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEdOQlFXTXNRMEZCUXl4TlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03TzFGQlJYQkRMRU5CUVVNN1VVRkZSQ3hKUVVGTkxFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCU1N4RFFVRkRMRVZCUTNoQ0xFZEJRVWNzUjBGQlJ5eGxRVUZsTEVOQlFVTXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSWFpETEhORlFVRnpSVHRSUVVOMFJTeHRSVUZCYlVVN1VVRkRia1VzZFVWQlFYVkZPMUZCUTNaRkxITkRRVUZ6UXp0UlFVTjBReXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZOTEVkQlFVY3NTVUZCU1N4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM1JDTEhORlFVRnpSVHRaUVVOMFJTeDFSVUZCZFVVN1dVRkRka1VzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRXRCUVVzc1YwRkJWeXhKUVVGSkxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWRCUVVjc1MwRkJTeXhSUVVGUkxFbEJRVWtzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGNrWXNVVUZCVVN4RFFVRkRPMWxCUTFnc1EwRkJRenRaUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhUUVVGVExFbEJRVWtzVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzUkVMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zUjBGQlJ5eEhRVUZITEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1RVRkJUU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzFsQlEzaERMRU5CUVVNN1VVRkRTQ3hEUVVGRE8xRkJSVVFzU1VGQlRTeFBRVUZQTEVkQlFVY3NVVUZCVVN4RFFVRkRMRTFCUVVrc1EwRkJReXhIUVVGSExHRkJRVTBzUTBGQlF5eEZRVUZGTEVWQlFVVXNUVUZCVFN4RlFVRkZPMWxCUTJ4RUxFbEJRVWtzUlVGQlJTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVVrc1EwRkJRenRaUVVONlFpeE5RVUZOTEVWQlFVVXNaVUZCVVN4RFFVRkRMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU1zUjBGQlJ5dzRRa0ZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhGUVVGRkxFVkJRVVVzVDBGQlR5eERRVUZETEVkQlFVY3NUVUZCVFN4RFFVRkRMRVZCUVVVN1dVRkRNMFVzVFVGQlRTeEZRVUZGTEUxQlFYbENPMWxCUTJwRExFOUJRVThzUlVGQlJTeFBRVUVyUWp0VFFVTjZReXhEUVVGMVFpeERRVUZETzFGQlJYcENMRFpDUVVGblFpeERRVUZETEU5QlFVOHNSVUZCUlN4VlFVRlRMRlZCUVZVN1dVRkRNME1zUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzSkNMRlZCUVZVc1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eEZRVUZGTEUxQlFVMHNSVUZCUlN4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVNelF5eERRVUZETzFGQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJjRU5FTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVUwc1RVRkJTU3hKUVVGSkxFOUJRVThzUTBGQlF6dG5Ra0ZCYUVJc1RVRkJTVHRMUVc5RFpEdEpRVVZFTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1FVRkRiRUlzUTBGQlF6dEJRVE5EUkN4blJFRXlRME03UVVGRlJDdzJRa0ZCYjBNc1MwRkJaMElzUlVGQlJTeFBRVUZqTzBsQlEyeEZMR2RDUVVGblFpeERRVUZETEV0QlFVc3NSVUZCUlN4VlFVRlRMRTlCUVU4c1JVRkJSU3hYUVVGWE8xRkJRMjVFTEVsQlFVMHNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRM0pDTEZOQlFWTXNSMEZCUnl4WFFVRlhMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTjBSQ3hKUVVGSkxGVkJRVlVzUjBGQlJ5eFhRVUZYTEVOQlFVTXNWVUZCVlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVVY0UkN4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNWMEZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhMUVVGTExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVVnFSU3cyUWtGQlowSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJVeXhWUVVGVk8xbEJRek5ETEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTjJRaXhQUVVGUExFZEJRVWNzVlVGQlZTeERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFsQlEzaEVMRU5CUVVNN1dVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE1VSXNWVUZCVlN4SFFVRkhMRlZCUVZVc1EwRkJReXhWUVVGVkxFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4VlFVRlZMRU5CUVVNc1EwRkJRenRaUVVOcVJTeERRVUZETzFGQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkZTQ3hQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETzFsQlExZ3NTVUZCU1N4RlFVRkZMRWxCUVVrc1IwRkJSeXhoUVVGTE8xbEJRMnhDTEVWQlFVVXNSVUZCUlN4RFFVRkRPMjlDUVVOSUxFMUJRVTBzUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4SlFVRkpMRVZCUVVNN2IwSkJRM1JDTEUxQlFVMHNSVUZCUlN3d1EwRkJkME1zVTBGQlV5eE5RVUZITzJsQ1FVTTNSQ3hEUVVGRE8xTkJRMGdzUlVGQlJUdFpRVU5FTEVsQlFVa3NSVUZCUlN4SlFVRkpMRWRCUVVjc1kwRkJUVHRaUVVOdVFpeEZRVUZGTEVWQlFVVXNRMEZCUXp0dlFrRkRTQ3hOUVVGTkxFVkJRVVVzUlVGQlF5eE5RVUZOTEVWQlFVVXNTVUZCU1N4RlFVRkRPMjlDUVVOMFFpeE5RVUZOTEVWQlFVVXNXVUZCVlN4clFrRkJWeXhEUVVGRExFbEJRVWtzUjBGQlJ5eGhRVUZMTEVOQlFVTXNWVUZCU3l4VlFVRlZMRTFCUVVjN2FVSkJRemxFTEVOQlFVTTdVMEZEU0N4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRExFTkJRVU1zUTBGQlF6dEpRVVZJTEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNN1FVRkRha0lzUTBGQlF6dEJRV3BEUkN4clJFRnBRME03UVVGRlJDeHBRMEZCZDBNc1MwRkJXVHRKUVVOc1JDeEpRVUZKTEU5QlFVOHNSMEZCVXl4RFFVRkRPMWxCUTI1Q0xFbEJRVWtzUlVGQlJTeE5RVUZOTzFsQlExb3NTMEZCU3l4RlFVRkZMRVZCUVVVN1dVRkRWQ3hGUVVGRkxFVkJRVVVzUTBGQlF5eEZRVUZETEUxQlFVMHNSVUZCUlN4WFFVRlhMRVZCUVVVc1RVRkJUU3hGUVVGRkxEaENRVUU0UWl4RlFVRkRMRU5CUVVNN1UwRkRjRVVzUTBGQlF5eERRVUZETzBsQlJVZ3NaMEpCUVdkQ0xFTkJRVU1zUzBGQlN5eEZRVUZGTEZWQlFWTXNUMEZCVHl4RlFVRkZMRmRCUVZjN1VVRkRia1FzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMR1ZCUVdVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eEZRVUZGTEZkQlFWY3NRMEZCUXl4bFFVRmxMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBVc1EwRkJRenRSUVVWRUxEWkNRVUZuUWl4RFFVRkRMRTlCUVU4c1JVRkJSU3hWUVVGVExGVkJRVlU3V1VGRE0wTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRV1VzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXk5Q0xFOUJRVThzUjBGQlJ5eFZRVUZWTEVOQlFVTXNaVUZCWlN4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEYUVVc1EwRkJRenRSUVVOSUxFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEwd3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzBGQlEycENMRU5CUVVNN1FVRndRa1FzTUVSQmIwSkRPMEZCUlVRc01FSkJRV2xETEV0QlFXZENMRVZCUVVVc1NVRkJZenRKUVVNdlJDeE5RVUZOTEVOQlFVTXNTVUZCU1R0VFFVTlNMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1UwRkJVeXhEUVVGRE8xTkJRek5ETEVkQlFVY3NRMEZCUXl4VlFVRlRMRU5CUVZNN1VVRkRja0lzVFVGQlRTeERRVUZETEVWQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhoUVVGTExFVkJRVU1zUTBGQlF6dEpRVU16UWl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRMVlzUTBGQlF6dEJRVTVFTERSRFFVMURPMEZCUlVRc01rSkJRV3RETEV0QlFXZENMRVZCUVVVc1MwRkJXVHRKUVVNNVJDeEpRVUZKTEZsQlFWa3NSMEZCUnl4TFFVRkxMRVZCUTNCQ0xGRkJRVkVzUjBGQlJ5eExRVUZMTEVOQlFVTTdTVUZEY2tJc1owSkJRV2RDTEVOQlFVTXNTMEZCU3l4RlFVRkZMRlZCUVZNc1QwRkJUeXhGUVVGRkxGZEJRVmM3VVVGRGJrUXNVVUZCVVN4SFFVRkhMRmRCUVZjc1EwRkJReXhMUVVGTExFZEJRVWNzVjBGQlZ5eERRVUZETEV0QlFVc3NRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxGRkJRVkVzUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXp0UlFVTjBSaXcyUWtGQlowSXNRMEZCUXl4UFFVRlBMRVZCUVVVc1ZVRkJVeXhWUVVGVk8xbEJRek5ETEZsQlFWa3NSMEZCUnl4WlFVRlpMRWxCUVVrc1ZVRkJWU3hEUVVGRExGbEJRVmtzUTBGQlF6dFpRVU4yUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhWUVVGVkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRja0lzVVVGQlVTeEhRVUZITEZWQlFWVXNRMEZCUXl4TFFVRkxMRU5CUVVNc1MwRkJTeXhGUVVGRkxFOUJRVThzUlVGQlJTeExRVUZMTEVWQlFVVXNVVUZCVVN4RFFVRkRMRU5CUVVNN1dVRkRMMFFzUTBGQlF6dFJRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJReXhEUVVGRExFTkJRVU03U1VGRlNDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBDTEZGQlFWRXNSMEZCUnl4RFFVRkRPMmRDUVVOV0xFbEJRVWtzUlVGQlJTeFBRVUZQTzJkQ1FVTmlMRTFCUVUwc1JVRkJSVHR2UWtGRFRpeExRVUZMTEVWQlFVVTdkMEpCUTB3c1MwRkJTeXhGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEVWQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJReXhGUVVGRE8zZENRVU5vUXl4TlFVRk5MRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RlFVRkRMRVZCUVVNN2QwSkJRMnhETEVsQlFVa3NSVUZCUlN4RlFVRkRMRXRCUVVzc1JVRkJSU3hoUVVGaExFVkJRVU03ZDBKQlF6VkNMRWxCUVVrc1JVRkJSU3hGUVVGRExFdEJRVXNzUlVGQlJTeEpRVUZKTEVWQlFVTTdjVUpCUTNCQ08ybENRVU5HTzJkQ1FVTkVMRXRCUVVzc1JVRkJSU3hSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEV0QlFVc3NRMEZCUXl4blFrRkJaMElzUTBGQlF6dGhRVU0xUXl4RFFVRkRMRU5CUVVNN1NVRkRUQ3hEUVVGRE8wbEJSVVFzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXp0QlFVTnNRaXhEUVVGRE8wRkJOMEpFTERoRFFUWkNRenRCUVVWRUxFbEJRVTBzWTBGQll5eEhRVUZITzBsQlEzSkNMRkZCUVZFc1JVRkJSU3h2UWtGQmIwSTdTVUZET1VJc1lVRkJZU3hGUVVGRkxIRkNRVUZ4UWp0SlFVTndReXhQUVVGUExFVkJRVVVzWjBKQlFXZENPMGxCUTNwQ0xHTkJRV01zUlVGQlJTeHRRa0ZCYlVJN1NVRkRia01zVjBGQlZ5eEZRVUZGTEc5Q1FVRnZRanRKUVVOcVF5eHJRa0ZCYTBJc1JVRkJSU3h6UWtGQmMwSTdRMEZETTBNc1EwRkJRenRCUVVWR0xHMUNRVUV3UWl4UFFVRXlRaXhGUVVGRkxFdEJRV003U1VGRGJrVXNTVUZCVFN4TFFVRkxMRWRCUVVjc2EwSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4SFFVRkhMR0ZCUVVzc1EwRkJReXhGUVVONlF5eEZRVUZGTEVkQlFVY3NZMEZCWXl4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU16UXl4TFFVRkxMRWRCUVVjc1MwRkJTeXhKUVVGSkxFOUJRVThzUTBGQlF6dEpRVU42UWl4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEZOQlFWTXNTVUZCUnl4TlFVRkpMRXRCUVVzc2MwSkJRV2xDTEV0QlFVc3NWVUZCU3l4RlFVRkZMRTFCUVVjc1EwRkJRU3hEUVVGRE8wRkJRMnBHTEVOQlFVTTdRVUZNUkN3NFFrRkxRenRCUVVWRUxHOUNRVUZ2UWp0QlFVVndRaXd3UWtGQk1FSXNTMEZCV1N4RlFVRkZMRVZCUVhsRk8wbEJReTlITEVsQlFVMHNWVUZCVlN4SFFVRkhMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVTBGQlV5eERRVUZETzBsQlF6ZERMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzVFVGQlNTeEpRVUZKTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRPVUlzUlVGQlJTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMR05CUVdNc1EwRkJReXhOUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEY0VNc1NVRkJUU3hIUVVGSExFZEJRVWNzVlVGQlZTeERRVUZETEUxQlFVa3NRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFVkJRVVVzUTBGQlF5eEhRVUZITEVWQlFVVXNVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGVrSXNRMEZCUXp0SlFVTklMRU5CUVVNN1FVRkRTQ3hEUVVGRE8wRkJSVVFzYTBKQlFXdENMRTlCUVRKQ08wbEJRek5ETEUxQlFVMHNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzSkNMRXRCUVVzc1VVRkJVVHRaUVVOWUxFMUJRVTBzUTBGQlF5eG5Ra0ZCWXl4RFFVRkRPMUZCUTNoQ0xFdEJRVXNzVDBGQlR6dFpRVU5XTEUxQlFVMHNRMEZCUXl4bFFVRmhMRU5CUVVNN1VVRkRka0lzUzBGQlN5eFZRVUZWTzFsQlEySXNUVUZCVFN4RFFVRkRMR3RDUVVGblFpeERRVUZETzBsQlF6VkNMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEyUXNRMEZCUXp0QlFVVkVMR2RDUVVGMVFpeExRVUZuUWl4RlFVRkZMRTlCUVRKQ0xFVkJRVVVzVDBGQlowSXNSVUZCUlN4SlFVRlpPMGxCUTJ4SExFbEJRVTBzUzBGQlN5eEhRVUZITEd0Q1FVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNCRUxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZCVFN4TFFVRkxMRTFCUVUwc1IwRkJSeXhaUVVGVkxFdEJRVXNzVlVGQlN5eEpRVUZKTEUxQlFVY3NSMEZCUnl4SlFVRkpMRU5CUVVNN1FVRkRlRVVzUTBGQlF6dEJRVWhFTEhkQ1FVZERPMEZCUlVRc01rSkJRV3RETEU5QlFUSkNMRVZCUVVVc1QwRkJaMEk3U1VGRE4wVXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFZEJRVWNzUjBGQlJ5eEhRVUZITEU5QlFVOHNRMEZCUXp0QlFVTjBReXhEUVVGRE8wRkJSa1FzT0VOQlJVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgbXVsdGlfMSA9IHJlcXVpcmUoXCIuL211bHRpXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vc2VsZWN0aW9uXCIpO1xudmFyIHNpbmdsZSA9IHtcbiAgICBwcmVkaWNhdGU6IG11bHRpXzEuZGVmYXVsdC5wcmVkaWNhdGUsXG4gICAgc2lnbmFsczogbXVsdGlfMS5kZWZhdWx0LnNpZ25hbHMsXG4gICAgdG9wTGV2ZWxTaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWU7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlOiBcImRhdGEoXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUobmFtZSArIHNlbGVjdGlvbl8xLlNUT1JFKSArIFwiKVswXVwiXG4gICAgICAgICAgICB9XTtcbiAgICB9LFxuICAgIHR1cGxlRXhwcjogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0KSB7XG4gICAgICAgIHZhciBuYW1lID0gc2VsQ21wdC5uYW1lLCB2YWx1ZXMgPSBuYW1lICsgXCIudmFsdWVzXCI7XG4gICAgICAgIHJldHVybiBcImZpZWxkczogXCIgKyBuYW1lICsgXCIuZmllbGRzLCB2YWx1ZXM6IFwiICsgdmFsdWVzICsgXCIsIFwiICtcbiAgICAgICAgICAgIHNlbENtcHQucHJvamVjdC5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5maWVsZCArIFwiOiBcIiArIHZhbHVlcyArIFwiW1wiICsgaSArIFwiXVwiO1xuICAgICAgICAgICAgfSkuam9pbignLCAnKTtcbiAgICB9LFxuICAgIG1vZGlmeUV4cHI6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCkge1xuICAgICAgICByZXR1cm4gc2VsQ21wdC5uYW1lICsgc2VsZWN0aW9uXzEuVFVQTEUgKyAnLCB0cnVlJztcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gc2luZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzJsdVoyeGxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YzJWc1pXTjBhVzl1TDNOcGJtZHNaUzUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMRzFEUVVGMVF6dEJRVU4yUXl4cFEwRkJORUk3UVVGRE5VSXNlVU5CUVRSRU8wRkJSVFZFTEVsQlFVMHNUVUZCVFN4SFFVRnhRanRKUVVNdlFpeFRRVUZUTEVWQlFVVXNaVUZCU3l4RFFVRkRMRk5CUVZNN1NVRkZNVUlzVDBGQlR5eEZRVUZGTEdWQlFVc3NRMEZCUXl4UFFVRlBPMGxCUlhSQ0xHVkJRV1VzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBPMUZCUTNSRExFbEJRVTBzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRNVUlzVFVGQlRTeERRVUZETEVOQlFVTTdaMEpCUTA0c1NVRkJTU3hGUVVGRkxFbEJRVWs3WjBKQlExWXNUVUZCVFN4RlFVRkZMRlZCUVZFc2EwSkJRVmNzUTBGQlF5eEpRVUZKTEVkQlFVY3NhVUpCUVVzc1EwRkJReXhUUVVGTk8yRkJRMmhFTEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkZSQ3hUUVVGVExFVkJRVVVzVlVGQlV5eExRVUZMTEVWQlFVVXNUMEZCVHp0UlFVTm9ReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTFCUVUwc1IwRkJUU3hKUVVGSkxGbEJRVk1zUTBGQlF6dFJRVU55UkN4TlFVRk5MRU5CUVVNc1lVRkJWeXhKUVVGSkxIbENRVUZ2UWl4TlFVRk5MRTlCUVVrN1dVRkRiRVFzVDBGQlR5eERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJVeXhEUVVGRExFVkJRVVVzUTBGQlF6dG5Ra0ZETDBJc1RVRkJUU3hEUVVGSkxFTkJRVU1zUTBGQlF5eExRVUZMTEZWQlFVc3NUVUZCVFN4VFFVRkpMRU5CUVVNc1RVRkJSeXhEUVVGRE8xbEJRM1pETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU5zUWl4RFFVRkRPMGxCUlVRc1ZVRkJWU3hGUVVGRkxGVkJRVk1zUzBGQlN5eEZRVUZGTEU5QlFVODdVVUZEYWtNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVkQlFVY3NhVUpCUVVzc1IwRkJSeXhSUVVGUkxFTkJRVU03U1VGRGVrTXNRMEZCUXp0RFFVTkdMRU5CUVVNN1FVRkZaMElzZVVKQlFVOGlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgaW5wdXRCaW5kaW5ncyA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnR5cGUgPT09ICdzaW5nbGUnICYmIHNlbENtcHQuYmluZCAmJiBzZWxDbXB0LmJpbmQgIT09ICdzY2FsZXMnO1xuICAgIH0sXG4gICAgdG9wTGV2ZWxTaWduYWxzOiBmdW5jdGlvbiAobW9kZWwsIHNlbENtcHQsIHNpZ25hbHMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHByb2ogPSBzZWxDbXB0LnByb2plY3QsIGJpbmQgPSBzZWxDbXB0LmJpbmQsIGRhdHVtID0gJyhpdGVtKCkuaXNWb3Jvbm9pID8gZGF0dW0uZGF0dW0gOiBkYXR1bSknO1xuICAgICAgICBwcm9qLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHNpZ25hbHMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSArIGlkKHAuZmllbGQpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogc2VsQ21wdC5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGRhdHVtICsgXCJbXCIgKyB1dGlsXzEuc3RyaW5nVmFsdWUocC5maWVsZCkgKyBcIl1cIlxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgICAgICBiaW5kOiBiaW5kW3AuZmllbGRdIHx8IGJpbmRbcC5lbmNvZGluZ10gfHwgYmluZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2lnbmFscztcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgcHJvaiA9IHNlbENtcHQucHJvamVjdCwgc2lnbmFsID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZTsgfSlbMF0sIGZpZWxkcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB1dGlsXzEuc3RyaW5nVmFsdWUocC5maWVsZCk7IH0pLmpvaW4oJywgJyksIHZhbHVlcyA9IHByb2oubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBuYW1lICsgaWQocC5maWVsZCk7IH0pLmpvaW4oJywgJyk7XG4gICAgICAgIHNpZ25hbC51cGRhdGUgPSBcIntmaWVsZHM6IFtcIiArIGZpZWxkcyArIFwiXSwgdmFsdWVzOiBbXCIgKyB2YWx1ZXMgKyBcIl19XCI7XG4gICAgICAgIGRlbGV0ZSBzaWduYWwudmFsdWU7XG4gICAgICAgIGRlbGV0ZSBzaWduYWwub247XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpbnB1dEJpbmRpbmdzO1xuZnVuY3Rpb24gaWQoc3RyKSB7XG4gICAgcmV0dXJuICdfJyArIHN0ci5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWFXNXdkWFJ6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM1J5WVc1elptOXliWE12YVc1d2RYUnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNjME5CUVRCRE8wRkJSekZETEVsQlFVMHNZVUZCWVN4SFFVRnhRanRKUVVOMFF5eEhRVUZITEVWQlFVVXNWVUZCVXl4UFFVRlBPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1NVRkJTU3hQUVVGUExFTkJRVU1zU1VGQlNTeEpRVUZKTEU5QlFVOHNRMEZCUXl4SlFVRkpMRXRCUVVzc1VVRkJVU3hEUVVGRE8wbEJRMmhHTEVOQlFVTTdTVUZGUkN4bFFVRmxMRVZCUVVVc1ZVRkJVeXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEU5QlFVODdVVUZETDBNc1NVRkJUU3hKUVVGSkxFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSVUZEY2tJc1NVRkJTU3hIUVVGSExFOUJRVThzUTBGQlF5eFBRVUZQTEVWQlEzUkNMRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVU51UWl4TFFVRkxMRWRCUVVjc01FTkJRVEJETEVOQlFVTTdVVUZGZGtRc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eFZRVUZUTEVOQlFVTTdXVUZEY2tJc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF6dG5Ra0ZEWkN4SlFVRkpMRVZCUVVVc1NVRkJTU3hIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRPMmRDUVVONFFpeExRVUZMTEVWQlFVVXNSVUZCUlR0blFrRkRWQ3hGUVVGRkxFVkJRVVVzUTBGQlF6dDNRa0ZEU0N4TlFVRk5MRVZCUVVVc1QwRkJUeXhEUVVGRExFMUJRVTA3ZDBKQlEzUkNMRTFCUVUwc1JVRkJTeXhMUVVGTExGTkJRVWtzYTBKQlFWY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVWM3Y1VKQlF6VkRMRU5CUVVNN1owSkJRMFlzU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hKUVVGSk8yRkJRMmhFTEVOQlFVTXNRMEZCUXp0UlFVTk1MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJSVWdzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXp0SlFVTnFRaXhEUVVGRE8wbEJSVVFzVDBGQlR5eEZRVUZGTEZWQlFWTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hQUVVGUE8xRkJRM1pETEVsQlFVMHNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4UFFVRlBMRVZCUXpkRExFMUJRVTBzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJReXhKUVVGTExFOUJRVUVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4SlFVRkpMRVZCUVdZc1EwRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlEyeEVMRTFCUVUwc1IwRkJSeXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNRMEZCUXl4SlFVRkxMRTlCUVVFc2EwSkJRVmNzUTBGQlF5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUVhCQ0xFTkJRVzlDTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRM3BFTEUxQlFVMHNSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNTVUZCU1N4SFFVRkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFXeENMRU5CUVd0Q0xFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkZOVVFzVFVGQlRTeERRVUZETEUxQlFVMHNSMEZCUnl4bFFVRmhMRTFCUVUwc2IwSkJRV1VzVFVGQlRTeFBRVUZKTEVOQlFVTTdVVUZETjBRc1QwRkJUeXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEzQkNMRTlCUVU4c1RVRkJUU3hEUVVGRExFVkJRVVVzUTBGQlF6dFJRVVZxUWl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJRMnBDTEVOQlFVTTdRMEZEUml4RFFVRkRPMEZCUlhWQ0xHZERRVUZQTzBGQlJXaERMRmxCUVZrc1IwRkJWenRKUVVOeVFpeE5RVUZOTEVOQlFVTXNSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMEZCUTNaRExFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFZPUk9OT0kgPSAndm9yb25vaSc7XG52YXIgbmVhcmVzdCA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0Lm5lYXJlc3QgIT09IHVuZGVmaW5lZCAmJiBzZWxDbXB0Lm5lYXJlc3QgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgbWFya3M6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgbWFya3MsIHNlbE1hcmtzKSB7XG4gICAgICAgIHZhciBtYXJrID0gbWFya3NbMF0sIGluZGV4ID0gc2VsTWFya3MuaW5kZXhPZihtYXJrKSwgaXNQYXRoZ3JvdXAgPSBtYXJrLm5hbWUgPT09IG1vZGVsLmdldE5hbWUoJ3BhdGhncm91cCcpLCBleGlzdHMgPSAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ubmFtZSAmJiBtLm5hbWUuaW5kZXhPZihWT1JPTk9JKSA+PSAwOyB9KSwgY2VsbERlZiA9IHtcbiAgICAgICAgICAgIG5hbWU6IG1vZGVsLmdldE5hbWUoVk9ST05PSSksXG4gICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICBmcm9tOiB7IGRhdGE6IG1vZGVsLmdldE5hbWUoJ21hcmtzJykgfSxcbiAgICAgICAgICAgIGVuY29kZToge1xuICAgICAgICAgICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHsgdmFsdWU6ICd0cmFuc3BhcmVudCcgfSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHsgdmFsdWU6IDAuMzUgfSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiAndHJhbnNwYXJlbnQnIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzVm9yb25vaTogeyB2YWx1ZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Zvcm9ub2knLFxuICAgICAgICAgICAgICAgICAgICB4OiAnZGF0dW0ueCcsXG4gICAgICAgICAgICAgICAgICAgIHk6ICdkYXR1bS55JyxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogW3sgc2lnbmFsOiAnd2lkdGgnIH0sIHsgc2lnbmFsOiAnaGVpZ2h0JyB9XVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1BhdGhncm91cCAmJiAhbWFyay5tYXJrcy5maWx0ZXIoZXhpc3RzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hcmsubWFya3MucHVzaChjZWxsRGVmKTtcbiAgICAgICAgICAgIHNlbE1hcmtzLnNwbGljZShpbmRleCwgMSwgbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUGF0aGdyb3VwICYmICFzZWxNYXJrcy5maWx0ZXIoZXhpc3RzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbE1hcmtzLnNwbGljZShpbmRleCArIDEsIDAsIGNlbGxEZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxNYXJrcztcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbmVhcmVzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJtVmhjbVZ6ZEM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMM05sYkdWamRHbHZiaTkwY21GdWMyWnZjbTF6TDI1bFlYSmxjM1F1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkZRU3hKUVVGTkxFOUJRVThzUjBGQlJ5eFRRVUZUTEVOQlFVTTdRVUZGTVVJc1NVRkJUU3hQUVVGUExFZEJRWEZDTzBsQlEyaERMRWRCUVVjc1JVRkJSU3hWUVVGVExFOUJRVTg3VVVGRGJrSXNUVUZCVFN4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFdEJRVXNzVTBGQlV5eEpRVUZKTEU5QlFVOHNRMEZCUXl4UFFVRlBMRXRCUVVzc1MwRkJTeXhEUVVGRE8wbEJRM0JGTEVOQlFVTTdTVUZGUkN4TFFVRkxMRVZCUVVVc1ZVRkJVeXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEV0QlFVc3NSVUZCUlN4UlFVRlJPMUZCUXpkRExFbEJRVTBzU1VGQlNTeEhRVUZITEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1JVRkRha0lzUzBGQlN5eEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFVkJRemxDTEZkQlFWY3NSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hMUVVGTExFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNWMEZCVnl4RFFVRkRMRVZCUTNSRUxFMUJRVTBzUjBGQlJ5eERRVUZETEZWQlFVTXNRMEZCVFN4SlFVRkxMRTlCUVVFc1EwRkJReXhEUVVGRExFbEJRVWtzU1VGQlNTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhQUVVGUExFTkJRVU1zU1VGQlNTeERRVUZETEVWQlFYUkRMRU5CUVhORExFTkJRVU1zUlVGRE4wUXNUMEZCVHl4SFFVRkhPMWxCUTFJc1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRPMWxCUXpWQ0xFbEJRVWtzUlVGQlJTeE5RVUZOTzFsQlExb3NTVUZCU1N4RlFVRkZMRVZCUVVNc1NVRkJTU3hGUVVGRkxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUVVNN1dVRkRjRU1zVFVGQlRTeEZRVUZGTzJkQ1FVTk9MRXRCUVVzc1JVRkJSVHR2UWtGRFRDeEpRVUZKTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1lVRkJZU3hGUVVGRE8yOUNRVU0xUWl4WFFVRlhMRVZCUVVVc1JVRkJReXhMUVVGTExFVkJRVVVzU1VGQlNTeEZRVUZETzI5Q1FVTXhRaXhOUVVGTkxFVkJRVVVzUlVGQlF5eExRVUZMTEVWQlFVVXNZVUZCWVN4RlFVRkRPMjlDUVVNNVFpeFRRVUZUTEVWQlFVVXNSVUZCUXl4TFFVRkxMRVZCUVVVc1NVRkJTU3hGUVVGRE8ybENRVU42UWp0aFFVTkdPMWxCUTBRc1UwRkJVeXhGUVVGRkxFTkJRVU03YjBKQlExWXNTVUZCU1N4RlFVRkZMRk5CUVZNN2IwSkJRMllzUTBGQlF5eEZRVUZGTEZOQlFWTTdiMEpCUTFvc1EwRkJReXhGUVVGRkxGTkJRVk03YjBKQlExb3NTVUZCU1N4RlFVRkZMRU5CUVVNc1JVRkJReXhOUVVGTkxFVkJRVVVzVDBGQlR5eEZRVUZETEVWQlFVVXNSVUZCUXl4TlFVRk5MRVZCUVVVc1VVRkJVU3hGUVVGRExFTkJRVU03YVVKQlF6bERMRU5CUVVNN1UwRkRTQ3hEUVVGRE8xRkJSVTRzUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU55UkN4SlFVRkpMRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTjZRaXhSUVVGUkxFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NSVUZCUlN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExFTkJRVU03VVVGRGJFTXNRMEZCUXp0UlFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZkQlFWY3NTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelJDeFJRVUZSTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUTNwRExFTkJRVU03VVVGRlJDeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRPMGxCUTJ4Q0xFTkJRVU03UTBGRFJpeERRVUZETzBGQlJXbENMREJDUVVGUEluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9qZWN0ID0ge1xuICAgIGhhczogZnVuY3Rpb24gKHNlbERlZikge1xuICAgICAgICByZXR1cm4gc2VsRGVmLmZpZWxkcyAhPT0gdW5kZWZpbmVkIHx8IHNlbERlZi5lbmNvZGluZ3MgIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAobW9kZWwsIHNlbERlZiwgc2VsQ21wdCkge1xuICAgICAgICB2YXIgZmllbGRzID0ge307XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBwb3NzaWJsZSBjaGFubmVsIG1hcHBpbmcgZm9yIHRoZXNlIGZpZWxkcy5cbiAgICAgICAgKHNlbERlZi5maWVsZHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZpZWxkc1tmXSA9IG51bGw7IH0pO1xuICAgICAgICAoc2VsRGVmLmVuY29kaW5ncyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZmllbGRzW21vZGVsLmZpZWxkKGUpXSA9IGU7IH0pO1xuICAgICAgICB2YXIgcHJvamVjdGlvbiA9IHNlbENtcHQucHJvamVjdCB8fCAoc2VsQ21wdC5wcm9qZWN0ID0gW10pO1xuICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZHMuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wdXNoKHsgZmllbGQ6IGZpZWxkLCBlbmNvZGluZzogZmllbGRzW2ZpZWxkXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBwcm9qZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pY0hKdmFtVmpkQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1THk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwzTmxiR1ZqZEdsdmJpOTBjbUZ1YzJadmNtMXpMM0J5YjJwbFkzUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGSlFTeEpRVUZOTEU5QlFVOHNSMEZCY1VJN1NVRkRhRU1zUjBGQlJ5eEZRVUZGTEZWQlFWTXNUVUZCYjBJN1VVRkRhRU1zVFVGQlRTeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRXRCUVVzc1UwRkJVeXhKUVVGSkxFMUJRVTBzUTBGQlF5eFRRVUZUTEV0QlFVc3NVMEZCVXl4RFFVRkRPMGxCUTNaRkxFTkJRVU03U1VGRlJDeExRVUZMTEVWQlFVVXNWVUZCVXl4TFFVRkxMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVTg3VVVGRGNFTXNTVUZCVFN4TlFVRk5MRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRMnhDTERCRVFVRXdSRHRSUVVNeFJDeERRVUZETEUxQlFVMHNRMEZCUXl4TlFVRk5MRWxCUVVrc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFVTXNRMEZCUXl4SlFVRkxMRTlCUVVFc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVsQlFVa3NSVUZCYUVJc1EwRkJaMElzUTBGQlF5eERRVUZETzFGQlEzWkVMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zU1VGQlNTeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJReXhEUVVGVkxFbEJRVXNzVDBGQlFTeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNSVUZCTVVJc1EwRkJNRUlzUTBGQlF5eERRVUZETzFGQlJUZEZMRWxCUVUwc1ZVRkJWU3hIUVVGSExFOUJRVThzUTBGQlF5eFBRVUZQTEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhIUVVGSExFVkJRVVVzUTBGQlF5eERRVUZETzFGQlF6ZEVMRWRCUVVjc1EwRkJReXhEUVVGRExFbEJRVTBzUzBGQlN5eEpRVUZKTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRNMElzUlVGQlJTeERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJwRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUXl4TFFVRkxMRVZCUVVVc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlJTeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRVZCUVVNc1EwRkJReXhEUVVGRE8xbEJRek5FTEVOQlFVTTdVVUZEU0N4RFFVRkRPMGxCUTBnc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRmFVSXNNRUpCUVU4aWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9sb2dcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zY2FsZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbFwiKTtcbnZhciBpbnRlcnZhbF8xID0gcmVxdWlyZShcIi4uL2ludGVydmFsXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvblwiKTtcbnZhciBzY2FsZUJpbmRpbmdzID0ge1xuICAgIGNsaXBwZWRHcm91cDogdHJ1ZSxcbiAgICBoYXM6IGZ1bmN0aW9uIChzZWxDbXB0KSB7XG4gICAgICAgIHJldHVybiBzZWxDbXB0LnR5cGUgPT09ICdpbnRlcnZhbCcgJiYgc2VsQ21wdC5iaW5kICYmIHNlbENtcHQuYmluZCA9PT0gJ3NjYWxlcyc7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gKG1vZGVsLCBzZWxEZWYsIHNlbENtcHQpIHtcbiAgICAgICAgdmFyIHNjYWxlcyA9IG1vZGVsLmNvbXBvbmVudC5zY2FsZXM7XG4gICAgICAgIHZhciBib3VuZCA9IHNlbENtcHQuc2NhbGVzID0gW107XG4gICAgICAgIHNlbENtcHQucHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHAuZW5jb2Rpbmc7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZXNbY2hhbm5lbF07XG4gICAgICAgICAgICBpZiAoIXNjYWxlIHx8ICFzY2FsZV8xLmhhc0NvbnRpbnVvdXNEb21haW4oc2NhbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dfMS53YXJuKCdTY2FsZSBiaW5kaW5ncyBhcmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGZvciBzY2FsZXMgd2l0aCBjb250aW51b3VzIGRvbWFpbnMuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NhbGUuZG9tYWluUmF3ID0geyBzaWduYWw6IHNlbGVjdGlvbl8xLmNoYW5uZWxTaWduYWxOYW1lKHNlbENtcHQsIGNoYW5uZWwpIH07XG4gICAgICAgICAgICBib3VuZC5wdXNoKGNoYW5uZWwpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHRvcExldmVsU2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKSB7XG4gICAgICAgIHJldHVybiBzaWduYWxzLmNvbmNhdChzZWxDbXB0LnNjYWxlcy5tYXAoZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IHNlbGVjdGlvbl8xLmNoYW5uZWxTaWduYWxOYW1lKHNlbENtcHQsIGNoYW5uZWwpIH07XG4gICAgICAgIH0pKTtcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZTtcbiAgICAgICAgc2lnbmFscyA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5uYW1lICE9PSBuYW1lICsgaW50ZXJ2YWxfMS5TSVpFICYmXG4gICAgICAgICAgICAgICAgcy5uYW1lICE9PSBuYW1lICsgc2VsZWN0aW9uXzEuVFVQTEUgJiYgcy5uYW1lICE9PSBzZWxlY3Rpb25fMS5NT0RJRlk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxDbXB0LnNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmFsID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZSArICdfJyArIGNoYW5uZWw7IH0pWzBdO1xuICAgICAgICAgICAgc2lnbmFsLnB1c2ggPSAnb3V0ZXInO1xuICAgICAgICAgICAgZGVsZXRlIHNpZ25hbC52YWx1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSBzaWduYWwudXBkYXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbHM7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNjYWxlQmluZGluZ3M7XG5mdW5jdGlvbiBkb21haW4obW9kZWwsIGNoYW5uZWwpIHtcbiAgICB2YXIgc2NhbGUgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpKTtcbiAgICByZXR1cm4gXCJkb21haW4oXCIgKyBzY2FsZSArIFwiKVwiO1xufVxuZXhwb3J0cy5kb21haW4gPSBkb21haW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMk5oYkdWekxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZMaTR2TGk0dkxpNHZjM0pqTDJOdmJYQnBiR1V2YzJWc1pXTjBhVzl1TDNSeVlXNXpabTl5YlhNdmMyTmhiR1Z6TG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRMEVzYjBOQlFXdERPMEZCUTJ4RExIZERRVUZ0UkR0QlFVTnVSQ3h6UTBGQk1FTTdRVUZGTVVNc2QwTkJRV3RFTzBGQlEyeEVMREJEUVVFNFJEdEJRVWM1UkN4SlFVRk5MR0ZCUVdFc1IwRkJjVUk3U1VGRGRFTXNXVUZCV1N4RlFVRkZMRWxCUVVrN1NVRkZiRUlzUjBGQlJ5eEZRVUZGTEZWQlFWTXNUMEZCVHp0UlFVTnVRaXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NTMEZCU3l4VlFVRlZMRWxCUVVrc1QwRkJUeXhEUVVGRExFbEJRVWtzU1VGQlNTeFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRkZCUVZFc1EwRkJRenRKUVVOc1JpeERRVUZETzBsQlJVUXNTMEZCU3l4RlFVRkZMRlZCUVZNc1MwRkJTeXhGUVVGRkxFMUJRVTBzUlVGQlJTeFBRVUZQTzFGQlEzQkRMRWxCUVUwc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRPMUZCUTNSRExFbEJRVTBzUzBGQlN5eEhRVUZoTEU5QlFVOHNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJSVFZETEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVk1zUTBGQlF6dFpRVU5vUXl4SlFVRk5MRTlCUVU4c1IwRkJSeXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETzFsQlF6TkNMRWxCUVUwc1MwRkJTeXhIUVVGSExFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVVTVRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4RFFVRkRMREpDUVVGdFFpeERRVUZETEV0QlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlF5OURMRlZCUVVrc1EwRkJReXhwUmtGQmFVWXNRMEZCUXl4RFFVRkRPMmRDUVVONFJpeE5RVUZOTEVOQlFVTTdXVUZEVkN4RFFVRkRPMWxCUlVRc1MwRkJTeXhEUVVGRExGTkJRVk1zUjBGQlJ5eEZRVUZETEUxQlFVMHNSVUZCUlN3MlFrRkJhVUlzUTBGQlF5eFBRVUZQTEVWQlFVVXNUMEZCVHl4RFFVRkRMRVZCUVVNc1EwRkJRenRaUVVOb1JTeExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJRM1JDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTB3c1EwRkJRenRKUVVWRUxHVkJRV1VzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1QwRkJUenRSUVVNdlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NRMEZCUXl4VlFVRkRMRTlCUVU4N1dVRkRMME1zVFVGQlRTeERRVUZETEVWQlFVTXNTVUZCU1N4RlFVRkZMRFpDUVVGcFFpeERRVUZETEU5QlFVOHNSVUZCUlN4UFFVRlBMRU5CUVVNc1JVRkJReXhEUVVGRE8xRkJRM0pFTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRUaXhEUVVGRE8wbEJSVVFzVDBGQlR5eEZRVUZGTEZWQlFWTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hQUVVGUE8xRkJRM1pETEVsQlFVMHNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRE1VSXNUMEZCVHl4SFFVRkhMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlV5eERRVUZETzFsQlEycERMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEVsQlFVa3NSMEZCUnl4bFFVRmhPMmRDUVVOd1F5eERRVUZETEVOQlFVTXNTVUZCU1N4TFFVRkxMRWxCUVVrc1IwRkJSeXhwUWtGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRXRCUVVzc2EwSkJRVTBzUTBGQlF6dFJRVU5xUkN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVWSUxFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1QwRkJUenRaUVVOeVF5eEpRVUZOTEUxQlFVMHNSMEZCUnl4UFFVRlBMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhKUVVGSkxFZEJRVWNzUjBGQlJ5eEhRVUZITEU5QlFVOHNSVUZCTDBJc1EwRkJLMElzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRPMWxCUTNSQ0xFOUJRVThzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0WlFVTndRaXhQUVVGUExFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTTdVVUZEZGtJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRlNDeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMGxCUTJwQ0xFTkJRVU03UTBGRFJpeERRVUZETzBGQlJYVkNMR2REUVVGUE8wRkJSV2hETEdkQ1FVRjFRaXhMUVVGblFpeEZRVUZGTEU5QlFXZENPMGxCUTNaRUxFbEJRVTBzUzBGQlN5eEhRVUZITEd0Q1FVRlhMRU5CUVVNc1MwRkJTeXhEUVVGRExGTkJRVk1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRPMGxCUTNCRUxFMUJRVTBzUTBGQlF5eFpRVUZWTEV0QlFVc3NUVUZCUnl4RFFVRkRPMEZCUXpWQ0xFTkJRVU03UVVGSVJDeDNRa0ZIUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3NlbGVjdGlvblwiKTtcbnZhciBUT0dHTEUgPSAnX3RvZ2dsZSc7XG52YXIgdG9nZ2xlID0ge1xuICAgIGhhczogZnVuY3Rpb24gKHNlbENtcHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbENtcHQudG9nZ2xlICE9PSB1bmRlZmluZWQgJiYgc2VsQ21wdC50b2dnbGUgIT09IGZhbHNlO1xuICAgIH0sXG4gICAgc2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKSB7XG4gICAgICAgIHJldHVybiBzaWduYWxzLmNvbmNhdCh7XG4gICAgICAgICAgICBuYW1lOiBzZWxDbXB0Lm5hbWUgKyBUT0dHTEUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICBvbjogW3sgZXZlbnRzOiBzZWxDbXB0LmV2ZW50cywgdXBkYXRlOiBzZWxDbXB0LnRvZ2dsZSB9XVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIG1vZGlmeUV4cHI6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgZXhwcikge1xuICAgICAgICB2YXIgdHBsID0gc2VsQ21wdC5uYW1lICsgc2VsZWN0aW9uXzEuVFVQTEUsIHNpZ25hbCA9IHNlbENtcHQubmFtZSArIFRPR0dMRTtcbiAgICAgICAgcmV0dXJuIHNpZ25hbCArIFwiID8gbnVsbCA6IFwiICsgdHBsICsgXCIsIFwiICtcbiAgICAgICAgICAgIChzaWduYWwgKyBcIiA/IG51bGwgOiB0cnVlLCBcIikgK1xuICAgICAgICAgICAgKHNpZ25hbCArIFwiID8gXCIgKyB0cGwgKyBcIiA6IG51bGxcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvZ2dsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRHOW5aMnhsTG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2TGk0dkxpNHZMaTR2TGk0dmMzSmpMMk52YlhCcGJHVXZjMlZzWldOMGFXOXVMM1J5WVc1elptOXliWE12ZEc5bloyeGxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNNRU5CUVcxRE8wRkJSMjVETEVsQlFVMHNUVUZCVFN4SFFVRkhMRk5CUVZNc1EwRkJRenRCUVVWNlFpeEpRVUZOTEUxQlFVMHNSMEZCY1VJN1NVRkRMMElzUjBGQlJ5eEZRVUZGTEZWQlFWTXNUMEZCVHp0UlFVTnVRaXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETEUxQlFVMHNTMEZCU3l4VFFVRlRMRWxCUVVrc1QwRkJUeXhEUVVGRExFMUJRVTBzUzBGQlN5eExRVUZMTEVOQlFVTTdTVUZEYkVVc1EwRkJRenRKUVVWRUxFOUJRVThzUlVGQlJTeFZRVUZUTEV0QlFVc3NSVUZCUlN4UFFVRlBMRVZCUVVVc1QwRkJUenRSUVVOMlF5eE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJRenRaUVVOd1FpeEpRVUZKTEVWQlFVVXNUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhOUVVGTk8xbEJRek5DTEV0QlFVc3NSVUZCUlN4TFFVRkxPMWxCUTFvc1JVRkJSU3hGUVVGRkxFTkJRVU1zUlVGQlF5eE5RVUZOTEVWQlFVVXNUMEZCVHl4RFFVRkRMRTFCUVUwc1JVRkJSU3hOUVVGTkxFVkJRVVVzVDBGQlR5eERRVUZETEUxQlFVMHNSVUZCUXl4RFFVRkRPMU5CUTNaRUxFTkJRVU1zUTBGQlF6dEpRVU5NTEVOQlFVTTdTVUZGUkN4VlFVRlZMRVZCUVVVc1ZVRkJVeXhMUVVGTExFVkJRVVVzVDBGQlR5eEZRVUZGTEVsQlFVazdVVUZEZGtNc1NVRkJUU3hIUVVGSExFZEJRVWNzVDBGQlR5eERRVUZETEVsQlFVa3NSMEZCUnl4cFFrRkJTeXhGUVVNMVFpeE5RVUZOTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1IwRkJSeXhOUVVGTkxFTkJRVU03VVVGRmJrTXNUVUZCVFN4RFFVRkpMRTFCUVUwc2EwSkJRV0VzUjBGQlJ5eFBRVUZKTzJGQlF5OUNMRTFCUVUwc2NVSkJRV3RDTEVOQlFVRTdZVUZEZUVJc1RVRkJUU3hYUVVGTkxFZEJRVWNzV1VGQlV5eERRVUZCTEVOQlFVTTdTVUZEYUVNc1EwRkJRenREUVVOR0xFTkJRVU03UVVGRlowSXNlVUpCUVU4aWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnB1dHNfMSA9IHJlcXVpcmUoXCIuL2lucHV0c1wiKTtcbnZhciBuZWFyZXN0XzEgPSByZXF1aXJlKFwiLi9uZWFyZXN0XCIpO1xudmFyIHByb2plY3RfMSA9IHJlcXVpcmUoXCIuL3Byb2plY3RcIik7XG52YXIgc2NhbGVzXzEgPSByZXF1aXJlKFwiLi9zY2FsZXNcIik7XG52YXIgdG9nZ2xlXzEgPSByZXF1aXJlKFwiLi90b2dnbGVcIik7XG52YXIgdHJhbnNsYXRlXzEgPSByZXF1aXJlKFwiLi90cmFuc2xhdGVcIik7XG52YXIgem9vbV8xID0gcmVxdWlyZShcIi4vem9vbVwiKTtcbnZhciBjb21waWxlcnMgPSB7IHByb2plY3Q6IHByb2plY3RfMS5kZWZhdWx0LCB0b2dnbGU6IHRvZ2dsZV8xLmRlZmF1bHQsIHNjYWxlczogc2NhbGVzXzEuZGVmYXVsdCxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZV8xLmRlZmF1bHQsIHpvb206IHpvb21fMS5kZWZhdWx0LCBpbnB1dHM6IGlucHV0c18xLmRlZmF1bHQsIG5lYXJlc3Q6IG5lYXJlc3RfMS5kZWZhdWx0IH07XG5mdW5jdGlvbiBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIGNiKSB7XG4gICAgZm9yICh2YXIgdCBpbiBjb21waWxlcnMpIHtcbiAgICAgICAgaWYgKGNvbXBpbGVyc1t0XS5oYXMoc2VsQ21wdCkpIHtcbiAgICAgICAgICAgIGNiKGNvbXBpbGVyc1t0XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmZvckVhY2hUcmFuc2Zvcm0gPSBmb3JFYWNoVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhKaGJuTm1iM0p0Y3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUx5NHVMeTR1THk0dUwzTnlZeTlqYjIxd2FXeGxMM05sYkdWamRHbHZiaTkwY21GdWMyWnZjbTF6TDNSeVlXNXpabTl5YlhNdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZwUWtFc2JVTkJRVGhDTzBGQlF6bENMSEZEUVVGblF6dEJRVU5vUXl4eFEwRkJaME03UVVGRGFFTXNiVU5CUVRoQ08wRkJRemxDTEcxRFFVRTRRanRCUVVNNVFpeDVRMEZCYjBNN1FVRkRjRU1zSzBKQlFUQkNPMEZCUXpGQ0xFbEJRVTBzVTBGQlV5eEhRVUUwUWl4RlFVRkRMRTlCUVU4c2JVSkJRVUVzUlVGQlJTeE5RVUZOTEd0Q1FVRkJMRVZCUVVVc1RVRkJUU3hyUWtGQlFUdEpRVU5xUlN4VFFVRlRMSEZDUVVGQkxFVkJRVVVzU1VGQlNTeG5Ra0ZCUVN4RlFVRkZMRTFCUVUwc2EwSkJRVUVzUlVGQlJTeFBRVUZQTEcxQ1FVRkJMRVZCUVVNc1EwRkJRenRCUVVWd1F5d3dRa0ZCYVVNc1QwRkJNa0lzUlVGQlJTeEZRVUZ0UXp0SlFVTXZSaXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZOTEVOQlFVTXNTVUZCU1N4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxDTEVWQlFVVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU51UWl4RFFVRkRPMGxCUTBnc1EwRkJRenRCUVVOSUxFTkJRVU03UVVGT1JDdzBRMEZOUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlZ2FfZXZlbnRfc2VsZWN0b3JfMSA9IHJlcXVpcmUoXCJ2ZWdhLWV2ZW50LXNlbGVjdG9yXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGFubmVsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGludGVydmFsXzEgPSByZXF1aXJlKFwiLi4vaW50ZXJ2YWxcIik7XG52YXIgc2NhbGVzXzEgPSByZXF1aXJlKFwiLi9zY2FsZXNcIik7XG52YXIgQU5DSE9SID0gJ190cmFuc2xhdGVfYW5jaG9yJywgREVMVEEgPSAnX3RyYW5zbGF0ZV9kZWx0YSc7XG52YXIgdHJhbnNsYXRlID0ge1xuICAgIGhhczogZnVuY3Rpb24gKHNlbENtcHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbENtcHQudHlwZSA9PT0gJ2ludGVydmFsJyAmJiBzZWxDbXB0LnRyYW5zbGF0ZSAhPT0gdW5kZWZpbmVkICYmIHNlbENtcHQudHJhbnNsYXRlICE9PSBmYWxzZTtcbiAgICB9LFxuICAgIHNpZ25hbHM6IGZ1bmN0aW9uIChtb2RlbCwgc2VsQ21wdCwgc2lnbmFscykge1xuICAgICAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgc2NhbGVzID0gc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCksIHNpemUgPSBzY2FsZXMgPyAndW5pdCcgOiBuYW1lICsgaW50ZXJ2YWxfMS5TSVpFLCBhbmNob3IgPSBuYW1lICsgQU5DSE9SLCBfYSA9IGludGVydmFsXzEucHJvamVjdGlvbnMoc2VsQ21wdCksIHggPSBfYS54LCB5ID0gX2EueTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHZlZ2FfZXZlbnRfc2VsZWN0b3JfMS5zZWxlY3RvcihzZWxDbXB0LnRyYW5zbGF0ZSwgJ3Njb3BlJyk7XG4gICAgICAgIGlmICghc2NhbGVzKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoZS5iZXR3ZWVuWzBdLm1hcmtuYW1lID0gbmFtZSArIGludGVydmFsXzEuQlJVU0gsIGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWxzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogYW5jaG9yLFxuICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgb246IFt7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5iZXR3ZWVuWzBdOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiAne3g6IHgodW5pdCksIHk6IHkodW5pdCksICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKFwid2lkdGg6IFwiICsgc2l6ZSArIFwiLndpZHRoLCBoZWlnaHQ6IFwiICsgc2l6ZSArIFwiLmhlaWdodCwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh4ICE9PSBudWxsID8gJ2V4dGVudF94OiAnICsgKHNjYWxlcyA/IHNjYWxlc18xLmRvbWFpbihtb2RlbCwgY2hhbm5lbF8xLlgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNsaWNlKFwiICsgbmFtZSArIFwiX3gpXCIpICsgJywgJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeSAhPT0gbnVsbCA/ICdleHRlbnRfeTogJyArIChzY2FsZXMgPyBzY2FsZXNfMS5kb21haW4obW9kZWwsIGNoYW5uZWxfMS5ZKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzbGljZShcIiArIG5hbWUgKyBcIl95KVwiKSArICcsICcgOiAnJykgKyAnfSdcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lICsgREVMVEEsXG4gICAgICAgICAgICB2YWx1ZToge30sXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogXCJ7eDogeCh1bml0KSAtIFwiICsgYW5jaG9yICsgXCIueCwgeTogeSh1bml0KSAtIFwiICsgYW5jaG9yICsgXCIueX1cIlxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb25EZWx0YShtb2RlbCwgc2VsQ21wdCwgY2hhbm5lbF8xLlgsICd3aWR0aCcsIHNpZ25hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbkRlbHRhKG1vZGVsLCBzZWxDbXB0LCBjaGFubmVsXzEuWSwgJ2hlaWdodCcsIHNpZ25hbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduYWxzO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSB0cmFuc2xhdGU7XG5mdW5jdGlvbiBnZXRTaWduKHNlbENtcHQsIGNoYW5uZWwpIHtcbiAgICB2YXIgcyA9IGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YID8gJysnIDogJy0nO1xuICAgIGlmIChzY2FsZXNfMS5kZWZhdWx0LmhhcyhzZWxDbXB0KSkge1xuICAgICAgICBzID0gcyA9PT0gJysnID8gJy0nIDogJysnO1xuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIG9uRGVsdGEobW9kZWwsIHNlbENtcHQsIGNoYW5uZWwsIHNpemUsIHNpZ25hbHMpIHtcbiAgICB2YXIgbmFtZSA9IHNlbENtcHQubmFtZSwgc2lnbmFsID0gc2lnbmFscy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMubmFtZSA9PT0gbmFtZSArICdfJyArIGNoYW5uZWw7IH0pWzBdLCBhbmNob3IgPSBuYW1lICsgQU5DSE9SLCBkZWx0YSA9IG5hbWUgKyBERUxUQSwgc2NhbGUgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpKSwgZXh0ZW50ID0gXCIuZXh0ZW50X1wiICsgY2hhbm5lbCwgc2lnbiA9IGdldFNpZ24oc2VsQ21wdCwgY2hhbm5lbCksIG9mZnNldCA9IHNpZ24gKyBcIiBhYnMoc3BhbihcIiArIGFuY2hvciArIGV4dGVudCArIFwiKSkgKiBcIiArXG4gICAgICAgIChkZWx0YSArIFwiLlwiICsgY2hhbm5lbCArIFwiIC8gXCIgKyBhbmNob3IgKyBcIi5cIiArIHNpemUpLCByYW5nZSA9IFwiW1wiICsgYW5jaG9yICsgZXh0ZW50ICsgXCJbMF0gXCIgKyBvZmZzZXQgKyBcIiwgXCIgK1xuICAgICAgICAoXCJcIiArIGFuY2hvciArIGV4dGVudCArIFwiWzFdIFwiICsgb2Zmc2V0ICsgXCJdXCIpLCBsbyA9IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyAnLCAwJyA6IFwiLCB1bml0LlwiICsgc2l6ZSkgKyAnKScsIGhpID0gXCJpbnZlcnQoXCIgKyBzY2FsZSArIChjaGFubmVsID09PSBjaGFubmVsXzEuWCA/IFwiLCB1bml0LlwiICsgc2l6ZSA6ICcsIDAnKSArICcpJztcbiAgICBzaWduYWwub24ucHVzaCh7XG4gICAgICAgIGV2ZW50czogeyBzaWduYWw6IGRlbHRhIH0sXG4gICAgICAgIHVwZGF0ZTogc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCkgPyByYW5nZSA6IFwiY2xhbXBSYW5nZShcIiArIHJhbmdlICsgXCIsIFwiICsgbG8gKyBcIiwgXCIgKyBoaSArIFwiKVwiXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5Oc1lYUmxMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2TGk0dkxpNHZMaTR2YzNKakwyTnZiWEJwYkdVdmMyVnNaV04wYVc5dUwzUnlZVzV6Wm05eWJYTXZkSEpoYm5Oc1lYUmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQlFVRXNNa1JCUVRoRU8wRkJRemxFTERSRFFVRXJRenRCUVVNdlF5eHpRMEZCTUVNN1FVRkRNVU1zZDBOQlFTdEhPMEZCUnk5SExHMURRVUV5UkR0QlFVY3pSQ3hKUVVGTkxFMUJRVTBzUjBGQlJ5eHRRa0ZCYlVJc1JVRkROVUlzUzBGQlN5eEhRVUZKTEd0Q1FVRnJRaXhEUVVGRE8wRkJSV3hETEVsQlFVMHNVMEZCVXl4SFFVRnhRanRKUVVOc1F5eEhRVUZITEVWQlFVVXNWVUZCVXl4UFFVRlBPMUZCUTI1Q0xFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4TFFVRkxMRlZCUVZVc1NVRkJTU3hQUVVGUExFTkJRVU1zVTBGQlV5eExRVUZMTEZOQlFWTXNTVUZCU1N4UFFVRlBMRU5CUVVNc1UwRkJVeXhMUVVGTExFdEJRVXNzUTBGQlF6dEpRVU4yUnl4RFFVRkRPMGxCUlVRc1QwRkJUeXhGUVVGRkxGVkJRVk1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UFFVRlBPMUZCUTJwRExFbEJRVUVzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUTNKQ0xFMUJRVTBzUjBGQlJ5eG5Ra0ZCWXl4RFFVRkRMRWRCUVVjc1EwRkJReXhQUVVGUExFTkJRVU1zUlVGRGNFTXNTVUZCU1N4SFFVRkhMRTFCUVUwc1IwRkJSeXhOUVVGTkxFZEJRVWNzU1VGQlNTeEhRVUZITEdWQlFXRXNSVUZETjBNc1RVRkJUU3hIUVVGSExFbEJRVWtzUjBGQlJ5eE5RVUZOTEVWQlEzUkNMRzlEUVVGeFF5eEZRVUZ3UXl4UlFVRkRMRVZCUVVVc1VVRkJReXhEUVVGcFF6dFJRVU14UXl4SlFVRkpMRTFCUVUwc1IwRkJSeXc0UWtGQllTeERRVUZETEU5QlFVOHNRMEZCUXl4VFFVRlRMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU03VVVGRmRrUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlExb3NUVUZCVFN4SFFVRkhMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVlVGQlF5eERRVUZETEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4SFFVRkhMRWxCUVVrc1IwRkJSeXhuUWtGQll5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RlFVRnNSQ3hEUVVGclJDeERRVUZETEVOQlFVTTdVVUZEYWtZc1EwRkJRenRSUVVWRUxFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZEV0N4SlFVRkpMRVZCUVVVc1RVRkJUVHRaUVVOYUxFdEJRVXNzUlVGQlJTeEZRVUZGTzFsQlExUXNSVUZCUlN4RlFVRkZMRU5CUVVNN2IwSkJRMGdzVFVGQlRTeEZRVUZGTEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJReXhEUVVGRExFbEJRVXNzVDBGQlFTeERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGYUxFTkJRVmtzUTBGQlF6dHZRa0ZEZGtNc1RVRkJUU3hGUVVGRkxESkNRVUV5UWp0NVFrRkRha01zV1VGQlZTeEpRVUZKTEhkQ1FVRnRRaXhKUVVGSkxHTkJRVmNzUTBGQlFUdDNRa0ZGYUVRc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeEhRVUZITEZsQlFWa3NSMEZCUnl4RFFVRkRMRTFCUVUwc1IwRkJSeXhsUVVGTkxFTkJRVU1zUzBGQlN5eEZRVUZGTEZkQlFVTXNRMEZCUXpzMFFrRkRia1FzVjBGQlV5eEpRVUZKTEZGQlFVc3NRMEZCUXl4SFFVRkhMRWxCUVVrc1IwRkJSeXhGUVVGRkxFTkJRVU03ZDBKQlJYQkRMRU5CUVVNc1EwRkJReXhMUVVGTExFbEJRVWtzUjBGQlJ5eFpRVUZaTEVkQlFVY3NRMEZCUXl4TlFVRk5MRWRCUVVjc1pVRkJUU3hEUVVGRExFdEJRVXNzUlVGQlJTeFhRVUZETEVOQlFVTTdORUpCUTI1RUxGZEJRVk1zU1VGQlNTeFJRVUZMTEVOQlFVTXNSMEZCUnl4SlFVRkpMRWRCUVVjc1JVRkJSU3hEUVVGRExFZEJRVWNzUjBGQlJ6dHBRa0ZETjBNc1EwRkJRenRUUVVOSUxFVkJRVVU3V1VGRFJDeEpRVUZKTEVWQlFVVXNTVUZCU1N4SFFVRkhMRXRCUVVzN1dVRkRiRUlzUzBGQlN5eEZRVUZGTEVWQlFVVTdXVUZEVkN4RlFVRkZMRVZCUVVVc1EwRkJRenR2UWtGRFNDeE5RVUZOTEVWQlFVVXNUVUZCVFR0dlFrRkRaQ3hOUVVGTkxFVkJRVVVzYlVKQlFXbENMRTFCUVUwc2VVSkJRVzlDTEUxQlFVMHNVVUZCU3p0cFFrRkRMMFFzUTBGQlF6dFRRVU5JTEVOQlFVTXNRMEZCUXp0UlFVVklMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJZc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeFBRVUZQTEVWQlFVVXNWMEZCUXl4RlFVRkZMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU12UXl4RFFVRkRPMUZCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRaaXhQUVVGUExFTkJRVU1zUzBGQlN5eEZRVUZGTEU5QlFVOHNSVUZCUlN4WFFVRkRMRVZCUVVVc1VVRkJVU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETzFGQlEyaEVMRU5CUVVNN1VVRkZSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzBsQlEycENMRU5CUVVNN1EwRkRSaXhEUVVGRE8wRkJSVzFDTERSQ1FVRlBPMEZCUlRWQ0xHbENRVUZwUWl4UFFVRXlRaXhGUVVGRkxFOUJRV2RDTzBsQlF6VkVMRWxCUVVrc1EwRkJReXhIUVVGSExFOUJRVThzUzBGQlN5eFhRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRWRCUVVjc1EwRkJRenRKUVVOc1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJZeXhEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRhRU1zUTBGQlF5eEhRVUZITEVOQlFVTXNTMEZCU3l4SFFVRkhMRWRCUVVjc1IwRkJSeXhIUVVGSExFZEJRVWNzUTBGQlF6dEpRVU0xUWl4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU5ZTEVOQlFVTTdRVUZGUkN4cFFrRkJhVUlzUzBGQlowSXNSVUZCUlN4UFFVRXlRaXhGUVVGRkxFOUJRV2RDTEVWQlFVVXNTVUZCV1N4RlFVRkZMRTlCUVdNN1NVRkROVWNzU1VGQlRTeEpRVUZKTEVkQlFVY3NUMEZCVHl4RFFVRkRMRWxCUVVrc1JVRkRja0lzVFVGQlRTeEhRVUZQTEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1ZVRkJReXhEUVVGTExFbEJRVXNzVDBGQlFTeERRVUZETEVOQlFVTXNTVUZCU1N4TFFVRkxMRWxCUVVrc1IwRkJSeXhIUVVGSExFZEJRVWNzVDBGQlR5eEZRVUV2UWl4RFFVRXJRaXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVWQlF6RkZMRTFCUVUwc1IwRkJSeXhKUVVGSkxFZEJRVWNzVFVGQlRTeEZRVU4wUWl4TFFVRkxMRWRCUVVrc1NVRkJTU3hIUVVGSExFdEJRVXNzUlVGRGNrSXNTMEZCU3l4SFFVRkpMR3RDUVVGWExFTkJRVU1zUzBGQlN5eERRVUZETEZOQlFWTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhGUVVNNVF5eE5RVUZOTEVkQlFVY3NZVUZCVnl4UFFVRlRMRVZCUXpkQ0xFbEJRVWtzUjBGQlJ5eFBRVUZQTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTlCUVU4c1EwRkJReXhGUVVOb1F5eE5RVUZOTEVkQlFVMHNTVUZCU1N4clFrRkJZU3hOUVVGTkxFZEJRVWNzVFVGQlRTeFZRVUZQTzFOQlF6bERMRXRCUVVzc1UwRkJTU3hQUVVGUExGZEJRVTBzVFVGQlRTeFRRVUZKTEVsQlFVMHNRMEZCUVN4RlFVTXpReXhMUVVGTExFZEJRVWNzVFVGQlNTeE5RVUZOTEVkQlFVY3NUVUZCVFN4WlFVRlBMRTFCUVUwc1QwRkJTVHRUUVVNeFF5eExRVUZITEUxQlFVMHNSMEZCUnl4TlFVRk5MRmxCUVU4c1RVRkJUU3hOUVVGSExFTkJRVUVzUlVGRGNFTXNSVUZCUlN4SFFVRkhMRmxCUVZVc1MwRkJUeXhIUVVGSExFTkJRVU1zVDBGQlR5eExRVUZMTEZkQlFVTXNSMEZCUnl4TFFVRkxMRWRCUVVjc1dVRkJWU3hKUVVGTkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVWQlEzcEZMRVZCUVVVc1IwRkJSeXhaUVVGVkxFdEJRVThzUjBGQlJ5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWRCUVVjc1dVRkJWU3hKUVVGTkxFZEJRVWNzUzBGQlN5eERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRPMGxCUlRsRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJJc1RVRkJUU3hGUVVGRkxFVkJRVU1zVFVGQlRTeEZRVUZGTEV0QlFVc3NSVUZCUXp0UlFVTjJRaXhOUVVGTkxFVkJRVVVzWjBKQlFXTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUzBGQlN5eEhRVUZITEdkQ1FVRmpMRXRCUVVzc1ZVRkJTeXhGUVVGRkxGVkJRVXNzUlVGQlJTeE5RVUZITzB0QlEyNUdMRU5CUVVNc1EwRkJRenRCUVVOTUxFTkJRVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlZ2FfZXZlbnRfc2VsZWN0b3JfMSA9IHJlcXVpcmUoXCJ2ZWdhLWV2ZW50LXNlbGVjdG9yXCIpO1xudmFyIGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jaGFubmVsXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsXCIpO1xudmFyIGludGVydmFsXzEgPSByZXF1aXJlKFwiLi4vaW50ZXJ2YWxcIik7XG52YXIgc2NhbGVzXzEgPSByZXF1aXJlKFwiLi9zY2FsZXNcIik7XG52YXIgQU5DSE9SID0gJ196b29tX2FuY2hvcicsIERFTFRBID0gJ196b29tX2RlbHRhJztcbnZhciB6b29tID0ge1xuICAgIGhhczogZnVuY3Rpb24gKHNlbENtcHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbENtcHQudHlwZSA9PT0gJ2ludGVydmFsJyAmJiBzZWxDbXB0Lnpvb20gIT09IHVuZGVmaW5lZCAmJiBzZWxDbXB0Lnpvb20gIT09IGZhbHNlO1xuICAgIH0sXG4gICAgc2lnbmFsczogZnVuY3Rpb24gKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKSB7XG4gICAgICAgIHZhciBuYW1lID0gc2VsQ21wdC5uYW1lLCBkZWx0YSA9IG5hbWUgKyBERUxUQSwgX2EgPSBpbnRlcnZhbF8xLnByb2plY3Rpb25zKHNlbENtcHQpLCB4ID0gX2EueCwgeSA9IF9hLnksIHN4ID0gdXRpbF8xLnN0cmluZ1ZhbHVlKG1vZGVsLnNjYWxlTmFtZShjaGFubmVsXzEuWCkpLCBzeSA9IHV0aWxfMS5zdHJpbmdWYWx1ZShtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbF8xLlkpKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHZlZ2FfZXZlbnRfc2VsZWN0b3JfMS5zZWxlY3RvcihzZWxDbXB0Lnpvb20sICdzY29wZScpO1xuICAgICAgICBpZiAoIXNjYWxlc18xLmRlZmF1bHQuaGFzKHNlbENtcHQpKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoZS5tYXJrbmFtZSA9IG5hbWUgKyBpbnRlcnZhbF8xLkJSVVNILCBlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFscy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBBTkNIT1IsXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogXCJ7eDogaW52ZXJ0KFwiICsgc3ggKyBcIiwgeCh1bml0KSksIHk6IGludmVydChcIiArIHN5ICsgXCIsIHkodW5pdCkpfVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogZGVsdGEsXG4gICAgICAgICAgICBvbjogW3tcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6ICdwb3coMS4wMDEsIGV2ZW50LmRlbHRhWSAqIHBvdygxNiwgZXZlbnQuZGVsdGFNb2RlKSknXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbkRlbHRhKG1vZGVsLCBzZWxDbXB0LCAneCcsICd3aWR0aCcsIHNpZ25hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbkRlbHRhKG1vZGVsLCBzZWxDbXB0LCAneScsICdoZWlnaHQnLCBzaWduYWxzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09IG5hbWUgKyBpbnRlcnZhbF8xLlNJWkU7IH0pO1xuICAgICAgICBpZiAoc2l6ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzbmFtZSA9IHNpemVbMF0ubmFtZTtcbiAgICAgICAgICAgIHNpemVbMF0ub24ucHVzaCh7XG4gICAgICAgICAgICAgICAgZXZlbnRzOiB7IHNpZ25hbDogZGVsdGEgfSxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IFwie3g6IFwiICsgc25hbWUgKyBcIi54LCB5OiBcIiArIHNuYW1lICsgXCIueSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJ3aWR0aDogXCIgKyBzbmFtZSArIFwiLndpZHRoICogXCIgKyBkZWx0YSArIFwiICwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwiaGVpZ2h0OiBcIiArIHNuYW1lICsgXCIuaGVpZ2h0ICogXCIgKyBkZWx0YSArIFwifVwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25hbHM7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHpvb207XG5mdW5jdGlvbiBvbkRlbHRhKG1vZGVsLCBzZWxDbXB0LCBjaGFubmVsLCBzaXplLCBzaWduYWxzKSB7XG4gICAgdmFyIG5hbWUgPSBzZWxDbXB0Lm5hbWUsIHNpZ25hbCA9IHNpZ25hbHMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm5hbWUgPT09IG5hbWUgKyAnXycgKyBjaGFubmVsOyB9KVswXSwgc2NhbGVzID0gc2NhbGVzXzEuZGVmYXVsdC5oYXMoc2VsQ21wdCksIGJhc2UgPSBzY2FsZXMgPyBzY2FsZXNfMS5kb21haW4obW9kZWwsIGNoYW5uZWwpIDogc2lnbmFsLm5hbWUsIGFuY2hvciA9IFwiXCIgKyBuYW1lICsgQU5DSE9SICsgXCIuXCIgKyBjaGFubmVsLCBkZWx0YSA9IG5hbWUgKyBERUxUQSwgc2NhbGUgPSB1dGlsXzEuc3RyaW5nVmFsdWUobW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpKSwgcmFuZ2UgPSBcIltcIiArIGFuY2hvciArIFwiICsgKFwiICsgYmFzZSArIFwiWzBdIC0gXCIgKyBhbmNob3IgKyBcIikgKiBcIiArIGRlbHRhICsgXCIsIFwiICtcbiAgICAgICAgKGFuY2hvciArIFwiICsgKFwiICsgYmFzZSArIFwiWzFdIC0gXCIgKyBhbmNob3IgKyBcIikgKiBcIiArIGRlbHRhICsgXCJdXCIpLCBsbyA9IFwiaW52ZXJ0KFwiICsgc2NhbGUgKyAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyAnLCAwJyA6IFwiLCB1bml0LlwiICsgc2l6ZSkgKyAnKScsIGhpID0gXCJpbnZlcnQoXCIgKyBzY2FsZSArIChjaGFubmVsID09PSBjaGFubmVsXzEuWCA/IFwiLCB1bml0LlwiICsgc2l6ZSA6ICcsIDAnKSArICcpJztcbiAgICBzaWduYWwub24ucHVzaCh7XG4gICAgICAgIGV2ZW50czogeyBzaWduYWw6IGRlbHRhIH0sXG4gICAgICAgIHVwZGF0ZTogc2NhbGVzID8gcmFuZ2UgOiBcImNsYW1wUmFuZ2UoXCIgKyByYW5nZSArIFwiLCBcIiArIGxvICsgXCIsIFwiICsgaGkgKyBcIilcIlxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZW05dmJTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1THk0dUx5NHVMM055WXk5amIyMXdhV3hsTDNObGJHVmpkR2x2Ymk5MGNtRnVjMlp2Y20xekwzcHZiMjB1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3d5UkVGQk9FUTdRVUZET1VRc05FTkJRU3RETzBGQlF5OURMSE5EUVVFd1F6dEJRVU14UXl4M1EwRkJLMGM3UVVGSEwwY3NiVU5CUVRKRU8wRkJSek5FTEVsQlFVMHNUVUZCVFN4SFFVRkhMR05CUVdNc1JVRkRka0lzUzBGQlN5eEhRVUZKTEdGQlFXRXNRMEZCUXp0QlFVVTNRaXhKUVVGTkxFbEJRVWtzUjBGQmNVSTdTVUZETjBJc1IwRkJSeXhGUVVGRkxGVkJRVk1zVDBGQlR6dFJRVU51UWl4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRExFbEJRVWtzUzBGQlN5eFZRVUZWTEVsQlFVa3NUMEZCVHl4RFFVRkRMRWxCUVVrc1MwRkJTeXhUUVVGVExFbEJRVWtzVDBGQlR5eERRVUZETEVsQlFVa3NTMEZCU3l4TFFVRkxMRU5CUVVNN1NVRkROMFlzUTBGQlF6dEpRVVZFTEU5QlFVOHNSVUZCUlN4VlFVRlRMRXRCUVVzc1JVRkJSU3hQUVVGUExFVkJRVVVzVDBGQlR6dFJRVU4yUXl4SlFVRk5MRWxCUVVrc1IwRkJSeXhQUVVGUExFTkJRVU1zU1VGQlNTeEZRVU55UWl4TFFVRkxMRWRCUVVjc1NVRkJTU3hIUVVGSExFdEJRVXNzUlVGRGNFSXNiME5CUVhGRExFVkJRWEJETEZGQlFVTXNSVUZCUlN4UlFVRkRMRVZCUTB3c1JVRkJSU3hIUVVGSExHdENRVUZYTEVOQlFVTXNTMEZCU3l4RFFVRkRMRk5CUVZNc1EwRkJReXhYUVVGRExFTkJRVU1zUTBGQlF5eEZRVU53UXl4RlFVRkZMRWRCUVVjc2EwSkJRVmNzUTBGQlF5eExRVUZMTEVOQlFVTXNVMEZCVXl4RFFVRkRMRmRCUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRmVrTXNTVUZCU1N4TlFVRk5MRWRCUVVjc09FSkJRV0VzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRE8xRkJSV3hFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1owSkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBETEUxQlFVMHNSMEZCUnl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hIUVVGSExFbEJRVWtzUjBGQlJ5eG5Ra0ZCWXl4RlFVRkZMRU5CUVVNc1EwRkJReXhGUVVGMlF5eERRVUYxUXl4RFFVRkRMRU5CUVVNN1VVRkRkRVVzUTBGQlF6dFJRVVZFTEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNN1dVRkRXQ3hKUVVGSkxFVkJRVVVzU1VGQlNTeEhRVUZITEUxQlFVMDdXVUZEYmtJc1JVRkJSU3hGUVVGRkxFTkJRVU03YjBKQlEwZ3NUVUZCVFN4RlFVRkZMRTFCUVUwN2IwSkJRMlFzVFVGQlRTeEZRVUZGTEdkQ1FVRmpMRVZCUVVVc09FSkJRWGxDTEVWQlFVVXNaMEpCUVdFN2FVSkJRMnBGTEVOQlFVTTdVMEZEU0N4RlFVRkZPMWxCUTBRc1NVRkJTU3hGUVVGRkxFdEJRVXM3V1VGRFdDeEZRVUZGTEVWQlFVVXNRMEZCUXp0dlFrRkRTQ3hOUVVGTkxFVkJRVVVzVFVGQlRUdHZRa0ZEWkN4TFFVRkxMRVZCUVVVc1NVRkJTVHR2UWtGRFdDeE5RVUZOTEVWQlFVVXNjVVJCUVhGRU8ybENRVU01UkN4RFFVRkRPMU5CUTBnc1EwRkJReXhEUVVGRE8xRkJSVWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFppeFBRVUZQTEVOQlFVTXNTMEZCU3l4RlFVRkZMRTlCUVU4c1JVRkJSU3hIUVVGSExFVkJRVVVzVDBGQlR5eEZRVUZGTEU5QlFVOHNRMEZCUXl4RFFVRkRPMUZCUTJwRUxFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU5tTEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1QwRkJUeXhGUVVGRkxFZEJRVWNzUlVGQlJTeFJRVUZSTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRiRVFzUTBGQlF6dFJRVVZFTEVsQlFVMHNTVUZCU1N4SFFVRkhMRTlCUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eERRVUZMTEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1NVRkJTU3hMUVVGTExFbEJRVWtzUjBGQlJ5eGxRVUZoTEVWQlFTOUNMRU5CUVN0Q0xFTkJRVU1zUTBGQlF6dFJRVU40UlN4RlFVRkZMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm9RaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRE8xbEJRek5DTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zU1VGQlNTeERRVUZETzJkQ1FVTmtMRTFCUVUwc1JVRkJSU3hGUVVGRExFMUJRVTBzUlVGQlJTeExRVUZMTEVWQlFVTTdaMEpCUTNaQ0xFMUJRVTBzUlVGQlJTeFRRVUZQTEV0QlFVc3NaVUZCVlN4TFFVRkxMRk5CUVUwN2NVSkJRM1pETEZsQlFWVXNTMEZCU3l4cFFrRkJXU3hMUVVGTExGRkJRVXNzUTBGQlFUdHhRa0ZEY2tNc1lVRkJWeXhMUVVGTExHdENRVUZoTEV0QlFVc3NUVUZCUnl4RFFVRkJPMkZCUTNoRExFTkJRVU1zUTBGQlF6dFJRVU5NTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1QwRkJUeXhEUVVGRE8wbEJRMnBDTEVOQlFVTTdRMEZEUml4RFFVRkRPMEZCUldNc2RVSkJRVTg3UVVGRmRrSXNhVUpCUVdsQ0xFdEJRV2RDTEVWQlFVVXNUMEZCTWtJc1JVRkJSU3hQUVVGblFpeEZRVUZGTEVsQlFWa3NSVUZCUlN4UFFVRmpPMGxCUXpWSExFbEJRVTBzU1VGQlNTeEhRVUZITEU5QlFVOHNRMEZCUXl4SlFVRkpMRVZCUTNKQ0xFMUJRVTBzUjBGQlR5eFBRVUZQTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1EwRkJTeXhKUVVGTExFOUJRVUVzUTBGQlF5eERRVUZETEVsQlFVa3NTMEZCU3l4SlFVRkpMRWRCUVVjc1IwRkJSeXhIUVVGSExFOUJRVThzUlVGQkwwSXNRMEZCSzBJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEZRVU14UlN4TlFVRk5MRWRCUVVjc1owSkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRVZCUTNCRExFbEJRVWtzUjBGQlJ5eE5RVUZOTEVkQlFVY3NaVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hQUVVGUExFTkJRVU1zUjBGQlJ5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RlFVTndSQ3hOUVVGTkxFZEJRVWNzUzBGQlJ5eEpRVUZKTEVkQlFVY3NUVUZCVFN4VFFVRkpMRTlCUVZNc1JVRkRkRU1zUzBGQlN5eEhRVUZKTEVsQlFVa3NSMEZCUnl4TFFVRkxMRVZCUTNKQ0xFdEJRVXNzUjBGQlNTeHJRa0ZCVnl4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNSVUZET1VNc1MwRkJTeXhIUVVGSkxFMUJRVWtzVFVGQlRTeFpRVUZQTEVsQlFVa3NZMEZCVXl4TlFVRk5MRmxCUVU4c1MwRkJTeXhQUVVGSk8xTkJRM2hFTEUxQlFVMHNXVUZCVHl4SlFVRkpMR05CUVZNc1RVRkJUU3haUVVGUExFdEJRVXNzVFVGQlJ5eERRVUZCTEVWQlEzQkVMRVZCUVVVc1IwRkJSeXhaUVVGVkxFdEJRVThzUjBGQlJ5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWRCUVVjc1MwRkJTeXhIUVVGSExGbEJRVlVzU1VGQlRTeERRVUZETEVkQlFVY3NSMEZCUnl4RlFVTjZSU3hGUVVGRkxFZEJRVWNzV1VGQlZTeExRVUZQTEVkQlFVY3NRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhIUVVGSExGbEJRVlVzU1VGQlRTeEhRVUZITEV0QlFVc3NRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJRenRKUVVVNVJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMRWxCUVVrc1EwRkJRenRSUVVOaUxFMUJRVTBzUlVGQlJTeEZRVUZETEUxQlFVMHNSVUZCUlN4TFFVRkxMRVZCUVVNN1VVRkRka0lzVFVGQlRTeEZRVUZGTEUxQlFVMHNSMEZCUnl4TFFVRkxMRWRCUVVjc1owSkJRV01zUzBGQlN5eFZRVUZMTEVWQlFVVXNWVUZCU3l4RlFVRkZMRTFCUVVjN1MwRkRPVVFzUTBGQlF5eERRVUZETzBGQlEwd3NRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4uL2NoYW5uZWxcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuLi9lbmNvZGluZ1wiKTtcbnZhciB2bEVuY29kaW5nID0gcmVxdWlyZShcIi4uL2VuY29kaW5nXCIpOyAvLyBUT0RPOiByZW1vdmVcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4uL2ZpZWxkZGVmXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuLi9tYXJrXCIpO1xudmFyIHNjYWxlXzEgPSByZXF1aXJlKFwiLi4vc2NhbGVcIik7XG52YXIgc3RhY2tfMSA9IHJlcXVpcmUoXCIuLi9zdGFja1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBwYXJzZV8xID0gcmVxdWlyZShcIi4vYXhpcy9wYXJzZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBhc3NlbWJsZV8xID0gcmVxdWlyZShcIi4vZGF0YS9hc3NlbWJsZVwiKTtcbnZhciBwYXJzZV8yID0gcmVxdWlyZShcIi4vZGF0YS9wYXJzZVwiKTtcbnZhciBsYXlvdXRfMSA9IHJlcXVpcmUoXCIuL2xheW91dFwiKTtcbnZhciBwYXJzZV8zID0gcmVxdWlyZShcIi4vbGVnZW5kL3BhcnNlXCIpO1xudmFyIGluaXRfMSA9IHJlcXVpcmUoXCIuL21hcmsvaW5pdFwiKTtcbnZhciBtYXJrXzIgPSByZXF1aXJlKFwiLi9tYXJrL21hcmtcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGluaXRfMiA9IHJlcXVpcmUoXCIuL3NjYWxlL2luaXRcIik7XG52YXIgcGFyc2VfNCA9IHJlcXVpcmUoXCIuL3NjYWxlL3BhcnNlXCIpO1xudmFyIHNlbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vc2VsZWN0aW9uL3NlbGVjdGlvblwiKTtcbi8qKlxuICogSW50ZXJuYWwgbW9kZWwgb2YgVmVnYS1MaXRlIHNwZWNpZmljYXRpb24gZm9yIHRoZSBjb21waWxlci5cbiAqL1xudmFyIFVuaXRNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVW5pdE1vZGVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuaXRNb2RlbChzcGVjLCBwYXJlbnQsIHBhcmVudEdpdmVuTmFtZSwgY2ZnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNwZWMsIHBhcmVudCwgcGFyZW50R2l2ZW5OYW1lLCBjZmcpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IHt9O1xuICAgICAgICBfdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYXhlcyA9IHt9O1xuICAgICAgICBfdGhpcy5sZWdlbmRzID0ge307XG4gICAgICAgIF90aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIEZJWE1FKCMyMDQxKTogY29weSBjb25maWcuZmFjZXQuY2VsbCB0byBjb25maWcuY2VsbCAtLSB0aGlzIHNlZW1zIGluY29ycmVjdCBhbmQgc2hvdWxkIGJlIHJld3JpdHRlblxuICAgICAgICBfdGhpcy5pbml0RmFjZXRDZWxsQ29uZmlnKCk7XG4gICAgICAgIC8vIHVzZSB0b3AtbGV2ZWwgd2lkdGggLyBoZWlnaHQgb3IgcGFyZW50J3MgdG9wLWxldmVsIHdpZHRoIC8gaGVpZ2h0XG4gICAgICAgIC8vIEZJWE1FOiBvbmNlIGZhY2V0IHN1cHBvcnRzIHdpZHRoL2hlaWdodCwgdGhpcyBpcyBubyBsb25nZXIgY29ycmVjdCFcbiAgICAgICAgdmFyIHByb3ZpZGVkV2lkdGggPSBzcGVjLndpZHRoICE9PSB1bmRlZmluZWQgPyBzcGVjLndpZHRoIDpcbiAgICAgICAgICAgIHBhcmVudCA/IHBhcmVudFsnd2lkdGgnXSA6IHVuZGVmaW5lZDsgLy8gb25seSBleGlzdHMgaWYgcGFyZW50IGlzIGxheWVyXG4gICAgICAgIHZhciBwcm92aWRlZEhlaWdodCA9IHNwZWMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBzcGVjLmhlaWdodCA6XG4gICAgICAgICAgICBwYXJlbnQgPyBwYXJlbnRbJ2hlaWdodCddIDogdW5kZWZpbmVkOyAvLyBvbmx5IGV4aXN0cyBpZiBwYXJlbnQgaXMgbGF5ZXJcbiAgICAgICAgdmFyIG1hcmsgPSBtYXJrXzEuaXNNYXJrRGVmKHNwZWMubWFyaykgPyBzcGVjLm1hcmsudHlwZSA6IHNwZWMubWFyaztcbiAgICAgICAgdmFyIGVuY29kaW5nID0gX3RoaXMuZW5jb2RpbmcgPSBlbmNvZGluZ18xLm5vcm1hbGl6ZUVuY29kaW5nKHNwZWMuZW5jb2RpbmcgfHwge30sIG1hcmspO1xuICAgICAgICAvLyBjYWxjdWxhdGUgc3RhY2sgcHJvcGVydGllc1xuICAgICAgICBfdGhpcy5zdGFjayA9IHN0YWNrXzEuc3RhY2sobWFyaywgZW5jb2RpbmcsIF90aGlzLmNvbmZpZy5zdGFjayk7XG4gICAgICAgIF90aGlzLnNjYWxlcyA9IF90aGlzLmluaXRTY2FsZXMobWFyaywgZW5jb2RpbmcsIHByb3ZpZGVkV2lkdGgsIHByb3ZpZGVkSGVpZ2h0KTtcbiAgICAgICAgX3RoaXMubWFya0RlZiA9IGluaXRfMS5pbml0TWFya0RlZihzcGVjLm1hcmssIGVuY29kaW5nLCBfdGhpcy5zY2FsZXMsIF90aGlzLmNvbmZpZyk7XG4gICAgICAgIF90aGlzLmVuY29kaW5nID0gaW5pdF8xLmluaXRFbmNvZGluZyhtYXJrLCBlbmNvZGluZywgX3RoaXMuc3RhY2ssIF90aGlzLmNvbmZpZyk7XG4gICAgICAgIF90aGlzLmF4ZXMgPSBfdGhpcy5pbml0QXhlcyhlbmNvZGluZyk7XG4gICAgICAgIF90aGlzLmxlZ2VuZHMgPSBfdGhpcy5pbml0TGVnZW5kKGVuY29kaW5nKTtcbiAgICAgICAgLy8gU2VsZWN0aW9ucyB3aWxsIGJlIGluaXRpYWxpemVkIHVwb24gcGFyc2UuXG4gICAgICAgIF90aGlzLnNlbGVjdGlvbiA9IHNwZWMuc2VsZWN0aW9uO1xuICAgICAgICAvLyB3aWR0aCAvIGhlaWdodFxuICAgICAgICB2YXIgX2EgPSBfdGhpcy5pbml0U2l6ZShtYXJrLCBfdGhpcy5zY2FsZXMsIHByb3ZpZGVkV2lkdGgsIHByb3ZpZGVkSGVpZ2h0KSwgX2IgPSBfYS53aWR0aCwgd2lkdGggPSBfYiA9PT0gdm9pZCAwID8gX3RoaXMud2lkdGggOiBfYiwgX2MgPSBfYS5oZWlnaHQsIGhlaWdodCA9IF9jID09PSB2b2lkIDAgPyBfdGhpcy5oZWlnaHQgOiBfYztcbiAgICAgICAgX3RoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgX3RoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaW5pdEZhY2V0Q2VsbENvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIGhhc0ZhY2V0QW5jZXN0b3IgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3IuaXNGYWNldCgpKSB7XG4gICAgICAgICAgICAgICAgaGFzRmFjZXRBbmNlc3RvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRmFjZXRBbmNlc3Rvcikge1xuICAgICAgICAgICAgY29uZmlnLmNlbGwgPSB1dGlsXzEuZXh0ZW5kKHt9LCBjb25maWcuY2VsbCwgY29uZmlnLmZhY2V0LmNlbGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmluaXRTY2FsZXMgPSBmdW5jdGlvbiAobWFyaywgZW5jb2RpbmcsIHRvcExldmVsV2lkdGgsIHRvcExldmVsSGVpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4eVJhbmdlU3RlcHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWxfMS5VTklUX1NDQUxFX0NIQU5ORUxTLnJlZHVjZShmdW5jdGlvbiAoc2NhbGVzLCBjaGFubmVsKSB7XG4gICAgICAgICAgICBpZiAodmxFbmNvZGluZy5jaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWwpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5uZWwgPT09IGNoYW5uZWxfMS5YICYmIHZsRW5jb2RpbmcuY2hhbm5lbEhhc0ZpZWxkKGVuY29kaW5nLCBjaGFubmVsXzEuWDIpKSB8fFxuICAgICAgICAgICAgICAgIChjaGFubmVsID09PSBjaGFubmVsXzEuWSAmJiB2bEVuY29kaW5nLmNoYW5uZWxIYXNGaWVsZChlbmNvZGluZywgY2hhbm5lbF8xLlkyKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZXNbY2hhbm5lbF0gPSBpbml0XzIuZGVmYXVsdChjaGFubmVsLCBlbmNvZGluZ1tjaGFubmVsXSwgX3RoaXMuY29uZmlnLCBtYXJrLCBjaGFubmVsID09PSBjaGFubmVsXzEuWCA/IHRvcExldmVsV2lkdGggOiBjaGFubmVsID09PSBjaGFubmVsXzEuWSA/IHRvcExldmVsSGVpZ2h0IDogdW5kZWZpbmVkLCB4eVJhbmdlU3RlcHMgLy8gZm9yIGRldGVybWluZSBwb2ludCAvIGJhciBzaXplXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggfHwgY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlLnJhbmdlU3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeHlSYW5nZVN0ZXBzLnB1c2goc2NhbGUucmFuZ2VTdGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzY2FsZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGNvbnNvbGlkYXRlIHRoaXMgd2l0aCBzY2FsZT8gIEN1cnJlbnQgc2NhbGUgcmFuZ2UgaXMgaW4gcGFyc2VTY2FsZSAobGF0ZXIpLFxuICAgIC8vIGJ1dCBub3QgaW4gaW5pdFNjYWxlIGJlY2F1c2Ugc2NhbGUgcmFuZ2UgZGVwZW5kcyBvbiBzaXplLFxuICAgIC8vIGJ1dCBzaXplIGRlcGVuZHMgb24gc2NhbGUgdHlwZSBhbmQgcmFuZ2VTdGVwXG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5pbml0U2l6ZSA9IGZ1bmN0aW9uIChtYXJrLCBzY2FsZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY2VsbENvbmZpZyA9IHRoaXMuY29uZmlnLmNlbGw7XG4gICAgICAgIHZhciBzY2FsZUNvbmZpZyA9IHRoaXMuY29uZmlnLnNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHNjYWxlW2NoYW5uZWxfMS5YXSkge1xuICAgICAgICAgICAgICAgIGlmICghc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZVtjaGFubmVsXzEuWF0udHlwZSkgfHwgIXNjYWxlW2NoYW5uZWxfMS5YXS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjZWxsQ29uZmlnLndpZHRoO1xuICAgICAgICAgICAgICAgIH0gLy8gZWxzZTogRG8gbm90aGluZywgdXNlIGR5bmFtaWMgd2lkdGguXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobWFyayA9PT0gbWFya18xLlRFWFQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRleHQgdGFibGUgd2l0aG91dCB4L3kgc2NhbGUgd2UgbmVlZCB3aWRlciByYW5nZVN0ZXBcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzY2FsZUNvbmZpZy50ZXh0WFJhbmdlU3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NhbGVDb25maWcucmFuZ2VTdGVwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfaW5pdFNpemUgZG9lcyBub3QgaGFuZGxlIHN0cmluZyByYW5nZVN0ZXBzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzY2FsZUNvbmZpZy5yYW5nZVN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHNjYWxlW2NoYW5uZWxfMS5ZXSkge1xuICAgICAgICAgICAgICAgIGlmICghc2NhbGVfMS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZVtjaGFubmVsXzEuWV0udHlwZSkgfHwgIXNjYWxlW2NoYW5uZWxfMS5ZXS5yYW5nZVN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gY2VsbENvbmZpZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlOiBEbyBub3RoaW5nLCB1c2UgZHluYW1pYyBoZWlnaHQgLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2FsZUNvbmZpZy5yYW5nZVN0ZXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX2luaXRTaXplIGRvZXMgbm90IGhhbmRsZSBzdHJpbmcgcmFuZ2VTdGVwcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzY2FsZUNvbmZpZy5yYW5nZVN0ZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5pbml0QXhlcyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0ucmVkdWNlKGZ1bmN0aW9uIChfYXhpcywgY2hhbm5lbCkge1xuICAgICAgICAgICAgLy8gUG9zaXRpb24gQXhpc1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxEZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICAgICAgICAgIGlmIChmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikgfHxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggJiYgZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLngyKSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbCA9PT0gY2hhbm5lbF8xLlkgJiYgZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLnkyKSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1NwZWMgPSBmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikgPyBjaGFubmVsRGVmLmF4aXMgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFdlIG5vIGxvbmdlciBzdXBwb3J0IGZhbHNlIGluIHRoZSBzY2hlbWEsIGJ1dCB3ZSBrZWVwIGZhbHNlIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHkuXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNTcGVjICE9PSBudWxsICYmIGF4aXNTcGVjICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBfYXhpc1tjaGFubmVsXSA9IHRzbGliXzEuX19hc3NpZ24oe30sIGF4aXNTcGVjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2F4aXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaW5pdExlZ2VuZCA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gY2hhbm5lbF8xLk5PTlNQQVRJQUxfU0NBTEVfQ0hBTk5FTFMucmVkdWNlKGZ1bmN0aW9uIChfbGVnZW5kLCBjaGFubmVsKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgaWYgKGZpZWxkZGVmXzEuaXNGaWVsZERlZihjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRTcGVjID0gY2hhbm5lbERlZi5sZWdlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZFNwZWMgIT09IG51bGwgJiYgbGVnZW5kU3BlYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX2xlZ2VuZFtjaGFubmVsXSA9IHRzbGliXzEuX19hc3NpZ24oe30sIGxlZ2VuZFNwZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfbGVnZW5kO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLnBhcnNlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuZGF0YSA9IHBhcnNlXzIucGFyc2VEYXRhKHRoaXMpO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5wYXJzZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuc2VsZWN0aW9uID0gc2VsZWN0aW9uXzEucGFyc2VVbml0U2VsZWN0aW9uKHRoaXMsIHRoaXMuc2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VMYXlvdXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5sYXlvdXQgPSBsYXlvdXRfMS5wYXJzZVVuaXRMYXlvdXQodGhpcyk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLnBhcnNlU2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnNjYWxlcyA9IHBhcnNlXzQuZGVmYXVsdCh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VNYXJrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5tYXJrID0gbWFya18yLnBhcnNlTWFyayh0aGlzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VBeGlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5heGVzID0gcGFyc2VfMS5wYXJzZUF4aXNDb21wb25lbnQodGhpcywgW2NoYW5uZWxfMS5YLCBjaGFubmVsXzEuWV0pO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5wYXJzZUF4aXNHcm91cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLnBhcnNlR3JpZEdyb3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUucGFyc2VMZWdlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LmxlZ2VuZHMgPSBwYXJzZV8zLnBhcnNlTGVnZW5kQ29tcG9uZW50KHRoaXMpO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZURhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgYXNzZW1ibGUgZGF0YSBpbiB0aGUgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlXzEuYXNzZW1ibGVEYXRhKHV0aWxfMS52YWxzKHRoaXMuY29tcG9uZW50LmRhdGEuc291cmNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVTaWduYWxzID0gZnVuY3Rpb24gKHNpZ25hbHMpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbl8xLmFzc2VtYmxlVW5pdFNpZ25hbHModGhpcywgc2lnbmFscyk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmFzc2VtYmxlU2VsZWN0aW9uRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25fMS5hc3NlbWJsZVVuaXREYXRhKHRoaXMsIGRhdGEpO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5hc3NlbWJsZUxheW91dCA9IGZ1bmN0aW9uIChsYXlvdXREYXRhKSB7XG4gICAgICAgIHJldHVybiBsYXlvdXRfMS5hc3NlbWJsZUxheW91dCh0aGlzLCBsYXlvdXREYXRhKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVNYXJrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcmtzID0gdGhpcy5jb21wb25lbnQubWFyayB8fCBbXTtcbiAgICAgICAgbWFya3MgPSBzZWxlY3Rpb25fMS5hc3NlbWJsZVVuaXRNYXJrcyh0aGlzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcy5tYXAodGhpcy5jb3JyZWN0RGF0YU5hbWVzKTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuYXNzZW1ibGVQYXJlbnRHcm91cFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoY2VsbENvbmZpZykge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuYXBwbHlDb25maWcoe30sIGNlbGxDb25maWcsIG1hcmtfMS5GSUxMX1NUUk9LRV9DT05GSUcuY29uY2F0KFsnY2xpcCddKSk7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmNoYW5uZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbF8xLlVOSVRfQ0hBTk5FTFM7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmdldE1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kaW5nO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS50b1NwZWMgPSBmdW5jdGlvbiAoZXhjbHVkZUNvbmZpZywgZXhjbHVkZURhdGEpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gdXRpbF8xLmR1cGxpY2F0ZSh0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIHNwZWMgPSB7XG4gICAgICAgICAgICBtYXJrOiB0aGlzLm1hcmtEZWYsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFleGNsdWRlQ29uZmlnKSB7XG4gICAgICAgICAgICBzcGVjLmNvbmZpZyA9IHV0aWxfMS5kdXBsaWNhdGUodGhpcy5jb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZURhdGEpIHtcbiAgICAgICAgICAgIHNwZWMuZGF0YSA9IHV0aWxfMS5kdXBsaWNhdGUodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgZGVmYXVsdHNcbiAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgfTtcbiAgICBVbml0TW9kZWwucHJvdG90eXBlLm1hcmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtEZWYudHlwZTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuY2hhbm5lbEhhc0ZpZWxkID0gZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIHZsRW5jb2RpbmcuY2hhbm5lbEhhc0ZpZWxkKHRoaXMuZW5jb2RpbmcsIGNoYW5uZWwpO1xuICAgIH07XG4gICAgVW5pdE1vZGVsLnByb3RvdHlwZS5maWVsZERlZiA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIHx8IHt9XG4gICAgICAgIC8vIEN1cnJlbnRseSB3ZSBoYXZlIGl0IHRvIHByZXZlbnQgbnVsbCBwb2ludGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RpbmdbY2hhbm5lbF0gfHwge307XG4gICAgfTtcbiAgICAvKiogR2V0IFwiZmllbGRcIiByZWZlcmVuY2UgZm9yIHZlZ2EgKi9cbiAgICBVbml0TW9kZWwucHJvdG90eXBlLmZpZWxkID0gZnVuY3Rpb24gKGNoYW5uZWwsIG9wdCkge1xuICAgICAgICBpZiAob3B0ID09PSB2b2lkIDApIHsgb3B0ID0ge307IH1cbiAgICAgICAgdmFyIGZpZWxkRGVmID0gdGhpcy5maWVsZERlZihjaGFubmVsKTtcbiAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgb3B0ID0gdXRpbF8xLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgYmluU3VmZml4OiBzY2FsZV8xLmhhc0Rpc2NyZXRlRG9tYWluKHRoaXMuc2NhbGUoY2hhbm5lbCkudHlwZSkgPyAncmFuZ2UnIDogJ3N0YXJ0J1xuICAgICAgICAgICAgfSwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRkZWZfMS5maWVsZChmaWVsZERlZiwgb3B0KTtcbiAgICB9O1xuICAgIFVuaXRNb2RlbC5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBVbml0TW9kZWw7XG59KG1vZGVsXzEuTW9kZWwpKTtcbmV4cG9ydHMuVW5pdE1vZGVsID0gVW5pdE1vZGVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZFc1cGRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMeTR1TDNOeVl5OWpiMjF3YVd4bEwzVnVhWFF1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRMEVzYzBOQlFXbElPMEZCUldwSUxIZERRVUYzUkR0QlFVTjRSQ3gzUTBGQk1FTXNRMEZCUXl4bFFVRmxPMEZCUXpGRUxIZERRVUYzUlR0QlFVVjRSU3huUTBGQmQwWTdRVUZEZUVZc2EwTkJRV3RFTzBGQlIyeEVMR3REUVVGblJEdEJRVU5vUkN4blEwRkJjMFE3UVVGSGRFUXNjME5CUVdkRU8wRkJRMmhFTEcxRFFVRnhRenRCUVVOeVF5dzBRMEZCTmtNN1FVRkROME1zYzBOQlFYVkRPMEZCUTNaRExHMURRVUY1UkR0QlFVTjZSQ3gzUTBGQmIwUTdRVUZEY0VRc2IwTkJRWE5FTzBGQlEzUkVMRzlEUVVGelF6dEJRVU4wUXl4cFEwRkJPRUk3UVVGRE9VSXNjVU5CUVhGRE8wRkJRM0pETEhWRFFVRm5SRHRCUVVOb1JDeHRSRUZCYzBzN1FVRkZkRXM3TzBkQlJVYzdRVUZEU0R0SlFVRXJRaXh4UTBGQlN6dEpRWGxDYkVNc2JVSkJRVmtzU1VGQll5eEZRVUZGTEUxQlFXRXNSVUZCUlN4bFFVRjFRaXhGUVVGRkxFZEJRVmM3VVVGQkwwVXNXVUZEUlN4clFrRkJUU3hKUVVGSkxFVkJRVVVzVFVGQlRTeEZRVUZGTEdWQlFXVXNSVUZCUlN4SFFVRkhMRU5CUVVNc1UwRnZRekZETzFGQk4wTnJRaXhsUVVGVExFZEJRWFZDTEVWQlFVVXNRMEZCUXp0UlFVTnVReXhaUVVGTkxFZEJRV2RDTEVWQlFVVXNRMEZCUXp0UlFVTjZRaXhWUVVGSkxFZEJRV1VzUlVGQlJTeERRVUZETzFGQlEzUkNMR0ZCUVU4c1IwRkJhVUlzUlVGQlJTeERRVUZETzFGQlIzWkRMR05CUVZFc1IwRkJXU3hGUVVGRkxFTkJRVU03VVVGTE5VSXNjMGRCUVhOSE8xRkJRM1JITEV0QlFVa3NRMEZCUXl4dFFrRkJiVUlzUlVGQlJTeERRVUZETzFGQlJUTkNMRzlGUVVGdlJUdFJRVVZ3UlN4elJVRkJjMFU3VVVGRGRFVXNTVUZCVFN4aFFVRmhMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVkQlFVY3NTVUZCU1N4RFFVRkRMRXRCUVVzN1dVRkRla1FzVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhUUVVGVExFTkJRVU1zUTBGQlF5eHBRMEZCYVVNN1VVRkRla1VzU1VGQlRTeGpRVUZqTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1MwRkJTeXhUUVVGVExFZEJRVWNzU1VGQlNTeERRVUZETEUxQlFVMDdXVUZETlVRc1RVRkJUU3hIUVVGSExFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNc1EwRkJReXhwUTBGQmFVTTdVVUZGTVVVc1NVRkJUU3hKUVVGSkxFZEJRVWNzWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVU12UkN4SlFVRk5MRkZCUVZFc1IwRkJSeXhMUVVGSkxFTkJRVU1zVVVGQlVTeEhRVUZITERSQ1FVRnBRaXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVsQlFVa3NSVUZCUlN4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJSVGxGTERaQ1FVRTJRanRSUVVNM1FpeExRVUZKTEVOQlFVTXNTMEZCU3l4SFFVRkhMR0ZCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzVVVGQlVTeEZRVUZGTEV0QlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03VVVGRGRFUXNTMEZCU1N4RFFVRkRMRTFCUVUwc1IwRkJSeXhMUVVGSkxFTkJRVU1zVlVGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4UlFVRlJMRVZCUVVVc1lVRkJZU3hGUVVGRkxHTkJRV01zUTBGQlF5eERRVUZETzFGQlJUZEZMRXRCUVVrc1EwRkJReXhQUVVGUExFZEJRVWNzYTBKQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGRkJRVkVzUlVGQlJTeExRVUZKTEVOQlFVTXNUVUZCVFN4RlFVRkZMRXRCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dFJRVU14UlN4TFFVRkpMRU5CUVVNc1VVRkJVU3hIUVVGSExHMUNRVUZaTEVOQlFVTXNTVUZCU1N4RlFVRkZMRkZCUVZFc1JVRkJSU3hMUVVGSkxFTkJRVU1zUzBGQlN5eEZRVUZGTEV0QlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVWMFJTeExRVUZKTEVOQlFVTXNTVUZCU1N4SFFVRkhMRXRCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdVVUZEY0VNc1MwRkJTU3hEUVVGRExFOUJRVThzUjBGQlJ5eExRVUZKTEVOQlFVTXNWVUZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRE8xRkJSWHBETERaRFFVRTJRenRSUVVNM1F5eExRVUZKTEVOQlFVTXNVMEZCVXl4SFFVRkhMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU03VVVGRmFFTXNhVUpCUVdsQ08xRkJRMWdzU1VGQlFTeHpSVUZIVEN4RlFVaE5MR0ZCUVd0Q0xFVkJRV3hDTEhkRFFVRnJRaXhGUVVGRkxHTkJRVzlDTEVWQlFYQkNMREJEUVVGdlFpeERRVWMzUXp0UlFVTkdMRXRCUVVrc1EwRkJReXhMUVVGTExFZEJRVWNzUzBGQlN5eERRVUZETzFGQlEyNUNMRXRCUVVrc1EwRkJReXhOUVVGTkxFZEJRVWNzVFVGQlRTeERRVUZET3p0SlFVTjJRaXhEUVVGRE8wbEJSVThzZFVOQlFXMUNMRWRCUVROQ08xRkJRMFVzU1VGQlRTeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRSUVVNelFpeEpRVUZKTEZGQlFWRXNSMEZCUnl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRek5DTEVsQlFVa3NaMEpCUVdkQ0xFZEJRVWNzUzBGQlN5eERRVUZETzFGQlF6ZENMRTlCUVU4c1VVRkJVU3hMUVVGTExFbEJRVWtzUlVGQlJTeERRVUZETzFsQlEzcENMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRM1pDTEdkQ1FVRm5RaXhIUVVGSExFbEJRVWtzUTBGQlF6dG5Ra0ZEZUVJc1MwRkJTeXhEUVVGRE8xbEJRMUlzUTBGQlF6dFpRVU5FTEZGQlFWRXNSMEZCUnl4UlFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRE8xRkJRemRDTEVOQlFVTTdVVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRja0lzVFVGQlRTeERRVUZETEVsQlFVa3NSMEZCUnl4aFFVRk5MRU5CUVVNc1JVRkJSU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVWQlFVVXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU16UkN4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVWUExEaENRVUZWTEVkQlFXeENMRlZCUVcxQ0xFbEJRVlVzUlVGQlJTeFJRVUZyUWl4RlFVRkZMR0ZCUVc5Q0xFVkJRVVVzWTBGQmMwSTdVVUZCTDBZc2FVSkJjMEpETzFGQmNrSkRMRWxCUVUwc1dVRkJXU3hIUVVGaExFVkJRVVVzUTBGQlF6dFJRVVZzUXl4TlFVRk5MRU5CUVVNc05rSkJRVzFDTEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVVNc1RVRkJUU3hGUVVGRkxFOUJRVTg3V1VGRGFFUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExHVkJRV1VzUTBGQlF5eFJRVUZSTEVWQlFVVXNUMEZCVHl4RFFVRkRPMmRDUVVNM1F5eERRVUZETEU5QlFVOHNTMEZCU3l4WFFVRkRMRWxCUVVrc1ZVRkJWU3hEUVVGRExHVkJRV1VzUTBGQlF5eFJRVUZSTEVWQlFVVXNXVUZCUlN4RFFVRkRMRU5CUVVNN1owSkJRek5FTEVOQlFVTXNUMEZCVHl4TFFVRkxMRmRCUVVNc1NVRkJTU3hWUVVGVkxFTkJRVU1zWlVGQlpTeERRVUZETEZGQlFWRXNSVUZCUlN4WlFVRkZMRU5CUVVNc1EwRkROVVFzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTBnc1NVRkJUU3hMUVVGTExFZEJRVWNzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SFFVRkhMR05CUVZNc1EwRkRka01zVDBGQlR5eEZRVUZGTEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hMUVVGSkxFTkJRVU1zVFVGQlRTeEZRVUZGTEVsQlFVa3NSVUZETjBNc1QwRkJUeXhMUVVGTExGZEJRVU1zUjBGQlJ5eGhRVUZoTEVkQlFVY3NUMEZCVHl4TFFVRkxMRmRCUVVNc1IwRkJSeXhqUVVGakxFZEJRVWNzVTBGQlV5eEZRVU14UlN4WlFVRlpMRU5CUVVNc2FVTkJRV2xETzJsQ1FVTXZReXhEUVVGRE8yZENRVVZHTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFbEJRVWtzVDBGQlR5eExRVUZMTEZkQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRMjVETEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzNkQ1FVTndRaXhaUVVGWkxFTkJRVU1zU1VGQlNTeERRVUZETEV0QlFVc3NRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJRenR2UWtGRGNrTXNRMEZCUXp0blFrRkRTQ3hEUVVGRE8xbEJRMGdzUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4TlFVRk5MRU5CUVVNN1VVRkRhRUlzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTFRc1EwRkJRenRKUVVWRUxHOUdRVUZ2Ump0SlFVTndSaXcwUkVGQk5FUTdTVUZETlVRc0swTkJRU3RETzBsQlEzWkRMRFJDUVVGUkxFZEJRV2hDTEZWQlFXbENMRWxCUVZVc1JVRkJSU3hMUVVGclFpeEZRVUZGTEV0QlFXRXNSVUZCUlN4TlFVRmpPMUZCUXpWRkxFbEJRVTBzVlVGQlZTeEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRM0JETEVsQlFVMHNWMEZCVnl4SFFVRkhMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzFGQlJYUkRMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNoQ0xFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NRMEZCUXl4WFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEySXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXg1UWtGQmFVSXNRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1YwRkJReXhEUVVGRExFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0dlFrRkROMFFzUzBGQlN5eEhRVUZITEZWQlFWVXNRMEZCUXl4TFFVRkxMRU5CUVVNN1owSkJRek5DTEVOQlFVTXNRMEZCUXl4MVEwRkJkVU03V1VGRE0wTXNRMEZCUXp0WlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yZENRVU5PTEVWQlFVVXNRMEZCUXl4RFFVRkRMRWxCUVVrc1MwRkJTeXhYUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTjJRaXd5UkVGQk1rUTdiMEpCUXpORUxFdEJRVXNzUjBGQlJ5eFhRVUZYTEVOQlFVTXNZMEZCWXl4RFFVRkRPMmRDUVVOeVF5eERRVUZETzJkQ1FVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8yOUNRVU5PTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1YwRkJWeXhEUVVGRExGTkJRVk1zUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPM2RDUVVNNVF5eE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMRFpEUVVFMlF5eERRVUZETEVOQlFVTTdiMEpCUTJwRkxFTkJRVU03YjBKQlEwUXNTMEZCU3l4SFFVRkhMRmRCUVZjc1EwRkJReXhUUVVGVExFTkJRVU03WjBKQlEyaERMRU5CUVVNN1dVRkRTQ3hEUVVGRE8xRkJRMGdzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTFCUVUwc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzcENMRVZCUVVVc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eFhRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMklzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4NVFrRkJhVUlzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNWMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZETjBRc1RVRkJUU3hIUVVGSExGVkJRVlVzUTBGQlF5eE5RVUZOTEVOQlFVTTdaMEpCUXpkQ0xFTkJRVU1zUTBGQlF5eDVRMEZCZVVNN1dVRkROME1zUTBGQlF6dFpRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMmRDUVVOT0xFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNWMEZCVnl4RFFVRkRMRk5CUVZNc1MwRkJTeXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETzI5Q1FVTTVReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVUZETERaRFFVRTJReXhEUVVGRExFTkJRVU03WjBKQlEycEZMRU5CUVVNN1owSkJRMFFzVFVGQlRTeEhRVUZITEZkQlFWY3NRMEZCUXl4VFFVRlRMRU5CUVVNN1dVRkRha01zUTBGQlF6dFJRVU5JTEVOQlFVTTdVVUZGUkN4TlFVRk5MRU5CUVVNc1JVRkJReXhMUVVGTExFOUJRVUVzUlVGQlJTeE5RVUZOTEZGQlFVRXNSVUZCUXl4RFFVRkRPMGxCUTNwQ0xFTkJRVU03U1VGRlR5dzBRa0ZCVVN4SFFVRm9RaXhWUVVGcFFpeFJRVUZyUWp0UlFVTnFReXhOUVVGTkxFTkJRVU1zUTBGQlF5eFhRVUZETEVWQlFVVXNWMEZCUXl4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVk1zUzBGQlN5eEZRVUZGTEU5QlFVODdXVUZETVVNc1owSkJRV2RDTzFsQlJXaENMRWxCUVUwc1ZVRkJWU3hIUVVGSExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTnlReXhGUVVGRkxFTkJRVU1zUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRlZCUVZVc1EwRkJRenRuUWtGRGRFSXNRMEZCUXl4UFFVRlBMRXRCUVVzc1YwRkJReXhKUVVGSkxIRkNRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRE8yZENRVU14UXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhYUVVGRExFbEJRVWtzY1VKQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUlM5RExFbEJRVTBzVVVGQlVTeEhRVUZITEhGQ1FVRlZMRU5CUVVNc1ZVRkJWU3hEUVVGRExFZEJRVWNzVlVGQlZTeERRVUZETEVsQlFVa3NSMEZCUnl4SlFVRkpMRU5CUVVNN1owSkJSV3BGTEN0R1FVRXJSanRuUWtGREwwWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hMUVVGTExFbEJRVWtzU1VGQlNTeFJRVUZSTEV0QlFVc3NTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRE5VTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXgzUWtGRFZDeFJRVUZSTEVOQlExb3NRMEZCUXp0blFrRkRTaXhEUVVGRE8xbEJRMGdzUTBGQlF6dFpRVU5FTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkRaaXhEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdTVUZEVkN4RFFVRkRPMGxCUlU4c09FSkJRVlVzUjBGQmJFSXNWVUZCYlVJc1VVRkJhMEk3VVVGRGJrTXNUVUZCVFN4RFFVRkRMRzFEUVVGNVFpeERRVUZETEUxQlFVMHNRMEZCUXl4VlFVRlRMRTlCUVU4c1JVRkJSU3hQUVVGUE8xbEJReTlFTEVsQlFVMHNWVUZCVlN4SFFVRkhMRkZCUVZFc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU55UXl4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRE0wSXNTVUZCVFN4VlFVRlZMRWRCUVVjc1ZVRkJWU3hEUVVGRExFMUJRVTBzUTBGQlF6dG5Ra0ZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeExRVUZMTEVsQlFVa3NTVUZCU1N4VlFVRlZMRXRCUVVzc1MwRkJTeXhEUVVGRExFTkJRVU1zUTBGQlF6dHZRa0ZEYUVRc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eDNRa0ZCVHl4VlFVRlZMRU5CUVVNc1EwRkJRenRuUWtGRGNrTXNRMEZCUXp0WlFVTklMRU5CUVVNN1dVRkRSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEycENMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZGVFN3MlFrRkJVeXhIUVVGb1FqdFJRVU5GTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1NVRkJTU3hIUVVGSExHbENRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRlRU1zUTBGQlF6dEpRVVZOTEd0RFFVRmpMRWRCUVhKQ08xRkJRMFVzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4VFFVRlRMRWRCUVVjc09FSkJRV3RDTEVOQlFVTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dEpRVU4wUlN4RFFVRkRPMGxCUlUwc2JVTkJRV1VzUjBGQmRFSTdVVUZEUlN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExFMUJRVTBzUjBGQlJ5eDNRa0ZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRMmhFTEVOQlFVTTdTVUZGVFN3NFFrRkJWU3hIUVVGcVFqdFJRVU5GTEVsQlFVa3NRMEZCUXl4VFFVRlRMRU5CUVVNc1RVRkJUU3hIUVVGSExHVkJRVzFDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRjRVFzUTBGQlF6dEpRVVZOTERaQ1FVRlRMRWRCUVdoQ08xRkJRMFVzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRWRCUVVjc1owSkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTjRReXhEUVVGRE8wbEJSVTBzTmtKQlFWTXNSMEZCYUVJN1VVRkRSU3hKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NSMEZCUnl3d1FrRkJhMElzUTBGQlF5eEpRVUZKTEVWQlFVVXNRMEZCUXl4WFFVRkRMRVZCUVVVc1YwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU42UkN4RFFVRkRPMGxCUlUwc2EwTkJRV01zUjBGQmNrSTdVVUZEUlN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wbEJRMlFzUTBGQlF6dEpRVVZOTEd0RFFVRmpMRWRCUVhKQ08xRkJRMFVzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTmtMRU5CUVVNN1NVRkZUU3dyUWtGQlZ5eEhRVUZzUWp0UlFVTkZMRWxCUVVrc1EwRkJReXhUUVVGVExFTkJRVU1zVDBGQlR5eEhRVUZITERSQ1FVRnZRaXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlEzUkVMRU5CUVVNN1NVRkZUU3huUTBGQldTeEhRVUZ1UWp0UlFVTkhMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRiRUlzYVVOQlFXbERPMWxCUTJwRExFMUJRVTBzUTBGQlF5eDFRa0ZCV1N4RFFVRkRMRmRCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM3BFTEVOQlFVTTdVVUZEUkN4TlFVRk5MRU5CUVVNc1JVRkJSU3hEUVVGRE8wbEJRMW9zUTBGQlF6dEpRVVZOTEcxRFFVRmxMRWRCUVhSQ0xGVkJRWFZDTEU5QlFXTTdVVUZEYmtNc1RVRkJUU3hEUVVGRExDdENRVUZ0UWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU0xUXl4RFFVRkRPMGxCUlUwc2VVTkJRWEZDTEVkQlFUVkNMRlZCUVRaQ0xFbEJRV003VVVGRGVrTXNUVUZCVFN4RFFVRkRMRFJDUVVGeFFpeERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVNelF5eERRVUZETzBsQlJVMHNhME5CUVdNc1IwRkJja0lzVlVGQmMwSXNWVUZCYjBJN1VVRkRlRU1zVFVGQlRTeERRVUZETEhWQ1FVRmpMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUTBGQlF5eERRVUZETzBsQlF6RkRMRU5CUVVNN1NVRkZUU3hwUTBGQllTeEhRVUZ3UWp0UlFVTkZMRWxCUVVrc1MwRkJTeXhIUVVGSExFbEJRVWtzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4SlFVRkpMRVZCUVVVc1EwRkJRenRSUVVOMFF5eExRVUZMTEVkQlFVY3NOa0pCUVhOQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEV0QlFVc3NRMEZCUXl4RFFVRkRPMUZCUlRWRExFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4RFFVRkRPMGxCUXpGRExFTkJRVU03U1VGRlRTeHBSRUZCTmtJc1IwRkJjRU1zVlVGQmNVTXNWVUZCYzBJN1VVRkRla1FzVFVGQlRTeERRVUZETEc5Q1FVRlhMRU5CUVVNc1JVRkJSU3hGUVVGRkxGVkJRVlVzUlVGQlJTeDVRa0ZCYTBJc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRNVVVzUTBGQlF6dEpRVVZOTERSQ1FVRlJMRWRCUVdZN1VVRkRSU3hOUVVGTkxFTkJRVU1zZFVKQlFXRXNRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVk1zT0VKQlFWVXNSMEZCY0VJN1VVRkRSU3hOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNRMEZCUXp0SlFVTjJRaXhEUVVGRE8wbEJSVTBzTUVKQlFVMHNSMEZCWWl4VlFVRmpMR0ZCUVcxQ0xFVkJRVVVzVjBGQmFVSTdVVUZEYkVRc1NVRkJUU3hSUVVGUkxFZEJRVWNzWjBKQlFWTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03VVVGRE1VTXNTVUZCU1N4SlFVRlRMRU5CUVVNN1VVRkZaQ3hKUVVGSkxFZEJRVWM3V1VGRFRDeEpRVUZKTEVWQlFVVXNTVUZCU1N4RFFVRkRMRTlCUVU4N1dVRkRiRUlzVVVGQlVTeEZRVUZGTEZGQlFWRTdVMEZEYmtJc1EwRkJRenRSUVVWR0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVFpeEpRVUZKTEVOQlFVTXNUVUZCVFN4SFFVRkhMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMUZCUTNaRExFTkJRVU03VVVGRlJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFrSXNTVUZCU1N4RFFVRkRMRWxCUVVrc1IwRkJSeXhuUWtGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOdVF5eERRVUZETzFGQlJVUXNhMEpCUVd0Q08xRkJRMnhDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVTBzZDBKQlFVa3NSMEZCV0R0UlFVTkZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTXpRaXhEUVVGRE8wbEJSVTBzYlVOQlFXVXNSMEZCZEVJc1ZVRkJkVUlzVDBGQlowSTdVVUZEY2tNc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eGxRVUZsTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dEpRVU0xUkN4RFFVRkRPMGxCUlUwc05FSkJRVkVzUjBGQlppeFZRVUZuUWl4UFFVRm5RanRSUVVNNVFpd3dRa0ZCTUVJN1VVRkRNVUlzTUVSQlFUQkVPMUZCUXpGRUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUlVRc2NVTkJRWEZETzBsQlF6bENMSGxDUVVGTExFZEJRVm9zVlVGQllTeFBRVUZuUWl4RlFVRkZMRWRCUVhkQ08xRkJRWGhDTEc5Q1FVRkJMRVZCUVVFc1VVRkJkMEk3VVVGRGNrUXNTVUZCVFN4UlFVRlJMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVVjRReXhGUVVGRkxFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOcVFpeEhRVUZITEVkQlFVY3NZVUZCVFN4RFFVRkRPMmRDUVVOWUxGTkJRVk1zUlVGQlJTeDVRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFOUJRVThzUjBGQlJ5eFBRVUZQTzJGQlF6TkZMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRFZpeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMR2RDUVVGTExFTkJRVU1zVVVGQlVTeEZRVUZGTEVkQlFVY3NRMEZCUXl4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRlRTd3dRa0ZCVFN4SFFVRmlPMUZCUTBVc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZEU0N4blFrRkJRenRCUVVGRUxFTkJRVU1zUVVGdVZFUXNRMEZCSzBJc1lVRkJTeXhIUVcxVWJrTTdRVUZ1VkZrc09FSkJRVk1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbmV4cG9ydHMuRVJST1JCQVIgPSAnZXJyb3ItYmFyJztcbi8qKlxuICogUmVnaXN0cnkgaW5kZXggZm9yIGFsbCBjb21wb3NpdGUgbWFyaydzIG5vcm1hbGl6ZXJcbiAqL1xudmFyIG5vcm1hbGl6ZXJSZWdpc3RyeSA9IHt9O1xuZnVuY3Rpb24gYWRkKG1hcmssIG5vcm1hbGl6ZXIpIHtcbiAgICBub3JtYWxpemVyUmVnaXN0cnlbbWFya10gPSBub3JtYWxpemVyO1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG5mdW5jdGlvbiByZW1vdmUobWFyaykge1xuICAgIGRlbGV0ZSBub3JtYWxpemVyUmVnaXN0cnlbbWFya107XG59XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbi8qKlxuICogVHJhbnNmb3JtIGEgdW5pdCBzcGVjIHdpdGggY29tcG9zaXRlIG1hcmsgaW50byBhIG5vcm1hbCBsYXllciBzcGVjLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoXG4gICAgLy8gVGhpcyBHZW5lcmljVW5pdFNwZWMgaGFzIGFueSBhcyBFbmNvZGluZyBiZWNhdXNlIHVuaXQgc3BlY3Mgd2l0aCBjb21wb3NpdGUgbWFyayBjYW4gaGF2ZSBhZGRpdGlvbmFsIGVuY29kaW5nIGNoYW5uZWxzLlxuICAgIHNwZWMpIHtcbiAgICB2YXIgbWFyayA9IG1hcmtfMS5pc01hcmtEZWYoc3BlYy5tYXJrKSA/IHNwZWMubWFyay50eXBlIDogc3BlYy5tYXJrO1xuICAgIHZhciBub3JtYWxpemVyID0gbm9ybWFsaXplclJlZ2lzdHJ5W21hcmtdO1xuICAgIGlmIChub3JtYWxpemVyKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVyKHNwZWMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlZ2lzdGVyZWQgY29tcG9zaXRlIG1hcmsgXCIgKyBtYXJrKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuYWRkKGV4cG9ydHMuRVJST1JCQVIsIGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIF9tID0gc3BlYy5tYXJrLCBlbmNvZGluZyA9IHNwZWMuZW5jb2RpbmcsIG91dGVyU3BlYyA9IHRzbGliXzEuX19yZXN0KHNwZWMsIFtcIm1hcmtcIiwgXCJlbmNvZGluZ1wiXSk7XG4gICAgdmFyIF9zID0gZW5jb2Rpbmcuc2l6ZSwgZW5jb2RpbmdXaXRob3V0U2l6ZSA9IHRzbGliXzEuX19yZXN0KGVuY29kaW5nLCBbXCJzaXplXCJdKTtcbiAgICB2YXIgX3gyID0gZW5jb2RpbmcueDIsIF95MiA9IGVuY29kaW5nLnkyLCBlbmNvZGluZ1dpdGhvdXRYMlkyID0gdHNsaWJfMS5fX3Jlc3QoZW5jb2RpbmcsIFtcIngyXCIsIFwieTJcIl0pO1xuICAgIHZhciBfeCA9IGVuY29kaW5nV2l0aG91dFgyWTIueCwgX3kgPSBlbmNvZGluZ1dpdGhvdXRYMlkyLnksIGVuY29kaW5nV2l0aG91dFhfWDJfWV9ZMiA9IHRzbGliXzEuX19yZXN0KGVuY29kaW5nV2l0aG91dFgyWTIsIFtcInhcIiwgXCJ5XCJdKTtcbiAgICBpZiAoIWVuY29kaW5nLngyICYmICFlbmNvZGluZy55Mikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgeDIgb3IgeTIgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIG91dGVyU3BlYywgeyBsYXllcjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcms6ICdydWxlJyxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdXaXRob3V0U2l6ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1hcms6ICd0aWNrJyxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdXaXRob3V0WDJZMlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG1hcms6ICd0aWNrJyxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcueDIgPyB0c2xpYl8xLl9fYXNzaWduKHsgeDogZW5jb2RpbmcueDIsIHk6IGVuY29kaW5nLnkgfSwgZW5jb2RpbmdXaXRob3V0WF9YMl9ZX1kyKSA6IHRzbGliXzEuX19hc3NpZ24oeyB4OiBlbmNvZGluZy54LCB5OiBlbmNvZGluZy55MiB9LCBlbmNvZGluZ1dpdGhvdXRYX1gyX1lfWTIpXG4gICAgICAgICAgICB9XG4gICAgICAgIF0gfSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyOXRjRzl6YVhSbGJXRnlheTVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWpiMjF3YjNOcGRHVnRZWEpyTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN096dEJRVU5CTEN0Q1FVRXdRenRCUVVjM1FpeFJRVUZCTEZGQlFWRXNSMEZCWjBJc1YwRkJWeXhEUVVGRE8wRkJTMnBFT3p0SFFVVkhPMEZCUTBnc1NVRkJUU3hyUWtGQmEwSXNSMEZCY1VNc1JVRkJSU3hEUVVGRE8wRkJSV2hGTEdGQlFXOUNMRWxCUVZrc1JVRkJSU3hWUVVFd1FqdEpRVU14UkN4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4VlFVRlZMRU5CUVVNN1FVRkRlRU1zUTBGQlF6dEJRVVpFTEd0Q1FVVkRPMEZCUlVRc1owSkJRWFZDTEVsQlFWazdTVUZEYWtNc1QwRkJUeXhyUWtGQmEwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRCUVVOc1F5eERRVUZETzBGQlJrUXNkMEpCUlVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTzBsQlEwa3NlVWhCUVhsSU8wbEJRM3BJTEVsQlFUUkRPMGxCUnpsRExFbEJRVTBzU1VGQlNTeEhRVUZITEdkQ1FVRlRMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdTVUZETDBRc1NVRkJUU3hWUVVGVkxFZEJRVWNzYTBKQlFXdENMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE5VTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5tTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE1VSXNRMEZCUXp0SlFVVkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zYVVOQlFTdENMRWxCUVUwc1EwRkJReXhEUVVGRE8wRkJRM3BFTEVOQlFVTTdRVUZhUkN3NFFrRlpRenRCUVVkRUxFZEJRVWNzUTBGQlF5eG5Ra0ZCVVN4RlFVRkZMRlZCUVVNc1NVRkJlVU03U1VGREwwTXNTVUZCUVN4alFVRlJMRVZCUVVVc2QwSkJRV3RDTEVWQlFVVXNjMFJCUVZrc1EwRkJVenRKUVVOdVJDeEpRVUZCTEd0Q1FVRlJMRVZCUVVVc2QwUkJRWE5DTEVOQlFXRTdTVUZETjBNc1NVRkJRU3hwUWtGQlR5eEZRVUZGTEdsQ1FVRlBMRVZCUVVVc05FUkJRWE5DTEVOQlFXRTdTVUZEY2tRc1NVRkJRU3d3UWtGQlN5eEZRVUZGTERCQ1FVRkxMRVZCUVVVc01FVkJRVEpDTEVOQlFYZENPMGxCUlhoRkxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRVZCUVVVc1NVRkJTU3hEUVVGRExGRkJRVkVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwRExFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlFVTXNNa0pCUVRKQ0xFTkJRVU1zUTBGQlF6dEpRVU12UXl4RFFVRkRPMGxCUlVRc1RVRkJUU3h6UWtGRFJDeFRRVUZUTEVsQlExb3NTMEZCU3l4RlFVRkZPMWxCUTB3N1owSkJRMFVzU1VGQlNTeEZRVUZGTEUxQlFVMDdaMEpCUTFvc1VVRkJVU3hGUVVGRkxHMUNRVUZ0UWp0aFFVTTVRaXhGUVVGRE8yZENRVU5CTEVsQlFVa3NSVUZCUlN4TlFVRk5PMmRDUVVOYUxGRkJRVkVzUlVGQlJTeHRRa0ZCYlVJN1lVRkRPVUlzUlVGQlJUdG5Ra0ZEUkN4SlFVRkpMRVZCUVVVc1RVRkJUVHRuUWtGRFdpeFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRVZCUVVVc2MwSkJRMjVDTEVOQlFVTXNSVUZCUlN4UlFVRlJMRU5CUVVNc1JVRkJSU3hGUVVOa0xFTkJRVU1zUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXl4SlFVTldMSGRDUVVGM1FpeDFRa0ZGTTBJc1EwRkJReXhGUVVGRkxGRkJRVkVzUTBGQlF5eERRVUZETEVWQlEySXNRMEZCUXl4RlFVRkZMRkZCUVZFc1EwRkJReXhGUVVGRkxFbEJRMWdzZDBKQlFYZENMRU5CUXpWQ08yRkJRMFk3VTBGRFJpeEpRVU5FTzBGQlEwb3NRMEZCUXl4RFFVRkRMRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsZWdlbmRfMSA9IHJlcXVpcmUoXCIuL2xlZ2VuZFwiKTtcbnZhciBtYXJrID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbnZhciBzY2FsZV8xID0gcmVxdWlyZShcIi4vc2NhbGVcIik7XG52YXIgc2VsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZWxlY3Rpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMuZGVmYXVsdENlbGxDb25maWcgPSB7XG4gICAgd2lkdGg6IDIwMCxcbiAgICBoZWlnaHQ6IDIwMCxcbiAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG59O1xuZXhwb3J0cy5kZWZhdWx0RmFjZXRDZWxsQ29uZmlnID0ge1xuICAgIHN0cm9rZTogJyNjY2MnLFxuICAgIHN0cm9rZVdpZHRoOiAxXG59O1xudmFyIGRlZmF1bHRGYWNldEdyaWRDb25maWcgPSB7XG4gICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICBvcGFjaXR5OiAwLjQsXG4gICAgb2Zmc2V0OiAwXG59O1xuZXhwb3J0cy5kZWZhdWx0RmFjZXRDb25maWcgPSB7XG4gICAgYXhpczoge30sXG4gICAgZ3JpZDogZGVmYXVsdEZhY2V0R3JpZENvbmZpZyxcbiAgICBjZWxsOiBleHBvcnRzLmRlZmF1bHRGYWNldENlbGxDb25maWdcbn07XG5leHBvcnRzLmRlZmF1bHRPdmVybGF5Q29uZmlnID0ge1xuICAgIGxpbmU6IGZhbHNlXG59O1xuZXhwb3J0cy5kZWZhdWx0Q29uZmlnID0ge1xuICAgIHBhZGRpbmc6IDUsXG4gICAgbnVtYmVyRm9ybWF0OiAncycsXG4gICAgdGltZUZvcm1hdDogJyViICVkLCAlWScsXG4gICAgY291bnRUaXRsZTogJ051bWJlciBvZiBSZWNvcmRzJyxcbiAgICBjZWxsOiBleHBvcnRzLmRlZmF1bHRDZWxsQ29uZmlnLFxuICAgIG1hcms6IG1hcmsuZGVmYXVsdE1hcmtDb25maWcsXG4gICAgYXJlYToge30sXG4gICAgYmFyOiBtYXJrLmRlZmF1bHRCYXJDb25maWcsXG4gICAgY2lyY2xlOiB7fSxcbiAgICBsaW5lOiB7fSxcbiAgICBwb2ludDoge30sXG4gICAgcmVjdDoge30sXG4gICAgcnVsZToge30sXG4gICAgc3F1YXJlOiB7fSxcbiAgICB0ZXh0OiBtYXJrLmRlZmF1bHRUZXh0Q29uZmlnLFxuICAgIHRpY2s6IG1hcmsuZGVmYXVsdFRpY2tDb25maWcsXG4gICAgb3ZlcmxheTogZXhwb3J0cy5kZWZhdWx0T3ZlcmxheUNvbmZpZyxcbiAgICBzY2FsZTogc2NhbGVfMS5kZWZhdWx0U2NhbGVDb25maWcsXG4gICAgYXhpczoge30sXG4gICAgYXhpc1g6IHt9LFxuICAgIGF4aXNZOiB7fSxcbiAgICBheGlzTGVmdDoge30sXG4gICAgYXhpc1JpZ2h0OiB7fSxcbiAgICBheGlzVG9wOiB7fSxcbiAgICBheGlzQm90dG9tOiB7fSxcbiAgICBheGlzQmFuZDoge30sXG4gICAgbGVnZW5kOiBsZWdlbmRfMS5kZWZhdWx0TGVnZW5kQ29uZmlnLFxuICAgIGZhY2V0OiBleHBvcnRzLmRlZmF1bHRGYWNldENvbmZpZyxcbiAgICBzZWxlY3Rpb246IHNlbGVjdGlvbl8xLmRlZmF1bHRDb25maWcsXG59O1xuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gdXRpbF8xLm1lcmdlRGVlcCh1dGlsXzEuZHVwbGljYXRlKGV4cG9ydHMuZGVmYXVsdENvbmZpZyksIGNvbmZpZyk7XG59XG5leHBvcnRzLmluaXRDb25maWcgPSBpbml0Q29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWTI5dVptbG5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyTnZibVpwWnk1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRVU5CTEcxRFFVRXlSRHRCUVVVelJDdzJRa0ZCSzBJN1FVRkRMMElzYVVOQlFYZEVPMEZCUTNoRUxIbERRVUZ4Ump0QlFVZHlSaXdyUWtGQk5FTTdRVUZ0Umk5Q0xGRkJRVUVzYVVKQlFXbENMRWRCUVdVN1NVRkRNME1zUzBGQlN5eEZRVUZGTEVkQlFVYzdTVUZEVml4TlFVRk5MRVZCUVVVc1IwRkJSenRKUVVOWUxFbEJRVWtzUlVGQlJTeGhRVUZoTzBOQlEzQkNMRU5CUVVNN1FVRkZWeXhSUVVGQkxITkNRVUZ6UWl4SFFVRmxPMGxCUTJoRUxFMUJRVTBzUlVGQlJTeE5RVUZOTzBsQlEyUXNWMEZCVnl4RlFVRkZMRU5CUVVNN1EwRkRaaXhEUVVGRE8wRkJOa0pHTEVsQlFVMHNjMEpCUVhOQ0xFZEJRVzlDTzBsQlF6bERMRXRCUVVzc1JVRkJSU3hUUVVGVE8wbEJRMmhDTEU5QlFVOHNSVUZCUlN4SFFVRkhPMGxCUTFvc1RVRkJUU3hGUVVGRkxFTkJRVU03UTBGRFZpeERRVUZETzBGQlJWY3NVVUZCUVN4clFrRkJhMElzUjBGQlowSTdTVUZETjBNc1NVRkJTU3hGUVVGRkxFVkJRVVU3U1VGRFVpeEpRVUZKTEVWQlFVVXNjMEpCUVhOQ08wbEJRelZDTEVsQlFVa3NSVUZCUlN3NFFrRkJjMEk3UTBGRE4wSXNRMEZCUXp0QlFXdENWeXhSUVVGQkxHOUNRVUZ2UWl4SFFVRnJRanRKUVVOcVJDeEpRVUZKTEVWQlFVVXNTMEZCU3p0RFFVTmFMRU5CUVVNN1FVRXdTbGNzVVVGQlFTeGhRVUZoTEVkQlFWYzdTVUZEYmtNc1QwRkJUeXhGUVVGRkxFTkJRVU03U1VGRFZpeFpRVUZaTEVWQlFVVXNSMEZCUnp0SlFVTnFRaXhWUVVGVkxFVkJRVVVzVjBGQlZ6dEpRVU4yUWl4VlFVRlZMRVZCUVVVc2JVSkJRVzFDTzBsQlJTOUNMRWxCUVVrc1JVRkJSU3g1UWtGQmFVSTdTVUZGZGtJc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eHBRa0ZCYVVJN1NVRkROVUlzU1VGQlNTeEZRVUZGTEVWQlFVVTdTVUZEVWl4SFFVRkhMRVZCUVVVc1NVRkJTU3hEUVVGRExHZENRVUZuUWp0SlFVTXhRaXhOUVVGTkxFVkJRVVVzUlVGQlJUdEpRVU5XTEVsQlFVa3NSVUZCUlN4RlFVRkZPMGxCUTFJc1MwRkJTeXhGUVVGRkxFVkJRVVU3U1VGRFZDeEpRVUZKTEVWQlFVVXNSVUZCUlR0SlFVTlNMRWxCUVVrc1JVRkJSU3hGUVVGRk8wbEJRMUlzVFVGQlRTeEZRVUZGTEVWQlFVVTdTVUZEVml4SlFVRkpMRVZCUVVVc1NVRkJTU3hEUVVGRExHbENRVUZwUWp0SlFVTTFRaXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEdsQ1FVRnBRanRKUVVVMVFpeFBRVUZQTEVWQlFVVXNORUpCUVc5Q08wbEJRemRDTEV0QlFVc3NSVUZCUlN3d1FrRkJhMEk3U1VGRGVrSXNTVUZCU1N4RlFVRkZMRVZCUVVVN1NVRkRVaXhMUVVGTExFVkJRVVVzUlVGQlJUdEpRVU5VTEV0QlFVc3NSVUZCUlN4RlFVRkZPMGxCUTFRc1VVRkJVU3hGUVVGRkxFVkJRVVU3U1VGRFdpeFRRVUZUTEVWQlFVVXNSVUZCUlR0SlFVTmlMRTlCUVU4c1JVRkJSU3hGUVVGRk8wbEJRMWdzVlVGQlZTeEZRVUZGTEVWQlFVVTdTVUZEWkN4UlFVRlJMRVZCUVVVc1JVRkJSVHRKUVVOYUxFMUJRVTBzUlVGQlJTdzBRa0ZCYlVJN1NVRkZNMElzUzBGQlN5eEZRVUZGTERCQ1FVRnJRanRKUVVWNlFpeFRRVUZUTEVWQlFVVXNlVUpCUVhOQ08wTkJRMnhETEVOQlFVTTdRVUZGUml4dlFrRkJNa0lzVFVGQll6dEpRVU4yUXl4TlFVRk5MRU5CUVVNc1owSkJRVk1zUTBGQlF5eG5Ra0ZCVXl4RFFVRkRMSEZDUVVGaExFTkJRVU1zUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTnlSQ3hEUVVGRE8wRkJSa1FzWjBOQlJVTWlmUT09IiwiLypcbiAqIENvbnN0YW50cyBhbmQgdXRpbGl0aWVzIGZvciBkYXRhLlxuICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzVXJsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuICEhZGF0YVsndXJsJ107XG59XG5leHBvcnRzLmlzVXJsRGF0YSA9IGlzVXJsRGF0YTtcbmZ1bmN0aW9uIGlzSW5saW5lRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuICEhZGF0YVsndmFsdWVzJ107XG59XG5leHBvcnRzLmlzSW5saW5lRGF0YSA9IGlzSW5saW5lRGF0YTtcbmZ1bmN0aW9uIGlzTmFtZWREYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gISFkYXRhWyduYW1lJ107XG59XG5leHBvcnRzLmlzTmFtZWREYXRhID0gaXNOYW1lZERhdGE7XG5leHBvcnRzLk1BSU4gPSAnbWFpbic7XG5leHBvcnRzLlJBVyA9ICdyYXcnO1xuZXhwb3J0cy5MQVlPVVQgPSAnbGF5b3V0Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpHRjBZUzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OWtZWFJoTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFVRkJPenRIUVVWSE96czdRVUZ4UlVnc2JVSkJRVEJDTEVsQlFXMUNPMGxCUXpORExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRE8wRkJRM1pDTEVOQlFVTTdRVUZHUkN3NFFrRkZRenRCUVVWRUxITkNRVUUyUWl4SlFVRnRRanRKUVVNNVF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU14UWl4RFFVRkRPMEZCUmtRc2IwTkJSVU03UVVGRlJDeHhRa0ZCTkVJc1NVRkJiVUk3U1VGRE4wTXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdRVUZEZUVJc1EwRkJRenRCUVVaRUxHdERRVVZETzBGQlMxa3NVVUZCUVN4SlFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wRkJRM1JDTEZGQlFVRXNSMEZCUnl4SFFVRlZMRXRCUVVzc1EwRkJRenRCUVVOdVFpeFJRVUZCTEUxQlFVMHNSMEZCWVN4UlFVRlJMRU5CUVVNaWZRPT0iLCIvLyBEYXRlVGltZSBkZWZpbml0aW9uIG9iamVjdFxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG4vKlxuICogQSBkZXNpZ25hdGVkIHllYXIgdGhhdCBzdGFydHMgb24gU3VuZGF5LlxuICovXG52YXIgU1VOREFZX1lFQVIgPSAyMDA2O1xuZnVuY3Rpb24gaXNEYXRlVGltZShvKSB7XG4gICAgcmV0dXJuICEhbyAmJiAoISFvLnllYXIgfHwgISFvLnF1YXJ0ZXIgfHwgISFvLm1vbnRoIHx8ICEhby5kYXRlIHx8ICEhby5kYXkgfHxcbiAgICAgICAgISFvLmhvdXJzIHx8ICEhby5taW51dGVzIHx8ICEhby5zZWNvbmRzIHx8ICEhby5taWxsaXNlY29uZHMpO1xufVxuZXhwb3J0cy5pc0RhdGVUaW1lID0gaXNEYXRlVGltZTtcbmV4cG9ydHMuTU9OVEhTID0gWydqYW51YXJ5JywgJ2ZlYnJ1YXJ5JywgJ21hcmNoJywgJ2FwcmlsJywgJ21heScsICdqdW5lJywgJ2p1bHknLCAnYXVndXN0JywgJ3NlcHRlbWJlcicsICdvY3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ107XG5leHBvcnRzLlNIT1JUX01PTlRIUyA9IGV4cG9ydHMuTU9OVEhTLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5zdWJzdHIoMCwgMyk7IH0pO1xuZXhwb3J0cy5EQVlTID0gWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheSddO1xuZXhwb3J0cy5TSE9SVF9EQVlTID0gZXhwb3J0cy5EQVlTLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5zdWJzdHIoMCwgMyk7IH0pO1xuZnVuY3Rpb24gbm9ybWFsaXplUXVhcnRlcihxKSB7XG4gICAgaWYgKHV0aWxfMS5pc051bWJlcihxKSkge1xuICAgICAgICBpZiAocSA+IDQpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmludmFsaWRUaW1lVW5pdCgncXVhcnRlcicsIHEpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhY2NlcHQgMS1iYXNlZCBxdWFydGVyLCBzbyBuZWVkIHRvIHJlYWRqdXN0IHRvIDAtYmFzZWQgcXVhcnRlclxuICAgICAgICByZXR1cm4gKHEgLSAxKSArICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSW52YWxpZCBxdWFydGVyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbnZhbGlkVGltZVVuaXQoJ3F1YXJ0ZXInLCBxKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplTW9udGgobSkge1xuICAgIGlmICh1dGlsXzEuaXNOdW1iZXIobSkpIHtcbiAgICAgICAgLy8gV2UgYWNjZXB0IDEtYmFzZWQgbW9udGgsIHNvIG5lZWQgdG8gcmVhZGp1c3QgdG8gMC1iYXNlZCBtb250aFxuICAgICAgICByZXR1cm4gKG0gLSAxKSArICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGxvd2VyTSA9IG0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG1vbnRoSW5kZXggPSBleHBvcnRzLk1PTlRIUy5pbmRleE9mKGxvd2VyTSk7XG4gICAgICAgIGlmIChtb250aEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoSW5kZXggKyAnJzsgLy8gMCBmb3IgamFudWFyeSwgLi4uXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3J0TSA9IGxvd2VyTS5zdWJzdHIoMCwgMyk7XG4gICAgICAgIHZhciBzaG9ydE1vbnRoSW5kZXggPSBleHBvcnRzLlNIT1JUX01PTlRIUy5pbmRleE9mKHNob3J0TSk7XG4gICAgICAgIGlmIChzaG9ydE1vbnRoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnRNb250aEluZGV4ICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZCBtb250aFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW52YWxpZFRpbWVVbml0KCdtb250aCcsIG0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVEYXkoZCkge1xuICAgIGlmICh1dGlsXzEuaXNOdW1iZXIoZCkpIHtcbiAgICAgICAgLy8gbW9kIHNvIHRoYXQgdGhpcyBjYW4gYmUgYm90aCAwLWJhc2VkIHdoZXJlIDAgPSBzdW5kYXlcbiAgICAgICAgLy8gYW5kIDEtYmFzZWQgd2hlcmUgNz1zdW5kYXlcbiAgICAgICAgcmV0dXJuIChkICUgNykgKyAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBsb3dlckQgPSBkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBkYXlJbmRleCA9IGV4cG9ydHMuREFZUy5pbmRleE9mKGxvd2VyRCk7XG4gICAgICAgIGlmIChkYXlJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXlJbmRleCArICcnOyAvLyAwIGZvciBqYW51YXJ5LCAuLi5cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvcnREID0gbG93ZXJELnN1YnN0cigwLCAzKTtcbiAgICAgICAgdmFyIHNob3J0RGF5SW5kZXggPSBleHBvcnRzLlNIT1JUX0RBWVMuaW5kZXhPZihzaG9ydEQpO1xuICAgICAgICBpZiAoc2hvcnREYXlJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydERheUluZGV4ICsgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZCBkYXlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLmludmFsaWRUaW1lVW5pdCgnZGF5JywgZCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcChkLCBub3JtYWxpemUpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKDAsIDAsIDEsIDAsIDAsIDAsIDApOyAvLyBzdGFydCB3aXRoIHVuaWZvcm0gZGF0ZVxuICAgIC8vIEZJWE1FIHN1cHBvcnQgVVRDXG4gICAgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5rZXlzKGQpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmRyb3BwZWREYXkoZCkpO1xuICAgICAgICAgICAgZCA9IHV0aWxfMS5kdXBsaWNhdGUoZCk7XG4gICAgICAgICAgICBkZWxldGUgZC5kYXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2UgYSB5ZWFyIHRoYXQgaGFzIDEvMSBhcyBTdW5kYXkgc28gd2UgY2FuIHNldERhdGUgYmVsb3dcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoU1VOREFZX1lFQVIpO1xuICAgICAgICAgICAgdmFyIGRheSA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZURheShkLmRheSkgOiBkLmRheTtcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZSgrZGF5ICsgMSk7IC8vICsxIHNpbmNlIGRhdGUgc3RhcnQgYXQgMSBpbiBKU1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkLnllYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKGQueWVhcik7XG4gICAgfVxuICAgIGlmIChkLnF1YXJ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcXVhcnRlciA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZVF1YXJ0ZXIoZC5xdWFydGVyKSA6IGQucXVhcnRlcjtcbiAgICAgICAgZGF0ZS5zZXRNb250aCgrcXVhcnRlciAqIDMpO1xuICAgIH1cbiAgICBpZiAoZC5tb250aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBtb250aCA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZU1vbnRoKGQubW9udGgpIDogZC5tb250aDtcbiAgICAgICAgZGF0ZS5zZXRNb250aCgrbW9udGgpO1xuICAgIH1cbiAgICBpZiAoZC5kYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZS5zZXREYXRlKGQuZGF0ZSk7XG4gICAgfVxuICAgIGlmIChkLmhvdXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZS5zZXRIb3VycyhkLmhvdXJzKTtcbiAgICB9XG4gICAgaWYgKGQubWludXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhkLm1pbnV0ZXMpO1xuICAgIH1cbiAgICBpZiAoZC5zZWNvbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKGQuc2Vjb25kcyk7XG4gICAgfVxuICAgIGlmIChkLm1pbGxpc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRhdGUuc2V0TWlsbGlzZWNvbmRzKGQubWlsbGlzZWNvbmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xufVxuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4vKipcbiAqIFJldHVybiBWZWdhIEV4cHJlc3Npb24gZm9yIGEgcGFydGljdWxhciBkYXRlIHRpbWUuXG4gKiBAcGFyYW0gZFxuICogQHBhcmFtIG5vcm1hbGl6ZSB3aGV0aGVyIHRvIG5vcm1hbGl6ZSBxdWFydGVyLCBtb250aCwgZGF5LlxuICovXG5mdW5jdGlvbiBkYXRlVGltZUV4cHIoZCwgbm9ybWFsaXplKSB7XG4gICAgaWYgKG5vcm1hbGl6ZSA9PT0gdm9pZCAwKSB7IG5vcm1hbGl6ZSA9IGZhbHNlOyB9XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgaWYgKG5vcm1hbGl6ZSAmJiBkLmRheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1dGlsXzEua2V5cyhkKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5kcm9wcGVkRGF5KGQpKTtcbiAgICAgICAgICAgIGQgPSB1dGlsXzEuZHVwbGljYXRlKGQpO1xuICAgICAgICAgICAgZGVsZXRlIGQuZGF5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkLnllYXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1bml0cy5wdXNoKGQueWVhcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGQuZGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU2V0IHllYXIgdG8gMjAwNiBmb3Igd29ya2luZyB3aXRoIGRheSBzaW5jZSBKYW51YXJ5IDEgMjAwNiBpcyBhIFN1bmRheVxuICAgICAgICB1bml0cy5wdXNoKFNVTkRBWV9ZRUFSKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVuaXRzLnB1c2goMCk7XG4gICAgfVxuICAgIGlmIChkLm1vbnRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG1vbnRoID0gbm9ybWFsaXplID8gbm9ybWFsaXplTW9udGgoZC5tb250aCkgOiBkLm1vbnRoO1xuICAgICAgICB1bml0cy5wdXNoKG1vbnRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZC5xdWFydGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHF1YXJ0ZXIgPSBub3JtYWxpemUgPyBub3JtYWxpemVRdWFydGVyKGQucXVhcnRlcikgOiBkLnF1YXJ0ZXI7XG4gICAgICAgIHVuaXRzLnB1c2gocXVhcnRlciArICcqMycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5pdHMucHVzaCgwKTsgLy8gbW9udGhzIHN0YXJ0IGF0IHplcm8gaW4gSlNcbiAgICB9XG4gICAgaWYgKGQuZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVuaXRzLnB1c2goZC5kYXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZC5kYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBIQUNLOiBEYXkgb25seSB3b3JrcyBhcyBhIHN0YW5kYWxvbmUgdW5pdFxuICAgICAgICAvLyBUaGlzIGlzIG9ubHkgY29ycmVjdCBiZWNhdXNlIHdlIGFsd2F5cyBzZXQgeWVhciB0byAyMDA2IGZvciBkYXlcbiAgICAgICAgdmFyIGRheSA9IG5vcm1hbGl6ZSA/IG5vcm1hbGl6ZURheShkLmRheSkgOiBkLmRheTtcbiAgICAgICAgdW5pdHMucHVzaChkYXkgKyAnKzEnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVuaXRzLnB1c2goMSk7IC8vIERhdGUgc3RhcnRzIGF0IDEgaW4gSlNcbiAgICB9XG4gICAgLy8gTm90ZTogY2FuJ3QgdXNlIFRpbWVVbml0IGVudW0gaGVyZSBhcyBpbXBvcnRpbmcgaXQgd2lsbCBjcmVhdGVcbiAgICAvLyBjaXJjdWxhciBkZXBlbmRlbmN5IHByb2JsZW0hXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJywgJ21pbGxpc2Vjb25kcyddOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdGltZVVuaXQgPSBfYVtfaV07XG4gICAgICAgIGlmIChkW3RpbWVVbml0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1bml0cy5wdXNoKGRbdGltZVVuaXRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdkYXRldGltZSgnICsgdW5pdHMuam9pbignLCAnKSArICcpJztcbn1cbmV4cG9ydHMuZGF0ZVRpbWVFeHByID0gZGF0ZVRpbWVFeHByO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWkdGMFpYUnBiV1V1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZaR0YwWlhScGJXVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJa0ZCUVVFc05rSkJRVFpDT3pzN1FVRkZOMElzTWtKQlFUWkNPMEZCUXpkQ0xDdENRVUZwUkR0QlFVVnFSRHM3UjBGRlJ6dEJRVU5JTEVsQlFVMHNWMEZCVnl4SFFVRkhMRWxCUVVrc1EwRkJRenRCUVhkSGVrSXNiMEpCUVRKQ0xFTkJRVTA3U1VGREwwSXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVYzdVVUZEZUVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhQUVVGUExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eFpRVUZaTEVOQlFVTXNRMEZCUXp0QlFVTnFSU3hEUVVGRE8wRkJTRVFzWjBOQlIwTTdRVUZGV1N4UlFVRkJMRTFCUVUwc1IwRkJSeXhEUVVGRExGTkJRVk1zUlVGQlJTeFZRVUZWTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTlCUVU4c1JVRkJSU3hMUVVGTExFVkJRVVVzVFVGQlRTeEZRVUZGTEUxQlFVMHNSVUZCUlN4UlFVRlJMRVZCUVVVc1YwRkJWeXhGUVVGRkxGTkJRVk1zUlVGQlJTeFZRVUZWTEVWQlFVVXNWVUZCVlN4RFFVRkRMRU5CUVVNN1FVRkRjRWtzVVVGQlFTeFpRVUZaTEVkQlFVY3NZMEZCVFN4RFFVRkRMRWRCUVVjc1EwRkJReXhWUVVGRExFTkJRVU1zU1VGQlN5eFBRVUZCTEVOQlFVTXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eEZRVUZrTEVOQlFXTXNRMEZCUXl4RFFVRkRPMEZCUldwRUxGRkJRVUVzU1VGQlNTeEhRVUZITEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1JVRkJSU3hUUVVGVExFVkJRVVVzVjBGQlZ5eEZRVUZGTEZWQlFWVXNSVUZCUlN4UlFVRlJMRVZCUVVVc1ZVRkJWU3hEUVVGRExFTkJRVU03UVVGRGRFWXNVVUZCUVN4VlFVRlZMRWRCUVVjc1dVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFZRVUZETEVOQlFVTXNTVUZCU3l4UFFVRkJMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eEZRVUZETEVOQlFVTXNRMEZCUXl4RlFVRmlMRU5CUVdFc1EwRkJReXhEUVVGRE8wRkJSWHBFTERCQ1FVRXdRaXhEUVVGclFqdEpRVU14UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJoQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMVlzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExHVkJRV1VzUTBGQlF5eFRRVUZUTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFJDeERRVUZETzFGQlEwUXNiMFZCUVc5Rk8xRkJRM0JGTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUjBGQlJ5eEZRVUZGTEVOQlFVTTdTVUZEZEVJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNhMEpCUVd0Q08xRkJRMnhDTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eGxRVUZsTEVOQlFVTXNVMEZCVXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE4wUXNRMEZCUXp0QlFVTklMRU5CUVVNN1FVRkZSQ3gzUWtGQmQwSXNRMEZCYTBJN1NVRkRlRU1zUlVGQlJTeERRVUZETEVOQlFVTXNaVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5vUWl4blJVRkJaMFU3VVVGRGFFVXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4SlFVRk5MRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTTdVVUZETDBJc1NVRkJUU3hWUVVGVkxFZEJRVWNzWTBGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVNeFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4VlFVRlZMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzUkNMRTFCUVUwc1EwRkJReXhWUVVGVkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTXNjVUpCUVhGQ08xRkJReTlETEVOQlFVTTdVVUZEUkN4SlFVRk5MRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVF5eEpRVUZOTEdWQlFXVXNSMEZCUnl4dlFrRkJXU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTnlSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZsTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5DTEUxQlFVMHNRMEZCUXl4bFFVRmxMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRemxDTEVOQlFVTTdVVUZEUkN4blFrRkJaMEk3VVVGRGFFSXNUVUZCVFN4SlFVRkpMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdWQlFXVXNRMEZCUXl4UFFVRlBMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU16UkN4RFFVRkRPMEZCUTBnc1EwRkJRenRCUVVWRUxITkNRVUZ6UWl4RFFVRnJRanRKUVVOMFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMSGRFUVVGM1JEdFJRVU40UkN3MlFrRkJOa0k3VVVGRE4wSXNUVUZCVFN4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEhRVUZITEVWQlFVVXNRMEZCUXp0SlFVTjBRaXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4SlFVRk5MRTFCUVUwc1IwRkJSeXhEUVVGRExFTkJRVU1zVjBGQlZ5eEZRVUZGTEVOQlFVTTdVVUZETDBJc1NVRkJUU3hSUVVGUkxFZEJRVWNzV1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOMFF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzQkNMRTFCUVUwc1EwRkJReXhSUVVGUkxFZEJRVWNzUlVGQlJTeERRVUZETEVOQlFVTXNjVUpCUVhGQ08xRkJRemRETEVOQlFVTTdVVUZEUkN4SlFVRk5MRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOdVF5eEpRVUZOTEdGQlFXRXNSMEZCUnl4clFrRkJWU3hEUVVGRExFOUJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0UlFVTnFSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGhRVUZoTEV0QlFVc3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM3BDTEUxQlFVMHNRMEZCUXl4aFFVRmhMRWRCUVVjc1JVRkJSU3hEUVVGRE8xRkJRelZDTEVOQlFVTTdVVUZEUkN4alFVRmpPMUZCUTJRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR1ZCUVdVc1EwRkJReXhMUVVGTExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTjZSQ3hEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTEcxQ1FVRXdRaXhEUVVGWExFVkJRVVVzVTBGQmEwSTdTVUZEZGtRc1NVRkJUU3hKUVVGSkxFZEJRVWNzU1VGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5d3dRa0ZCTUVJN1NVRkZkRVVzYjBKQlFXOUNPMGxCUlhCQ0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU40UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGRrSXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRM0JETEVOQlFVTXNSMEZCUnl4blFrRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycENMRTlCUVU4c1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF6dFJRVU5tTEVOQlFVTTdVVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRaUVVOT0xEUkVRVUUwUkR0WlFVTTFSQ3hKUVVGSkxFTkJRVU1zVjBGQlZ5eERRVUZETEZkQlFWY3NRMEZCUXl4RFFVRkRPMWxCUlRsQ0xFbEJRVTBzUjBGQlJ5eEhRVUZITEZOQlFWTXNSMEZCUnl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNN1dVRkRjRVFzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEdsRFFVRnBRenRSUVVNelJDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlFpeEpRVUZKTEVOQlFVTXNWMEZCVnl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU16UWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEU5QlFVOHNTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRelZDTEVsQlFVMHNUMEZCVHl4SFFVRkhMRk5CUVZNc1IwRkJSeXhuUWtGQlowSXNRMEZCUXl4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXp0UlFVTndSU3hKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNUMEZCVHl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRNVUlzU1VGQlRTeExRVUZMTEVkQlFVY3NVMEZCVXl4SFFVRkhMR05CUVdNc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJRenRSUVVNMVJDeEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1MwRkJTeXhEUVVGRExFTkJRVU03U1VGRGVFSXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlFpeEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU4yUWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRekZDTEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETzBsQlEzcENMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE5VSXNTVUZCU1N4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdTVUZETjBJc1EwRkJRenRKUVVWRUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0xUWl4SlFVRkpMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0SlFVTTNRaXhEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRmxCUVZrc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycERMRWxCUVVrc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMGxCUTNaRExFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hEUVVGRE8wRkJRM2hDTEVOQlFVTTdRVUYwUkVRc09FSkJjMFJETzBGQlJVUTdPenM3UjBGSlJ6dEJRVU5JTEhOQ1FVRTJRaXhEUVVFd1FpeEZRVUZGTEZOQlFXbENPMGxCUVdwQ0xEQkNRVUZCTEVWQlFVRXNhVUpCUVdsQ08wbEJRM2hGTEVsQlFVMHNTMEZCU3l4SFFVRjNRaXhGUVVGRkxFTkJRVU03U1VGRmRFTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1UwRkJVeXhKUVVGSkxFTkJRVU1zUTBGQlF5eEhRVUZITEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOeVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVFVGQlRTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRka0lzUjBGQlJ5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExGVkJRVlVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNCRExFTkJRVU1zUjBGQlJ5eG5Ra0ZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnBDTEU5QlFVOHNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJRenRSUVVObUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUzBGQlN5eFRRVUZUTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNwQ0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJRM0pDTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTEhsRlFVRjVSVHRSUVVONlJTeExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRekZDTEVOQlFVTTdTVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOT0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRhRUlzUTBGQlF6dEpRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXhRaXhKUVVGTkxFdEJRVXNzUjBGQlJ5eFRRVUZUTEVkQlFVY3NZMEZCWXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUXpWRUxFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNN1NVRkRjRUlzUTBGQlF6dEpRVUZETEVsQlFVa3NRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVDBGQlR5eExRVUZMTEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRia01zU1VGQlRTeFBRVUZQTEVkQlFVY3NVMEZCVXl4SFFVRkhMR2RDUVVGblFpeERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETzFGQlEzQkZMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXpkQ0xFTkJRVU03U1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0UlFVTk9MRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl3MlFrRkJOa0k3U1VGRE9VTXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVONlFpeExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dEpRVU55UWl4RFFVRkRPMGxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRXRCUVVzc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UWl3MFEwRkJORU03VVVGRE5VTXNhMFZCUVd0Rk8xRkJRMnhGTEVsQlFVMHNSMEZCUnl4SFFVRkhMRk5CUVZNc1IwRkJSeXhaUVVGWkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU03VVVGRGNFUXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEZWtJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEhsQ1FVRjVRanRKUVVNeFF5eERRVUZETzBsQlJVUXNhVVZCUVdsRk8wbEJRMnBGTEN0Q1FVRXJRanRKUVVNdlFpeEhRVUZITEVOQlFVTXNRMEZCYlVJc1ZVRkJLME1zUlVGQkwwTXNUVUZCUXl4UFFVRlBMRVZCUVVVc1UwRkJVeXhGUVVGRkxGTkJRVk1zUlVGQlJTeGpRVUZqTEVOQlFVTXNSVUZCTDBNc1kwRkJLME1zUlVGQkwwTXNTVUZCSzBNN1VVRkJha1VzU1VGQlRTeFJRVUZSTEZOQlFVRTdVVUZEYWtJc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4TFFVRkxMRk5CUVZNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRE9VSXNTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXhRaXhEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4TFFVRkxMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEyaENMRU5CUVVNN1MwRkRSanRKUVVWRUxFMUJRVTBzUTBGQlF5eFhRVUZYTEVkQlFVY3NTMEZCU3l4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVOQlFVTTdRVUZET1VNc1EwRkJRenRCUVhCRVJDeHZRMEZ2UkVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHV0aWxpdHkgZm9yIGVuY29kaW5nIG1hcHBpbmdcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xudmFyIGZpZWxkZGVmXzEgPSByZXF1aXJlKFwiLi9maWVsZGRlZlwiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmZ1bmN0aW9uIGNoYW5uZWxIYXNGaWVsZChlbmNvZGluZywgY2hhbm5lbCkge1xuICAgIHZhciBjaGFubmVsRGVmID0gZW5jb2RpbmcgJiYgZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgaWYgKGNoYW5uZWxEZWYpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KGNoYW5uZWxEZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLnNvbWUoY2hhbm5lbERlZiwgZnVuY3Rpb24gKGZpZWxkRGVmKSB7IHJldHVybiAhIWZpZWxkRGVmLmZpZWxkOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5jaGFubmVsSGFzRmllbGQgPSBjaGFubmVsSGFzRmllbGQ7XG5mdW5jdGlvbiBpc0FnZ3JlZ2F0ZShlbmNvZGluZykge1xuICAgIHJldHVybiB1dGlsXzEuc29tZShjaGFubmVsXzEuQ0hBTk5FTFMsIGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIGlmIChjaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KGNoYW5uZWxEZWYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5zb21lKGNoYW5uZWxEZWYsIGZ1bmN0aW9uIChmaWVsZERlZikgeyByZXR1cm4gISFmaWVsZERlZi5hZ2dyZWdhdGU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkZGVmXzEuaXNGaWVsZERlZihjaGFubmVsRGVmKSAmJiAhIWNoYW5uZWxEZWYuYWdncmVnYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaXNBZ2dyZWdhdGUgPSBpc0FnZ3JlZ2F0ZTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nLCBtYXJrKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGVuY29kaW5nKS5yZWR1Y2UoZnVuY3Rpb24gKG5vcm1hbGl6ZWRFbmNvZGluZywgY2hhbm5lbCkge1xuICAgICAgICBpZiAoIWNoYW5uZWxfMS5zdXBwb3J0TWFyayhjaGFubmVsLCBtYXJrKSkge1xuICAgICAgICAgICAgLy8gRHJvcCB1bnN1cHBvcnRlZCBjaGFubmVsXG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsKGNoYW5uZWwsIG1hcmspKTtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJvcCBsaW5lJ3Mgc2l6ZSBpZiB0aGUgZmllbGQgaXMgYWdncmVnYXRlZC5cbiAgICAgICAgaWYgKGNoYW5uZWwgPT09ICdzaXplJyAmJiBtYXJrID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsRGVmID0gZW5jb2RpbmdbY2hhbm5lbF07XG4gICAgICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGNoYW5uZWxEZWYpICYmIGNoYW5uZWxEZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbChjaGFubmVsLCBtYXJrLCAnd2hlbiB0aGUgZmllbGQgaXMgYWdncmVnYXRlZC4nKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkoZW5jb2RpbmdbY2hhbm5lbF0pKSB7XG4gICAgICAgICAgICAvLyBBcnJheSBvZiBmaWVsZERlZnMgZm9yIGRldGFpbCBjaGFubmVsIChvciBwcm9kdWN0aW9uIHJ1bGUpXG4gICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdbY2hhbm5lbF0gPSBlbmNvZGluZ1tjaGFubmVsXS5yZWR1Y2UoZnVuY3Rpb24gKGNoYW5uZWxEZWZzLCBjaGFubmVsRGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikgJiYgIWZpZWxkZGVmXzEuaXNWYWx1ZURlZihjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5lbXB0eUZpZWxkRGVmKGNoYW5uZWxEZWYsIGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxEZWZzLnB1c2goZmllbGRkZWZfMS5ub3JtYWxpemUoY2hhbm5lbERlZiwgY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhbm5lbERlZnM7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgaWYgKCFmaWVsZGRlZl8xLmlzRmllbGREZWYoY2hhbm5lbERlZikgJiYgIWZpZWxkZGVmXzEuaXNWYWx1ZURlZihjaGFubmVsRGVmKSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLmVtcHR5RmllbGREZWYoY2hhbm5lbERlZiwgY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRW5jb2Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdbY2hhbm5lbF0gPSBmaWVsZGRlZl8xLm5vcm1hbGl6ZShjaGFubmVsRGVmLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEVuY29kaW5nO1xuICAgIH0sIHt9KTtcbn1cbmV4cG9ydHMubm9ybWFsaXplRW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZztcbmZ1bmN0aW9uIGlzUmFuZ2VkKGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGVuY29kaW5nICYmICgoISFlbmNvZGluZy54ICYmICEhZW5jb2RpbmcueDIpIHx8ICghIWVuY29kaW5nLnkgJiYgISFlbmNvZGluZy55MikpO1xufVxuZXhwb3J0cy5pc1JhbmdlZCA9IGlzUmFuZ2VkO1xuZnVuY3Rpb24gZmllbGREZWZzKGVuY29kaW5nKSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGNoYW5uZWxfMS5DSEFOTkVMUy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgIGlmIChjaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgKHV0aWxfMS5pc0FycmF5KGNoYW5uZWxEZWYpID8gY2hhbm5lbERlZiA6IFtjaGFubmVsRGVmXSkuZm9yRWFjaChmdW5jdGlvbiAoZmllbGREZWYpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChmaWVsZERlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLmZpZWxkRGVmcyA9IGZpZWxkRGVmcztcbmZ1bmN0aW9uIGZvckVhY2gobWFwcGluZywgZiwgdGhpc0FyZykge1xuICAgIGlmICghbWFwcGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG1hcHBpbmcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjO1xuICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkobWFwcGluZ1tjaGFubmVsXSkpIHtcbiAgICAgICAgICAgIG1hcHBpbmdbY2hhbm5lbF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhbm5lbERlZikge1xuICAgICAgICAgICAgICAgIGYuY2FsbCh0aGlzQXJnLCBjaGFubmVsRGVmLCBjaGFubmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZi5jYWxsKHRoaXNBcmcsIG1hcHBpbmdbY2hhbm5lbF0sIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmZvckVhY2ggPSBmb3JFYWNoO1xuZnVuY3Rpb24gcmVkdWNlKG1hcHBpbmcsIGYsIGluaXQsIHRoaXNBcmcpIHtcbiAgICBpZiAoIW1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIGluaXQ7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXBwaW5nKS5yZWR1Y2UoZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjO1xuICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkobWFwcGluZ1tjaGFubmVsXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBwaW5nW2NoYW5uZWxdLnJlZHVjZShmdW5jdGlvbiAocjEsIGNoYW5uZWxEZWYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZi5jYWxsKHRoaXNBcmcsIHIxLCBjaGFubmVsRGVmLCBjaGFubmVsKTtcbiAgICAgICAgICAgIH0sIHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGYuY2FsbCh0aGlzQXJnLCByLCBtYXBwaW5nW2NoYW5uZWxdLCBjaGFubmVsKTtcbiAgICAgICAgfVxuICAgIH0sIGluaXQpO1xufVxuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2laVzVqYjJScGJtY3Vhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lJdUxpOHVMaTl6Y21NdlpXNWpiMlJwYm1jdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZCUVN3clFrRkJLMEk3UVVGREwwSXNjVU5CUVhsRU8wRkJSWHBFTEhWRFFVRnBURHRCUVVOcVRDd3lRa0ZCTmtJN1FVRkZOMElzSzBKQlFYRkRPMEZCTWtWeVF5eDVRa0ZCWjBNc1VVRkJNa0lzUlVGQlJTeFBRVUZuUWp0SlFVTXpSU3hKUVVGTkxGVkJRVlVzUjBGQlJ5eFJRVUZSTEVsQlFVa3NVVUZCVVN4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRE8wbEJRMnBFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFppeEZRVUZGTEVOQlFVTXNRMEZCUXl4alFVRlBMRU5CUVVNc1ZVRkJWU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRTFCUVUwc1EwRkJReXhYUVVGSkxFTkJRVU1zVlVGQlZTeEZRVUZGTEZWQlFVTXNVVUZCVVN4SlFVRkxMRTlCUVVFc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eExRVUZMTEVWQlFXaENMRU5CUVdkQ0xFTkJRVU1zUTBGQlF6dFJRVU14UkN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNjVUpCUVZVc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF6dFJRVU5vUXl4RFFVRkRPMGxCUTBnc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdRVUZEWml4RFFVRkRPMEZCVmtRc01FTkJWVU03UVVGRlJDeHhRa0ZCTkVJc1VVRkJNa0k3U1VGRGNrUXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhyUWtGQlVTeEZRVUZGTEZWQlFVTXNUMEZCVHp0UlFVTTFRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eGxRVUZsTEVOQlFVTXNVVUZCVVN4RlFVRkZMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUXl4SlFVRk5MRlZCUVZVc1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zWTBGQlR5eERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGVFSXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhWUVVGVkxFVkJRVVVzVlVGQlF5eFJRVUZSTEVsQlFVc3NUMEZCUVN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExGTkJRVk1zUlVGQmNFSXNRMEZCYjBJc1EwRkJReXhEUVVGRE8xbEJRemxFTEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRuUWtGRFRpeE5RVUZOTEVOQlFVTXNjVUpCUVZVc1EwRkJReXhWUVVGVkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNWVUZCVlN4RFFVRkRMRk5CUVZNc1EwRkJRenRaUVVNeFJDeERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVTkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03U1VGRFppeERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTk1MRU5CUVVNN1FVRmFSQ3hyUTBGWlF6dEJRVVZFTERKQ1FVRnJReXhSUVVGclFpeEZRVUZGTEVsQlFWVTdTVUZET1VRc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zYTBKQlFUUkNMRVZCUVVVc1QwRkJaMEk3VVVGRGFrWXNSVUZCUlN4RFFVRkRMRU5CUVVNc1EwRkJReXh4UWtGQlZ5eERRVUZETEU5QlFVOHNSVUZCUlN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRGFFTXNNa0pCUVRKQ08xbEJSVE5DTEVkQlFVY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5eHRRa0ZCYlVJc1EwRkJReXhQUVVGUExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZSQ3hOUVVGTkxFTkJRVU1zYTBKQlFXdENMRU5CUVVNN1VVRkROVUlzUTBGQlF6dFJRVVZFTEN0RFFVRXJRenRSUVVNdlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1RVRkJUU3hKUVVGSkxFbEJRVWtzUzBGQlN5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpGRExFbEJRVTBzVlVGQlZTeEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVOeVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4eFFrRkJWU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEZWQlFWVXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU51UkN4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNiVUpCUVcxQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEVsQlFVa3NSVUZCUlN3clFrRkJLMElzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUXpGR0xFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1EwRkJRenRaUVVNMVFpeERRVUZETzFGQlEwZ3NRMEZCUXp0UlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExHTkJRVThzUTBGQlF5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGREwwSXNOa1JCUVRaRU8xbEJRemRFTEd0Q1FVRnJRaXhEUVVGRExFOUJRVThzUTBGQlF5eEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eFhRVUY1UWl4RlFVRkZMRlZCUVhOQ08yZENRVU4yUnl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExIRkNRVUZWTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWxCUVVrc1EwRkJReXh4UWtGQlZTeERRVUZETEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenR2UWtGRGRrUXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEdGQlFXRXNRMEZCUXl4VlFVRlZMRVZCUVVVc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZETTBRc1EwRkJRenRuUWtGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0dlFrRkRUaXhYUVVGWExFTkJRVU1zU1VGQlNTeERRVUZETEc5Q1FVRlRMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTI1RUxFTkJRVU03WjBKQlEwUXNUVUZCVFN4RFFVRkRMRmRCUVZjc1EwRkJRenRaUVVOeVFpeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1VVRkRWQ3hEUVVGRE8xRkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdXVUZEVGl4SlFVRk5MRlZCUVZVc1IwRkJSeXhSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTTdXVUZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eHhRa0ZCVlN4RFFVRkRMRlZCUVZVc1EwRkJReXhKUVVGSkxFTkJRVU1zY1VKQlFWVXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkVMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4aFFVRmhMRU5CUVVNc1ZVRkJWU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNwRUxFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1EwRkJRenRaUVVNMVFpeERRVUZETzFsQlEwUXNhMEpCUVd0Q0xFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NiMEpCUVZNc1EwRkJReXhWUVVGVkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdVVUZETDBRc1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eHJRa0ZCYTBJc1EwRkJRenRKUVVNMVFpeERRVUZETEVWQlFVVXNSVUZCUlN4RFFVRkRMRU5CUVVNN1FVRkRWQ3hEUVVGRE8wRkJkRU5FTERoRFFYTkRRenRCUVVkRUxHdENRVUY1UWl4UlFVRXlRanRKUVVOc1JDeE5RVUZOTEVOQlFVTXNVVUZCVVN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRekZHTEVOQlFVTTdRVUZHUkN3MFFrRkZRenRCUVVWRUxHMUNRVUV3UWl4UlFVRXlRanRKUVVOdVJDeEpRVUZOTEVkQlFVY3NSMEZCWlN4RlFVRkZMRU5CUVVNN1NVRkRNMElzYTBKQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJVeXhQUVVGUE8xRkJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMR1ZCUVdVc1EwRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNaRExFbEJRVTBzVlVGQlZTeEhRVUZITEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJRenRaUVVOeVF5eERRVUZETEdOQlFVOHNRMEZCUXl4VlFVRlZMRU5CUVVNc1IwRkJSeXhWUVVGVkxFZEJRVWNzUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGRExGRkJRVkU3WjBKQlEycEZMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdXVUZEY2tJc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFRDeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRTQ3hOUVVGTkxFTkJRVU1zUjBGQlJ5eERRVUZETzBGQlEySXNRMEZCUXp0QlFWaEVMRGhDUVZkRE8wRkJSVVFzYVVKQlFYZENMRTlCUVZrc1JVRkRhRU1zUTBGQmNVTXNSVUZEY2tNc1QwRkJZVHRKUVVObUxFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOaUxFMUJRVTBzUTBGQlF6dEpRVU5VTEVOQlFVTTdTVUZGUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkRMRU5CUVUwN1VVRkRiRU1zU1VGQlRTeFBRVUZQTEVkQlFWa3NRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZET1VJc1QwRkJUeXhEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRlRMRlZCUVhOQ08yZENRVU4wUkN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRka01zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVEN4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeERRVUZETEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1JVRkJSU3hQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkROME1zUTBGQlF6dEpRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTB3c1EwRkJRenRCUVdwQ1JDd3dRa0ZwUWtNN1FVRkZSQ3huUWtGQk5rSXNUMEZCVlN4RlFVTnVReXhEUVVFMFF5eEZRVU0xUXl4SlFVRlBMRVZCUVVVc1QwRkJZVHRKUVVONFFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFlpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUTJRc1EwRkJRenRKUVVWRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEVOQlFVa3NSVUZCUlN4RFFVRk5PMUZCUXpsRExFbEJRVTBzVDBGQlR5eEhRVUZaTEVOQlFVTXNRMEZCUXp0UlFVTXpRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZQTEVOQlFVTXNUMEZCVHl4RFFVRkRMRTlCUVU4c1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6bENMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNUVUZCVFN4RFFVRkRMRlZCUVZNc1JVRkJTeXhGUVVGRkxGVkJRWE5DTzJkQ1FVTnVSU3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4UFFVRlBMRVZCUVVVc1JVRkJSU3hGUVVGRkxGVkJRVlVzUlVGQlJTeFBRVUZQTEVOQlFVTXNRMEZCUXp0WlFVTnNSQ3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRFRpeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFVkJRVVVzUTBGQlF5eEZRVUZGTEU5QlFVOHNRMEZCUXl4UFFVRlBMRU5CUVVNc1JVRkJSU3hQUVVGUExFTkJRVU1zUTBGQlF6dFJRVU4yUkN4RFFVRkRPMGxCUTBnc1EwRkJReXhGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETzBGQlExZ3NRMEZCUXp0QlFXcENSQ3gzUWtGcFFrTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labUZqWlhRdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12Wm1GalpYUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJaUo5IiwiLy8gdXRpbGl0eSBmb3IgYSBmaWVsZCBkZWZpbml0aW9uIG9iamVjdFxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBhZ2dyZWdhdGVfMSA9IHJlcXVpcmUoXCIuL2FnZ3JlZ2F0ZVwiKTtcbnZhciBiaW5fMSA9IHJlcXVpcmUoXCIuL2JpblwiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciB0aW1ldW5pdF8xID0gcmVxdWlyZShcIi4vdGltZXVuaXRcIik7XG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gaXNGaWVsZERlZihjaGFubmVsRGVmKSB7XG4gICAgcmV0dXJuICEhY2hhbm5lbERlZiAmJiAoISFjaGFubmVsRGVmWydmaWVsZCddIHx8IGNoYW5uZWxEZWZbJ2FnZ3JlZ2F0ZSddID09PSAnY291bnQnKTtcbn1cbmV4cG9ydHMuaXNGaWVsZERlZiA9IGlzRmllbGREZWY7XG5mdW5jdGlvbiBpc1ZhbHVlRGVmKGNoYW5uZWxEZWYpIHtcbiAgICByZXR1cm4gY2hhbm5lbERlZiAmJiAndmFsdWUnIGluIGNoYW5uZWxEZWYgJiYgY2hhbm5lbERlZlsndmFsdWUnXSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc1ZhbHVlRGVmID0gaXNWYWx1ZURlZjtcbmZ1bmN0aW9uIGZpZWxkKGZpZWxkRGVmLCBvcHQpIHtcbiAgICBpZiAob3B0ID09PSB2b2lkIDApIHsgb3B0ID0ge307IH1cbiAgICB2YXIgZmllbGQgPSBmaWVsZERlZi5maWVsZDtcbiAgICB2YXIgcHJlZml4ID0gb3B0LnByZWZpeDtcbiAgICB2YXIgc3VmZml4ID0gb3B0LnN1ZmZpeDtcbiAgICBpZiAoaXNDb3VudChmaWVsZERlZikpIHtcbiAgICAgICAgZmllbGQgPSAnY291bnRfKic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghb3B0Lm5vZm4pIHtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi5iaW4pIHtcbiAgICAgICAgICAgICAgICBmbiA9IGJpbl8xLmJpblRvU3RyaW5nKGZpZWxkRGVmLmJpbik7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gb3B0LmJpblN1ZmZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGZuID0gU3RyaW5nKG9wdC5hZ2dyZWdhdGUgfHwgZmllbGREZWYuYWdncmVnYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkRGVmLnRpbWVVbml0KSB7XG4gICAgICAgICAgICAgICAgZm4gPSBTdHJpbmcoZmllbGREZWYudGltZVVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZmllbGQgPSBmbiArIFwiX1wiICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkICsgXCJfXCIgKyBzdWZmaXg7XG4gICAgfVxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgZmllbGQgPSBwcmVmaXggKyBcIl9cIiArIGZpZWxkO1xuICAgIH1cbiAgICBpZiAob3B0LmRhdHVtKSB7XG4gICAgICAgIGZpZWxkID0gXCJkYXR1bVtcXFwiXCIgKyBmaWVsZCArIFwiXFxcIl1cIjtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkO1xufVxuZXhwb3J0cy5maWVsZCA9IGZpZWxkO1xuZnVuY3Rpb24gaXNEaXNjcmV0ZShmaWVsZERlZikge1xuICAgIHN3aXRjaCAoZmllbGREZWYudHlwZSkge1xuICAgICAgICBjYXNlICdub21pbmFsJzpcbiAgICAgICAgY2FzZSAnb3JkaW5hbCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAncXVhbnRpdGF0aXZlJzpcbiAgICAgICAgICAgIHJldHVybiAhIWZpZWxkRGVmLmJpbjtcbiAgICAgICAgY2FzZSAndGVtcG9yYWwnOlxuICAgICAgICAgICAgLy8gVE9ETzogZGVhbCB3aXRoIGN1c3RvbSBzY2FsZSB0eXBlIGNhc2UuXG4gICAgICAgICAgICByZXR1cm4gdGltZXVuaXRfMS5pc0Rpc2NyZXRlQnlEZWZhdWx0KGZpZWxkRGVmLnRpbWVVbml0KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGxvZy5tZXNzYWdlLmludmFsaWRGaWVsZFR5cGUoZmllbGREZWYudHlwZSkpO1xufVxuZXhwb3J0cy5pc0Rpc2NyZXRlID0gaXNEaXNjcmV0ZTtcbmZ1bmN0aW9uIGlzQ29udGludW91cyhmaWVsZERlZikge1xuICAgIHJldHVybiAhaXNEaXNjcmV0ZShmaWVsZERlZik7XG59XG5leHBvcnRzLmlzQ29udGludW91cyA9IGlzQ29udGludW91cztcbmZ1bmN0aW9uIGlzQ291bnQoZmllbGREZWYpIHtcbiAgICByZXR1cm4gZmllbGREZWYuYWdncmVnYXRlID09PSAnY291bnQnO1xufVxuZXhwb3J0cy5pc0NvdW50ID0gaXNDb3VudDtcbmZ1bmN0aW9uIHRpdGxlKGZpZWxkRGVmLCBjb25maWcpIHtcbiAgICBpZiAoZmllbGREZWYudGl0bGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmllbGREZWYudGl0bGU7XG4gICAgfVxuICAgIGlmIChpc0NvdW50KGZpZWxkRGVmKSkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmNvdW50VGl0bGU7XG4gICAgfVxuICAgIHZhciBmbiA9IGZpZWxkRGVmLmFnZ3JlZ2F0ZSB8fCBmaWVsZERlZi50aW1lVW5pdCB8fCAoZmllbGREZWYuYmluICYmICdiaW4nKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuLnRvVXBwZXJDYXNlKCkgKyAnKCcgKyBmaWVsZERlZi5maWVsZCArICcpJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWVsZERlZi5maWVsZDtcbiAgICB9XG59XG5leHBvcnRzLnRpdGxlID0gdGl0bGU7XG5mdW5jdGlvbiBkZWZhdWx0VHlwZShmaWVsZERlZiwgY2hhbm5lbCkge1xuICAgIGlmIChmaWVsZERlZi50aW1lVW5pdCkge1xuICAgICAgICByZXR1cm4gJ3RlbXBvcmFsJztcbiAgICB9XG4gICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICByZXR1cm4gJ3F1YW50aXRhdGl2ZSc7XG4gICAgfVxuICAgIHN3aXRjaCAoY2hhbm5lbF8xLnJhbmdlVHlwZShjaGFubmVsKSkge1xuICAgICAgICBjYXNlICdjb250aW51b3VzJzpcbiAgICAgICAgICAgIHJldHVybiAncXVhbnRpdGF0aXZlJztcbiAgICAgICAgY2FzZSAnZGlzY3JldGUnOlxuICAgICAgICAgICAgcmV0dXJuICdub21pbmFsJztcbiAgICAgICAgY2FzZSAnZmxleGlibGUnOlxuICAgICAgICAgICAgcmV0dXJuICdub21pbmFsJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAncXVhbnRpdGF0aXZlJztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRUeXBlID0gZGVmYXVsdFR5cGU7XG4vKipcbiAqIENvbnZlcnQgdHlwZSB0byBmdWxsLCBsb3dlcmNhc2UgdHlwZSwgb3IgYXVnbWVudCB0aGUgZmllbGREZWYgd2l0aCBhIGRlZmF1bHQgdHlwZSBpZiBtaXNzaW5nLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoY2hhbm5lbERlZiwgY2hhbm5lbCkge1xuICAgIC8vIElmIGEgZmllbGREZWYgY29udGFpbnMgYSBmaWVsZCwgd2UgbmVlZCB0eXBlLlxuICAgIGlmIChpc0ZpZWxkRGVmKGNoYW5uZWxEZWYpKSB7XG4gICAgICAgIHZhciBmaWVsZERlZiA9IGNoYW5uZWxEZWY7XG4gICAgICAgIC8vIERyb3AgaW52YWxpZCBhZ2dyZWdhdGVcbiAgICAgICAgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSAmJiAhYWdncmVnYXRlXzEuQUdHUkVHQVRFX09QX0lOREVYW2ZpZWxkRGVmLmFnZ3JlZ2F0ZV0pIHtcbiAgICAgICAgICAgIHZhciBhZ2dyZWdhdGUgPSBmaWVsZERlZi5hZ2dyZWdhdGUsIGZpZWxkRGVmV2l0aG91dEFnZ3JlZ2F0ZSA9IHRzbGliXzEuX19yZXN0KGZpZWxkRGVmLCBbXCJhZ2dyZWdhdGVcIl0pO1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuaW52YWxpZEFnZ3JlZ2F0ZShmaWVsZERlZi5hZ2dyZWdhdGUpKTtcbiAgICAgICAgICAgIGZpZWxkRGVmID0gZmllbGREZWZXaXRob3V0QWdncmVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBiaW5cbiAgICAgICAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgdmFyIGJpbiA9IGZpZWxkRGVmLmJpbjtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuaXNCb29sZWFuKGJpbikpIHtcbiAgICAgICAgICAgICAgICBmaWVsZERlZiA9IHRzbGliXzEuX19hc3NpZ24oe30sIGZpZWxkRGVmLCB7IGJpbjogeyBtYXhiaW5zOiBiaW5fMS5hdXRvTWF4QmlucyhjaGFubmVsKSB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWJpbi5tYXhiaW5zICYmICFiaW4uc3RlcCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRGVmID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgZmllbGREZWYsIHsgYmluOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBiaW4sIHsgbWF4YmluczogYmluXzEuYXV0b01heEJpbnMoY2hhbm5lbCkgfSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIFR5cGVcbiAgICAgICAgaWYgKGZpZWxkRGVmLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciBmdWxsVHlwZSA9IHR5cGVfMS5nZXRGdWxsTmFtZShmaWVsZERlZi50eXBlKTtcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlICE9PSBmdWxsVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgc2hvcnQgdHlwZSB0byBmdWxsIHR5cGVcbiAgICAgICAgICAgICAgICBmaWVsZERlZiA9IHRzbGliXzEuX19hc3NpZ24oe30sIGZpZWxkRGVmLCB7IHR5cGU6IGZ1bGxUeXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdHlwZSBpcyBlbXB0eSAvIGludmFsaWQsIHRoZW4gYXVnbWVudCB3aXRoIGRlZmF1bHQgdHlwZVxuICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSBkZWZhdWx0VHlwZShmaWVsZERlZiwgY2hhbm5lbCk7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5lbXB0eU9ySW52YWxpZEZpZWxkVHlwZShmaWVsZERlZi50eXBlLCBjaGFubmVsLCBuZXdUeXBlKSk7XG4gICAgICAgICAgICBmaWVsZERlZiA9IHRzbGliXzEuX19hc3NpZ24oe30sIGZpZWxkRGVmLCB7IHR5cGU6IG5ld1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gY2hhbm5lbENvbXBhdGliaWxpdHkoZmllbGREZWYsIGNoYW5uZWwpLCBjb21wYXRpYmxlID0gX2EuY29tcGF0aWJsZSwgd2FybmluZyA9IF9hLndhcm5pbmc7XG4gICAgICAgIGlmICghY29tcGF0aWJsZSkge1xuICAgICAgICAgICAgbG9nLndhcm4od2FybmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkRGVmO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbERlZjtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xudmFyIENPTVBBVElCTEUgPSB7IGNvbXBhdGlibGU6IHRydWUgfTtcbmZ1bmN0aW9uIGNoYW5uZWxDb21wYXRpYmlsaXR5KGZpZWxkRGVmLCBjaGFubmVsKSB7XG4gICAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgICAgIGNhc2UgJ3Jvdyc6XG4gICAgICAgIGNhc2UgJ2NvbHVtbic6XG4gICAgICAgICAgICBpZiAoaXNDb250aW51b3VzKGZpZWxkRGVmKSAmJiAhZmllbGREZWYudGltZVVuaXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOihodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhLWxpdGUvaXNzdWVzLzIwMTEpOlxuICAgICAgICAgICAgICAgIC8vIHdpdGggdGltZVVuaXQgaXQncyBub3QgYWx3YXlzIHN0cmljdGx5IGNvbnRpbnVvdXNcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogbG9nLm1lc3NhZ2UuZmFjZXRDaGFubmVsU2hvdWxkQmVEaXNjcmV0ZShjaGFubmVsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ09NUEFUSUJMRTtcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBjYXNlICdkZXRhaWwnOlxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICBjYXNlICdzaXplJzpcbiAgICAgICAgY2FzZSAneDInOlxuICAgICAgICBjYXNlICd5Mic6XG4gICAgICAgICAgICBpZiAoaXNEaXNjcmV0ZShmaWVsZERlZikgJiYgIWZpZWxkRGVmLmJpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdGlibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nOiBcIkNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggZGlzY3JldGUgZmllbGQuXCJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ3NoYXBlJzpcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlICE9PSAnbm9taW5hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogJ1NoYXBlIGNoYW5uZWwgc2hvdWxkIGJlIHVzZWQgd2l0aCBub21pbmFsIGRhdGEgb25seSdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIENPTVBBVElCTEU7XG4gICAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgICAgIGlmIChmaWVsZERlZi50eXBlID09PSAnbm9taW5hbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZzogXCJDaGFubmVsIG9yZGVyIGlzIGluYXBwcm9wcmlhdGUgZm9yIG5vbWluYWwgZmllbGQsIHdoaWNoIGhhcyBubyBpbmhlcmVudCBvcmRlci5cIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQ09NUEFUSUJMRTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjaGFubmVsQ29tcGF0YWJpbGl0eSBub3QgaW1wbGVtZW50ZWQgZm9yIGNoYW5uZWwgJyArIGNoYW5uZWwpO1xufVxuZXhwb3J0cy5jaGFubmVsQ29tcGF0aWJpbGl0eSA9IGNoYW5uZWxDb21wYXRpYmlsaXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pWm1sbGJHUmtaV1l1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZabWxsYkdSa1pXWXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJa0ZCUTBFc2QwTkJRWGRET3pzN08wRkJSWGhETEhsRFFVRTBSRHRCUVVVMVJDdzJRa0ZCYjBRN1FVRkRjRVFzY1VOQlFUWkRPMEZCUnpkRExESkNRVUUyUWp0QlFVazNRaXgxUTBGQmVVUTdRVUZEZWtRc0swSkJRWGxETzBGQlEzcERMQ3RDUVVGcFF6dEJRVGhIYWtNc2IwSkJRVEpDTEZWQlFYTkNPMGxCUXk5RExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNWVUZCVlN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVOQlFVTXNTVUZCU1N4VlFVRlZMRU5CUVVNc1YwRkJWeXhEUVVGRExFdEJRVXNzVDBGQlR5eERRVUZETEVOQlFVTTdRVUZEZUVZc1EwRkJRenRCUVVaRUxHZERRVVZETzBGQlJVUXNiMEpCUVRKQ0xGVkJRWE5DTzBsQlF5OURMRTFCUVUwc1EwRkJReXhWUVVGVkxFbEJRVWtzVDBGQlR5eEpRVUZKTEZWQlFWVXNTVUZCU1N4VlFVRlZMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETzBGQlEyeEdMRU5CUVVNN1FVRkdSQ3huUTBGRlF6dEJRVzlDUkN4bFFVRnpRaXhSUVVGclFpeEZRVUZGTEVkQlFYZENPMGxCUVhoQ0xHOUNRVUZCTEVWQlFVRXNVVUZCZDBJN1NVRkRhRVVzU1VGQlNTeExRVUZMTEVkQlFVY3NVVUZCVVN4RFFVRkRMRXRCUVVzc1EwRkJRenRKUVVNelFpeEpRVUZOTEUxQlFVMHNSMEZCUnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hEUVVGRE8wbEJRekZDTEVsQlFVa3NUVUZCVFN4SFFVRkhMRWRCUVVjc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRmVFSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTjBRaXhMUVVGTExFZEJRVWNzVTBGQlV5eERRVUZETzBsQlEzQkNMRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU5PTEVsQlFVa3NSVUZCUlN4SFFVRlhMRk5CUVZNc1EwRkJRenRSUVVVelFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTJwQ0xFVkJRVVVzUjBGQlJ5eHBRa0ZCVnl4RFFVRkRMRkZCUVZFc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dG5Ra0ZETDBJc1RVRkJUU3hIUVVGSExFZEJRVWNzUTBGQlF5eFRRVUZUTEVOQlFVTTdXVUZEZWtJc1EwRkJRenRaUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZET1VJc1JVRkJSU3hIUVVGSExFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNVMEZCVXl4SlFVRkpMRkZCUVZFc1EwRkJReXhUUVVGVExFTkJRVU1zUTBGQlF6dFpRVU51UkN4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU0zUWl4RlFVRkZMRWRCUVVjc1RVRkJUU3hEUVVGRExGRkJRVkVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXp0WlFVTnFReXhEUVVGRE8xRkJRMGdzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFVDeExRVUZMTEVkQlFVMHNSVUZCUlN4VFFVRkpMRXRCUVU4c1EwRkJRenRSUVVNelFpeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEV0N4TFFVRkxMRWRCUVUwc1MwRkJTeXhUUVVGSkxFMUJRVkVzUTBGQlF6dEpRVU12UWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTllMRXRCUVVzc1IwRkJUU3hOUVVGTkxGTkJRVWtzUzBGQlR5eERRVUZETzBsQlF5OUNMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOa0xFdEJRVXNzUjBGQlJ5eGhRVUZWTEV0QlFVc3NVVUZCU1N4RFFVRkRPMGxCUXpsQ0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMEZCUTJZc1EwRkJRenRCUVhaRFJDeHpRa0YxUTBNN1FVRkZSQ3h2UWtGQk1rSXNVVUZCYTBJN1NVRkRNME1zVFVGQlRTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFSXNTMEZCU3l4VFFVRlRMRU5CUVVNN1VVRkRaaXhMUVVGTExGTkJRVk03V1VGRFdpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMUZCUTJRc1MwRkJTeXhqUVVGak8xbEJRMnBDTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzUTBGQlF6dFJRVU40UWl4TFFVRkxMRlZCUVZVN1dVRkRZaXd3UTBGQk1FTTdXVUZETVVNc1RVRkJUU3hEUVVGRExEaENRVUZ0UWl4RFFVRkRMRkZCUVZFc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU5zUkN4RFFVRkRPMGxCUTBRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJReTlFTEVOQlFVTTdRVUZhUkN4blEwRlpRenRCUVVWRUxITkNRVUUyUWl4UlFVRnJRanRKUVVNM1F5eE5RVUZOTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU03UVVGREwwSXNRMEZCUXp0QlFVWkVMRzlEUVVWRE8wRkJSVVFzYVVKQlFYZENMRkZCUVd0Q08wbEJRM2hETEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1UwRkJVeXhMUVVGTExFOUJRVThzUTBGQlF6dEJRVU40UXl4RFFVRkRPMEZCUmtRc01FSkJSVU03UVVGRlJDeGxRVUZ6UWl4UlFVRnJRaXhGUVVGRkxFMUJRV003U1VGRGRFUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFdEJRVXNzU1VGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFMUJRVTBzUTBGQlF5eFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRPMGxCUTNoQ0xFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlZTeERRVUZETzBsQlF6TkNMRU5CUVVNN1NVRkRSQ3hKUVVGTkxFVkJRVVVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNVMEZCVXl4SlFVRkpMRkZCUVZFc1EwRkJReXhSUVVGUkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNSMEZCUnl4SlFVRkpMRXRCUVVzc1EwRkJReXhEUVVGRE8wbEJRemxGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRVZCUVVVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFVDeE5RVUZOTEVOQlFVTXNSVUZCUlN4RFFVRkRMRmRCUVZjc1JVRkJSU3hIUVVGSExFZEJRVWNzUjBGQlJ5eFJRVUZSTEVOQlFVTXNTMEZCU3l4SFFVRkhMRWRCUVVjc1EwRkJRenRKUVVOMlJDeERRVUZETzBsQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRUaXhOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEV0QlFVc3NRMEZCUXp0SlFVTjRRaXhEUVVGRE8wRkJRMGdzUTBGQlF6dEJRV0pFTEhOQ1FXRkRPMEZCUlVRc2NVSkJRVFJDTEZGQlFXdENMRVZCUVVVc1QwRkJaMEk3U1VGRE9VUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExGRkJRVkVzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVJc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF6dEpRVU53UWl4RFFVRkRPMGxCUTBRc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha0lzVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXp0SlFVTjRRaXhEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEVOQlFVTXNiVUpCUVZNc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBJc1MwRkJTeXhaUVVGWk8xbEJRMllzVFVGQlRTeERRVUZETEdOQlFXTXNRMEZCUXp0UlFVTjRRaXhMUVVGTExGVkJRVlU3V1VGRFlpeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTI1Q0xFdEJRVXNzVlVGQlZUdFpRVU5pTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNN1VVRkRia0k3V1VGRFJTeE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRPMGxCUXpGQ0xFTkJRVU03UVVGRFNDeERRVUZETzBGQmFrSkVMR3REUVdsQ1F6dEJRVVZFT3p0SFFVVkhPMEZCUTBnc2JVSkJRVEJDTEZWQlFYTkNMRVZCUVVVc1QwRkJaMEk3U1VGRGFFVXNaMFJCUVdkRU8wbEJRMmhFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhWUVVGVkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETTBJc1NVRkJTU3hSUVVGUkxFZEJRV0VzVlVGQlZTeERRVUZETzFGQlJYQkRMSGxDUVVGNVFqdFJRVU42UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zVTBGQlV5eEpRVUZKTEVOQlFVTXNPRUpCUVd0Q0xFTkJRVU1zVVVGQlVTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVNelJDeEpRVUZCTERoQ1FVRlRMRVZCUVVVc2EwVkJRVEpDTEVOQlFXRTdXVUZETVVRc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZGQlFWRXNRMEZCUXl4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRek5FTEZGQlFWRXNSMEZCUnl4M1FrRkJkMElzUTBGQlF6dFJRVU4wUXl4RFFVRkRPMUZCUlVRc1owSkJRV2RDTzFGQlEyaENMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJwQ0xFbEJRVTBzUjBGQlJ5eEhRVUZITEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNN1dVRkRla0lzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTI1Q0xGRkJRVkVzZDBKQlEwZ3NVVUZCVVN4SlFVTllMRWRCUVVjc1JVRkJSU3hGUVVGRExFOUJRVThzUlVGQlJTeHBRa0ZCVnl4RFFVRkRMRTlCUVU4c1EwRkJReXhGUVVGRExFZEJRM0pETEVOQlFVTTdXVUZEU2l4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVOeVF5eFJRVUZSTEhkQ1FVTklMRkZCUVZFc1NVRkRXQ3hIUVVGSExIVkNRVU5GTEVkQlFVY3NTVUZEVGl4UFFVRlBMRVZCUVVVc2FVSkJRVmNzUTBGQlF5eFBRVUZQTEVOQlFVTXNUVUZGYUVNc1EwRkJRenRaUVVOS0xFTkJRVU03VVVGRFNDeERRVUZETzFGQlJVUXNhVUpCUVdsQ08xRkJRMnBDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyeENMRWxCUVUwc1VVRkJVU3hIUVVGSExHdENRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xbEJRelZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFdEJRVXNzVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRMMElzYTBOQlFXdERPMmRDUVVOc1F5eFJRVUZSTEhkQ1FVTklMRkZCUVZFc1NVRkRXQ3hKUVVGSkxFVkJRVVVzVVVGQlVTeEhRVU5tTEVOQlFVTTdXVUZEU2l4RFFVRkRPMUZCUTBnc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNOa1JCUVRaRU8xbEJRemRFTEVsQlFVMHNUMEZCVHl4SFFVRkhMRmRCUVZjc1EwRkJReXhSUVVGUkxFVkJRVVVzVDBGQlR5eERRVUZETEVOQlFVTTdXVUZETDBNc1IwRkJSeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMSFZDUVVGMVFpeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRVZCUVVVc1QwRkJUeXhGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZETDBVc1VVRkJVU3gzUWtGRFJDeFJRVUZSTEVsQlEySXNTVUZCU1N4RlFVRkZMRTlCUVU4c1IwRkRaQ3hEUVVGRE8xRkJRMG9zUTBGQlF6dFJRVVZMTEVsQlFVRXNORU5CUVN0RUxFVkJRVGxFTERCQ1FVRlZMRVZCUVVVc2IwSkJRVThzUTBGQk5FTTdVVUZEZEVVc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTJoQ0xFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1VVRkRjRUlzUTBGQlF6dFJRVU5FTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNN1NVRkRiRUlzUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1FVRkRjRUlzUTBGQlF6dEJRVEZFUkN3NFFrRXdSRU03UVVGRlJDeEpRVUZOTEZWQlFWVXNSMEZCUnl4RlFVRkRMRlZCUVZVc1JVRkJSU3hKUVVGSkxFVkJRVU1zUTBGQlF6dEJRVU4wUXl3NFFrRkJjVU1zVVVGQmEwSXNSVUZCUlN4UFFVRm5RanRKUVVOMlJTeE5RVUZOTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMmhDTEV0QlFVc3NTMEZCU3l4RFFVRkRPMUZCUTFnc1MwRkJTeXhSUVVGUk8xbEJRMWdzUlVGQlJTeERRVUZETEVOQlFVTXNXVUZCV1N4RFFVRkRMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRMnBFTEhkRVFVRjNSRHRuUWtGRGVFUXNiMFJCUVc5RU8yZENRVU53UkN4TlFVRk5MRU5CUVVNN2IwSkJRMHdzVlVGQlZTeEZRVUZGTEV0QlFVczdiMEpCUTJwQ0xFOUJRVThzUlVGQlJTeEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMRFJDUVVFMFFpeERRVUZETEU5QlFVOHNRMEZCUXp0cFFrRkRNMFFzUTBGQlF6dFpRVU5LTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8xRkJSWEJDTEV0QlFVc3NSMEZCUnl4RFFVRkRPMUZCUTFRc1MwRkJTeXhIUVVGSExFTkJRVU03VVVGRFZDeExRVUZMTEU5QlFVOHNRMEZCUXp0UlFVTmlMRXRCUVVzc1RVRkJUU3hEUVVGRE8xRkJRMW9zUzBGQlN5eFJRVUZSTzFsQlExZ3NUVUZCVFN4RFFVRkRMRlZCUVZVc1EwRkJRenRSUVVWd1FpeExRVUZMTEZOQlFWTXNRMEZCUXp0UlFVTm1MRXRCUVVzc1RVRkJUU3hEUVVGRE8xRkJRMW9zUzBGQlN5eEpRVUZKTEVOQlFVTTdVVUZEVml4TFFVRkxMRWxCUVVrN1dVRkRVQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eFZRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRNVU1zVFVGQlRTeERRVUZETzI5Q1FVTk1MRlZCUVZVc1JVRkJSU3hMUVVGTE8yOUNRVU5xUWl4UFFVRlBMRVZCUVVVc1lVRkJWeXhQUVVGUExEWkRRVUV3UXp0cFFrRkRkRVVzUTBGQlF6dFpRVU5LTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRE8xRkJSWEJDTEV0QlFVc3NUMEZCVHp0WlFVTldMRVZCUVVVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEpRVUZKTEV0QlFVc3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGFFTXNUVUZCVFN4RFFVRkRPMjlDUVVOTUxGVkJRVlVzUlVGQlJTeExRVUZMTzI5Q1FVTnFRaXhQUVVGUExFVkJRVVVzY1VSQlFYRkVPMmxDUVVNdlJDeERRVUZETzFsQlEwb3NRMEZCUXp0WlFVTkVMRTFCUVUwc1EwRkJReXhWUVVGVkxFTkJRVU03VVVGRmNFSXNTMEZCU3l4UFFVRlBPMWxCUTFZc1JVRkJSU3hEUVVGRExFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NTMEZCU3l4VFFVRlRMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU5vUXl4TlFVRk5MRU5CUVVNN2IwSkJRMHdzVlVGQlZTeEZRVUZGTEV0QlFVczdiMEpCUTJwQ0xFOUJRVThzUlVGQlJTeG5Sa0ZCWjBZN2FVSkJRekZHTEVOQlFVTTdXVUZEU2l4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF6dEpRVU4wUWl4RFFVRkRPMGxCUTBRc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5eHRSRUZCYlVRc1IwRkJSeXhQUVVGUExFTkJRVU1zUTBGQlF6dEJRVU5xUml4RFFVRkRPMEZCY0VSRUxHOUVRVzlFUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGV0aW1lXzEgPSByZXF1aXJlKFwiLi9kYXRldGltZVwiKTtcbnZhciBmaWVsZGRlZl8xID0gcmVxdWlyZShcIi4vZmllbGRkZWZcIik7XG52YXIgdGltZXVuaXRfMSA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5mdW5jdGlvbiBpc0VxdWFsRmlsdGVyKGZpbHRlcikge1xuICAgIHJldHVybiBmaWx0ZXIgJiYgISFmaWx0ZXIuZmllbGQgJiYgZmlsdGVyLmVxdWFsICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRXF1YWxGaWx0ZXIgPSBpc0VxdWFsRmlsdGVyO1xuZnVuY3Rpb24gaXNSYW5nZUZpbHRlcihmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5maWVsZCkge1xuICAgICAgICBpZiAodXRpbF8xLmlzQXJyYXkoZmlsdGVyLnJhbmdlKSAmJiBmaWx0ZXIucmFuZ2UubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUmFuZ2VGaWx0ZXIgPSBpc1JhbmdlRmlsdGVyO1xuZnVuY3Rpb24gaXNPbmVPZkZpbHRlcihmaWx0ZXIpIHtcbiAgICByZXR1cm4gZmlsdGVyICYmICEhZmlsdGVyLmZpZWxkICYmICh1dGlsXzEuaXNBcnJheShmaWx0ZXIub25lT2YpIHx8XG4gICAgICAgIHV0aWxfMS5pc0FycmF5KGZpbHRlci5pbikgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICk7XG59XG5leHBvcnRzLmlzT25lT2ZGaWx0ZXIgPSBpc09uZU9mRmlsdGVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGZpbHRlciBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKi9cbmZ1bmN0aW9uIGV4cHJlc3Npb24oZmlsdGVyKSB7XG4gICAgaWYgKHV0aWxfMS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuICcoJyArXG4gICAgICAgICAgICBmaWx0ZXIubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBleHByZXNzaW9uKGYpOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYgIT09IHVuZGVmaW5lZDsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignKSAmJiAoJykgK1xuICAgICAgICAgICAgJyknO1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsXzEuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkRXhwciA9IGZpbHRlci50aW1lVW5pdCA/XG4gICAgICAgICAgICAvLyBGb3IgdGltZVVuaXQsIGNhc3QgaW50byBpbnRlZ2VyIHdpdGggdGltZSgpIHNvIHdlIGNhbiB1c2UgPT09LCBpbnJhbmdlLCBpbmRleE9mIHRvIGNvbXBhcmUgdmFsdWVzIGRpcmVjdGx5LlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY2FsY3VsYXRlIHRpbWVVbml0IG9uIHRoZSBmbHkgaGVyZS4gQ29uc2lkZXIgaWYgd2Ugd291bGQgbGlrZSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGggdGltZVVuaXQgcGlwZWxpbmVcbiAgICAgICAgICAgIC8vIFRPRE86IHN1cHBvcnQgdXRjXG4gICAgICAgICAgICAoJ3RpbWUoJyArIHRpbWV1bml0XzEuZmllbGRFeHByKGZpbHRlci50aW1lVW5pdCwgZmlsdGVyLmZpZWxkKSArICcpJykgOlxuICAgICAgICAgICAgZmllbGRkZWZfMS5maWVsZChmaWx0ZXIsIHsgZGF0dW06IHRydWUgfSk7XG4gICAgICAgIGlmIChpc0VxdWFsRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZEV4cHIgKyAnPT09JyArIHZhbHVlRXhwcihmaWx0ZXIuZXF1YWwsIGZpbHRlci50aW1lVW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPbmVPZkZpbHRlcihmaWx0ZXIpKSB7XG4gICAgICAgICAgICAvLyBcIm9uZU9mXCIgd2FzIGZvcm1lcmx5IFwiaW5cIiAtLSBzbyB3ZSBuZWVkIHRvIGFkZCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICB2YXIgb25lT2YgPSBmaWx0ZXIub25lT2YgfHwgZmlsdGVyWydpbiddO1xuICAgICAgICAgICAgcmV0dXJuICdpbmRleG9mKFsnICtcbiAgICAgICAgICAgICAgICBvbmVPZi5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlRXhwcih2LCBmaWx0ZXIudGltZVVuaXQpOyB9KS5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICddLCAnICsgZmllbGRFeHByICsgJykgIT09IC0xJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1JhbmdlRmlsdGVyKGZpbHRlcikpIHtcbiAgICAgICAgICAgIHZhciBsb3dlciA9IGZpbHRlci5yYW5nZVswXTtcbiAgICAgICAgICAgIHZhciB1cHBlciA9IGZpbHRlci5yYW5nZVsxXTtcbiAgICAgICAgICAgIGlmIChsb3dlciAhPT0gbnVsbCAmJiB1cHBlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaW5yYW5nZSgnICsgZmllbGRFeHByICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlRXhwcihsb3dlciwgZmlsdGVyLnRpbWVVbml0KSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUV4cHIodXBwZXIsIGZpbHRlci50aW1lVW5pdCkgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsb3dlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZEV4cHIgKyAnID49ICcgKyBsb3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkRXhwciArICcgPD0gJyArIHVwcGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuZnVuY3Rpb24gdmFsdWVFeHByKHYsIHRpbWVVbml0KSB7XG4gICAgaWYgKGRhdGV0aW1lXzEuaXNEYXRlVGltZSh2KSkge1xuICAgICAgICB2YXIgZXhwciA9IGRhdGV0aW1lXzEuZGF0ZVRpbWVFeHByKHYsIHRydWUpO1xuICAgICAgICByZXR1cm4gJ3RpbWUoJyArIGV4cHIgKyAnKSc7XG4gICAgfVxuICAgIGlmICh0aW1ldW5pdF8xLmlzU2luZ2xlVGltZVVuaXQodGltZVVuaXQpKSB7XG4gICAgICAgIHZhciBkYXRldGltZSA9IHt9O1xuICAgICAgICBkYXRldGltZVt0aW1lVW5pdF0gPSB2O1xuICAgICAgICB2YXIgZXhwciA9IGRhdGV0aW1lXzEuZGF0ZVRpbWVFeHByKGRhdGV0aW1lLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICd0aW1lKCcgKyBleHByICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2labWxzZEdWeUxtcHpJaXdpYzI5MWNtTmxVbTl2ZENJNklpSXNJbk52ZFhKalpYTWlPbHNpTGk0dkxpNHZjM0pqTDJacGJIUmxjaTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pT3p0QlFVRkJMSFZEUVVFNFJEdEJRVU01UkN4MVEwRkJhVU03UVVGRGFrTXNkVU5CUVhOR08wRkJRM1JHTEN0Q1FVRjVRenRCUVhsQ2VrTXNkVUpCUVRoQ0xFMUJRVmM3U1VGRGRrTXNUVUZCVFN4RFFVRkRMRTFCUVUwc1NVRkJTU3hEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEV0QlFVc3NTVUZCU1N4TlFVRk5MRU5CUVVNc1MwRkJTeXhMUVVGSExGTkJRVk1zUTBGQlF6dEJRVU01UkN4RFFVRkRPMEZCUmtRc2MwTkJSVU03UVVGNVFrUXNkVUpCUVRoQ0xFMUJRVmM3U1VGRGRrTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1RVRkJUU3hKUVVGSkxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXpOQ0xFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFbEJRVWtzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXl4TlFVRk5MRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU4yUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8xRkJRMlFzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRVkJFTEhORFFVOURPMEZCZFVKRUxIVkNRVUU0UWl4TlFVRlhPMGxCUTNaRExFMUJRVTBzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFbEJRVWtzUTBGRGFrTXNZMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03VVVGRGNrSXNZMEZCVHl4RFFVRkRMRTFCUVUwc1EwRkJReXhGUVVGRkxFTkJRVU1zUTBGQlF5eDVRa0ZCZVVJN1MwRkROME1zUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZNUkN4elEwRkxRenRCUVVWRU96dEhRVVZITzBGQlEwZ3NiMEpCUVRKQ0xFMUJRWGxDTzBsQlEyeEVMRVZCUVVVc1EwRkJReXhEUVVGRExHTkJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRUlzVFVGQlRTeERRVUZETEVkQlFVYzdXVUZEVWl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNWVUZCVlN4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGaUxFTkJRV0VzUTBGQlF6dHBRa0ZETjBJc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEpRVUZMTEU5QlFVRXNRMEZCUXl4TFFVRkpMRk5CUVZNc1JVRkJaQ3hEUVVGakxFTkJRVU03YVVKQlF6ZENMRWxCUVVrc1EwRkJReXhSUVVGUkxFTkJRVU03V1VGRGFrSXNSMEZCUnl4RFFVRkRPMGxCUTFJc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6VkNMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU03U1VGRGFFSXNRMEZCUXp0SlFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRMDRzU1VGQlRTeFRRVUZUTEVkQlFVY3NUVUZCVFN4RFFVRkRMRkZCUVZFN1dVRkRMMElzT0VkQlFUaEhPMWxCUXpWSExHOUlRVUZ2U0R0WlFVTndTQ3h2UWtGQmIwSTdXVUZEZEVJc1EwRkJReXhQUVVGUExFZEJRVWNzYjBKQlFXbENMRU5CUVVNc1RVRkJUU3hEUVVGRExGRkJRVkVzUlVGQlJTeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRE8xbEJRMnhGTEdkQ1FVRkxMRU5CUVVNc1RVRkJUU3hGUVVGRkxFVkJRVU1zUzBGQlN5eEZRVUZGTEVsQlFVa3NSVUZCUXl4RFFVRkRMRU5CUVVNN1VVRkZMMElzUlVGQlJTeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTFCUVUwc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU14UWl4TlFVRk5MRU5CUVVNc1UwRkJVeXhIUVVGSExFdEJRVXNzUjBGQlJ5eFRRVUZUTEVOQlFVTXNUVUZCVFN4RFFVRkRMRXRCUVVzc1JVRkJSU3hOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTTdVVUZEZEVVc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4aFFVRmhMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEycERMSGRGUVVGM1JUdFpRVU40UlN4SlFVRk5MRXRCUVVzc1IwRkJhMElzVFVGQlRTeERRVUZETEV0QlFVc3NTVUZCU1N4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03V1VGRE1VUXNUVUZCVFN4RFFVRkRMRmRCUVZjN1owSkJRMmhDTEV0QlFVc3NRMEZCUXl4SFFVRkhMRU5CUVVNc1ZVRkJReXhEUVVGRExFbEJRVXNzVDBGQlFTeFRRVUZUTEVOQlFVTXNRMEZCUXl4RlFVRkZMRTFCUVUwc1EwRkJReXhSUVVGUkxFTkJRVU1zUlVGQk4wSXNRMEZCTmtJc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTTdaMEpCUTNwRUxFdEJRVXNzUjBGQlJ5eFRRVUZUTEVkQlFVY3NWVUZCVlN4RFFVRkRPMUZCUTI1RExFTkJRVU03VVVGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1lVRkJZU3hEUVVGRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTnFReXhKUVVGTkxFdEJRVXNzUjBGQlJ5eE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxDTEVsQlFVMHNTMEZCU3l4SFFVRkhMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZGT1VJc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEVsQlFVa3NTVUZCU3l4TFFVRkxMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dG5Ra0ZEZEVNc1RVRkJUU3hEUVVGRExGVkJRVlVzUjBGQlJ5eFRRVUZUTEVkQlFVY3NTVUZCU1R0dlFrRkRiRU1zVTBGQlV5eERRVUZETEV0QlFVc3NSVUZCUlN4TlFVRk5MRU5CUVVNc1VVRkJVU3hEUVVGRExFZEJRVWNzU1VGQlNUdHZRa0ZEZUVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1IwRkJSeXhEUVVGRE8xbEJRelZETEVOQlFVTTdXVUZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRekZDTEUxQlFVMHNRMEZCUXl4VFFVRlRMRWRCUVVjc1RVRkJUU3hIUVVGSExFdEJRVXNzUTBGQlF6dFpRVU53UXl4RFFVRkRPMWxCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEV0QlFVc3NTMEZCU3l4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU14UWl4TlFVRk5MRU5CUVVNc1UwRkJVeXhIUVVGSExFMUJRVTBzUjBGQlJ5eExRVUZMTEVOQlFVTTdXVUZEY0VNc1EwRkJRenRSUVVOSUxFTkJRVU03U1VGRFNDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJRenRCUVVOdVFpeERRVUZETzBGQmVrTkVMR2REUVhsRFF6dEJRVVZFTEcxQ1FVRnRRaXhEUVVGTkxFVkJRVVVzVVVGQmEwSTdTVUZETTBNc1JVRkJSU3hEUVVGRExFTkJRVU1zY1VKQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJFSXNTVUZCVFN4SlFVRkpMRWRCUVVjc2RVSkJRVmtzUTBGQlF5eERRVUZETEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRia01zVFVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRWRCUVVjc1IwRkJSeXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXd5UWtGQlowSXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGREwwSXNTVUZCVFN4UlFVRlJMRWRCUVdFc1JVRkJSU3hEUVVGRE8xRkJRemxDTEZGQlFWRXNRMEZCUXl4UlFVRlJMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03VVVGRGRrSXNTVUZCVFN4SlFVRkpMRWRCUVVjc2RVSkJRVmtzUTBGQlF5eFJRVUZSTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1VVRkRNVU1zVFVGQlRTeERRVUZETEU5QlFVOHNSMEZCUnl4SlFVRkpMRWRCUVVjc1IwRkJSeXhEUVVGRE8wbEJRemxDTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTXpRaXhEUVVGREluMD0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdExlZ2VuZENvbmZpZyA9IHtcbiAgICBvcmllbnQ6IHVuZGVmaW5lZCxcbn07XG5leHBvcnRzLkxFR0VORF9QUk9QRVJUSUVTID0gWydlbnRyeVBhZGRpbmcnLCAnZm9ybWF0JywgJ29mZnNldCcsICdvcmllbnQnLCAndGlja0NvdW50JywgJ3RpdGxlJywgJ3R5cGUnLCAndmFsdWVzJywgJ3ppbmRleCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYkdWblpXNWtMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyeGxaMlZ1WkM1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96dEJRV2RGWVN4UlFVRkJMRzFDUVVGdFFpeEhRVUZwUWp0SlFVTXZReXhOUVVGTkxFVkJRVVVzVTBGQlV6dERRVU5zUWl4RFFVRkRPMEZCUlZjc1VVRkJRU3hwUWtGQmFVSXNSMEZCYjBJc1EwRkJReXhqUVVGakxFVkJRVVVzVVVGQlVTeEZRVUZGTEZGQlFWRXNSVUZCUlN4UlFVRlJMRVZCUVVVc1YwRkJWeXhGUVVGRkxFOUJRVThzUlVGQlJTeE5RVUZOTEVWQlFVVXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGREluMD0iLCIvLy88cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL3ZlZ2EtdXRpbC5kLnRzXCIgLz5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBWZWdhLUxpdGUncyBzaW5nbGV0b24gbG9nZ2VyIHV0aWxpdHkuXG4gKi9cbnZhciB2ZWdhX3V0aWxfMSA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG4vKipcbiAqIE1haW4gKGRlZmF1bHQpIFZlZ2EgTG9nZ2VyIGluc3RhbmNlIGZvciBWZWdhLUxpdGVcbiAqL1xudmFyIG1haW4gPSB2ZWdhX3V0aWxfMS5sb2dnZXIodmVnYV91dGlsXzEuV2Fybik7XG52YXIgY3VycmVudCA9IG1haW47XG4vKipcbiAqIExvZ2dlciB0b29sIGZvciBjaGVja2luZyBpZiB0aGUgY29kZSB0aHJvd3MgY29ycmVjdCB3YXJuaW5nXG4gKi9cbnZhciBMb2NhbExvZ2dlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9jYWxMb2dnZXIoKSB7XG4gICAgICAgIHRoaXMud2FybnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmZvcyA9IFtdO1xuICAgICAgICB0aGlzLmRlYnVncyA9IFtdO1xuICAgIH1cbiAgICBMb2NhbExvZ2dlci5wcm90b3R5cGUubGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTG9jYWxMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy53YXJucykucHVzaC5hcHBseShfYSwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBMb2NhbExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmluZm9zKS5wdXNoLmFwcGx5KF9hLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIExvY2FsTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmRlYnVncykucHVzaC5hcHBseShfYSwgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICByZXR1cm4gTG9jYWxMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5Mb2NhbExvZ2dlciA9IExvY2FsTG9nZ2VyO1xuZnVuY3Rpb24gcnVuTG9jYWxMb2dnZXIoZikge1xuICAgIHZhciBsb2NhbExvZ2dlciA9IGN1cnJlbnQgPSBuZXcgTG9jYWxMb2dnZXIoKTtcbiAgICBmKGxvY2FsTG9nZ2VyKTtcbiAgICByZXNldCgpO1xufVxuZXhwb3J0cy5ydW5Mb2NhbExvZ2dlciA9IHJ1bkxvY2FsTG9nZ2VyO1xuZnVuY3Rpb24gd3JhcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IGN1cnJlbnQgPSBuZXcgTG9jYWxMb2dnZXIoKTtcbiAgICAgICAgZihsb2dnZXIpO1xuICAgICAgICByZXNldCgpO1xuICAgIH07XG59XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuLyoqXG4gKiBTZXQgdGhlIHNpbmdsZXRvbiBsb2dnZXIgdG8gYmUgYSBjdXN0b20gbG9nZ2VyXG4gKi9cbmZ1bmN0aW9uIHNldChsb2dnZXIpIHtcbiAgICBjdXJyZW50ID0gbG9nZ2VyO1xuICAgIHJldHVybiBjdXJyZW50O1xufVxuZXhwb3J0cy5zZXQgPSBzZXQ7XG4vKipcbiAqIFJlc2V0IHRoZSBtYWluIGxvZ2dlciB0byB1c2UgdGhlIGRlZmF1bHQgVmVnYSBMb2dnZXJcbiAqL1xuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY3VycmVudCA9IG1haW47XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5leHBvcnRzLnJlc2V0ID0gcmVzZXQ7XG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIHZhciBfID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBjdXJyZW50Lndhcm4uYXBwbHkoY3VycmVudCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydHMud2FybiA9IHdhcm47XG5mdW5jdGlvbiBpbmZvKCkge1xuICAgIHZhciBfID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBjdXJyZW50LmluZm8uYXBwbHkoY3VycmVudCwgYXJndW1lbnRzKTtcbn1cbmV4cG9ydHMuaW5mbyA9IGluZm87XG5mdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICB2YXIgXyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIF9bX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgY3VycmVudC5kZWJ1Zy5hcHBseShjdXJyZW50LCBhcmd1bWVudHMpO1xufVxuZXhwb3J0cy5kZWJ1ZyA9IGRlYnVnO1xuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIGFsbCBWZWdhLUxpdGUgRXJyb3IgTWVzc2FnZXNcbiAqL1xudmFyIG1lc3NhZ2U7XG4oZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlLklOVkFMSURfU1BFQyA9ICdJbnZhbGlkIHNwZWMnO1xuICAgIC8vIFRSQU5TRk9STVNcbiAgICBmdW5jdGlvbiBpbnZhbGlkVHJhbnNmb3JtSWdub3JlZCh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIFwiSWdub3JpbmcgYW4gaW52YWxpZCB0cmFuc2Zvcm06IFwiICsgSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtKSArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmludmFsaWRUcmFuc2Zvcm1JZ25vcmVkID0gaW52YWxpZFRyYW5zZm9ybUlnbm9yZWQ7XG4gICAgLy8gRU5DT0RJTkcgJiBGQUNFVFxuICAgIGZ1bmN0aW9uIGludmFsaWRGaWVsZFR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGZpZWxkIHR5cGUgXFxcIlwiICsgdHlwZSArIFwiXFxcIlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmludmFsaWRGaWVsZFR5cGUgPSBpbnZhbGlkRmllbGRUeXBlO1xuICAgIGZ1bmN0aW9uIGludmFsaWRBZ2dyZWdhdGUoYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBcIkludmFsaWQgYWdncmVnYXRpb24gb3BlcmF0b3IgXFxcIlwiICsgYWdncmVnYXRlICsgXCJcXFwiXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuaW52YWxpZEFnZ3JlZ2F0ZSA9IGludmFsaWRBZ2dyZWdhdGU7XG4gICAgZnVuY3Rpb24gZW1wdHlPckludmFsaWRGaWVsZFR5cGUodHlwZSwgY2hhbm5lbCwgbmV3VHlwZSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGZpZWxkIHR5cGUgKFwiICsgdHlwZSArIFwiKSBmb3IgY2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiwgdXNpbmcgXCIgKyBuZXdUeXBlICsgXCIgaW5zdGVhZC5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5lbXB0eU9ySW52YWxpZEZpZWxkVHlwZSA9IGVtcHR5T3JJbnZhbGlkRmllbGRUeXBlO1xuICAgIGZ1bmN0aW9uIGVtcHR5RmllbGREZWYoZmllbGREZWYsIGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIFwiRHJvcHBpbmcgXCIgKyBKU09OLnN0cmluZ2lmeShmaWVsZERlZikgKyBcIiBmcm9tIGNoYW5uZWwgXCIgKyBjaGFubmVsICsgXCIgc2luY2UgaXQgZG9lcyBub3QgY29udGFpbiBkYXRhIGZpZWxkIG9yIHZhbHVlLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmVtcHR5RmllbGREZWYgPSBlbXB0eUZpZWxkRGVmO1xuICAgIGZ1bmN0aW9uIGluY29tcGF0aWJsZUNoYW5uZWwoY2hhbm5lbCwgbWFya09yRmFjZXQsIHdoZW4pIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgKyBcIiBkcm9wcGVkIGFzIGl0IGlzIGluY29tcGF0aWJsZSB3aXRoIFwiICsgbWFya09yRmFjZXQgK1xuICAgICAgICAgICAgd2hlbiA/IFwid2hlbiBcIiArIHdoZW4gOiAnJztcbiAgICB9XG4gICAgbWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsID0gaW5jb21wYXRpYmxlQ2hhbm5lbDtcbiAgICBmdW5jdGlvbiBmYWNldENoYW5uZWxTaG91bGRCZURpc2NyZXRlKGNoYW5uZWwpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWwgKyBcIiBlbmNvZGluZyBzaG91bGQgYmUgZGlzY3JldGUgKG9yZGluYWwgLyBub21pbmFsIC8gYmlubmVkKS5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5mYWNldENoYW5uZWxTaG91bGRCZURpc2NyZXRlID0gZmFjZXRDaGFubmVsU2hvdWxkQmVEaXNjcmV0ZTtcbiAgICBmdW5jdGlvbiBkaXNjcmV0ZUNoYW5uZWxDYW5ub3RFbmNvZGUoY2hhbm5lbCwgdHlwZSkge1xuICAgICAgICByZXR1cm4gXCJVc2luZyBkaXNjcmV0ZSBjaGFubmVsIFwiICsgY2hhbm5lbCArIFwiIHRvIGVuY29kZSBcIiArIHR5cGUgKyBcIiBmaWVsZCBjYW4gYmUgbWlzbGVhZGluZyBhcyBpdCBkb2VzIG5vdCBlbmNvZGUgXCIgKyAodHlwZSA9PT0gJ29yZGluYWwnID8gJ29yZGVyJyA6ICdtYWduaXR1ZGUnKSArIFwiLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZSA9IGRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZTtcbiAgICAvLyBNYXJrXG4gICAgbWVzc2FnZS5CQVJfV0lUSF9QT0lOVF9TQ0FMRV9BTkRfUkFOR0VTVEVQX05VTEwgPSAnQmFyIG1hcmsgc2hvdWxkIG5vdCBiZSB1c2VkIHdpdGggcG9pbnQgc2NhbGUgd2hlbiByYW5nZVN0ZXAgaXMgbnVsbC4gUGxlYXNlIHVzZSBiYW5kIHNjYWxlIGluc3RlYWQuJztcbiAgICBmdW5jdGlvbiB1bmNsZWFyT3JpZW50Q29udGludW91cyhtYXJrKSB7XG4gICAgICAgIHJldHVybiAnQ2Fubm90IGNsZWFybHkgZGV0ZXJtaW5lIG9yaWVudGF0aW9uIGZvciAnICsgbWFyayArICcgc2luY2UgYm90aCB4IGFuZCB5IGNoYW5uZWwgZW5jb2RlIGNvbnRpbm91cyBmaWVsZHMuIEluIHRoaXMgY2FzZSwgd2UgdXNlIHZlcnRpY2FsIGJ5IGRlZmF1bHQnO1xuICAgIH1cbiAgICBtZXNzYWdlLnVuY2xlYXJPcmllbnRDb250aW51b3VzID0gdW5jbGVhck9yaWVudENvbnRpbnVvdXM7XG4gICAgZnVuY3Rpb24gdW5jbGVhck9yaWVudERpc2NyZXRlT3JFbXB0eShtYXJrKSB7XG4gICAgICAgIHJldHVybiAnQ2Fubm90IGNsZWFybHkgZGV0ZXJtaW5lIG9yaWVudGF0aW9uIGZvciAnICsgbWFyayArICcgc2luY2UgYm90aCB4IGFuZCB5IGNoYW5uZWwgZW5jb2RlIGRpc2NyZXRlIG9yIGVtcHR5IGZpZWxkcy4nO1xuICAgIH1cbiAgICBtZXNzYWdlLnVuY2xlYXJPcmllbnREaXNjcmV0ZU9yRW1wdHkgPSB1bmNsZWFyT3JpZW50RGlzY3JldGVPckVtcHR5O1xuICAgIGZ1bmN0aW9uIG9yaWVudE92ZXJyaWRkZW4ob3JpZ2luYWwsIGFjdHVhbCkge1xuICAgICAgICByZXR1cm4gXCJTcGVjaWZpZWQgb3JpZW50IFwiICsgb3JpZ2luYWwgKyBcIiBvdmVycmlkZGVuIHdpdGggXCIgKyBhY3R1YWw7XG4gICAgfVxuICAgIG1lc3NhZ2Uub3JpZW50T3ZlcnJpZGRlbiA9IG9yaWVudE92ZXJyaWRkZW47XG4gICAgLy8gU0NBTEVcbiAgICBtZXNzYWdlLkNBTk5PVF9VTklPTl9DVVNUT01fRE9NQUlOX1dJVEhfRklFTERfRE9NQUlOID0gJ2N1c3RvbSBkb21haW4gc2NhbGUgY2Fubm90IGJlIHVuaW9uZWQgd2l0aCBkZWZhdWx0IGZpZWxkLWJhc2VkIGRvbWFpbic7XG4gICAgZnVuY3Rpb24gY2Fubm90VXNlU2NhbGVQcm9wZXJ0eVdpdGhOb25Db2xvcihwcm9wKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCB1c2UgXCIgKyBwcm9wICsgXCIgd2l0aCBub24tY29sb3IgY2hhbm5lbC5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RVc2VTY2FsZVByb3BlcnR5V2l0aE5vbkNvbG9yID0gY2Fubm90VXNlU2NhbGVQcm9wZXJ0eVdpdGhOb25Db2xvcjtcbiAgICBmdW5jdGlvbiB1bmFnZ3JlZ2F0ZURvbWFpbkhhc05vRWZmZWN0Rm9yUmF3RmllbGQoZmllbGREZWYpIHtcbiAgICAgICAgcmV0dXJuIFwiVXNpbmcgdW5hZ2dyZWdhdGVkIGRvbWFpbiB3aXRoIHJhdyBmaWVsZCBoYXMgbm8gZWZmZWN0IChcIiArIEpTT04uc3RyaW5naWZ5KGZpZWxkRGVmKSArIFwiKS5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS51bmFnZ3JlZ2F0ZURvbWFpbkhhc05vRWZmZWN0Rm9yUmF3RmllbGQgPSB1bmFnZ3JlZ2F0ZURvbWFpbkhhc05vRWZmZWN0Rm9yUmF3RmllbGQ7XG4gICAgZnVuY3Rpb24gdW5hZ2dyZWdhdGVEb21haW5XaXRoTm9uU2hhcmVkRG9tYWluT3AoYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBcIlVuYWdncmVnYXRlZCBkb21haW4gbm90IGFwcGxpY2FibGUgZm9yIFwiICsgYWdncmVnYXRlICsgXCIgc2luY2UgaXQgcHJvZHVjZXMgdmFsdWVzIG91dHNpZGUgdGhlIG9yaWdpbiBkb21haW4gb2YgdGhlIHNvdXJjZSBkYXRhLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnVuYWdncmVnYXRlRG9tYWluV2l0aE5vblNoYXJlZERvbWFpbk9wID0gdW5hZ2dyZWdhdGVEb21haW5XaXRoTm9uU2hhcmVkRG9tYWluT3A7XG4gICAgZnVuY3Rpb24gdW5hZ2dyZWdhdGVkRG9tYWluV2l0aExvZ1NjYWxlKGZpZWxkRGVmKSB7XG4gICAgICAgIHJldHVybiBcIlVuYWdncmVnYXRlZCBkb21haW4gaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkIGZvciBsb2cgc2NhbGUgKFwiICsgSlNPTi5zdHJpbmdpZnkoZmllbGREZWYpICsgXCIpLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnVuYWdncmVnYXRlZERvbWFpbldpdGhMb2dTY2FsZSA9IHVuYWdncmVnYXRlZERvbWFpbldpdGhMb2dTY2FsZTtcbiAgICBtZXNzYWdlLkNBTk5PVF9VU0VfUkFOR0VfV0lUSF9QT1NJVElPTiA9ICdDYW5ub3QgdXNlIGN1c3RvbSByYW5nZSB3aXRoIHggb3IgeSBjaGFubmVsLiAgUGxlYXNlIGN1c3RvbWl6ZSB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCBvciByYW5nZVN0ZXAgaW5zdGVhZC4nO1xuICAgIG1lc3NhZ2UuQ0FOTk9UX1VTRV9QQURESU5HX1dJVEhfRkFDRVQgPSAnQ2Fubm90IHVzZSBwYWRkaW5nIHdpdGggZmFjZXRcXCdzIHNjYWxlLiAgUGxlYXNlIHVzZSBzcGFjaW5nIGluc3RlYWQuJztcbiAgICBmdW5jdGlvbiBjYW5ub3RVc2VSYW5nZVByb3BlcnR5V2l0aEZhY2V0KHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCB1c2UgY3VzdG9tIFwiICsgcHJvcE5hbWUgKyBcIiB3aXRoIHJvdyBvciBjb2x1bW4gY2hhbm5lbC4gUGxlYXNlIHVzZSB3aWR0aCwgaGVpZ2h0LCBvciBzcGFjaW5nIGluc3RlYWQuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuY2Fubm90VXNlUmFuZ2VQcm9wZXJ0eVdpdGhGYWNldCA9IGNhbm5vdFVzZVJhbmdlUHJvcGVydHlXaXRoRmFjZXQ7XG4gICAgZnVuY3Rpb24gcmFuZ2VTdGVwRHJvcHBlZChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiBcInJhbmdlU3RlcCBmb3IgXCIgKyBjaGFubmVsICsgXCIgaXMgZHJvcHBlZCBhcyB0b3AtbGV2ZWwgXCIgKyAoY2hhbm5lbCA9PT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnKSArIFwiIGlzIHByb3ZpZGVkLlwiO1xuICAgIH1cbiAgICBtZXNzYWdlLnJhbmdlU3RlcERyb3BwZWQgPSByYW5nZVN0ZXBEcm9wcGVkO1xuICAgIGZ1bmN0aW9uIHNjYWxlVHlwZU5vdFdvcmtXaXRoQ2hhbm5lbChjaGFubmVsLCBzY2FsZVR5cGUsIGRlZmF1bHRTY2FsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhbm5lbCBcIiArIGNoYW5uZWwgKyBcIiBkb2VzIG5vdCB3b3JrIHdpdGggXCIgKyBzY2FsZVR5cGUgKyBcIiBzY2FsZS4gV2UgYXJlIHVzaW5nIFwiICsgZGVmYXVsdFNjYWxlVHlwZSArIFwiIHNjYWxlIGluc3RlYWQuXCI7XG4gICAgfVxuICAgIG1lc3NhZ2Uuc2NhbGVUeXBlTm90V29ya1dpdGhDaGFubmVsID0gc2NhbGVUeXBlTm90V29ya1dpdGhDaGFubmVsO1xuICAgIGZ1bmN0aW9uIHNjYWxlVHlwZU5vdFdvcmtXaXRoRmllbGREZWYoc2NhbGVUeXBlLCBkZWZhdWx0U2NhbGVUeXBlKSB7XG4gICAgICAgIHJldHVybiBcIkZpZWxkRGVmIGRvZXMgbm90IHdvcmsgd2l0aCBcIiArIHNjYWxlVHlwZSArIFwiIHNjYWxlLiBXZSBhcmUgdXNpbmcgXCIgKyBkZWZhdWx0U2NhbGVUeXBlICsgXCIgc2NhbGUgaW5zdGVhZC5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aEZpZWxkRGVmID0gc2NhbGVUeXBlTm90V29ya1dpdGhGaWVsZERlZjtcbiAgICBmdW5jdGlvbiBzY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGUoc2NhbGVUeXBlLCBwcm9wTmFtZSwgY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbCArIFwiLXNjYWxlJ3MgXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgaXMgZHJvcHBlZCBhcyBpdCBkb2VzIG5vdCB3b3JrIHdpdGggXCIgKyBzY2FsZVR5cGUgKyBcIiBzY2FsZS5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5zY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGUgPSBzY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGU7XG4gICAgZnVuY3Rpb24gc2NhbGVUeXBlTm90V29ya1dpdGhNYXJrKG1hcmssIHNjYWxlVHlwZSkge1xuICAgICAgICByZXR1cm4gXCJTY2FsZSB0eXBlIFxcXCJcIiArIHNjYWxlVHlwZSArIFwiXFxcIiBkb2VzIG5vdCB3b3JrIHdpdGggbWFyayBcIiArIG1hcmsgKyBcIi5cIjtcbiAgICB9XG4gICAgbWVzc2FnZS5zY2FsZVR5cGVOb3RXb3JrV2l0aE1hcmsgPSBzY2FsZVR5cGVOb3RXb3JrV2l0aE1hcms7XG4gICAgbWVzc2FnZS5JTlZBSURfRE9NQUlOID0gJ0ludmFsaWQgc2NhbGUgZG9tYWluJztcbiAgICBtZXNzYWdlLlVOQUJMRV9UT19NRVJHRV9ET01BSU5TID0gJ1VuYWJsZSB0byBtZXJnZSBkb21haW5zJztcbiAgICAvLyBBWElTXG4gICAgbWVzc2FnZS5JTlZBTElEX0NIQU5ORUxfRk9SX0FYSVMgPSAnSW52YWxpZCBjaGFubmVsIGZvciBheGlzLic7XG4gICAgLy8gU1RBQ0tcbiAgICBmdW5jdGlvbiBjYW5ub3RTdGFja1JhbmdlZE1hcmsoY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gXCJDYW5ub3Qgc3RhY2sgXCIgKyBjaGFubmVsICsgXCIgaWYgdGhlcmUgaXMgYWxyZWFkeSBcIiArIGNoYW5uZWwgKyBcIjJcIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RTdGFja1JhbmdlZE1hcmsgPSBjYW5ub3RTdGFja1JhbmdlZE1hcms7XG4gICAgZnVuY3Rpb24gY2Fubm90U3RhY2tOb25MaW5lYXJTY2FsZShzY2FsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHN0YWNrIG5vbi1saW5lYXIgc2NhbGUgKFwiICsgc2NhbGVUeXBlICsgXCIpXCI7XG4gICAgfVxuICAgIG1lc3NhZ2UuY2Fubm90U3RhY2tOb25MaW5lYXJTY2FsZSA9IGNhbm5vdFN0YWNrTm9uTGluZWFyU2NhbGU7XG4gICAgZnVuY3Rpb24gY2Fubm90U3RhY2tOb25TdW1tYXRpdmVBZ2dyZWdhdGUoYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBzdGFjayB3aGVuIHRoZSBhZ2dyZWdhdGUgZnVuY3Rpb24gaXMgbm9uLXN1bW1hdGl2ZSAoXCIgKyBhZ2dyZWdhdGUgKyBcIilcIjtcbiAgICB9XG4gICAgbWVzc2FnZS5jYW5ub3RTdGFja05vblN1bW1hdGl2ZUFnZ3JlZ2F0ZSA9IGNhbm5vdFN0YWNrTm9uU3VtbWF0aXZlQWdncmVnYXRlO1xuICAgIC8vIFRJTUVVTklUXG4gICAgZnVuY3Rpb24gaW52YWxpZFRpbWVVbml0KHVuaXROYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJJbnZhbGlkIFwiICsgdW5pdE5hbWUgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgbWVzc2FnZS5pbnZhbGlkVGltZVVuaXQgPSBpbnZhbGlkVGltZVVuaXQ7XG4gICAgZnVuY3Rpb24gZGF5UmVwbGFjZWRXaXRoRGF0ZShmdWxsVGltZVVuaXQpIHtcbiAgICAgICAgcmV0dXJuIFwiVGltZSB1bml0IFxcXCJcIiArIGZ1bGxUaW1lVW5pdCArIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkLiBXZSBhcmUgcmVwbGFjaW5nIGl0IHdpdGggXCIgK1xuICAgICAgICAgICAgKGZ1bGxUaW1lVW5pdCArICcnKS5yZXBsYWNlKCdkYXknLCAnZGF0ZScpICsgJy4nO1xuICAgIH1cbiAgICBtZXNzYWdlLmRheVJlcGxhY2VkV2l0aERhdGUgPSBkYXlSZXBsYWNlZFdpdGhEYXRlO1xuICAgIGZ1bmN0aW9uIGRyb3BwZWREYXkoZCkge1xuICAgICAgICByZXR1cm4gJ0Ryb3BwaW5nIGRheSBmcm9tIGRhdGV0aW1lICcgKyBKU09OLnN0cmluZ2lmeShkKSArXG4gICAgICAgICAgICAnIGFzIGRheSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB1bml0cy4nO1xuICAgIH1cbiAgICBtZXNzYWdlLmRyb3BwZWREYXkgPSBkcm9wcGVkRGF5O1xufSkobWVzc2FnZSA9IGV4cG9ydHMubWVzc2FnZSB8fCAoZXhwb3J0cy5tZXNzYWdlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWJHOW5MbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwyeHZaeTUwY3lKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pUVVGQlFTeHBSRUZCYVVRN096dEJRVVZxUkRzN1IwRkZSenRCUVVWSUxIVkRRVUYzUkR0QlFXRjRSRHM3UjBGRlJ6dEJRVU5JTEVsQlFVMHNTVUZCU1N4SFFVRkhMR3RDUVVGTkxFTkJRVU1zWjBKQlFVa3NRMEZCUXl4RFFVRkRPMEZCUXpGQ0xFbEJRVWtzVDBGQlR5eEhRVUZ2UWl4SlFVRkpMRU5CUVVNN1FVRkZjRU03TzBkQlJVYzdRVUZEU0R0SlFVRkJPMUZCUTFNc1ZVRkJTeXhIUVVGVkxFVkJRVVVzUTBGQlF6dFJRVU5zUWl4VlFVRkxMRWRCUVZVc1JVRkJSU3hEUVVGRE8xRkJRMnhDTEZkQlFVMHNSMEZCVlN4RlFVRkZMRU5CUVVNN1NVRnZRalZDTEVOQlFVTTdTVUZzUWxFc01rSkJRVXNzUjBGQldqdFJRVU5GTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVTBzTUVKQlFVa3NSMEZCV0R0UlFVRlpMR05CUVdNN1lVRkJaQ3hWUVVGakxFVkJRV1FzY1VKQlFXTXNSVUZCWkN4SlFVRmpPMWxCUVdRc2VVSkJRV003TzFGQlEzaENMRU5CUVVFc1MwRkJRU3hKUVVGSkxFTkJRVU1zUzBGQlN5eERRVUZCTEVOQlFVTXNTVUZCU1N4WFFVRkpMRWxCUVVrc1JVRkJSVHRSUVVONlFpeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPenRKUVVOa0xFTkJRVU03U1VGRlRTd3dRa0ZCU1N4SFFVRllPMUZCUVZrc1kwRkJZenRoUVVGa0xGVkJRV01zUlVGQlpDeHhRa0ZCWXl4RlFVRmtMRWxCUVdNN1dVRkJaQ3g1UWtGQll6czdVVUZEZUVJc1EwRkJRU3hMUVVGQkxFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVRXNRMEZCUXl4SlFVRkpMRmRCUVVrc1NVRkJTU3hGUVVGRk8xRkJRM3BDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN08wbEJRMlFzUTBGQlF6dEpRVVZOTERKQ1FVRkxMRWRCUVZvN1VVRkJZU3hqUVVGak8yRkJRV1FzVlVGQll5eEZRVUZrTEhGQ1FVRmpMRVZCUVdRc1NVRkJZenRaUVVGa0xIbENRVUZqT3p0UlFVTjZRaXhEUVVGQkxFdEJRVUVzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUVN4RFFVRkRMRWxCUVVrc1YwRkJTU3hKUVVGSkxFVkJRVVU3VVVGRE1VSXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenM3U1VGRFpDeERRVUZETzBsQlEwZ3NhMEpCUVVNN1FVRkJSQ3hEUVVGRExFRkJka0pFTEVsQmRVSkRPMEZCZGtKWkxHdERRVUZYTzBGQmVVSjRRaXgzUWtGQkswSXNRMEZCY1VNN1NVRkRiRVVzU1VGQlRTeFhRVUZYTEVkQlFVY3NUMEZCVHl4SFFVRkhMRWxCUVVrc1YwRkJWeXhGUVVGRkxFTkJRVU03U1VGRGFFUXNRMEZCUXl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8wbEJRMllzUzBGQlN5eEZRVUZGTEVOQlFVTTdRVUZEVml4RFFVRkRPMEZCU2tRc2QwTkJTVU03UVVGRlJDeGpRVUZ4UWl4RFFVRm5RenRKUVVOdVJDeE5RVUZOTEVOQlFVTTdVVUZEVEN4SlFVRk5MRTFCUVUwc1IwRkJSeXhQUVVGUExFZEJRVWNzU1VGQlNTeFhRVUZYTEVWQlFVVXNRMEZCUXp0UlFVTXpReXhEUVVGRExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTTdVVUZEVml4TFFVRkxMRVZCUVVVc1EwRkJRenRKUVVOV0xFTkJRVU1zUTBGQlF6dEJRVU5LTEVOQlFVTTdRVUZPUkN4dlFrRk5RenRCUVVWRU96dEhRVVZITzBGQlEwZ3NZVUZCYjBJc1RVRkJkVUk3U1VGRGVrTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJRenRKUVVOcVFpeE5RVUZOTEVOQlFVTXNUMEZCVHl4RFFVRkRPMEZCUTJwQ0xFTkJRVU03UVVGSVJDeHJRa0ZIUXp0QlFVVkVPenRIUVVWSE8wRkJRMGc3U1VGRFJTeFBRVUZQTEVkQlFVY3NTVUZCU1N4RFFVRkRPMGxCUTJZc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF6dEJRVU5xUWl4RFFVRkRPMEZCU0VRc2MwSkJSME03UVVGRlJEdEpRVUZ4UWl4WFFVRlhPMU5CUVZnc1ZVRkJWeXhGUVVGWUxIRkNRVUZYTEVWQlFWZ3NTVUZCVnp0UlFVRllMSE5DUVVGWE96dEpRVU01UWl4UFFVRlBMRU5CUVVNc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF5eFBRVUZQTEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNN1FVRkRla01zUTBGQlF6dEJRVVpFTEc5Q1FVVkRPMEZCUlVRN1NVRkJjVUlzVjBGQlZ6dFRRVUZZTEZWQlFWY3NSVUZCV0N4eFFrRkJWeXhGUVVGWUxFbEJRVmM3VVVGQldDeHpRa0ZCVnpzN1NVRkRPVUlzVDBGQlR5eERRVUZETEVsQlFVa3NRMEZCUXl4TFFVRkxMRU5CUVVNc1QwRkJUeXhGUVVGRkxGTkJRVk1zUTBGQlF5eERRVUZETzBGQlEzcERMRU5CUVVNN1FVRkdSQ3h2UWtGRlF6dEJRVVZFTzBsQlFYTkNMRmRCUVZjN1UwRkJXQ3hWUVVGWExFVkJRVmdzY1VKQlFWY3NSVUZCV0N4SlFVRlhPMUZCUVZnc2MwSkJRVmM3TzBsQlF5OUNMRTlCUVU4c1EwRkJReXhMUVVGTExFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRCUVVNeFF5eERRVUZETzBGQlJrUXNjMEpCUlVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEVsQlFXbENMRTlCUVU4c1EwRjFTWFpDTzBGQmRrbEVMRmRCUVdsQ0xFOUJRVTg3U1VGRFZDeHZRa0ZCV1N4SFFVRkhMR05CUVdNc1EwRkJRenRKUVVVelF5eGhRVUZoTzBsQlEySXNhVU5CUVhkRExGTkJRV003VVVGRGNFUXNUVUZCVFN4RFFVRkRMRzlEUVVGclF5eEpRVUZKTEVOQlFVTXNVMEZCVXl4RFFVRkRMRk5CUVZNc1EwRkJReXhOUVVGSExFTkJRVU03U1VGRGVFVXNRMEZCUXp0SlFVWmxMQ3RDUVVGMVFpd3dRa0ZGZEVNc1EwRkJRVHRKUVVWRUxHMUNRVUZ0UWp0SlFVTnVRaXd3UWtGQmFVTXNTVUZCVlR0UlFVTjZReXhOUVVGTkxFTkJRVU1zTUVKQlFYVkNMRWxCUVVrc1QwRkJSeXhEUVVGRE8wbEJRM2hETEVOQlFVTTdTVUZHWlN4M1FrRkJaMElzYlVKQlJTOUNMRU5CUVVFN1NVRkRSQ3d3UWtGQmFVTXNVMEZCSzBJN1VVRkRPVVFzVFVGQlRTeERRVUZETEc5RFFVRnBReXhUUVVGVExFOUJRVWNzUTBGQlF6dEpRVU4yUkN4RFFVRkRPMGxCUm1Vc2QwSkJRV2RDTEcxQ1FVVXZRaXhEUVVGQk8wbEJSVVFzYVVOQlFYZERMRWxCUVcxQ0xFVkJRVVVzVDBGQlowSXNSVUZCUlN4UFFVRmhPMUZCUXpGR0xFMUJRVTBzUTBGQlF5eDVRa0ZCZFVJc1NVRkJTU3h6UWtGQmFVSXNUMEZCVHl4blFrRkJWeXhQUVVGUExHTkJRVmNzUTBGQlF6dEpRVU14Uml4RFFVRkRPMGxCUm1Vc0swSkJRWFZDTERCQ1FVVjBReXhEUVVGQk8wbEJSVVFzZFVKQlFUaENMRkZCUVd0Q0xFVkJRVVVzVDBGQlowSTdVVUZEYUVVc1RVRkJUU3hEUVVGRExHTkJRVmtzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc2MwSkJRV2xDTEU5QlFVOHNiMFJCUVdsRUxFTkJRVU03U1VGRGRrZ3NRMEZCUXp0SlFVWmxMSEZDUVVGaExHZENRVVUxUWl4RFFVRkJPMGxCUlVRc05rSkJRVzlETEU5QlFXZENMRVZCUVVVc1YwRkJNa0lzUlVGQlJTeEpRVUZoTzFGQlF6bEdMRTFCUVUwc1EwRkJTU3hQUVVGUExEUkRRVUYxUXl4WFFVRmhPMWxCUTI1RkxFbEJRVWtzUjBGQlJ5eFZRVUZSTEVsQlFVMHNSMEZCUnl4RlFVRkZMRU5CUVVNN1NVRkRMMElzUTBGQlF6dEpRVWhsTERKQ1FVRnRRaXh6UWtGSGJFTXNRMEZCUVR0SlFVVkVMSE5EUVVFMlF5eFBRVUZsTzFGQlF6RkVMRTFCUVUwc1EwRkJTU3hQUVVGUExDdEVRVUUwUkN4RFFVRkRPMGxCUTJoR0xFTkJRVU03U1VGR1pTeHZRMEZCTkVJc0swSkJSVE5ETEVOQlFVRTdTVUZGUkN4eFEwRkJORU1zVDBGQlowSXNSVUZCUlN4SlFVRlZPMUZCUTNSRkxFMUJRVTBzUTBGQlF5dzBRa0ZCTUVJc1QwRkJUeXh0UWtGQll5eEpRVUZKTEhkRVFVRnJSQ3hKUVVGSkxFdEJRVXNzVTBGQlV5eEhRVUZITEU5QlFVOHNSMEZCUnl4WFFVRlhMRTlCUVVjc1EwRkJRenRKUVVNMVNpeERRVUZETzBsQlJtVXNiVU5CUVRKQ0xEaENRVVV4UXl4RFFVRkJPMGxCUlVRc1QwRkJUenRKUVVOTkxDdERRVUYxUXl4SFFVRkhMSEZIUVVGeFJ5eERRVUZETzBsQlJUZEtMR2xEUVVGM1F5eEpRVUZWTzFGQlEyaEVMRTFCUVUwc1EwRkJReXd5UTBGQk1rTXNSMEZCUnl4SlFVRkpMRWRCUVVjc0swWkJRU3RHTEVOQlFVTTdTVUZET1Vvc1EwRkJRenRKUVVabExDdENRVUYxUWl3d1FrRkZkRU1zUTBGQlFUdEpRVVZFTEhORFFVRTJReXhKUVVGVk8xRkJRM0pFTEUxQlFVMHNRMEZCUXl3eVEwRkJNa01zUjBGQlJ5eEpRVUZKTEVkQlFVY3NPRVJCUVRoRUxFTkJRVU03U1VGRE4wZ3NRMEZCUXp0SlFVWmxMRzlEUVVFMFFpd3JRa0ZGTTBNc1EwRkJRVHRKUVVWRUxEQkNRVUZwUXl4UlFVRm5RaXhGUVVGRkxFMUJRV003VVVGREwwUXNUVUZCVFN4RFFVRkRMSE5DUVVGdlFpeFJRVUZSTEhsQ1FVRnZRaXhOUVVGUkxFTkJRVU03U1VGRGJFVXNRMEZCUXp0SlFVWmxMSGRDUVVGblFpeHRRa0ZGTDBJc1EwRkJRVHRKUVVWRUxGRkJRVkU3U1VGRFN5eHZSRUZCTkVNc1IwRkJSeXgxUlVGQmRVVXNRMEZCUXp0SlFVVndTU3cwUTBGQmJVUXNTVUZCV1R0UlFVTTNSQ3hOUVVGTkxFTkJRVU1zWjBKQlFXTXNTVUZCU1N3MlFrRkJNRUlzUTBGQlF6dEpRVU4wUkN4RFFVRkRPMGxCUm1Vc01FTkJRV3RETEhGRFFVVnFSQ3hEUVVGQk8wbEJSVVFzYVVSQlFYZEVMRkZCUVd0Q08xRkJRM2hGTEUxQlFVMHNRMEZCUXl3MlJFRkJNa1FzU1VGQlNTeERRVUZETEZOQlFWTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1QwRkJTU3hEUVVGRE8wbEJRMnBITEVOQlFVTTdTVUZHWlN3clEwRkJkVU1zTUVOQlJYUkVMRU5CUVVFN1NVRkZSQ3huUkVGQmRVUXNVMEZCYzBJN1VVRkRNMFVzVFVGQlRTeERRVUZETERSRFFVRXdReXhUUVVGVExEUkZRVUY1UlN4RFFVRkRPMGxCUTNSSkxFTkJRVU03U1VGR1pTdzRRMEZCYzBNc2VVTkJSWEpFTEVOQlFVRTdTVUZGUkN4M1EwRkJLME1zVVVGQmEwSTdVVUZETDBRc1RVRkJUU3hEUVVGRExHbEZRVUVyUkN4SlFVRkpMRU5CUVVNc1UwRkJVeXhEUVVGRExGRkJRVkVzUTBGQlF5eFBRVUZKTEVOQlFVTTdTVUZEY2tjc1EwRkJRenRKUVVabExITkRRVUU0UWl4cFEwRkZOME1zUTBGQlFUdEpRVVZaTEhORFFVRTRRaXhIUVVONlF5dzRSMEZCT0Vjc1EwRkJRenRKUVVWc1J5eHhRMEZCTmtJc1IwRkJSeXh6UlVGQmMwVXNRMEZCUXp0SlFVVjBTQ3g1UTBGQlowUXNVVUZCWjBJN1VVRkRPVVFzVFVGQlRTeERRVUZETEhWQ1FVRnhRaXhSUVVGUkxDdEZRVUUwUlN4RFFVRkRPMGxCUTI1SUxFTkJRVU03U1VGR1pTeDFRMEZCSzBJc2EwTkJSVGxETEVOQlFVRTdTVUZGUkN3d1FrRkJhVU1zVDBGQlowSTdVVUZETDBNc1RVRkJUU3hEUVVGRExHMUNRVUZwUWl4UFFVRlBMR3REUVVNM1FpeFBRVUZQTEV0QlFVc3NSMEZCUnl4SFFVRkhMRTlCUVU4c1IwRkJSeXhSUVVGUkxHMUNRVUZsTEVOQlFVTTdTVUZEZUVRc1EwRkJRenRKUVVobExIZENRVUZuUWl4dFFrRkhMMElzUTBGQlFUdEpRVVZFTEhGRFFVRTBReXhQUVVGblFpeEZRVUZGTEZOQlFXOUNMRVZCUVVVc1owSkJRVEpDTzFGQlF6ZEhMRTFCUVUwc1EwRkJReXhoUVVGWExFOUJRVThzTkVKQlFYVkNMRk5CUVZNc05rSkJRWGRDTEdkQ1FVRm5RaXh2UWtGQmFVSXNRMEZCUXp0SlFVTnlTQ3hEUVVGRE8wbEJSbVVzYlVOQlFUSkNMRGhDUVVVeFF5eERRVUZCTzBsQlJVUXNjME5CUVRaRExGTkJRVzlDTEVWQlFVVXNaMEpCUVRKQ08xRkJRelZHTEUxQlFVMHNRMEZCUXl4cFEwRkJLMElzVTBGQlV5dzJRa0ZCZDBJc1owSkJRV2RDTEc5Q1FVRnBRaXhEUVVGRE8wbEJRek5ITEVOQlFVTTdTVUZHWlN4dlEwRkJORUlzSzBKQlJUTkRMRU5CUVVFN1NVRkZSQ3d5UTBGQmEwUXNVMEZCYjBJc1JVRkJSU3hSUVVGblFpeEZRVUZGTEU5QlFXZENPMUZCUTNoSExFMUJRVTBzUTBGQlNTeFBRVUZQTEcxQ1FVRmhMRkZCUVZFc0swTkJRWGxETEZOQlFWTXNXVUZCVXl4RFFVRkRPMGxCUTNCSExFTkJRVU03U1VGR1pTeDVRMEZCYVVNc2IwTkJSV2hFTEVOQlFVRTdTVUZGUkN4clEwRkJlVU1zU1VGQlZTeEZRVUZGTEZOQlFXOUNPMUZCUTNaRkxFMUJRVTBzUTBGQlF5eHJRa0ZCWlN4VFFVRlRMRzFEUVVFMlFpeEpRVUZKTEUxQlFVY3NRMEZCUXp0SlFVTjBSU3hEUVVGRE8wbEJSbVVzWjBOQlFYZENMREpDUVVWMlF5eERRVUZCTzBsQlJWa3NjVUpCUVdFc1IwRkJSeXh6UWtGQmMwSXNRMEZCUXp0SlFVVjJReXdyUWtGQmRVSXNSMEZCUnl4NVFrRkJlVUlzUTBGQlF6dEpRVVZxUlN4UFFVRlBPMGxCUTAwc1owTkJRWGRDTEVkQlFVY3NNa0pCUVRKQ0xFTkJRVU03U1VGRmNFVXNVVUZCVVR0SlFVTlNMQ3RDUVVGelF5eFBRVUZuUWp0UlFVTndSQ3hOUVVGTkxFTkJRVU1zYTBKQlFXZENMRTlCUVU4c05rSkJRWGRDTEU5QlFVOHNUVUZCUnl4RFFVRkRPMGxCUTI1RkxFTkJRVU03U1VGR1pTdzJRa0ZCY1VJc2QwSkJSWEJETEVOQlFVRTdTVUZGUkN4dFEwRkJNRU1zVTBGQmIwSTdVVUZETlVRc1RVRkJUU3hEUVVGRExHOURRVUZyUXl4VFFVRlRMRTFCUVVjc1EwRkJRenRKUVVONFJDeERRVUZETzBsQlJtVXNhVU5CUVhsQ0xEUkNRVVY0UXl4RFFVRkJPMGxCUlVRc01FTkJRV2xFTEZOQlFYTkNPMUZCUTNKRkxFMUJRVTBzUTBGQlF5eG5SVUZCT0VRc1UwRkJVeXhOUVVGSExFTkJRVU03U1VGRGNFWXNRMEZCUXp0SlFVWmxMSGREUVVGblF5eHRRMEZGTDBNc1EwRkJRVHRKUVVWRUxGZEJRVmM3U1VGRFdDeDVRa0ZCWjBNc1VVRkJaMElzUlVGQlJTeExRVUZ6UWp0UlFVTjBSU3hOUVVGTkxFTkJRVU1zWVVGQlZ5eFJRVUZSTEZWQlFVc3NTMEZCVHl4RFFVRkRPMGxCUTNwRExFTkJRVU03U1VGR1pTeDFRa0ZCWlN4clFrRkZPVUlzUTBGQlFUdEpRVVZFTERaQ1FVRnZReXhaUVVGelFqdFJRVU40UkN4TlFVRk5MRU5CUVVNc2FVSkJRV01zV1VGQldTeHRSRUZCSzBNN1dVRkRPVVVzUTBGQlF5eFpRVUZaTEVkQlFVTXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVOQlFVTXNSMEZCUnl4SFFVRkhMRU5CUVVNN1NVRkRia1FzUTBGQlF6dEpRVWhsTERKQ1FVRnRRaXh6UWtGSGJFTXNRMEZCUVR0SlFVVkVMRzlDUVVFeVFpeERRVUV3UWp0UlFVTnVSQ3hOUVVGTkxFTkJRVU1zTmtKQlFUWkNMRWRCUVVjc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVRc09FTkJRVGhETEVOQlFVTTdTVUZEZGtRc1EwRkJRenRKUVVobExHdENRVUZWTEdGQlIzcENMRU5CUVVFN1FVRkRTQ3hEUVVGRExFVkJka2xuUWl4UFFVRlBMRWRCUVZBc1pVRkJUeXhMUVVGUUxHVkJRVThzVVVGMVNYWkNJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBNYXJrO1xuKGZ1bmN0aW9uIChNYXJrKSB7XG4gICAgTWFyay5BUkVBID0gJ2FyZWEnO1xuICAgIE1hcmsuQkFSID0gJ2Jhcic7XG4gICAgTWFyay5MSU5FID0gJ2xpbmUnO1xuICAgIE1hcmsuUE9JTlQgPSAncG9pbnQnO1xuICAgIE1hcmsuUkVDVCA9ICdyZWN0JztcbiAgICBNYXJrLlJVTEUgPSAncnVsZSc7XG4gICAgTWFyay5URVhUID0gJ3RleHQnO1xuICAgIE1hcmsuVElDSyA9ICd0aWNrJztcbiAgICBNYXJrLkNJUkNMRSA9ICdjaXJjbGUnO1xuICAgIE1hcmsuU1FVQVJFID0gJ3NxdWFyZSc7XG59KShNYXJrID0gZXhwb3J0cy5NYXJrIHx8IChleHBvcnRzLk1hcmsgPSB7fSkpO1xuZXhwb3J0cy5BUkVBID0gTWFyay5BUkVBO1xuZXhwb3J0cy5CQVIgPSBNYXJrLkJBUjtcbmV4cG9ydHMuTElORSA9IE1hcmsuTElORTtcbmV4cG9ydHMuUE9JTlQgPSBNYXJrLlBPSU5UO1xuZXhwb3J0cy5URVhUID0gTWFyay5URVhUO1xuZXhwb3J0cy5USUNLID0gTWFyay5USUNLO1xuZXhwb3J0cy5SRUNUID0gTWFyay5SRUNUO1xuZXhwb3J0cy5SVUxFID0gTWFyay5SVUxFO1xuZXhwb3J0cy5DSVJDTEUgPSBNYXJrLkNJUkNMRTtcbmV4cG9ydHMuU1FVQVJFID0gTWFyay5TUVVBUkU7XG5leHBvcnRzLlBSSU1JVElWRV9NQVJLUyA9IFtleHBvcnRzLkFSRUEsIGV4cG9ydHMuQkFSLCBleHBvcnRzLkxJTkUsIGV4cG9ydHMuUE9JTlQsIGV4cG9ydHMuVEVYVCwgZXhwb3J0cy5USUNLLCBleHBvcnRzLlJFQ1QsIGV4cG9ydHMuUlVMRSwgZXhwb3J0cy5DSVJDTEUsIGV4cG9ydHMuU1FVQVJFXTtcbmZ1bmN0aW9uIGlzTWFya0RlZihtYXJrKSB7XG4gICAgcmV0dXJuIG1hcmtbJ3R5cGUnXTtcbn1cbmV4cG9ydHMuaXNNYXJrRGVmID0gaXNNYXJrRGVmO1xudmFyIFBSSU1JVElWRV9NQVJLX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuUFJJTUlUSVZFX01BUktTKTtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlTWFyayhtYXJrKSB7XG4gICAgdmFyIG1hcmtUeXBlID0gaXNNYXJrRGVmKG1hcmspID8gbWFyay50eXBlIDogbWFyaztcbiAgICByZXR1cm4gbWFya1R5cGUgaW4gUFJJTUlUSVZFX01BUktfSU5ERVg7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlTWFyayA9IGlzUHJpbWl0aXZlTWFyaztcbmV4cG9ydHMuU1RST0tFX0NPTkZJRyA9IFsnc3Ryb2tlJywgJ3N0cm9rZVdpZHRoJyxcbiAgICAnc3Ryb2tlRGFzaCcsICdzdHJva2VEYXNoT2Zmc2V0JywgJ3N0cm9rZU9wYWNpdHknXTtcbmV4cG9ydHMuRklMTF9DT05GSUcgPSBbJ2ZpbGwnLCAnZmlsbE9wYWNpdHknXTtcbmV4cG9ydHMuRklMTF9TVFJPS0VfQ09ORklHID0gW10uY29uY2F0KGV4cG9ydHMuU1RST0tFX0NPTkZJRywgZXhwb3J0cy5GSUxMX0NPTkZJRyk7XG5leHBvcnRzLmRlZmF1bHRNYXJrQ29uZmlnID0ge1xuICAgIGNvbG9yOiAnIzRjNzhhOCcsXG59O1xuZXhwb3J0cy5kZWZhdWx0QmFyQ29uZmlnID0ge1xuICAgIGJpblNwYWNpbmc6IDEsXG4gICAgY29udGludW91c0JhbmRTaXplOiAyXG59O1xuZXhwb3J0cy5kZWZhdWx0VGV4dENvbmZpZyA9IHtcbiAgICBiYXNlbGluZTogJ21pZGRsZScsXG59O1xuZXhwb3J0cy5kZWZhdWx0VGlja0NvbmZpZyA9IHtcbiAgICB0aGlja25lc3M6IDFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2liV0Z5YXk1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1THk0dUwzTnlZeTl0WVhKckxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPMEZCUVVFc0swSkJRVFpDTzBGQlNUZENMRWxCUVdsQ0xFbEJRVWtzUTBGWGNFSTdRVUZZUkN4WFFVRnBRaXhKUVVGSk8wbEJRMDRzVTBGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0SlFVTjBRaXhSUVVGSExFZEJRVlVzUzBGQlN5eERRVUZETzBsQlEyNUNMRk5CUVVrc1IwRkJWeXhOUVVGTkxFTkJRVU03U1VGRGRFSXNWVUZCU3l4SFFVRlpMRTlCUVU4c1EwRkJRenRKUVVONlFpeFRRVUZKTEVkQlFWY3NUVUZCVFN4RFFVRkRPMGxCUTNSQ0xGTkJRVWtzUjBGQlZ5eE5RVUZOTEVOQlFVTTdTVUZEZEVJc1UwRkJTU3hIUVVGWExFMUJRVTBzUTBGQlF6dEpRVU4wUWl4VFFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wbEJRM1JDTEZkQlFVMHNSMEZCWVN4UlFVRlJMRU5CUVVNN1NVRkROVUlzVjBGQlRTeEhRVUZoTEZGQlFWRXNRMEZCUXp0QlFVTXpReXhEUVVGRExFVkJXR2RDTEVsQlFVa3NSMEZCU2l4WlFVRkpMRXRCUVVvc1dVRkJTU3hSUVZkd1FqdEJRVkZaTEZGQlFVRXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRGFrSXNVVUZCUVN4SFFVRkhMRWRCUVVjc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF6dEJRVU5tTEZGQlFVRXNTVUZCU1N4SFFVRkhMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRGFrSXNVVUZCUVN4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU51UWl4UlFVRkJMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlEycENMRkZCUVVFc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEYWtJc1VVRkJRU3hKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTnFRaXhSUVVGQkxFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUldwQ0xGRkJRVUVzVFVGQlRTeEhRVUZITEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNN1FVRkRja0lzVVVGQlFTeE5RVUZOTEVkQlFVY3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRCUVVWeVFpeFJRVUZCTEdWQlFXVXNSMEZCUnl4RFFVRkRMRmxCUVVrc1JVRkJSU3hYUVVGSExFVkJRVVVzV1VGQlNTeEZRVUZGTEdGQlFVc3NSVUZCUlN4WlFVRkpMRVZCUVVVc1dVRkJTU3hGUVVGRkxGbEJRVWtzUlVGQlJTeFpRVUZKTEVWQlFVVXNZMEZCVFN4RlFVRkZMR05CUVUwc1EwRkJReXhEUVVGRE8wRkJLMFJvUnl4dFFrRkJNRUlzU1VGQmMwSTdTVUZET1VNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTjBRaXhEUVVGRE8wRkJSa1FzT0VKQlJVTTdRVUZGUkN4SlFVRk5MRzlDUVVGdlFpeEhRVUZITEZsQlFVc3NRMEZCUXl4MVFrRkJaU3hEUVVGRExFTkJRVU03UVVGRmNFUXNlVUpCUVdkRExFbEJRWE5DTzBsQlEzQkVMRWxCUVUwc1VVRkJVU3hIUVVGSExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dEpRVU53UkN4TlFVRk5MRU5CUVVNc1VVRkJVU3hKUVVGSkxHOUNRVUZ2UWl4RFFVRkRPMEZCUXpGRExFTkJRVU03UVVGSVJDd3dRMEZIUXp0QlFVVlpMRkZCUVVFc1lVRkJZU3hIUVVGSExFTkJRVU1zVVVGQlVTeEZRVUZGTEdGQlFXRTdTVUZEYmtRc1dVRkJXU3hGUVVGRkxHdENRVUZyUWl4RlFVRkZMR1ZCUVdVc1EwRkJReXhEUVVGRE8wRkJSWGhETEZGQlFVRXNWMEZCVnl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRkxHRkJRV0VzUTBGQlF5eERRVUZETzBGQlJYUkRMRkZCUVVFc2EwSkJRV3RDTEVkQlFVY3NSVUZCUlN4RFFVRkRMRTFCUVUwc1EwRkJReXh4UWtGQllTeEZRVUZGTEcxQ1FVRlhMRU5CUVVNc1EwRkJRenRCUVhkQ00wUXNVVUZCUVN4cFFrRkJhVUlzUjBGQlpUdEpRVU16UXl4TFFVRkxMRVZCUVVVc1UwRkJVenREUVVOcVFpeERRVUZETzBGQk5FSlhMRkZCUVVFc1owSkJRV2RDTEVkQlFXTTdTVUZEZWtNc1ZVRkJWU3hGUVVGRkxFTkJRVU03U1VGRFlpeHJRa0ZCYTBJc1JVRkJSU3hEUVVGRE8wTkJRM1JDTEVOQlFVTTdRVUZUVnl4UlFVRkJMR2xDUVVGcFFpeEhRVUZsTzBsQlF6TkRMRkZCUVZFc1JVRkJSU3hSUVVGUk8wTkJRMjVDTEVOQlFVTTdRVUZ2UWxjc1VVRkJRU3hwUWtGQmFVSXNSMEZCWlR0SlFVTXpReXhUUVVGVExFVkJRVVVzUTBGQlF6dERRVU5pTEVOQlFVTWlmUT09IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbG9nID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgU2NhbGVUeXBlO1xuKGZ1bmN0aW9uIChTY2FsZVR5cGUpIHtcbiAgICAvLyBDb250aW51b3VzIC0gUXVhbnRpdGF0aXZlXG4gICAgU2NhbGVUeXBlLkxJTkVBUiA9ICdsaW5lYXInO1xuICAgIFNjYWxlVHlwZS5CSU5fTElORUFSID0gJ2Jpbi1saW5lYXInO1xuICAgIFNjYWxlVHlwZS5MT0cgPSAnbG9nJztcbiAgICBTY2FsZVR5cGUuUE9XID0gJ3Bvdyc7XG4gICAgU2NhbGVUeXBlLlNRUlQgPSAnc3FydCc7XG4gICAgLy8gQ29udGludW91cyAtIFRpbWVcbiAgICBTY2FsZVR5cGUuVElNRSA9ICd0aW1lJztcbiAgICBTY2FsZVR5cGUuVVRDID0gJ3V0Yyc7XG4gICAgLy8gc2VxdWVudGlhbFxuICAgIFNjYWxlVHlwZS5TRVFVRU5USUFMID0gJ3NlcXVlbnRpYWwnO1xuICAgIC8vIFF1YW50aWxlLCBRdWFudGl6ZSwgdGhyZXNob2xkXG4gICAgU2NhbGVUeXBlLlFVQU5USUxFID0gJ3F1YW50aWxlJztcbiAgICBTY2FsZVR5cGUuUVVBTlRJWkUgPSAncXVhbnRpemUnO1xuICAgIFNjYWxlVHlwZS5USFJFU0hPTEQgPSAndGhyZXNob2xkJztcbiAgICBTY2FsZVR5cGUuT1JESU5BTCA9ICdvcmRpbmFsJztcbiAgICBTY2FsZVR5cGUuQklOX09SRElOQUwgPSAnYmluLW9yZGluYWwnO1xuICAgIFNjYWxlVHlwZS5QT0lOVCA9ICdwb2ludCc7XG4gICAgU2NhbGVUeXBlLkJBTkQgPSAnYmFuZCc7XG59KShTY2FsZVR5cGUgPSBleHBvcnRzLlNjYWxlVHlwZSB8fCAoZXhwb3J0cy5TY2FsZVR5cGUgPSB7fSkpO1xuZXhwb3J0cy5TQ0FMRV9UWVBFUyA9IFtcbiAgICAvLyBDb250aW51b3VzIC0gUXVhbnRpdGF0aXZlXG4gICAgJ2xpbmVhcicsICdiaW4tbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsXG4gICAgLy8gQ29udGludW91cyAtIFRpbWVcbiAgICAndGltZScsICd1dGMnLFxuICAgIC8vIFNlcXVlbnRpYWxcbiAgICAnc2VxdWVudGlhbCcsXG4gICAgLy8gRGlzY3JldGVcbiAgICAnb3JkaW5hbCcsICdiaW4tb3JkaW5hbCcsICdwb2ludCcsICdiYW5kJyxcbl07XG5leHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMgPSBbJ2xpbmVhcicsICdiaW4tbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsICd0aW1lJywgJ3V0YyddO1xudmFyIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19JTkRFWCA9IHV0aWxfMS50b1NldChleHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpO1xuZXhwb3J0cy5DT05USU5VT1VTX0RPTUFJTl9TQ0FMRVMgPSBleHBvcnRzLkNPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMuY29uY2F0KFsnc2VxdWVudGlhbCcgLyogVE9ETyBhZGQgJ3F1YW50aWxlJywgJ3F1YW50aXplJywgJ3RocmVzaG9sZCcqL10pO1xudmFyIENPTlRJTlVPVVNfRE9NQUlOX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuQ09OVElOVU9VU19ET01BSU5fU0NBTEVTKTtcbmV4cG9ydHMuRElTQ1JFVEVfRE9NQUlOX1NDQUxFUyA9IFsnb3JkaW5hbCcsICdiaW4tb3JkaW5hbCcsICdwb2ludCcsICdiYW5kJ107XG52YXIgRElTQ1JFVEVfRE9NQUlOX0lOREVYID0gdXRpbF8xLnRvU2V0KGV4cG9ydHMuRElTQ1JFVEVfRE9NQUlOX1NDQUxFUyk7XG52YXIgQklOX1NDQUxFU19JTkRFWCA9IHV0aWxfMS50b1NldChbJ2Jpbi1saW5lYXInLCAnYmluLW9yZGluYWwnXSk7XG5leHBvcnRzLlRJTUVfU0NBTEVfVFlQRVMgPSBbJ3RpbWUnLCAndXRjJ107XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZURvbWFpbih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW4gRElTQ1JFVEVfRE9NQUlOX0lOREVYO1xufVxuZXhwb3J0cy5oYXNEaXNjcmV0ZURvbWFpbiA9IGhhc0Rpc2NyZXRlRG9tYWluO1xuZnVuY3Rpb24gaXNCaW5TY2FsZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgaW4gQklOX1NDQUxFU19JTkRFWDtcbn1cbmV4cG9ydHMuaXNCaW5TY2FsZSA9IGlzQmluU2NhbGU7XG5mdW5jdGlvbiBoYXNDb250aW51b3VzRG9tYWluKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSBpbiBDT05USU5VT1VTX0RPTUFJTl9JTkRFWDtcbn1cbmV4cG9ydHMuaGFzQ29udGludW91c0RvbWFpbiA9IGhhc0NvbnRpbnVvdXNEb21haW47XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNUb0NvbnRpbnVvdXModHlwZSkge1xuICAgIHJldHVybiB0eXBlIGluIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19JTkRFWDtcbn1cbmV4cG9ydHMuaXNDb250aW51b3VzVG9Db250aW51b3VzID0gaXNDb250aW51b3VzVG9Db250aW51b3VzO1xuZXhwb3J0cy5kZWZhdWx0U2NhbGVDb25maWcgPSB7XG4gICAgcm91bmQ6IHRydWUsXG4gICAgdGV4dFhSYW5nZVN0ZXA6IDkwLFxuICAgIHJhbmdlU3RlcDogMjEsXG4gICAgcG9pbnRQYWRkaW5nOiAwLjUsXG4gICAgYmFuZFBhZGRpbmdJbm5lcjogMC4xLFxuICAgIGZhY2V0U3BhY2luZzogMTYsXG4gICAgbWluRm9udFNpemU6IDgsXG4gICAgbWF4Rm9udFNpemU6IDQwLFxuICAgIG1pbk9wYWNpdHk6IDAuMyxcbiAgICBtYXhPcGFjaXR5OiAwLjgsXG4gICAgLy8gRklYTUU6IHJldmlzZSBpZiB0aGVzZSAqY2FuKiBiZWNvbWUgcmF0aW9zIG9mIHJhbmdlU3RlcFxuICAgIG1pblNpemU6IDksXG4gICAgbWluU3Ryb2tlV2lkdGg6IDEsXG4gICAgbWF4U3Ryb2tlV2lkdGg6IDQsXG4gICAgc2hhcGVzOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS11cCcsICd0cmlhbmdsZS1kb3duJ11cbn07XG5mdW5jdGlvbiBpc0V4dGVuZGVkU2NoZW1lKHNjaGVtZSkge1xuICAgIHJldHVybiBzY2hlbWUgJiYgISFzY2hlbWVbJ25hbWUnXTtcbn1cbmV4cG9ydHMuaXNFeHRlbmRlZFNjaGVtZSA9IGlzRXh0ZW5kZWRTY2hlbWU7XG5leHBvcnRzLlNDQUxFX1BST1BFUlRJRVMgPSBbXG4gICAgJ3R5cGUnLCAnZG9tYWluJywgJ3JhbmdlJywgJ3JvdW5kJywgJ3JhbmdlU3RlcCcsICdzY2hlbWUnLCAncGFkZGluZycsICdwYWRkaW5nSW5uZXInLCAncGFkZGluZ091dGVyJywgJ2NsYW1wJywgJ25pY2UnLFxuICAgICdleHBvbmVudCcsICd6ZXJvJywgJ2ludGVycG9sYXRlJ1xuXTtcbmZ1bmN0aW9uIHNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZVR5cGUsIHByb3BOYW1lKSB7XG4gICAgc3dpdGNoIChwcm9wTmFtZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICBjYXNlICdzY2hlbWUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuY29udGFpbnMoWydsaW5lYXInLCAnYmluLWxpbmVhcicsICdwb3cnLCAnbG9nJywgJ3NxcnQnLCAndXRjJywgJ3RpbWUnXSwgc2NhbGVUeXBlKTtcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGludW91c1RvQ29udGludW91cyhzY2FsZVR5cGUpIHx8IHNjYWxlVHlwZSA9PT0gJ2JhbmQnIHx8IHNjYWxlVHlwZSA9PT0gJ3BvaW50JztcbiAgICAgICAgY2FzZSAncmFuZ2VTdGVwJzpcbiAgICAgICAgY2FzZSAncGFkZGluZyc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdPdXRlcic6XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKFsncG9pbnQnLCAnYmFuZCddLCBzY2FsZVR5cGUpO1xuICAgICAgICBjYXNlICdwYWRkaW5nSW5uZXInOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSA9PT0gJ2JhbmQnO1xuICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgICAgICByZXR1cm4gaXNDb250aW51b3VzVG9Db250aW51b3VzKHNjYWxlVHlwZSkgfHwgc2NhbGVUeXBlID09PSAnc2VxdWVudGlhbCc7XG4gICAgICAgIGNhc2UgJ25pY2UnOlxuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGludW91c1RvQ29udGludW91cyhzY2FsZVR5cGUpIHx8IHNjYWxlVHlwZSA9PT0gJ3NlcXVlbnRpYWwnIHx8IHNjYWxlVHlwZSA9PT0gJ3F1YW50aXplJztcbiAgICAgICAgY2FzZSAnZXhwb25lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxlVHlwZSA9PT0gJ3BvdycgfHwgc2NhbGVUeXBlID09PSAnbG9nJztcbiAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHF1YW50aXplLCB0aHJlc2hvbGQ/XG4gICAgICAgICAgICByZXR1cm4gc2NhbGVUeXBlID09PSAnYmluLW9yZGluYWwnIHx8ICghaGFzRGlzY3JldGVEb21haW4oc2NhbGVUeXBlKSAmJiAhdXRpbF8xLmNvbnRhaW5zKFsnbG9nJywgJ3RpbWUnLCAndXRjJywgJ2Jpbi1saW5lYXInXSwgc2NhbGVUeXBlKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSovXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzY2FsZSBwcm9wZXJ0eSBcIiArIHByb3BOYW1lICsgXCIuXCIpO1xufVxuZXhwb3J0cy5zY2FsZVR5cGVTdXBwb3J0UHJvcGVydHkgPSBzY2FsZVR5cGVTdXBwb3J0UHJvcGVydHk7XG4vKipcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBpbnB1dCBjaGFubmVsIHN1cHBvcnRzIHRoZSBpbnB1dCBzY2FsZSBwcm9wZXJ0eSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5KGNoYW5uZWwsIHByb3BOYW1lKSB7XG4gICAgc3dpdGNoIChwcm9wTmFtZSkge1xuICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAvLyBVc2VyIHNob3VsZCBub3QgY3VzdG9taXplIHJhbmdlIGZvciBwb3NpdGlvbiBhbmQgZmFjZXQgY2hhbm5lbCBkaXJlY3RseS5cbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAneCcgfHwgY2hhbm5lbCA9PT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZy5tZXNzYWdlLkNBTk5PVF9VU0VfUkFOR0VfV0lUSF9QT1NJVElPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAncm93JyB8fCBjaGFubmVsID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2cubWVzc2FnZS5jYW5ub3RVc2VSYW5nZVByb3BlcnR5V2l0aEZhY2V0KCdyYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gR09PRCFcbiAgICAgICAgLy8gYmFuZCAvIHBvaW50XG4gICAgICAgIGNhc2UgJ3JhbmdlU3RlcCc6XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCA9PT0gJ3JvdycgfHwgY2hhbm5lbCA9PT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nLm1lc3NhZ2UuY2Fubm90VXNlUmFuZ2VQcm9wZXJ0eVdpdGhGYWNldCgncmFuZ2VTdGVwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBHT09EIVxuICAgICAgICBjYXNlICdwYWRkaW5nJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0lubmVyJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ091dGVyJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsID09PSAncm93JyB8fCBjaGFubmVsID09PSAnY29sdW1uJykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2UgZG8gbm90IHVzZSBkMyBzY2FsZSdzIHBhZGRpbmcgZm9yIHJvdy9jb2x1bW4gYmVjYXVzZSBwYWRkaW5nIHRoZXJlXG4gICAgICAgICAgICAgICAgICogaXMgYSByYXRpbyAoWzAsIDFdKSBhbmQgaXQgY2F1c2VzIHRoZSBwYWRkaW5nIHRvIGJlIGRlY2ltYWxzLlxuICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UgbWFudWFsbHkgY2FsY3VsYXRlIFwic3BhY2luZ1wiIGluIHRoZSBsYXlvdXQgYnkgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2cubWVzc2FnZS5DQU5OT1RfVVNFX1BBRERJTkdfV0lUSF9GQUNFVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIEdPT0QhXG4gICAgICAgIGNhc2UgJ2ludGVycG9sYXRlJzpcbiAgICAgICAgY2FzZSAnc2NoZW1lJzpcbiAgICAgICAgICAgIGlmIChjaGFubmVsICE9PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZy5tZXNzYWdlLmNhbm5vdFVzZVNjYWxlUHJvcGVydHlXaXRoTm9uQ29sb3IoY2hhbm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgY2FzZSAncm91bmQnOlxuICAgICAgICBjYXNlICdjbGFtcCc6XG4gICAgICAgIGNhc2UgJ2V4cG9uZW50JzpcbiAgICAgICAgY2FzZSAnbmljZSc6XG4gICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgLy8gVGhlc2UgY2hhbm5lbCBkbyBub3QgaGF2ZSBzdHJpY3QgcmVxdWlyZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIEdPT0QhXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBpdCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY2FsZSBwcm9wZXJ0eSBcIiR7cHJvcE5hbWV9XCIuJyk7XG59XG5leHBvcnRzLmNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5ID0gY2hhbm5lbFNjYWxlUHJvcGVydHlJbmNvbXBhdGFiaWxpdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMk5oYkdVdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YzJOaGJHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGRlFTd3lRa0ZCTmtJN1FVRkROMElzSzBKQlFYVkRPMEZCUlhaRExFbEJRV2xDTEZOQlFWTXNRMEZ6UW5wQ08wRkJkRUpFTEZkQlFXbENMRk5CUVZNN1NVRkRlRUlzTkVKQlFUUkNPMGxCUTJZc1owSkJRVTBzUjBGQllTeFJRVUZSTEVOQlFVTTdTVUZETlVJc2IwSkJRVlVzUjBGQmFVSXNXVUZCV1N4RFFVRkRPMGxCUTNoRExHRkJRVWNzUjBGQlZTeExRVUZMTEVOQlFVTTdTVUZEYmtJc1lVRkJSeXhIUVVGVkxFdEJRVXNzUTBGQlF6dEpRVU51UWl4alFVRkpMRWRCUVZjc1RVRkJUU3hEUVVGRE8wbEJRMjVETEc5Q1FVRnZRanRKUVVOUUxHTkJRVWtzUjBGQlZ5eE5RVUZOTEVOQlFVTTdTVUZEZEVJc1lVRkJSeXhIUVVGWExFdEJRVXNzUTBGQlF6dEpRVU5xUXl4aFFVRmhPMGxCUTBFc2IwSkJRVlVzUjBGQmFVSXNXVUZCV1N4RFFVRkRPMGxCUlhKRUxHZERRVUZuUXp0SlFVTnVRaXhyUWtGQlVTeEhRVUZsTEZWQlFWVXNRMEZCUXp0SlFVTnNReXhyUWtGQlVTeEhRVUZsTEZWQlFWVXNRMEZCUXp0SlFVTnNReXh0UWtGQlV5eEhRVUZuUWl4WFFVRlhMRU5CUVVNN1NVRkZja01zYVVKQlFVOHNSMEZCWXl4VFFVRlRMRU5CUVVNN1NVRkRMMElzY1VKQlFWY3NSMEZCYTBJc1lVRkJZU3hEUVVGRE8wbEJRek5ETEdWQlFVc3NSMEZCV1N4UFFVRlBMRU5CUVVNN1NVRkRla0lzWTBGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0QlFVTnlReXhEUVVGRExFVkJkRUpuUWl4VFFVRlRMRWRCUVZRc2FVSkJRVk1zUzBGQlZDeHBRa0ZCVXl4UlFYTkNla0k3UVVGVFdTeFJRVUZCTEZkQlFWY3NSMEZCWjBJN1NVRkRkRU1zTkVKQlFUUkNPMGxCUXpWQ0xGRkJRVkVzUlVGQlJTeFpRVUZaTEVWQlFVVXNTMEZCU3l4RlFVRkZMRXRCUVVzc1JVRkJSU3hOUVVGTk8wbEJRelZETEc5Q1FVRnZRanRKUVVOd1FpeE5RVUZOTEVWQlFVVXNTMEZCU3p0SlFVTmlMR0ZCUVdFN1NVRkRZaXhaUVVGWk8wbEJRMW9zVjBGQlZ6dEpRVU5ZTEZOQlFWTXNSVUZCUlN4aFFVRmhMRVZCUVVVc1QwRkJUeXhGUVVGRkxFMUJRVTA3UTBGRE1VTXNRMEZCUXp0QlFVVlhMRkZCUVVFc0swSkJRU3RDTEVkQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGbEJRVmtzUlVGQlJTeExRVUZMTEVWQlFVVXNTMEZCU3l4RlFVRkZMRTFCUVUwc1JVRkJSU3hOUVVGTkxFVkJRVVVzUzBGQlN5eERRVUZETEVOQlFVTTdRVUZETVVnc1NVRkJUU3c0UWtGQk9FSXNSMEZCUnl4WlFVRkxMRU5CUVVNc2RVTkJRU3RDTEVOQlFVTXNRMEZCUXp0QlFVVnFSU3hSUVVGQkxIZENRVUYzUWl4SFFVRm5RaXgxUTBGQkswSXNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhaUVVGWkxFTkJRVU1zYVVSQlFXbEVMRU5CUVVNc1EwRkJReXhEUVVGRE8wRkJRemxLTEVsQlFVMHNkVUpCUVhWQ0xFZEJRVWNzV1VGQlN5eERRVUZETEdkRFFVRjNRaXhEUVVGRExFTkJRVU03UVVGRmJrUXNVVUZCUVN4elFrRkJjMElzUjBGQlowSXNRMEZCUXl4VFFVRlRMRVZCUVVVc1lVRkJZU3hGUVVGRkxFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNRMEZCUXp0QlFVTXZSaXhKUVVGTkxIRkNRVUZ4UWl4SFFVRkhMRmxCUVVzc1EwRkJReXc0UWtGQmMwSXNRMEZCUXl4RFFVRkRPMEZCUlRWRUxFbEJRVTBzWjBKQlFXZENMRWRCUVVjc1dVRkJTeXhEUVVGRExFTkJRVU1zV1VGQldTeEZRVUZGTEdGQlFXRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkZha1FzVVVGQlFTeG5Ra0ZCWjBJc1IwRkJaMElzUTBGQlF5eE5RVUZOTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNN1FVRkZOMFFzTWtKQlFXdERMRWxCUVdVN1NVRkRMME1zVFVGQlRTeERRVUZETEVsQlFVa3NTVUZCU1N4eFFrRkJjVUlzUTBGQlF6dEJRVU4yUXl4RFFVRkRPMEZCUmtRc09FTkJSVU03UVVGRlJDeHZRa0ZCTWtJc1NVRkJaVHRKUVVONFF5eE5RVUZOTEVOQlFVTXNTVUZCU1N4SlFVRkpMR2RDUVVGblFpeERRVUZETzBGQlEyeERMRU5CUVVNN1FVRkdSQ3huUTBGRlF6dEJRVVZFTERaQ1FVRnZReXhKUVVGbE8wbEJSMnBFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRWxCUVVrc2RVSkJRWFZDTEVOQlFVTTdRVUZEZWtNc1EwRkJRenRCUVVwRUxHdEVRVWxETzBGQlJVUXNhME5CUVhsRExFbEJRV1U3U1VGRGRFUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1NVRkJTU3c0UWtGQk9FSXNRMEZCUXp0QlFVTm9SQ3hEUVVGRE8wRkJSa1FzTkVSQlJVTTdRVUZ6VEZrc1VVRkJRU3hyUWtGQmEwSXNSMEZCUnp0SlFVTm9ReXhMUVVGTExFVkJRVVVzU1VGQlNUdEpRVU5ZTEdOQlFXTXNSVUZCUlN4RlFVRkZPMGxCUTJ4Q0xGTkJRVk1zUlVGQlJTeEZRVUZGTzBsQlEySXNXVUZCV1N4RlFVRkZMRWRCUVVjN1NVRkRha0lzWjBKQlFXZENMRVZCUVVVc1IwRkJSenRKUVVOeVFpeFpRVUZaTEVWQlFVVXNSVUZCUlR0SlFVVm9RaXhYUVVGWExFVkJRVVVzUTBGQlF6dEpRVU5rTEZkQlFWY3NSVUZCUlN4RlFVRkZPMGxCUldZc1ZVRkJWU3hGUVVGRkxFZEJRVWM3U1VGRFppeFZRVUZWTEVWQlFVVXNSMEZCUnp0SlFVVm1MREJFUVVFd1JEdEpRVU14UkN4UFFVRlBMRVZCUVVVc1EwRkJRenRKUVVWV0xHTkJRV01zUlVGQlJTeERRVUZETzBsQlEycENMR05CUVdNc1JVRkJSU3hEUVVGRE8wbEJSV3BDTEUxQlFVMHNSVUZCUlN4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFVkJRVVVzVDBGQlR5eEZRVUZGTEZOQlFWTXNSVUZCUlN4aFFVRmhMRVZCUVVVc1pVRkJaU3hEUVVGRE8wTkJRMnBHTEVOQlFVTTdRVUZ2UWtZc01FSkJRV2xETEUxQlFTdENPMGxCUXpsRUxFMUJRVTBzUTBGQlF5eE5RVUZOTEVsQlFVa3NRMEZCUXl4RFFVRkRMRTFCUVUwc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEJRVU53UXl4RFFVRkRPMEZCUmtRc05FTkJSVU03UVVFMFNGa3NVVUZCUVN4blFrRkJaMElzUjBGQmEwSTdTVUZETjBNc1RVRkJUU3hGUVVGRkxGRkJRVkVzUlVGQlJTeFBRVUZQTEVWQlFVVXNUMEZCVHl4RlFVRkZMRmRCUVZjc1JVRkJSU3hSUVVGUkxFVkJRVVVzVTBGQlV5eEZRVUZGTEdOQlFXTXNSVUZCUlN4alFVRmpMRVZCUVVVc1QwRkJUeXhGUVVGRkxFMUJRVTA3U1VGRGNrZ3NWVUZCVlN4RlFVRkZMRTFCUVUwc1JVRkJSU3hoUVVGaE8wTkJRMnhETEVOQlFVTTdRVUZGUml4clEwRkJlVU1zVTBGQmIwSXNSVUZCUlN4UlFVRnhRanRKUVVOc1JpeE5RVUZOTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMnBDTEV0QlFVc3NUVUZCVFN4RFFVRkRPMUZCUTFvc1MwRkJTeXhSUVVGUkxFTkJRVU03VVVGRFpDeExRVUZMTEU5QlFVOHNRMEZCUXp0UlFVTmlMRXRCUVVzc1VVRkJVVHRaUVVOWUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4TFFVRkxMR0ZCUVdFN1dVRkRhRUlzVFVGQlRTeERRVUZETEdWQlFWRXNRMEZCUXl4RFFVRkRMRkZCUVZFc1JVRkJSU3haUVVGWkxFVkJRVVVzUzBGQlN5eEZRVUZGTEV0QlFVc3NSVUZCUlN4TlFVRk5MRVZCUVVVc1MwRkJTeXhGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTEZOQlFWTXNRMEZCUXl4RFFVRkRPMUZCUXpWR0xFdEJRVXNzVDBGQlR6dFpRVU5XTEUxQlFVMHNRMEZCUXl4M1FrRkJkMElzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4VFFVRlRMRXRCUVVzc1RVRkJUU3hKUVVGSkxGTkJRVk1zUzBGQlN5eFBRVUZQTEVOQlFVTTdVVUZET1VZc1MwRkJTeXhYUVVGWExFTkJRVU03VVVGRGFrSXNTMEZCU3l4VFFVRlRMRU5CUVVNN1VVRkRaaXhMUVVGTExHTkJRV003V1VGRGFrSXNUVUZCVFN4RFFVRkRMR1ZCUVZFc1EwRkJReXhEUVVGRExFOUJRVThzUlVGQlJTeE5RVUZOTEVOQlFVTXNSVUZCUlN4VFFVRlRMRU5CUVVNc1EwRkJRenRSUVVOb1JDeExRVUZMTEdOQlFXTTdXVUZEYWtJc1RVRkJUU3hEUVVGRExGTkJRVk1zUzBGQlN5eE5RVUZOTEVOQlFVTTdVVUZET1VJc1MwRkJTeXhQUVVGUE8xbEJRMVlzVFVGQlRTeERRVUZETEhkQ1FVRjNRaXhEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEZOQlFWTXNTMEZCU3l4WlFVRlpMRU5CUVVNN1VVRkRNMFVzUzBGQlN5eE5RVUZOTzFsQlExUXNUVUZCVFN4RFFVRkRMSGRDUVVGM1FpeERRVUZETEZOQlFWTXNRMEZCUXl4SlFVRkpMRk5CUVZNc1MwRkJTeXhaUVVGWkxFbEJRVWtzVTBGQlowSXNTMEZCU3l4VlFVRlZMRU5CUVVNN1VVRkRPVWNzUzBGQlN5eFZRVUZWTzFsQlEySXNUVUZCVFN4RFFVRkRMRk5CUVZNc1MwRkJTeXhMUVVGTExFbEJRVWtzVTBGQlV5eExRVUZMTEV0QlFVc3NRMEZCUXp0UlFVTndSQ3hMUVVGTExFMUJRVTA3V1VGRFZDeDNRMEZCZDBNN1dVRkRlRU1zVFVGQlRTeERRVUZETEZOQlFWTXNTMEZCU3l4aFFVRmhMRWxCUVVrc1EwRkJReXhEUVVGRExHbENRVUZwUWl4RFFVRkRMRk5CUVZNc1EwRkJReXhKUVVGSkxFTkJRVU1zWlVGQlVTeERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRTFCUVUwc1JVRkJSU3hMUVVGTExFVkJRVVVzV1VGQldTeERRVUZETEVWQlFVVXNVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVONFNTeERRVUZETzBsQlEwUXNhMFJCUVd0RU8wbEJRMnhFTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc05FSkJRVEJDTEZGQlFWRXNUVUZCUnl4RFFVRkRMRU5CUVVNN1FVRkRla1FzUTBGQlF6dEJRVGRDUkN3MFJFRTJRa003UVVGRlJEczdSMEZGUnp0QlFVTklMRFpEUVVGdlJDeFBRVUZuUWl4RlFVRkZMRkZCUVhGQ08wbEJRM3BHTEUxQlFVMHNRMEZCUXl4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrSXNTMEZCU3l4UFFVRlBPMWxCUTFZc01rVkJRVEpGTzFsQlF6TkZMRVZCUVVVc1EwRkJReXhEUVVGRExFOUJRVThzUzBGQlN5eEhRVUZITEVsQlFVa3NUMEZCVHl4TFFVRkxMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU03WjBKQlEzWkRMRTFCUVUwc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETERoQ1FVRTRRaXhEUVVGRE8xbEJRM0JFTEVOQlFVTTdXVUZEUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhQUVVGUExFdEJRVXNzUzBGQlN5eEpRVUZKTEU5QlFVOHNTMEZCU3l4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU01UXl4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5d3JRa0ZCSzBJc1EwRkJReXhQUVVGUExFTkJRVU1zUTBGQlF6dFpRVU01UkN4RFFVRkRPMWxCUTBRc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEZGQlFWRTdVVUZETlVJc1pVRkJaVHRSUVVObUxFdEJRVXNzVjBGQlZ6dFpRVU5rTEVWQlFVVXNRMEZCUXl4RFFVRkRMRTlCUVU4c1MwRkJTeXhMUVVGTExFbEJRVWtzVDBGQlR5eExRVUZMTEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1owSkJRemxETEUxQlFVMHNRMEZCUXl4SFFVRkhMRU5CUVVNc1QwRkJUeXhEUVVGRExDdENRVUVyUWl4RFFVRkRMRmRCUVZjc1EwRkJReXhEUVVGRE8xbEJRMnhGTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFTkJRVU1zVVVGQlVUdFJRVU0xUWl4TFFVRkxMRk5CUVZNc1EwRkJRenRSUVVObUxFdEJRVXNzWTBGQll5eERRVUZETzFGQlEzQkNMRXRCUVVzc1kwRkJZenRaUVVOcVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRXRCUVVzc1MwRkJTeXhKUVVGSkxFOUJRVThzUzBGQlN5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMmRDUVVNNVF6czdPenR0UWtGSlJ6dG5Ra0ZEU0N4TlFVRk5MRU5CUVVNc1IwRkJSeXhEUVVGRExFOUJRVThzUTBGQlF5dzJRa0ZCTmtJc1EwRkJRenRaUVVOdVJDeERRVUZETzFsQlEwUXNUVUZCVFN4RFFVRkRMRk5CUVZNc1EwRkJReXhEUVVGRExGRkJRVkU3VVVGRE5VSXNTMEZCU3l4aFFVRmhMRU5CUVVNN1VVRkRia0lzUzBGQlN5eFJRVUZSTzFsQlExZ3NSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhMUVVGTExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoQ0xFMUJRVTBzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCVHl4RFFVRkRMR3REUVVGclF5eERRVUZETEU5QlFVOHNRMEZCUXl4RFFVRkRPMWxCUTJwRkxFTkJRVU03V1VGRFJDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMUZCUTI1Q0xFdEJRVXNzVFVGQlRTeERRVUZETzFGQlExb3NTMEZCU3l4UlFVRlJMRU5CUVVNN1VVRkRaQ3hMUVVGTExFOUJRVThzUTBGQlF6dFJRVU5pTEV0QlFVc3NUMEZCVHl4RFFVRkRPMUZCUTJJc1MwRkJTeXhWUVVGVkxFTkJRVU03VVVGRGFFSXNTMEZCU3l4TlFVRk5MRU5CUVVNN1VVRkRXaXhMUVVGTExFMUJRVTA3V1VGRFZDd3JRMEZCSzBNN1dVRkRMME1zVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXl4RFFVRkRMRkZCUVZFN1NVRkRPVUlzUTBGQlF6dEpRVU5FTEhORVFVRnpSRHRKUVVOMFJDeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVRkRMSFZEUVVGMVF5eERRVUZETEVOQlFVTTdRVUZETTBRc1EwRkJRenRCUVM5RFJDeHJSa0VyUTBNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICBzaW5nbGU6IHsgb246ICdjbGljaycsIGZpZWxkczogWydfaWQnXSB9LFxuICAgIG11bHRpOiB7IG9uOiAnY2xpY2snLCBmaWVsZHM6IFsnX2lkJ10sIHRvZ2dsZTogJ2V2ZW50LnNoaWZ0S2V5JyB9LFxuICAgIGludGVydmFsOiB7XG4gICAgICAgIG9uOiAnW21vdXNlZG93biwgd2luZG93Om1vdXNldXBdID4gd2luZG93Om1vdXNlbW92ZSEnLFxuICAgICAgICBlbmNvZGluZ3M6IFsneCcsICd5J10sXG4gICAgICAgIHRyYW5zbGF0ZTogJ1ttb3VzZWRvd24sIHdpbmRvdzptb3VzZXVwXSA+IHdpbmRvdzptb3VzZW1vdmUhJyxcbiAgICAgICAgem9vbTogJ3doZWVsJ1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljMlZzWldOMGFXOXVMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzTmxiR1ZqZEdsdmJpNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVdkRFlTeFJRVUZCTEdGQlFXRXNSMEZCYlVJN1NVRkRNME1zVFVGQlRTeEZRVUZGTEVWQlFVTXNSVUZCUlN4RlFVRkZMRTlCUVU4c1JVRkJSU3hOUVVGTkxFVkJRVVVzUTBGQlF5eExRVUZMTEVOQlFVTXNSVUZCUXp0SlFVTjBReXhMUVVGTExFVkJRVVVzUlVGQlF5eEZRVUZGTEVWQlFVVXNUMEZCVHl4RlFVRkZMRTFCUVUwc1JVRkJSU3hEUVVGRExFdEJRVXNzUTBGQlF5eEZRVUZGTEUxQlFVMHNSVUZCUlN4blFrRkJaMElzUlVGQlF6dEpRVU12UkN4UlFVRlJMRVZCUVVVN1VVRkRVaXhGUVVGRkxFVkJRVVVzYVVSQlFXbEVPMUZCUTNKRUxGTkJRVk1zUlVGQlJTeERRVUZETEVkQlFVY3NSVUZCUlN4SFFVRkhMRU5CUVVNN1VVRkRja0lzVTBGQlV5eEZRVUZGTEdsRVFVRnBSRHRSUVVNMVJDeEpRVUZKTEVWQlFVVXNUMEZCVHp0TFFVTmtPME5CUTBZc1EwRkJReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc1NvcnRGaWVsZChzb3J0KSB7XG4gICAgcmV0dXJuICEhc29ydCAmJiAhIXNvcnRbJ2ZpZWxkJ10gJiYgISFzb3J0WydvcCddO1xufVxuZXhwb3J0cy5pc1NvcnRGaWVsZCA9IGlzU29ydEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzI5eWRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emIzSjBMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQmFVSkJMSEZDUVVFMFFpeEpRVUV5UWp0SlFVTnlSQ3hOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NTVUZCU1N4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03UVVGRGJrUXNRMEZCUXp0QlFVWkVMR3REUVVWREluMD0iLCIvKiBQYWNrYWdlIG9mIGRlZmluaW5nIFZlZ2EtbGl0ZSBTcGVjaWZpY2F0aW9uJ3MganNvbiBzY2hlbWEgYXQgaXRzIHV0aWxpdHkgZnVuY3Rpb25zICovXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvbXBvc2l0ZU1hcmsgPSByZXF1aXJlKFwiLi9jb21wb3NpdGVtYXJrXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbnZhciBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xudmFyIHZsRW5jb2RpbmcgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgbWFya18xID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbnZhciBzdGFja18xID0gcmVxdWlyZShcIi4vc3RhY2tcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qIEN1c3RvbSB0eXBlIGd1YXJkcyAqL1xuZnVuY3Rpb24gaXNGYWNldFNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWydmYWNldCddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRmFjZXRTcGVjID0gaXNGYWNldFNwZWM7XG5mdW5jdGlvbiBpc1VuaXRTcGVjKHNwZWMpIHtcbiAgICByZXR1cm4gISFzcGVjWydtYXJrJ107XG59XG5leHBvcnRzLmlzVW5pdFNwZWMgPSBpc1VuaXRTcGVjO1xuZnVuY3Rpb24gaXNMYXllclNwZWMoc3BlYykge1xuICAgIHJldHVybiBzcGVjWydsYXllciddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTGF5ZXJTcGVjID0gaXNMYXllclNwZWM7XG4vKipcbiAqIERlY29tcG9zZSBleHRlbmRlZCB1bml0IHNwZWNzIGludG8gY29tcG9zaXRpb24gb2YgcHVyZSB1bml0IHNwZWNzLlxuICovXG4vLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdGhpcyB0byBhbm90aGVyIGZpbGUuICBNYXliZSB2bC5zcGVjLm5vcm1hbGl6ZSBvciB2bC5ub3JtYWxpemVcbmZ1bmN0aW9uIG5vcm1hbGl6ZShzcGVjKSB7XG4gICAgaWYgKGlzRmFjZXRTcGVjKHNwZWMpKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVGYWNldChzcGVjLCBzcGVjLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChpc0xheWVyU3BlYyhzcGVjKSkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplTGF5ZXIoc3BlYywgc3BlYy5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoaXNVbml0U3BlYyhzcGVjKSkge1xuICAgICAgICB2YXIgaGFzUm93ID0gZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoc3BlYy5lbmNvZGluZywgY2hhbm5lbF8xLlJPVyk7XG4gICAgICAgIHZhciBoYXNDb2x1bW4gPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuQ09MVU1OKTtcbiAgICAgICAgaWYgKGhhc1JvdyB8fCBoYXNDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVGYWNldGVkVW5pdChzcGVjLCBzcGVjLmNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZU5vbkZhY2V0VW5pdChzcGVjLCBzcGVjLmNvbmZpZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5JTlZBTElEX1NQRUMpO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5mdW5jdGlvbiBub3JtYWxpemVOb25GYWNldChzcGVjLCBjb25maWcpIHtcbiAgICBpZiAoaXNMYXllclNwZWMoc3BlYykpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUxheWVyKHNwZWMsIGNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVOb25GYWNldFVuaXQoc3BlYywgY29uZmlnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUZhY2V0KHNwZWMsIGNvbmZpZykge1xuICAgIHZhciBzdWJzcGVjID0gc3BlYy5zcGVjLCByZXN0ID0gdHNsaWJfMS5fX3Jlc3Qoc3BlYywgW1wic3BlY1wiXSk7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIHJlc3QsIHsgc3BlYzogbm9ybWFsaXplTm9uRmFjZXQoc3Vic3BlYywgY29uZmlnKSB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxheWVyKHNwZWMsIGNvbmZpZykge1xuICAgIHZhciBsYXllciA9IHNwZWMubGF5ZXIsIHJlc3QgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJsYXllclwiXSk7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIHJlc3QsIHsgbGF5ZXI6IGxheWVyLm1hcChmdW5jdGlvbiAoc3Vic3BlYykgeyByZXR1cm4gbm9ybWFsaXplTm9uRmFjZXQoc3Vic3BlYywgY29uZmlnKTsgfSkgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVGYWNldGVkVW5pdChzcGVjLCBjb25maWcpIHtcbiAgICAvLyBOZXcgZW5jb2RpbmcgaW4gdGhlIGluc2lkZSBzcGVjIHNob3VsZCBub3QgY29udGFpbiByb3cgLyBjb2x1bW5cbiAgICAvLyBhcyByb3cvY29sdW1uIHNob3VsZCBiZSBtb3ZlZCB0byBmYWNldFxuICAgIHZhciBfYSA9IHNwZWMuZW5jb2RpbmcsIHJvdyA9IF9hLnJvdywgY29sdW1uID0gX2EuY29sdW1uLCBlbmNvZGluZyA9IHRzbGliXzEuX19yZXN0KF9hLCBbXCJyb3dcIiwgXCJjb2x1bW5cIl0pO1xuICAgIC8vIE1hcmsgYW5kIGVuY29kaW5nIHNob3VsZCBiZSBtb3ZlZCBpbnRvIHRoZSBpbm5lciBzcGVjXG4gICAgdmFyIG1hcmsgPSBzcGVjLm1hcmssIF8gPSBzcGVjLmVuY29kaW5nLCBvdXRlclNwZWMgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJtYXJrXCIsIFwiZW5jb2RpbmdcIl0pO1xuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBvdXRlclNwZWMsIHsgZmFjZXQ6IHRzbGliXzEuX19hc3NpZ24oe30sIChyb3cgPyB7IHJvdzogcm93IH0gOiB7fSksIChjb2x1bW4gPyB7IGNvbHVtbjogY29sdW1uIH0gOiB7fSkpLCBzcGVjOiBub3JtYWxpemVOb25GYWNldFVuaXQoe1xuICAgICAgICAgICAgbWFyazogbWFyayxcbiAgICAgICAgICAgIGVuY29kaW5nOiBlbmNvZGluZ1xuICAgICAgICB9LCBjb25maWcpIH0pO1xufVxuZnVuY3Rpb24gaXNOb25GYWNldFVuaXRTcGVjV2l0aFByaW1pdGl2ZU1hcmsoc3BlYykge1xuICAgIHJldHVybiBtYXJrXzEuaXNQcmltaXRpdmVNYXJrKHNwZWMubWFyayk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVOb25GYWNldFVuaXQoc3BlYywgY29uZmlnKSB7XG4gICAgaWYgKGlzTm9uRmFjZXRVbml0U3BlY1dpdGhQcmltaXRpdmVNYXJrKHNwZWMpKSB7XG4gICAgICAgIC8vIFRPRE86IHRob3JvdWdobHkgdGVzdFxuICAgICAgICBpZiAoZW5jb2RpbmdfMS5pc1JhbmdlZChzcGVjLmVuY29kaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVJhbmdlZFVuaXQoc3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXJsYXlDb25maWcgPSBjb25maWcgJiYgY29uZmlnLm92ZXJsYXk7XG4gICAgICAgIHZhciBvdmVybGF5V2l0aExpbmUgPSBvdmVybGF5Q29uZmlnICYmIHNwZWMubWFyayA9PT0gbWFya18xLkFSRUEgJiZcbiAgICAgICAgICAgIHV0aWxfMS5jb250YWlucyhbJ2xpbmVwb2ludCcsICdsaW5lJ10sIG92ZXJsYXlDb25maWcuYXJlYSk7XG4gICAgICAgIHZhciBvdmVybGF5V2l0aFBvaW50ID0gb3ZlcmxheUNvbmZpZyAmJiAoKG92ZXJsYXlDb25maWcubGluZSAmJiBzcGVjLm1hcmsgPT09IG1hcmtfMS5MSU5FKSB8fFxuICAgICAgICAgICAgKG92ZXJsYXlDb25maWcuYXJlYSA9PT0gJ2xpbmVwb2ludCcgJiYgc3BlYy5tYXJrID09PSBtYXJrXzEuQVJFQSkpO1xuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBtb3ZpbmcgdGhpcyB0byBiZWNvbWUgYW5vdGhlciBjYXNlIG9mIGNvbXBvc2l0ZU1hcmtcbiAgICAgICAgaWYgKG92ZXJsYXlXaXRoUG9pbnQgfHwgb3ZlcmxheVdpdGhMaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplT3ZlcmxheShzcGVjLCBvdmVybGF5V2l0aFBvaW50LCBvdmVybGF5V2l0aExpbmUsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwZWM7IC8vIE5vdGhpbmcgdG8gbm9ybWFsaXplXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tcG9zaXRlTWFyay5ub3JtYWxpemUoc3BlYyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2VkVW5pdChzcGVjKSB7XG4gICAgdmFyIGhhc1ggPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuWCk7XG4gICAgdmFyIGhhc1kgPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuWSk7XG4gICAgdmFyIGhhc1gyID0gZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoc3BlYy5lbmNvZGluZywgY2hhbm5lbF8xLlgyKTtcbiAgICB2YXIgaGFzWTIgPSBlbmNvZGluZ18xLmNoYW5uZWxIYXNGaWVsZChzcGVjLmVuY29kaW5nLCBjaGFubmVsXzEuWTIpO1xuICAgIGlmICgoaGFzWDIgJiYgIWhhc1gpIHx8IChoYXNZMiAmJiAhaGFzWSkpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRTcGVjID0gdXRpbF8xLmR1cGxpY2F0ZShzcGVjKTtcbiAgICAgICAgaWYgKGhhc1gyICYmICFoYXNYKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkU3BlYy5lbmNvZGluZy54ID0gbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueDI7XG4gICAgICAgICAgICBkZWxldGUgbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1kyICYmICFoYXNZKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkU3BlYy5lbmNvZGluZy55ID0gbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueTI7XG4gICAgICAgICAgICBkZWxldGUgbm9ybWFsaXplZFNwZWMuZW5jb2RpbmcueTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRTcGVjO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYztcbn1cbi8vIEZJWE1FKCMxODA0KTogcmUtZGVzaWduIHRoaXNcbmZ1bmN0aW9uIG5vcm1hbGl6ZU92ZXJsYXkoc3BlYywgb3ZlcmxheVdpdGhQb2ludCwgb3ZlcmxheVdpdGhMaW5lLCBjb25maWcpIHtcbiAgICB2YXIgbWFyayA9IHNwZWMubWFyaywgZW5jb2RpbmcgPSBzcGVjLmVuY29kaW5nLCBvdXRlclNwZWMgPSB0c2xpYl8xLl9fcmVzdChzcGVjLCBbXCJtYXJrXCIsIFwiZW5jb2RpbmdcIl0pO1xuICAgIHZhciBsYXllciA9IFt7IG1hcms6IG1hcmssIGVuY29kaW5nOiBlbmNvZGluZyB9XTtcbiAgICAvLyBOZWVkIHRvIGNvcHkgc3RhY2sgY29uZmlnIHRvIG92ZXJsYXllZCBsYXllclxuICAgIHZhciBzdGFja1Byb3BzID0gc3RhY2tfMS5zdGFjayhtYXJrLCBlbmNvZGluZywgY29uZmlnID8gY29uZmlnLnN0YWNrIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgb3ZlcmxheUVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgaWYgKHN0YWNrUHJvcHMpIHtcbiAgICAgICAgdmFyIHN0YWNrRmllbGRDaGFubmVsID0gc3RhY2tQcm9wcy5maWVsZENoYW5uZWwsIG9mZnNldCA9IHN0YWNrUHJvcHMub2Zmc2V0O1xuICAgICAgICBvdmVybGF5RW5jb2RpbmcgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBlbmNvZGluZywgKF9hID0ge30sIF9hW3N0YWNrRmllbGRDaGFubmVsXSA9IHRzbGliXzEuX19hc3NpZ24oe30sIGVuY29kaW5nW3N0YWNrRmllbGRDaGFubmVsXSwgKG9mZnNldCA/IHsgc3RhY2s6IG9mZnNldCB9IDoge30pKSwgX2EpKTtcbiAgICB9XG4gICAgaWYgKG92ZXJsYXlXaXRoTGluZSkge1xuICAgICAgICBsYXllci5wdXNoKHtcbiAgICAgICAgICAgIG1hcms6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2xpbmVPdmVybGF5J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY29kaW5nOiBvdmVybGF5RW5jb2RpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvdmVybGF5V2l0aFBvaW50KSB7XG4gICAgICAgIGxheWVyLnB1c2goe1xuICAgICAgICAgICAgbWFyazoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdwb2ludCcsXG4gICAgICAgICAgICAgICAgZmlsbGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJvbGU6ICdwb2ludE92ZXJsYXknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5jb2Rpbmc6IG92ZXJsYXlFbmNvZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oe30sIG91dGVyU3BlYywgeyBsYXllcjogbGF5ZXIgfSk7XG4gICAgdmFyIF9hO1xufVxuLy8gVE9ETzogYWRkIHZsLnNwZWMudmFsaWRhdGUgJiBtb3ZlIHN0dWZmIGZyb20gdmwudmFsaWRhdGUgdG8gaGVyZVxuLyogQWNjdW11bGF0ZSBub24tZHVwbGljYXRlIGZpZWxkRGVmcyBpbiBhIGRpY3Rpb25hcnkgKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoZGljdCwgZmllbGREZWZzKSB7XG4gICAgZmllbGREZWZzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkRGVmKSB7XG4gICAgICAgIC8vIENvbnNpZGVyIG9ubHkgcHVyZSBmaWVsZERlZiBwcm9wZXJ0aWVzIChpZ25vcmluZyBzY2FsZSwgYXhpcywgbGVnZW5kKVxuICAgICAgICB2YXIgcHVyZUZpZWxkRGVmID0gWydmaWVsZCcsICd0eXBlJywgJ3ZhbHVlJywgJ3RpbWVVbml0JywgJ2JpbicsICdhZ2dyZWdhdGUnXS5yZWR1Y2UoZnVuY3Rpb24gKGYsIGtleSkge1xuICAgICAgICAgICAgaWYgKGZpZWxkRGVmW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZba2V5XSA9IGZpZWxkRGVmW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIga2V5ID0gdXRpbF8xLmhhc2gocHVyZUZpZWxkRGVmKTtcbiAgICAgICAgZGljdFtrZXldID0gZGljdFtrZXldIHx8IGZpZWxkRGVmO1xuICAgIH0pO1xuICAgIHJldHVybiBkaWN0O1xufVxuLyogUmVjdXJzaXZlbHkgZ2V0IGZpZWxkRGVmcyBmcm9tIGEgc3BlYywgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgZmllbGREZWZzICovXG5mdW5jdGlvbiBmaWVsZERlZkluZGV4KHNwZWMsIGRpY3QpIHtcbiAgICBpZiAoZGljdCA9PT0gdm9pZCAwKSB7IGRpY3QgPSB7fTsgfVxuICAgIC8vIFRPRE86IFN1cHBvcnQgcmVwZWF0IGFuZCBjb25jYXRcbiAgICBpZiAoaXNMYXllclNwZWMoc3BlYykpIHtcbiAgICAgICAgc3BlYy5sYXllci5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgaWYgKGlzVW5pdFNwZWMobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZShkaWN0LCB2bEVuY29kaW5nLmZpZWxkRGVmcyhsYXllci5lbmNvZGluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGREZWZJbmRleChsYXllciwgZGljdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0ZhY2V0U3BlYyhzcGVjKSkge1xuICAgICAgICBhY2N1bXVsYXRlKGRpY3QsIHZsRW5jb2RpbmcuZmllbGREZWZzKHNwZWMuZmFjZXQpKTtcbiAgICAgICAgZmllbGREZWZJbmRleChzcGVjLnNwZWMsIGRpY3QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjdW11bGF0ZShkaWN0LCB2bEVuY29kaW5nLmZpZWxkRGVmcyhzcGVjLmVuY29kaW5nKSk7XG4gICAgfVxuICAgIHJldHVybiBkaWN0O1xufVxuLyogUmV0dXJucyBhbGwgbm9uLWR1cGxpY2F0ZSBmaWVsZERlZnMgaW4gYSBzcGVjIGluIGEgZmxhdCBhcnJheSAqL1xuZnVuY3Rpb24gZmllbGREZWZzKHNwZWMpIHtcbiAgICByZXR1cm4gdXRpbF8xLnZhbHMoZmllbGREZWZJbmRleChzcGVjKSk7XG59XG5leHBvcnRzLmZpZWxkRGVmcyA9IGZpZWxkRGVmcztcbmZ1bmN0aW9uIGlzU3RhY2tlZChzcGVjLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwgc3BlYy5jb25maWc7XG4gICAgaWYgKG1hcmtfMS5pc1ByaW1pdGl2ZU1hcmsoc3BlYy5tYXJrKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tfMS5zdGFjayhzcGVjLm1hcmssIHNwZWMuZW5jb2RpbmcsIGNvbmZpZyA/IGNvbmZpZy5zdGFjayA6IHVuZGVmaW5lZCkgIT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNTdGFja2VkID0gaXNTdGFja2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYzNCbFl5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5emNHVmpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxIZEdRVUYzUmpzN096dEJRVVY0Uml3clEwRkJhVVE3UVVGSGFrUXNkVU5CUVd0R08wRkJTV3hHTEhGRFFVRnZSRHRCUVVOd1JDeDFRMEZCZVVNN1FVRkRla01zTWtKQlFUWkNPMEZCUXpkQ0xDdENRVUZyUlR0QlFVVnNSU3hwUTBGQk9FSTdRVUZIT1VJc0swSkJRWFZFTzBGQmVVZDJSQ3gzUWtGQmQwSTdRVUZIZUVJc2NVSkJRVFJDTEVsQlFUUkRPMGxCUTNSRkxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTXNUMEZCVHl4RFFVRkRMRXRCUVVzc1UwRkJVeXhEUVVGRE8wRkJRM0pETEVOQlFVTTdRVUZHUkN4clEwRkZRenRCUVVWRUxHOUNRVUV5UWl4SlFVRjVRanRKUVVOc1JDeE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF6dEJRVU40UWl4RFFVRkRPMEZCUmtRc1owTkJSVU03UVVGRlJDeHhRa0ZCTkVJc1NVRkJlVUk3U1VGRGJrUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eFRRVUZUTEVOQlFVTTdRVUZEY2tNc1EwRkJRenRCUVVaRUxHdERRVVZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3gxUmtGQmRVWTdRVUZEZGtZc2JVSkJRVEJDTEVsQlFUUkNPMGxCUTNCRUxFVkJRVVVzUTBGQlF5eERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRFSXNUVUZCVFN4RFFVRkRMR05CUVdNc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEUxQlFVMHNRMEZCUXl4RFFVRkRPMGxCUXpORExFTkJRVU03U1VGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4WFFVRlhMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzUkNMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVNelF5eERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlRaXhKUVVGTkxFMUJRVTBzUjBGQlJ5d3dRa0ZCWlN4RFFVRkRMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzWVVGQlJ5eERRVUZETEVOQlFVTTdVVUZEYmtRc1NVRkJUU3hUUVVGVExFZEJRVWNzTUVKQlFXVXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hGUVVGRkxHZENRVUZOTEVOQlFVTXNRMEZCUXp0UlFVVjZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eE5RVUZOTEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVONFFpeE5RVUZOTEVOQlFVTXNiMEpCUVc5Q0xFTkJRVU1zU1VGQlNTeEZRVUZGTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVOcVJDeERRVUZETzFGQlEwUXNUVUZCVFN4RFFVRkRMSEZDUVVGeFFpeERRVUZETEVsQlFVa3NSVUZCUlN4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU03U1VGRGJFUXNRMEZCUXp0SlFVTkVMRTFCUVUwc1NVRkJTU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJRenRCUVVNMVF5eERRVUZETzBGQmFrSkVMRGhDUVdsQ1F6dEJRVVZFTERKQ1FVRXlRaXhKUVVGNVJDeEZRVUZGTEUxQlFXTTdTVUZEYkVjc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeE5RVUZOTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEpRVU4wUXl4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExIRkNRVUZ4UWl4RFFVRkRMRWxCUVVrc1JVRkJSU3hOUVVGTkxFTkJRVU1zUTBGQlF6dEJRVU0zUXl4RFFVRkRPMEZCUlVRc2QwSkJRWGRDTEVsQlFYVkRMRVZCUVVVc1RVRkJZenRKUVVOMFJTeEpRVUZCTEcxQ1FVRmhMRVZCUVVVc2NVTkJRVThzUTBGQlV6dEpRVU4wUXl4TlFVRk5MSE5DUVVORUxFbEJRVWtzU1VGRFVDeEpRVUZKTEVWQlFVVXNhVUpCUVdsQ0xFTkJRVU1zVDBGQlR5eEZRVUZGTEUxQlFVMHNRMEZCUXl4SlFVTjRRenRCUVVOS0xFTkJRVU03UVVGRlJDeDNRa0ZCZDBJc1NVRkJkVU1zUlVGQlJTeE5RVUZqTzBsQlEzUkZMRWxCUVVFc2EwSkJRVmtzUlVGQlJTeHpRMEZCVHl4RFFVRlRPMGxCUTNKRExFMUJRVTBzYzBKQlEwUXNTVUZCU1N4SlFVTlFMRXRCUVVzc1JVRkJSU3hMUVVGTExFTkJRVU1zUjBGQlJ5eERRVUZETEZWQlFVTXNUMEZCVHl4SlFVRkxMRTlCUVVFc2FVSkJRV2xDTEVOQlFVTXNUMEZCVHl4RlFVRkZMRTFCUVUwc1EwRkJReXhGUVVGc1F5eERRVUZyUXl4RFFVRkRMRWxCUTJwRk8wRkJRMG9zUTBGQlF6dEJRVVZFTERoQ1FVRTRRaXhKUVVGeFFpeEZRVUZGTEUxQlFXTTdTVUZEYWtVc2EwVkJRV3RGTzBsQlEyeEZMSGxEUVVGNVF6dEpRVU42UXl4SlFVRk5MR3RDUVVGMVJDeEZRVUYwUkN4WlFVRlJMRVZCUVVVc2EwSkJRV01zUlVGQlJTeG5SRUZCTkVJc1EwRkJRenRKUVVVNVJDeDNSRUZCZDBRN1NVRkRha1FzU1VGQlFTeG5Ra0ZCVlN4RlFVRkZMR2xDUVVGWExFVkJRVVVzYzBSQlFWa3NRMEZCVXp0SlFVVnlSQ3hOUVVGTkxITkNRVU5FTEZOQlFWTXNTVUZEV2l4TFFVRkxMSFZDUVVOQkxFTkJRVU1zUjBGQlJ5eEhRVUZITEVWQlFVTXNSMEZCUnl4TFFVRkJMRVZCUVVNc1IwRkJSeXhGUVVGRkxFTkJRVU1zUlVGRGJFSXNRMEZCUXl4TlFVRk5MRWRCUVVjc1JVRkJReXhOUVVGTkxGRkJRVUVzUlVGQlF5eEhRVUZGTEVWQlFVVXNRMEZCUXl4SFFVVTFRaXhKUVVGSkxFVkJRVVVzY1VKQlFYRkNMRU5CUVVNN1dVRkRNVUlzU1VGQlNTeE5RVUZCTzFsQlEwb3NVVUZCVVN4VlFVRkJPMU5CUTFRc1JVRkJSU3hOUVVGTkxFTkJRVU1zU1VGRFZqdEJRVU5LTEVOQlFVTTdRVUZGUkN3MlEwRkJOa01zU1VGQmFVUTdTVUZGTVVZc1RVRkJUU3hEUVVGRExITkNRVUZsTEVOQlFVTXNTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wRkJRM1JETEVOQlFVTTdRVUZGUkN3clFrRkJLMElzU1VGQmFVUXNSVUZCUlN4TlFVRmpPMGxCUXpsR0xFVkJRVVVzUTBGQlF5eERRVUZETEcxRFFVRnRReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTTVReXgzUWtGQmQwSTdVVUZEZUVJc1JVRkJSU3hEUVVGRExFTkJRVU1zYlVKQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkNMRTFCUVUwc1EwRkJReXh0UWtGQmJVSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRSUVVOdVF5eERRVUZETzFGQlJVUXNTVUZCVFN4aFFVRmhMRWRCUVVjc1RVRkJUU3hKUVVGSkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVOQlFVTTdVVUZETDBNc1NVRkJUU3hsUVVGbExFZEJRVWNzWVVGQllTeEpRVUZMTEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1YwRkJTVHRaUVVNeFJDeGxRVUZSTEVOQlFVTXNRMEZCUXl4WFFVRlhMRVZCUVVVc1RVRkJUU3hEUVVGRExFVkJRVVVzWVVGQllTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMUZCUTNSRUxFbEJRVTBzWjBKQlFXZENMRWRCUVVjc1lVRkJZU3hKUVVGSkxFTkJRM2hETEVOQlFVTXNZVUZCWVN4RFFVRkRMRWxCUVVrc1NVRkJTU3hKUVVGSkxFTkJRVU1zU1VGQlNTeExRVUZMTEZkQlFVa3NRMEZCUXp0WlFVTXhReXhEUVVGRExHRkJRV0VzUTBGQlF5eEpRVUZKTEV0QlFVc3NWMEZCVnl4SlFVRkpMRWxCUVVrc1EwRkJReXhKUVVGSkxFdEJRVXNzVjBGQlNTeERRVUZETEVOQlF6TkVMRU5CUVVNN1VVRkRSaXh4UlVGQmNVVTdVVUZEY2tVc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRWxCUVVrc1pVRkJaU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU40UXl4TlFVRk5MRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNTVUZCU1N4RlFVRkZMR2RDUVVGblFpeEZRVUZGTEdWQlFXVXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRSUVVNelJTeERRVUZETzFGQlJVUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExIVkNRVUYxUWp0SlFVTjBReXhEUVVGRE8wbEJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEVGl4TlFVRk5MRU5CUVVNc1lVRkJZU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTjJReXhEUVVGRE8wRkJRMGdzUTBGQlF6dEJRVVZFTERaQ1FVRTJRaXhKUVVGak8wbEJRM3BETEVsQlFVMHNTVUZCU1N4SFFVRkhMREJDUVVGbExFTkJRVU1zU1VGQlNTeERRVUZETEZGQlFWRXNSVUZCUlN4WFFVRkRMRU5CUVVNc1EwRkJRenRKUVVNdlF5eEpRVUZOTEVsQlFVa3NSMEZCUnl3d1FrRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlFVVXNWMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRMME1zU1VGQlRTeExRVUZMTEVkQlFVY3NNRUpCUVdVc1EwRkJReXhKUVVGSkxFTkJRVU1zVVVGQlVTeEZRVUZGTEZsQlFVVXNRMEZCUXl4RFFVRkRPMGxCUTJwRUxFbEJRVTBzUzBGQlN5eEhRVUZITERCQ1FVRmxMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeFpRVUZGTEVOQlFVTXNRMEZCUXp0SlFVTnFSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NTVUZCU1N4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM3BETEVsQlFVMHNZMEZCWXl4SFFVRkhMR2RDUVVGVExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdVVUZEZGtNc1JVRkJSU3hEUVVGRExFTkJRVU1zUzBGQlN5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOdVFpeGpRVUZqTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1IwRkJSeXhqUVVGakxFTkJRVU1zVVVGQlVTeERRVUZETEVWQlFVVXNRMEZCUXp0WlFVTjJSQ3hQUVVGUExHTkJRV01zUTBGQlF5eFJRVUZSTEVOQlFVTXNSVUZCUlN4RFFVRkRPMUZCUTNCRExFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4TFFVRkxMRWxCUVVrc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEyNUNMR05CUVdNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eEhRVUZITEdOQlFXTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1JVRkJSU3hEUVVGRE8xbEJRM1pFTEU5QlFVOHNZMEZCWXl4RFFVRkRMRkZCUVZFc1EwRkJReXhGUVVGRkxFTkJRVU03VVVGRGNFTXNRMEZCUXp0UlFVVkVMRTFCUVUwc1EwRkJReXhqUVVGakxFTkJRVU03U1VGRGVFSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlIwUXNLMEpCUVN0Q08wRkJReTlDTERCQ1FVRXdRaXhKUVVGakxFVkJRVVVzWjBKQlFYbENMRVZCUVVVc1pVRkJkMElzUlVGQlJTeE5RVUZqTzBsQlEzQkhMRWxCUVVFc1owSkJRVWtzUlVGQlJTeDNRa0ZCVVN4RlFVRkZMSE5FUVVGWkxFTkJRVk03U1VGRE5VTXNTVUZCVFN4TFFVRkxMRWRCUVVjc1EwRkJReXhGUVVGRExFbEJRVWtzVFVGQlFTeEZRVUZGTEZGQlFWRXNWVUZCUVN4RlFVRkRMRU5CUVVNc1EwRkJRenRKUVVWcVF5d3JRMEZCSzBNN1NVRkRMME1zU1VGQlRTeFZRVUZWTEVkQlFVY3NZVUZCU3l4RFFVRkRMRWxCUVVrc1JVRkJSU3hSUVVGUkxFVkJRVVVzVFVGQlRTeEhRVUZITEUxQlFVMHNRMEZCUXl4TFFVRkxMRWRCUVVjc1UwRkJVeXhEUVVGRExFTkJRVU03U1VGRk5VVXNTVUZCU1N4bFFVRmxMRWRCUVVjc1VVRkJVU3hEUVVGRE8wbEJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRlZCUVZVc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRFVpeEpRVUZCTERKRFFVRXJRaXhGUVVGRkxEQkNRVUZOTEVOQlFXVTdVVUZETjBRc1pVRkJaU3gzUWtGRFZpeFJRVUZSTEdWQlExWXNhVUpCUVdsQ0xIbENRVU5pTEZGQlFWRXNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eEZRVU16UWl4RFFVRkRMRTFCUVUwc1IwRkJSeXhGUVVGRExFdEJRVXNzUlVGQlJTeE5RVUZOTEVWQlFVTXNSMEZCUnl4RlFVRkZMRU5CUVVNc1QwRkZja01zUTBGQlF6dEpRVU5LTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhsUVVGbExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEzQkNMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU03V1VGRFZDeEpRVUZKTEVWQlFVVTdaMEpCUTBvc1NVRkJTU3hGUVVGRkxFMUJRVTA3WjBKQlExb3NTVUZCU1N4RlFVRkZMR0ZCUVdFN1lVRkRjRUk3V1VGRFJDeFJRVUZSTEVWQlFVVXNaVUZCWlR0VFFVTXhRaXhEUVVGRExFTkJRVU03U1VGRFRDeERRVUZETzBsQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTNKQ0xFdEJRVXNzUTBGQlF5eEpRVUZKTEVOQlFVTTdXVUZEVkN4SlFVRkpMRVZCUVVVN1owSkJRMG9zU1VGQlNTeEZRVUZGTEU5QlFVODdaMEpCUTJJc1RVRkJUU3hGUVVGRkxFbEJRVWs3WjBKQlExb3NTVUZCU1N4RlFVRkZMR05CUVdNN1lVRkRja0k3V1VGRFJDeFJRVUZSTEVWQlFVVXNaVUZCWlR0VFFVTXhRaXhEUVVGRExFTkJRVU03U1VGRFRDeERRVUZETzBsQlJVUXNUVUZCVFN4elFrRkRSQ3hUUVVGVExFbEJRMW9zUzBGQlN5eFBRVUZCTEVsQlEwdzdPMEZCUTBvc1EwRkJRenRCUVVWRUxHMUZRVUZ0UlR0QlFVVnVSU3gzUkVGQmQwUTdRVUZEZUVRc2IwSkJRVzlDTEVsQlFWTXNSVUZCUlN4VFFVRnhRanRKUVVOc1JDeFRRVUZUTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVZNc1VVRkJVVHRSUVVOcVF5eDNSVUZCZDBVN1VVRkRlRVVzU1VGQlRTeFpRVUZaTEVkQlFVY3NRMEZCUXl4UFFVRlBMRVZCUVVVc1RVRkJUU3hGUVVGRkxFOUJRVThzUlVGQlJTeFZRVUZWTEVWQlFVVXNTMEZCU3l4RlFVRkZMRmRCUVZjc1EwRkJReXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEVOQlFVTXNSVUZCUlN4SFFVRkhPMWxCUXpWR0xFVkJRVVVzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4SFFVRkhMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzJkQ1FVTm9ReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVkQlFVY3NVVUZCVVN4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xbEJRM3BDTEVOQlFVTTdXVUZEUkN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMWdzUTBGQlF5eEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRPMUZCUTFBc1NVRkJUU3hIUVVGSExFZEJRVWNzVjBGQlNTeERRVUZETEZsQlFWa3NRMEZCUXl4RFFVRkRPMUZCUXk5Q0xFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFbEJRVWtzVVVGQlVTeERRVUZETzBsQlEzQkRMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRMGdzVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0QlFVTmtMRU5CUVVNN1FVRkZSQ3c0UlVGQk9FVTdRVUZET1VVc2RVSkJRWFZDTEVsQlFYTkRMRVZCUVVVc1NVRkJZenRKUVVGa0xIRkNRVUZCTEVWQlFVRXNVMEZCWXp0SlFVTXpSU3hyUTBGQmEwTTdTVUZEYkVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVjBGQlZ5eERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOMFFpeEpRVUZKTEVOQlFVTXNTMEZCU3l4RFFVRkRMRTlCUVU4c1EwRkJReXhWUVVGVExFdEJRVXM3V1VGREwwSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1ZVRkJWU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0blFrRkRkRUlzVlVGQlZTeERRVUZETEVsQlFVa3NSVUZCUlN4VlFVRlZMRU5CUVVNc1UwRkJVeXhEUVVGRExFdEJRVXNzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUTNwRUxFTkJRVU03V1VGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXp0blFrRkRUaXhoUVVGaExFTkJRVU1zUzBGQlN5eEZRVUZGTEVsQlFVa3NRMEZCUXl4RFFVRkRPMWxCUXpkQ0xFTkJRVU03VVVGRFNDeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTk1MRU5CUVVNN1NVRkJReXhKUVVGSkxFTkJRVU1zUlVGQlJTeERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU0zUWl4VlFVRlZMRU5CUVVNc1NVRkJTU3hGUVVGRkxGVkJRVlVzUTBGQlF5eFRRVUZUTEVOQlFVTXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGJrUXNZVUZCWVN4RFFVRkRMRWxCUVVrc1EwRkJReXhKUVVGSkxFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEYWtNc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFGQlEwNHNWVUZCVlN4RFFVRkRMRWxCUVVrc1JVRkJSU3hWUVVGVkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8wbEJRM2hFTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wRkJRMlFzUTBGQlF6dEJRVVZFTEcxRlFVRnRSVHRCUVVOdVJTeHRRa0ZCTUVJc1NVRkJjME03U1VGRE9VUXNUVUZCVFN4RFFVRkRMRmRCUVVrc1EwRkJReXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXp0QlFVTnVReXhEUVVGRE8wRkJSa1FzT0VKQlJVTTdRVUZGUkN4dFFrRkJNRUlzU1VGQkswSXNSVUZCUlN4TlFVRmxPMGxCUTNoRkxFMUJRVTBzUjBGQlJ5eE5RVUZOTEVsQlFVa3NTVUZCU1N4RFFVRkRMRTFCUVUwc1EwRkJRenRKUVVNdlFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4elFrRkJaU3hEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRMMElzVFVGQlRTeERRVUZETEdGQlFVc3NRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hGUVVGRkxFbEJRVWtzUTBGQlF5eFJRVUZSTEVWQlF6ZENMRTFCUVUwc1IwRkJSeXhOUVVGTkxFTkJRVU1zUzBGQlN5eEhRVUZITEZOQlFWTXNRMEZEYkVNc1MwRkJTeXhKUVVGSkxFTkJRVU03U1VGRGJrSXNRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQlVrUXNPRUpCVVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBsb2cgPSByZXF1aXJlKFwiLi9sb2dcIik7XG52YXIgYWdncmVnYXRlXzEgPSByZXF1aXJlKFwiLi9hZ2dyZWdhdGVcIik7XG52YXIgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG52YXIgZmllbGRkZWZfMSA9IHJlcXVpcmUoXCIuL2ZpZWxkZGVmXCIpO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuL21hcmtcIik7XG52YXIgc2NhbGVfMSA9IHJlcXVpcmUoXCIuL3NjYWxlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5leHBvcnRzLlNUQUNLQUJMRV9NQVJLUyA9IFttYXJrXzEuQkFSLCBtYXJrXzEuQVJFQSwgbWFya18xLlJVTEUsIG1hcmtfMS5QT0lOVCwgbWFya18xLkNJUkNMRSwgbWFya18xLlNRVUFSRSwgbWFya18xLkxJTkUsIG1hcmtfMS5URVhULCBtYXJrXzEuVElDS107XG5leHBvcnRzLlNUQUNLX0JZX0RFRkFVTFRfTUFSS1MgPSBbbWFya18xLkJBUiwgbWFya18xLkFSRUFdO1xuLy8gTm90ZTogQ29tcGFzc1FMIHVzZXMgdGhpcyBtZXRob2QgYW5kIG9ubHkgcGFzcyBpbiByZXF1aXJlZCBwcm9wZXJ0aWVzIG9mIGVhY2ggYXJndW1lbnQgb2JqZWN0LlxuLy8gSWYgcmVxdWlyZWQgcHJvcGVydGllcyBjaGFuZ2UsIG1ha2Ugc3VyZSB0byB1cGRhdGUgQ29tcGFzc1FMLlxuZnVuY3Rpb24gc3RhY2sobSwgZW5jb2RpbmcsIHN0YWNrQ29uZmlnKSB7XG4gICAgdmFyIG1hcmsgPSBtYXJrXzEuaXNNYXJrRGVmKG0pID8gbS50eXBlIDogbTtcbiAgICAvLyBTaG91bGQgaGF2ZSBzdGFja2FibGUgbWFya1xuICAgIGlmICghdXRpbF8xLmNvbnRhaW5zKGV4cG9ydHMuU1RBQ0tBQkxFX01BUktTLCBtYXJrKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2hvdWxkIGJlIGFnZ3JlZ2F0ZSBwbG90XG4gICAgaWYgKCFlbmNvZGluZ18xLmlzQWdncmVnYXRlKGVuY29kaW5nKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2hvdWxkIGhhdmUgZ3JvdXBpbmcgbGV2ZWwgb2YgZGV0YWlsXG4gICAgdmFyIHN0YWNrQnkgPSBjaGFubmVsXzEuU1RBQ0tfR1JPVVBfQ0hBTk5FTFMucmVkdWNlKGZ1bmN0aW9uIChzYywgY2hhbm5lbCkge1xuICAgICAgICBpZiAoZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGNoYW5uZWwpKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbERlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgICAgICAgICAgKHV0aWxfMS5pc0FycmF5KGNoYW5uZWxEZWYpID8gY2hhbm5lbERlZiA6IFtjaGFubmVsRGVmXSkuZm9yRWFjaChmdW5jdGlvbiAoZmllbGREZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGZpZWxkRGVmKSAmJiAhZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkRGVmOiBmaWVsZERlZlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2M7XG4gICAgfSwgW10pO1xuICAgIGlmIChzdGFja0J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gSGFzIG9ubHkgb25lIGFnZ3JlZ2F0ZSBheGlzXG4gICAgdmFyIGhhc1hGaWVsZCA9IGZpZWxkZGVmXzEuaXNGaWVsZERlZihlbmNvZGluZy54KTtcbiAgICB2YXIgaGFzWUZpZWxkID0gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLnkpO1xuICAgIHZhciB4SXNBZ2dyZWdhdGUgPSBmaWVsZGRlZl8xLmlzRmllbGREZWYoZW5jb2RpbmcueCkgJiYgISFlbmNvZGluZy54LmFnZ3JlZ2F0ZTtcbiAgICB2YXIgeUlzQWdncmVnYXRlID0gZmllbGRkZWZfMS5pc0ZpZWxkRGVmKGVuY29kaW5nLnkpICYmICEhZW5jb2RpbmcueS5hZ2dyZWdhdGU7XG4gICAgaWYgKHhJc0FnZ3JlZ2F0ZSAhPT0geUlzQWdncmVnYXRlKSB7XG4gICAgICAgIHZhciBmaWVsZENoYW5uZWwgPSB4SXNBZ2dyZWdhdGUgPyBjaGFubmVsXzEuWCA6IGNoYW5uZWxfMS5ZO1xuICAgICAgICB2YXIgZmllbGREZWYgPSBlbmNvZGluZ1tmaWVsZENoYW5uZWxdO1xuICAgICAgICB2YXIgZmllbGRDaGFubmVsQWdncmVnYXRlID0gZmllbGREZWYuYWdncmVnYXRlO1xuICAgICAgICB2YXIgZmllbGRDaGFubmVsU2NhbGUgPSBmaWVsZERlZi5zY2FsZTtcbiAgICAgICAgdmFyIHN0YWNrT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgaWYgKGZpZWxkRGVmLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWNrT2Zmc2V0ID0gZmllbGREZWYuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbF8xLmNvbnRhaW5zKGV4cG9ydHMuU1RBQ0tfQllfREVGQVVMVF9NQVJLUywgbWFyaykpIHtcbiAgICAgICAgICAgIC8vIEJhciBhbmQgQXJlYSB3aXRoIHN1bSBvcHMgYXJlIGF1dG9tYXRpY2FsbHkgc3RhY2tlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICBzdGFja09mZnNldCA9IHN0YWNrQ29uZmlnID09PSB1bmRlZmluZWQgPyAnemVybycgOiBzdGFja0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrT2Zmc2V0ID0gc3RhY2tDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGFja09mZnNldCB8fCBzdGFja09mZnNldCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBzdGFja2VkLCBjaGVjayBpZiBpdCBxdWFsaWZpZXMgZm9yIHN0YWNraW5nIChhbmQgbG9nIHdhcm5pbmcgaWYgbm90IHF1YWxpZmllZC4pXG4gICAgICAgIGlmIChmaWVsZENoYW5uZWxTY2FsZSAmJiBmaWVsZENoYW5uZWxTY2FsZS50eXBlICYmIGZpZWxkQ2hhbm5lbFNjYWxlLnR5cGUgIT09IHNjYWxlXzEuU2NhbGVUeXBlLkxJTkVBUikge1xuICAgICAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuY2Fubm90U3RhY2tOb25MaW5lYXJTY2FsZShmaWVsZENoYW5uZWxTY2FsZS50eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jb2RpbmdfMS5jaGFubmVsSGFzRmllbGQoZW5jb2RpbmcsIGZpZWxkQ2hhbm5lbCA9PT0gY2hhbm5lbF8xLlggPyBjaGFubmVsXzEuWDIgOiBjaGFubmVsXzEuWTIpKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5jYW5ub3RTdGFja1JhbmdlZE1hcmsoZmllbGRDaGFubmVsKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWxfMS5jb250YWlucyhhZ2dyZWdhdGVfMS5TVU1fT1BTLCBmaWVsZENoYW5uZWxBZ2dyZWdhdGUpKSB7XG4gICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5jYW5ub3RTdGFja05vblN1bW1hdGl2ZUFnZ3JlZ2F0ZShmaWVsZENoYW5uZWxBZ2dyZWdhdGUpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncm91cGJ5Q2hhbm5lbDogeElzQWdncmVnYXRlID8gKGhhc1lGaWVsZCA/IGNoYW5uZWxfMS5ZIDogbnVsbCkgOiAoaGFzWEZpZWxkID8gY2hhbm5lbF8xLlggOiBudWxsKSxcbiAgICAgICAgICAgIGZpZWxkQ2hhbm5lbDogZmllbGRDaGFubmVsLFxuICAgICAgICAgICAgc3RhY2tCeTogc3RhY2tCeSxcbiAgICAgICAgICAgIG9mZnNldDogc3RhY2tPZmZzZXRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnN0YWNrID0gc3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2ljM1JoWTJzdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12YzNSaFkyc3VkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTd3lRa0ZCTmtJN1FVRkZOMElzZVVOQlFXOURPMEZCUTNCRExIRkRRVUZ6UlR0QlFVTjBSU3gxUTBGQmEwVTdRVUZEYkVVc2RVTkJRV3RGTzBGQlEyeEZMQ3RDUVVFd1J6dEJRVU14Unl4cFEwRkJhME03UVVGRGJFTXNLMEpCUVhsRE8wRkJLMEkxUWl4UlFVRkJMR1ZCUVdVc1IwRkJSeXhEUVVGRExGVkJRVWNzUlVGQlJTeFhRVUZKTEVWQlFVVXNWMEZCU1N4RlFVRkZMRmxCUVVzc1JVRkJSU3hoUVVGTkxFVkJRVVVzWVVGQlRTeEZRVUZGTEZkQlFVa3NSVUZCUlN4WFFVRkpMRVZCUVVVc1YwRkJTU3hEUVVGRExFTkJRVU03UVVGRE4wVXNVVUZCUVN4elFrRkJjMElzUjBGQlJ5eERRVUZETEZWQlFVY3NSVUZCUlN4WFFVRkpMRU5CUVVNc1EwRkJRenRCUVVWc1JDeHBSMEZCYVVjN1FVRkRha2NzWjBWQlFXZEZPMEZCUldoRkxHVkJRWE5DTEVOQlFXbENMRVZCUVVVc1VVRkJhMElzUlVGQlJTeFhRVUYzUWp0SlFVTnVSaXhKUVVGTkxFbEJRVWtzUjBGQlJ5eG5Ra0ZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZKTEVkQlFVY3NRMEZCUXl4RFFVRkRPMGxCUTNaRExEWkNRVUUyUWp0SlFVTTNRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdWQlFWRXNRMEZCUXl4MVFrRkJaU3hGUVVGRkxFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnlReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVkVMREpDUVVFeVFqdEpRVU16UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExITkNRVUZYTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRek5DTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1NVRkRaQ3hEUVVGRE8wbEJSVVFzZFVOQlFYVkRPMGxCUTNaRExFbEJRVTBzVDBGQlR5eEhRVUZITERoQ1FVRnZRaXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZETEVWQlFVVXNSVUZCUlN4UFFVRlBPMUZCUTNSRUxFVkJRVVVzUTBGQlF5eERRVUZETERCQ1FVRmxMRU5CUVVNc1VVRkJVU3hGUVVGRkxFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjJReXhKUVVGTkxGVkJRVlVzUjBGQlJ5eFJRVUZSTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNN1dVRkRja01zUTBGQlF5eGpRVUZQTEVOQlFVTXNWVUZCVlN4RFFVRkRMRWRCUVVjc1ZVRkJWU3hIUVVGSExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1ZVRkJReXhSUVVGUk8yZENRVU5xUlN4RlFVRkZMRU5CUVVNc1EwRkJReXh4UWtGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4SlFVRkpMRU5CUVVNc1VVRkJVU3hEUVVGRExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdiMEpCUTJoRUxFVkJRVVVzUTBGQlF5eEpRVUZKTEVOQlFVTTdkMEpCUTA0c1QwRkJUeXhGUVVGRkxFOUJRVTg3ZDBKQlEyaENMRkZCUVZFc1JVRkJSU3hSUVVGUk8zRkNRVU51UWl4RFFVRkRMRU5CUVVNN1owSkJRMHdzUTBGQlF6dFpRVU5JTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTB3c1EwRkJRenRSUVVORUxFMUJRVTBzUTBGQlF5eEZRVUZGTEVOQlFVTTdTVUZEV2l4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRExFTkJRVU03U1VGRlVDeEZRVUZGTEVOQlFVTXNRMEZCUXl4UFFVRlBMRU5CUVVNc1RVRkJUU3hMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZWtJc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dEpRVU5rTEVOQlFVTTdTVUZGUkN3NFFrRkJPRUk3U1VGRE9VSXNTVUZCVFN4VFFVRlRMRWRCUVVjc2NVSkJRVlVzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkRla01zU1VGQlRTeFRRVUZUTEVkQlFVY3NjVUpCUVZVc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEZWtNc1NVRkJUU3haUVVGWkxFZEJRVWNzY1VKQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNc1UwRkJVeXhEUVVGRE8wbEJRM1JGTEVsQlFVMHNXVUZCV1N4SFFVRkhMSEZDUVVGVkxFTkJRVU1zVVVGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEZOQlFWTXNRMEZCUXp0SlFVVjBSU3hGUVVGRkxFTkJRVU1zUTBGQlF5eFpRVUZaTEV0QlFVc3NXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOc1F5eEpRVUZOTEZsQlFWa3NSMEZCUnl4WlFVRlpMRWRCUVVjc1YwRkJReXhIUVVGSExGZEJRVU1zUTBGQlF6dFJRVU14UXl4SlFVRk5MRkZCUVZFc1IwRkJSeXhSUVVGUkxFTkJRVU1zV1VGQldTeERRVUZ4UWl4RFFVRkRPMUZCUXpWRUxFbEJRVTBzY1VKQlFYRkNMRWRCUVVjc1VVRkJVU3hEUVVGRExGTkJRVk1zUTBGQlF6dFJRVU5xUkN4SlFVRk5MR2xDUVVGcFFpeEhRVUZITEZGQlFWRXNRMEZCUXl4TFFVRkxMRU5CUVVNN1VVRkZla01zU1VGQlNTeFhRVUZYTEVkQlFXZENMRWxCUVVrc1EwRkJRenRSUVVOd1F5eEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRU5CUVVNc1MwRkJTeXhMUVVGTExGTkJRVk1zUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYWtNc1YwRkJWeXhIUVVGSExGRkJRVkVzUTBGQlF5eExRVUZMTEVOQlFVTTdVVUZETDBJc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc09FSkJRWE5DTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMnhFTEdsRlFVRnBSVHRaUVVOcVJTeFhRVUZYTEVkQlFVY3NWMEZCVnl4TFFVRkxMRk5CUVZNc1IwRkJSeXhOUVVGTkxFZEJRVWNzVjBGQlZ5eERRVUZETzFGQlEycEZMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEZkQlFWY3NSMEZCUnl4WFFVRlhMRU5CUVVNN1VVRkROVUlzUTBGQlF6dFJRVVZFTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1YwRkJWeXhKUVVGSkxGZEJRVmNzUzBGQlN5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpORExFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdVVUZEWkN4RFFVRkRPMUZCUlVRc2NVWkJRWEZHTzFGQlEzSkdMRVZCUVVVc1EwRkJReXhEUVVGRExHbENRVUZwUWl4SlFVRkpMR2xDUVVGcFFpeERRVUZETEVsQlFVa3NTVUZCU1N4cFFrRkJhVUlzUTBGQlF5eEpRVUZKTEV0QlFVc3NhVUpCUVZNc1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF5OUdMRWRCUVVjc1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEU5QlFVOHNRMEZCUXl4NVFrRkJlVUlzUTBGQlF5eHBRa0ZCYVVJc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaEZMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRFpDeERRVUZETzFGQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc01FSkJRV1VzUTBGQlF5eFJRVUZSTEVWQlFVVXNXVUZCV1N4TFFVRkxMRmRCUVVNc1IwRkJSeXhaUVVGRkxFZEJRVWNzV1VGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMWxCUXpWRUxFZEJRVWNzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4RFFVRkRMRTlCUVU4c1EwRkJReXh4UWtGQmNVSXNRMEZCUXl4WlFVRlpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZFTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4bFFVRlJMRU5CUVVNc2JVSkJRVThzUlVGQlJTeHhRa0ZCY1VJc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU01UXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eFBRVUZQTEVOQlFVTXNaME5CUVdkRExFTkJRVU1zY1VKQlFYRkNMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRemxGTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJSVVFzVFVGQlRTeERRVUZETzFsQlEwd3NZMEZCWXl4RlFVRkZMRmxCUVZrc1IwRkJSeXhEUVVGRExGTkJRVk1zUjBGQlJ5eFhRVUZETEVkQlFVY3NTVUZCU1N4RFFVRkRMRWRCUVVjc1EwRkJReXhUUVVGVExFZEJRVWNzVjBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0WlFVTTVSU3haUVVGWkxFVkJRVVVzV1VGQldUdFpRVU14UWl4UFFVRlBMRVZCUVVVc1QwRkJUenRaUVVOb1FpeE5RVUZOTEVWQlFVVXNWMEZCVnp0VFFVTndRaXhEUVVGRE8wbEJRMG9zUTBGQlF6dEpRVU5FTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1FVRkRaQ3hEUVVGRE8wRkJiRVpFTEhOQ1FXdEdReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0ZXRpbWVfMSA9IHJlcXVpcmUoXCIuL2RhdGV0aW1lXCIpO1xudmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFRpbWVVbml0O1xuKGZ1bmN0aW9uIChUaW1lVW5pdCkge1xuICAgIFRpbWVVbml0LllFQVIgPSAneWVhcic7XG4gICAgVGltZVVuaXQuTU9OVEggPSAnbW9udGgnO1xuICAgIFRpbWVVbml0LkRBWSA9ICdkYXknO1xuICAgIFRpbWVVbml0LkRBVEUgPSAnZGF0ZSc7XG4gICAgVGltZVVuaXQuSE9VUlMgPSAnaG91cnMnO1xuICAgIFRpbWVVbml0Lk1JTlVURVMgPSAnbWludXRlcyc7XG4gICAgVGltZVVuaXQuU0VDT05EUyA9ICdzZWNvbmRzJztcbiAgICBUaW1lVW5pdC5NSUxMSVNFQ09ORFMgPSAnbWlsbGlzZWNvbmRzJztcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEggPSAneWVhcm1vbnRoJztcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFID0gJ3llYXJtb250aGRhdGUnO1xuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSUyA9ICd5ZWFybW9udGhkYXRlaG91cnMnO1xuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSU01JTlVURVMgPSAneWVhcm1vbnRoZGF0ZWhvdXJzbWludXRlcyc7XG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURUhPVVJTTUlOVVRFU1NFQ09ORFMgPSAneWVhcm1vbnRoZGF0ZWhvdXJzbWludXRlc3NlY29uZHMnO1xuICAgIC8vIE1PTlRIREFURSBhbHdheXMgaW5jbHVkZSAyOSBGZWJydWFyeSBzaW5jZSB3ZSB1c2UgeWVhciAwdGggKHdoaWNoIGlzIGEgbGVhcCB5ZWFyKTtcbiAgICBUaW1lVW5pdC5NT05USERBVEUgPSAnbW9udGhkYXRlJztcbiAgICBUaW1lVW5pdC5IT1VSU01JTlVURVMgPSAnaG91cnNtaW51dGVzJztcbiAgICBUaW1lVW5pdC5IT1VSU01JTlVURVNTRUNPTkRTID0gJ2hvdXJzbWludXRlc3NlY29uZHMnO1xuICAgIFRpbWVVbml0Lk1JTlVURVNTRUNPTkRTID0gJ21pbnV0ZXNzZWNvbmRzJztcbiAgICBUaW1lVW5pdC5TRUNPTkRTTUlMTElTRUNPTkRTID0gJ3NlY29uZHNtaWxsaXNlY29uZHMnO1xuICAgIFRpbWVVbml0LlFVQVJURVIgPSAncXVhcnRlcic7XG4gICAgVGltZVVuaXQuWUVBUlFVQVJURVIgPSAneWVhcnF1YXJ0ZXInO1xuICAgIFRpbWVVbml0LlFVQVJURVJNT05USCA9ICdxdWFydGVybW9udGgnO1xuICAgIFRpbWVVbml0LllFQVJRVUFSVEVSTU9OVEggPSAneWVhcnF1YXJ0ZXJtb250aCc7XG59KShUaW1lVW5pdCA9IGV4cG9ydHMuVGltZVVuaXQgfHwgKGV4cG9ydHMuVGltZVVuaXQgPSB7fSkpO1xuLyoqIFRpbWUgVW5pdCB0aGF0IG9ubHkgY29ycmVzcG9uZHMgdG8gb25seSBvbmUgcGFydCBvZiBEYXRlIG9iamVjdHMuICovXG5leHBvcnRzLlNJTkdMRV9USU1FVU5JVFMgPSBbXG4gICAgVGltZVVuaXQuWUVBUixcbiAgICBUaW1lVW5pdC5RVUFSVEVSLFxuICAgIFRpbWVVbml0Lk1PTlRILFxuICAgIFRpbWVVbml0LkRBWSxcbiAgICBUaW1lVW5pdC5EQVRFLFxuICAgIFRpbWVVbml0LkhPVVJTLFxuICAgIFRpbWVVbml0Lk1JTlVURVMsXG4gICAgVGltZVVuaXQuU0VDT05EUyxcbiAgICBUaW1lVW5pdC5NSUxMSVNFQ09ORFMsXG5dO1xudmFyIFNJTkdMRV9USU1FVU5JVF9JTkRFWCA9IGV4cG9ydHMuU0lOR0xFX1RJTUVVTklUUy5yZWR1Y2UoZnVuY3Rpb24gKGQsIHRpbWVVbml0KSB7XG4gICAgZFt0aW1lVW5pdF0gPSB0cnVlO1xuICAgIHJldHVybiBkO1xufSwge30pO1xuZnVuY3Rpb24gaXNTaW5nbGVUaW1lVW5pdCh0aW1lVW5pdCkge1xuICAgIHJldHVybiAhIVNJTkdMRV9USU1FVU5JVF9JTkRFWFt0aW1lVW5pdF07XG59XG5leHBvcnRzLmlzU2luZ2xlVGltZVVuaXQgPSBpc1NpbmdsZVRpbWVVbml0O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGRhdGUgdG8gb25seSBoYXZlIHRoZSBtZWFzdXJlbWVudHMgcmVsZXZhbnQgdG8gdGhlIHNwZWNpZmllZCB1bml0XG4gKiBpLmUuICgneWVhcm1vbnRoJywgJzIwMDAtMTItMDQgMDc6NTg6MTQnKSAtPiAnMjAwMC0xMi0wMSAwMDowMDowMCdcbiAqIE5vdGU6IHRoZSBiYXNlIGRhdGUgaXMgSmFuIDAxIDE5MDAgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gY29udmVydCh1bml0LCBkYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKDAsIDAsIDEsIDAsIDAsIDAsIDApOyAvLyBzdGFydCB3aXRoIHVuaWZvcm0gZGF0ZVxuICAgIGV4cG9ydHMuU0lOR0xFX1RJTUVVTklUUy5mb3JFYWNoKGZ1bmN0aW9uIChzaW5nbGVVbml0KSB7XG4gICAgICAgIGlmIChjb250YWluc1RpbWVVbml0KHVuaXQsIHNpbmdsZVVuaXQpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpbmdsZVVuaXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0LkRBWTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29udmVydCB0byBUaW1lVW5pdHMgY29udGFpbmluZyBcXCdkYXlcXCcnKTtcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0LllFQVI6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0LlFVQVJURVI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRlIHF1YXJ0ZXIgYnkgc2V0dGluZyBtb250aCB0byBiZSB0aGUgZmlyc3Qgb2YgdGhlIHF1YXJ0ZXIgaS5lLiBtYXkgKDQpIC0+IGFwcmlsICgzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0TW9udGgoKE1hdGguZmxvb3IoZGF0ZS5nZXRNb250aCgpIC8gMykpICogMyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGltZVVuaXQuTU9OVEg6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRNb250aChkYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0LkRBVEU6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5IT1VSUzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGltZVVuaXQuTUlOVVRFUzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWVVbml0LlNFQ09ORFM6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRTZWNvbmRzKGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUaW1lVW5pdC5NSUxMSVNFQ09ORFM6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29udmVydCA9IGNvbnZlcnQ7XG5leHBvcnRzLk1VTFRJX1RJTUVVTklUUyA9IFtcbiAgICBUaW1lVW5pdC5ZRUFSUVVBUlRFUixcbiAgICBUaW1lVW5pdC5ZRUFSUVVBUlRFUk1PTlRILFxuICAgIFRpbWVVbml0LllFQVJNT05USCxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFLFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSUyxcbiAgICBUaW1lVW5pdC5ZRUFSTU9OVEhEQVRFSE9VUlNNSU5VVEVTLFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSU01JTlVURVNTRUNPTkRTLFxuICAgIFRpbWVVbml0LlFVQVJURVJNT05USCxcbiAgICBUaW1lVW5pdC5IT1VSU01JTlVURVMsXG4gICAgVGltZVVuaXQuSE9VUlNNSU5VVEVTU0VDT05EUyxcbiAgICBUaW1lVW5pdC5NSU5VVEVTU0VDT05EUyxcbiAgICBUaW1lVW5pdC5TRUNPTkRTTUlMTElTRUNPTkRTLFxuXTtcbnZhciBNVUxUSV9USU1FVU5JVF9JTkRFWCA9IGV4cG9ydHMuTVVMVElfVElNRVVOSVRTLnJlZHVjZShmdW5jdGlvbiAoZCwgdGltZVVuaXQpIHtcbiAgICBkW3RpbWVVbml0XSA9IHRydWU7XG4gICAgcmV0dXJuIGQ7XG59LCB7fSk7XG5mdW5jdGlvbiBpc011bHRpVGltZVVuaXQodGltZVVuaXQpIHtcbiAgICByZXR1cm4gISFNVUxUSV9USU1FVU5JVF9JTkRFWFt0aW1lVW5pdF07XG59XG5leHBvcnRzLmlzTXVsdGlUaW1lVW5pdCA9IGlzTXVsdGlUaW1lVW5pdDtcbmV4cG9ydHMuVElNRVVOSVRTID0gW1xuICAgIFRpbWVVbml0LllFQVIsXG4gICAgVGltZVVuaXQuUVVBUlRFUixcbiAgICBUaW1lVW5pdC5NT05USCxcbiAgICBUaW1lVW5pdC5EQVksXG4gICAgVGltZVVuaXQuREFURSxcbiAgICBUaW1lVW5pdC5IT1VSUyxcbiAgICBUaW1lVW5pdC5NSU5VVEVTLFxuICAgIFRpbWVVbml0LlNFQ09ORFMsXG4gICAgVGltZVVuaXQuTUlMTElTRUNPTkRTLFxuICAgIFRpbWVVbml0LllFQVJRVUFSVEVSLFxuICAgIFRpbWVVbml0LllFQVJRVUFSVEVSTU9OVEgsXG4gICAgVGltZVVuaXQuWUVBUk1PTlRILFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEUsXG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURUhPVVJTLFxuICAgIFRpbWVVbml0LllFQVJNT05USERBVEVIT1VSU01JTlVURVMsXG4gICAgVGltZVVuaXQuWUVBUk1PTlRIREFURUhPVVJTTUlOVVRFU1NFQ09ORFMsXG4gICAgVGltZVVuaXQuUVVBUlRFUk1PTlRILFxuICAgIFRpbWVVbml0LkhPVVJTTUlOVVRFUyxcbiAgICBUaW1lVW5pdC5IT1VSU01JTlVURVNTRUNPTkRTLFxuICAgIFRpbWVVbml0Lk1JTlVURVNTRUNPTkRTLFxuICAgIFRpbWVVbml0LlNFQ09ORFNNSUxMSVNFQ09ORFNcbl07XG4vKiogUmV0dXJucyB0cnVlIGlmIGZ1bGxUaW1lVW5pdCBjb250YWlucyB0aGUgdGltZVVuaXQsIGZhbHNlIG90aGVyd2lzZS4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zVGltZVVuaXQoZnVsbFRpbWVVbml0LCB0aW1lVW5pdCkge1xuICAgIHZhciBpbmRleCA9IGZ1bGxUaW1lVW5pdC5pbmRleE9mKHRpbWVVbml0KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSAmJlxuICAgICAgICAodGltZVVuaXQgIT09IFRpbWVVbml0LlNFQ09ORFMgfHxcbiAgICAgICAgICAgIGluZGV4ID09PSAwIHx8XG4gICAgICAgICAgICBmdWxsVGltZVVuaXQuY2hhckF0KGluZGV4IC0gMSkgIT09ICdpJyAvLyBleGNsdWRlIG1pbGxpc2Vjb25kc1xuICAgICAgICApO1xufVxuZXhwb3J0cy5jb250YWluc1RpbWVVbml0ID0gY29udGFpbnNUaW1lVW5pdDtcbi8qKlxuICogUmV0dXJucyBWZWdhIGV4cHJlc3NzaW9uIGZvciBhIGdpdmVuIHRpbWVVbml0IGFuZCBmaWVsZFJlZlxuICovXG5mdW5jdGlvbiBmaWVsZEV4cHIoZnVsbFRpbWVVbml0LCBmaWVsZCkge1xuICAgIHZhciBmaWVsZFJlZiA9IFwiZGF0dW1bXFxcIlwiICsgZmllbGQgKyBcIlxcXCJdXCI7XG4gICAgZnVuY3Rpb24gZnVuYyh0aW1lVW5pdCkge1xuICAgICAgICBpZiAodGltZVVuaXQgPT09IFRpbWVVbml0LlFVQVJURVIpIHtcbiAgICAgICAgICAgIC8vIHF1YXJ0ZXIgc3RhcnRpbmcgYXQgMCAoMCwzLDYsOSkuXG4gICAgICAgICAgICByZXR1cm4gXCIocXVhcnRlcihcIiArIGZpZWxkUmVmICsgXCIpLTEpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZVVuaXQgKyBcIihcIiArIGZpZWxkUmVmICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGQgPSBleHBvcnRzLlNJTkdMRV9USU1FVU5JVFMucmVkdWNlKGZ1bmN0aW9uIChfZCwgdHUpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zVGltZVVuaXQoZnVsbFRpbWVVbml0LCB0dSkpIHtcbiAgICAgICAgICAgIF9kW3R1XSA9IGZ1bmModHUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZDtcbiAgICB9LCB7fSk7XG4gICAgaWYgKGQuZGF5ICYmIHV0aWxfMS5rZXlzKGQpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2UuZGF5UmVwbGFjZWRXaXRoRGF0ZShmdWxsVGltZVVuaXQpKTtcbiAgICAgICAgZGVsZXRlIGQuZGF5O1xuICAgICAgICBkLmRhdGUgPSBmdW5jKFRpbWVVbml0LkRBVEUpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZXRpbWVfMS5kYXRlVGltZUV4cHIoZCk7XG59XG5leHBvcnRzLmZpZWxkRXhwciA9IGZpZWxkRXhwcjtcbi8qKiByZXR1cm5zIHRoZSBzbWFsbGVzdCBuaWNlIHVuaXQgZm9yIHNjYWxlLm5pY2UgKi9cbmZ1bmN0aW9uIHNtYWxsZXN0VW5pdCh0aW1lVW5pdCkge1xuICAgIGlmICghdGltZVVuaXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LlNFQ09ORFMpKSB7XG4gICAgICAgIHJldHVybiAnc2Vjb25kJztcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0Lk1JTlVURVMpKSB7XG4gICAgICAgIHJldHVybiAnbWludXRlJztcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LkhPVVJTKSkge1xuICAgICAgICByZXR1cm4gJ2hvdXInO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuREFZKSB8fFxuICAgICAgICBjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5EQVRFKSkge1xuICAgICAgICByZXR1cm4gJ2RheSc7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5NT05USCkpIHtcbiAgICAgICAgcmV0dXJuICdtb250aCc7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5ZRUFSKSkge1xuICAgICAgICByZXR1cm4gJ3llYXInO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5zbWFsbGVzdFVuaXQgPSBzbWFsbGVzdFVuaXQ7XG4vKiogcmV0dXJucyB0aGUgc2lnbmFsIGV4cHJlc3Npb24gdXNlZCBmb3IgYXhpcyBsYWJlbHMgZm9yIGEgdGltZSB1bml0ICovXG5mdW5jdGlvbiBmb3JtYXRFeHByZXNzaW9uKHRpbWVVbml0LCBmaWVsZCwgc2hvcnRUaW1lTGFiZWxzKSB7XG4gICAgaWYgKCF0aW1lVW5pdCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgZGF0ZUNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9ICcnO1xuICAgIHZhciBoYXNZZWFyID0gY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuWUVBUik7XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0LlFVQVJURVIpKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgZXhwcmVzc2lvbiBmb3IgcXVhcnRlciBhcyBwcmVmaXhcbiAgICAgICAgZXhwcmVzc2lvbiA9IFwiJ1EnICsgcXVhcnRlcihcIiArIGZpZWxkICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5NT05USCkpIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCB1c2Ugc2hvcnQgbW9udGggbmFtZVxuICAgICAgICBkYXRlQ29tcG9uZW50cy5wdXNoKHNob3J0VGltZUxhYmVscyAhPT0gZmFsc2UgPyAnJWInIDogJyVCJyk7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5EQVkpKSB7XG4gICAgICAgIGRhdGVDb21wb25lbnRzLnB1c2goc2hvcnRUaW1lTGFiZWxzID8gJyVhJyA6ICclQScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5EQVRFKSkge1xuICAgICAgICBkYXRlQ29tcG9uZW50cy5wdXNoKCclZCcgKyAoaGFzWWVhciA/ICcsJyA6ICcnKSk7IC8vIGFkZCBjb21tYSBpZiB0aGVyZSBpcyB5ZWFyXG4gICAgfVxuICAgIGlmIChoYXNZZWFyKSB7XG4gICAgICAgIGRhdGVDb21wb25lbnRzLnB1c2goc2hvcnRUaW1lTGFiZWxzID8gJyV5JyA6ICclWScpO1xuICAgIH1cbiAgICB2YXIgdGltZUNvbXBvbmVudHMgPSBbXTtcbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuSE9VUlMpKSB7XG4gICAgICAgIHRpbWVDb21wb25lbnRzLnB1c2goJyVIJyk7XG4gICAgfVxuICAgIGlmIChjb250YWluc1RpbWVVbml0KHRpbWVVbml0LCBUaW1lVW5pdC5NSU5VVEVTKSkge1xuICAgICAgICB0aW1lQ29tcG9uZW50cy5wdXNoKCclTScpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNUaW1lVW5pdCh0aW1lVW5pdCwgVGltZVVuaXQuU0VDT05EUykpIHtcbiAgICAgICAgdGltZUNvbXBvbmVudHMucHVzaCgnJVMnKTtcbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zVGltZVVuaXQodGltZVVuaXQsIFRpbWVVbml0Lk1JTExJU0VDT05EUykpIHtcbiAgICAgICAgdGltZUNvbXBvbmVudHMucHVzaCgnJUwnKTtcbiAgICB9XG4gICAgdmFyIGRhdGVUaW1lQ29tcG9uZW50cyA9IFtdO1xuICAgIGlmIChkYXRlQ29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRhdGVUaW1lQ29tcG9uZW50cy5wdXNoKGRhdGVDb21wb25lbnRzLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIGlmICh0aW1lQ29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRhdGVUaW1lQ29tcG9uZW50cy5wdXNoKHRpbWVDb21wb25lbnRzLmpvaW4oJzonKSk7XG4gICAgfVxuICAgIGlmIChkYXRlVGltZUNvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgLy8gQWRkIHNwYWNlIGJldHdlZW4gcXVhcnRlciBhbmQgbWFpbiB0aW1lIGZvcm1hdFxuICAgICAgICAgICAgZXhwcmVzc2lvbiArPSBcIiArICcgJyArIFwiO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb24gKz0gXCJ0aW1lRm9ybWF0KFwiICsgZmllbGQgKyBcIiwgJ1wiICsgZGF0ZVRpbWVDb21wb25lbnRzLmpvaW4oJyAnKSArIFwiJylcIjtcbiAgICB9XG4gICAgLy8gSWYgZXhwcmVzc2lvbiBpcyBzdGlsbCBhbiBlbXB0eSBzdHJpbmcsIHJldHVybiB1bmRlZmluZWQgaW5zdGVhZC5cbiAgICByZXR1cm4gZXhwcmVzc2lvbiB8fCB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmZvcm1hdEV4cHJlc3Npb24gPSBmb3JtYXRFeHByZXNzaW9uO1xuZnVuY3Rpb24gaXNEaXNjcmV0ZUJ5RGVmYXVsdCh0aW1lVW5pdCkge1xuICAgIHN3aXRjaCAodGltZVVuaXQpIHtcbiAgICAgICAgLy8gVGhlc2UgdGltZSB1bml0IHVzZSBkaXNjcmV0ZSBzY2FsZSBieSBkZWZhdWx0XG4gICAgICAgIGNhc2UgJ2hvdXJzJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzRGlzY3JldGVCeURlZmF1bHQgPSBpc0Rpc2NyZXRlQnlEZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEdsdFpYVnVhWFF1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZkR2x0WlhWdWFYUXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTeDFRMEZCYzBRN1FVRkRkRVFzTWtKQlFUWkNPMEZCUXpkQ0xDdENRVUZyUXp0QlFVVnNReXhKUVVGcFFpeFJRVUZSTEVOQmVVSjRRanRCUVhwQ1JDeFhRVUZwUWl4UlFVRlJPMGxCUTFZc1lVRkJTU3hIUVVGWExFMUJRVTBzUTBGQlF6dEpRVU4wUWl4alFVRkxMRWRCUVZrc1QwRkJUeXhEUVVGRE8wbEJRM3BDTEZsQlFVY3NSMEZCVlN4TFFVRkxMRU5CUVVNN1NVRkRia0lzWVVGQlNTeEhRVUZYTEUxQlFVMHNRMEZCUXp0SlFVTjBRaXhqUVVGTExFZEJRVmtzVDBGQlR5eERRVUZETzBsQlEzcENMR2RDUVVGUExFZEJRV01zVTBGQlV5eERRVUZETzBsQlF5OUNMR2RDUVVGUExFZEJRV01zVTBGQlV5eERRVUZETzBsQlF5OUNMSEZDUVVGWkxFZEJRVzFDTEdOQlFXTXNRMEZCUXp0SlFVTTVReXhyUWtGQlV5eEhRVUZuUWl4WFFVRlhMRU5CUVVNN1NVRkRja01zYzBKQlFXRXNSMEZCYjBJc1pVRkJaU3hEUVVGRE8wbEJRMnBFTERKQ1FVRnJRaXhIUVVGNVFpeHZRa0ZCYjBJc1EwRkJRenRKUVVOb1JTeHJRMEZCZVVJc1IwRkJaME1zTWtKQlFUSkNMRU5CUVVNN1NVRkRja1lzZVVOQlFXZERMRWRCUVhWRExHdERRVUZyUXl4RFFVRkRPMGxCUlhaSUxIRkdRVUZ4Ump0SlFVTjRSU3hyUWtGQlV5eEhRVUZuUWl4WFFVRlhMRU5CUVVNN1NVRkRja01zY1VKQlFWa3NSMEZCYlVJc1kwRkJZeXhEUVVGRE8wbEJRemxETERSQ1FVRnRRaXhIUVVFd1FpeHhRa0ZCY1VJc1EwRkJRenRKUVVOdVJTeDFRa0ZCWXl4SFFVRnhRaXhuUWtGQlowSXNRMEZCUXp0SlFVTndSQ3cwUWtGQmJVSXNSMEZCTUVJc2NVSkJRWEZDTEVOQlFVTTdTVUZEYmtVc1owSkJRVThzUjBGQll5eFRRVUZUTEVOQlFVTTdTVUZETDBJc2IwSkJRVmNzUjBGQmEwSXNZVUZCWVN4RFFVRkRPMGxCUXpORExIRkNRVUZaTEVkQlFXMUNMR05CUVdNc1EwRkJRenRKUVVNNVF5eDVRa0ZCWjBJc1IwRkJkVUlzYTBKQlFXdENMRU5CUVVNN1FVRkRla1VzUTBGQlF5eEZRWHBDWjBJc1VVRkJVU3hIUVVGU0xHZENRVUZSTEV0QlFWSXNaMEpCUVZFc1VVRjVRbmhDTzBGQlUwUXNkMFZCUVhkRk8wRkJRek5FTEZGQlFVRXNaMEpCUVdkQ0xFZEJRVWM3U1VGRE9VSXNVVUZCVVN4RFFVRkRMRWxCUVVrN1NVRkRZaXhSUVVGUkxFTkJRVU1zVDBGQlR6dEpRVU5vUWl4UlFVRlJMRU5CUVVNc1MwRkJTenRKUVVOa0xGRkJRVkVzUTBGQlF5eEhRVUZITzBsQlExb3NVVUZCVVN4RFFVRkRMRWxCUVVrN1NVRkRZaXhSUVVGUkxFTkJRVU1zUzBGQlN6dEpRVU5rTEZGQlFWRXNRMEZCUXl4UFFVRlBPMGxCUTJoQ0xGRkJRVkVzUTBGQlF5eFBRVUZQTzBsQlEyaENMRkZCUVZFc1EwRkJReXhaUVVGWk8wTkJRM1JDTEVOQlFVTTdRVUZGUml4SlFVRk5MSEZDUVVGeFFpeEhRVUZyUWl4M1FrRkJaMElzUTBGQlF5eE5RVUZOTEVOQlFVTXNWVUZCUXl4RFFVRkRMRVZCUVVVc1VVRkJVVHRKUVVNdlJTeERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRE8wbEJRMjVDTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNN1FVRkRXQ3hEUVVGRExFVkJRVVVzUlVGQlJTeERRVUZETEVOQlFVTTdRVUZGVUN3d1FrRkJhVU1zVVVGQmEwSTdTVUZEYWtRc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eHhRa0ZCY1VJc1EwRkJReXhSUVVGUkxFTkJRVU1zUTBGQlF6dEJRVU16UXl4RFFVRkRPMEZCUmtRc05FTkJSVU03UVVGRlJEczdPenRIUVVsSE8wRkJRMGdzYVVKQlFYZENMRWxCUVdNc1JVRkJSU3hKUVVGVk8wbEJRMmhFTEVsQlFVMHNUVUZCVFN4SFFVRlRMRWxCUVVrc1NVRkJTU3hEUVVGRExFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc01FSkJRVEJDTzBsQlF6bEZMSGRDUVVGblFpeERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRlRMRlZCUVZVN1VVRkRNVU1zUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zU1VGQlNTeEZRVUZGTEZWQlFWVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4VlFVRlZMRU5CUVVNc1EwRkJReXhEUVVGRE8yZENRVU51UWl4TFFVRkxMRkZCUVZFc1EwRkJReXhIUVVGSE8yOUNRVU5tTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUVVNc1owUkJRV2RFTEVOQlFVTXNRMEZCUXp0blFrRkRjRVVzUzBGQlN5eFJRVUZSTEVOQlFVTXNTVUZCU1R0dlFrRkRhRUlzVFVGQlRTeERRVUZETEZkQlFWY3NRMEZCUXl4SlFVRkpMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU1zUTBGQlF6dHZRa0ZEZGtNc1MwRkJTeXhEUVVGRE8yZENRVU5TTEV0QlFVc3NVVUZCVVN4RFFVRkRMRTlCUVU4N2IwSkJRMjVDTERaR1FVRTJSanR2UWtGRE4wWXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRkZCUVZFc1JVRkJSU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNN2IwSkJRM1pFTEV0QlFVc3NRMEZCUXp0blFrRkRVaXhMUVVGTExGRkJRVkVzUTBGQlF5eExRVUZMTzI5Q1FVTnFRaXhOUVVGTkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4UlFVRlJMRVZCUVVVc1EwRkJReXhEUVVGRE8yOUNRVU5xUXl4TFFVRkxMRU5CUVVNN1owSkJRMUlzUzBGQlN5eFJRVUZSTEVOQlFVTXNTVUZCU1R0dlFrRkRhRUlzVFVGQlRTeERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1QwRkJUeXhGUVVGRkxFTkJRVU1zUTBGQlF6dHZRa0ZETDBJc1MwRkJTeXhEUVVGRE8yZENRVU5TTEV0QlFVc3NVVUZCVVN4RFFVRkRMRXRCUVVzN2IwSkJRMnBDTEUxQlFVMHNRMEZCUXl4UlFVRlJMRU5CUVVNc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETEVOQlFVTTdiMEpCUTJwRExFdEJRVXNzUTBGQlF6dG5Ra0ZEVWl4TFFVRkxMRkZCUVZFc1EwRkJReXhQUVVGUE8yOUNRVU51UWl4TlFVRk5MRU5CUVVNc1ZVRkJWU3hEUVVGRExFbEJRVWtzUTBGQlF5eFZRVUZWTEVWQlFVVXNRMEZCUXl4RFFVRkRPMjlDUVVOeVF5eExRVUZMTEVOQlFVTTdaMEpCUTFJc1MwRkJTeXhSUVVGUkxFTkJRVU1zVDBGQlR6dHZRa0ZEYmtJc1RVRkJUU3hEUVVGRExGVkJRVlVzUTBGQlF5eEpRVUZKTEVOQlFVTXNWVUZCVlN4RlFVRkZMRU5CUVVNc1EwRkJRenR2UWtGRGNrTXNTMEZCU3l4RFFVRkRPMmRDUVVOU0xFdEJRVXNzVVVGQlVTeERRVUZETEZsQlFWazdiMEpCUTNoQ0xFMUJRVTBzUTBGQlF5eGxRVUZsTEVOQlFVTXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1JVRkJSU3hEUVVGRExFTkJRVU03YjBKQlF5OURMRXRCUVVzc1EwRkJRenRaUVVOV0xFTkJRVU03VVVGRFNDeERRVUZETzBsQlEwZ3NRMEZCUXl4RFFVRkRMRU5CUVVNN1NVRkZTQ3hOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETzBGQlEyaENMRU5CUVVNN1FVRnlRMFFzTUVKQmNVTkRPMEZCUlZrc1VVRkJRU3hsUVVGbExFZEJRVWM3U1VGRE4wSXNVVUZCVVN4RFFVRkRMRmRCUVZjN1NVRkRjRUlzVVVGQlVTeERRVUZETEdkQ1FVRm5RanRKUVVONlFpeFJRVUZSTEVOQlFVTXNVMEZCVXp0SlFVTnNRaXhSUVVGUkxFTkJRVU1zWVVGQllUdEpRVU4wUWl4UlFVRlJMRU5CUVVNc2EwSkJRV3RDTzBsQlF6TkNMRkZCUVZFc1EwRkJReXg1UWtGQmVVSTdTVUZEYkVNc1VVRkJVU3hEUVVGRExHZERRVUZuUXp0SlFVTjZReXhSUVVGUkxFTkJRVU1zV1VGQldUdEpRVU55UWl4UlFVRlJMRU5CUVVNc1dVRkJXVHRKUVVOeVFpeFJRVUZSTEVOQlFVTXNiVUpCUVcxQ08wbEJRelZDTEZGQlFWRXNRMEZCUXl4alFVRmpPMGxCUTNaQ0xGRkJRVkVzUTBGQlF5eHRRa0ZCYlVJN1EwRkROMElzUTBGQlF6dEJRVVZHTEVsQlFVMHNiMEpCUVc5Q0xFZEJRV3RDTEhWQ1FVRmxMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEZRVUZGTEZGQlFWRTdTVUZETjBVc1EwRkJReXhEUVVGRExGRkJRVkVzUTBGQlF5eEhRVUZITEVsQlFVa3NRMEZCUXp0SlFVTnVRaXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETzBGQlExZ3NRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wRkJSVkFzZVVKQlFXZERMRkZCUVd0Q08wbEJRMmhFTEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc2IwSkJRVzlDTEVOQlFVTXNVVUZCVVN4RFFVRkRMRU5CUVVNN1FVRkRNVU1zUTBGQlF6dEJRVVpFTERCRFFVVkRPMEZCUlZrc1VVRkJRU3hUUVVGVExFZEJRVWM3U1VGRGRrSXNVVUZCVVN4RFFVRkRMRWxCUVVrN1NVRkRZaXhSUVVGUkxFTkJRVU1zVDBGQlR6dEpRVU5vUWl4UlFVRlJMRU5CUVVNc1MwRkJTenRKUVVOa0xGRkJRVkVzUTBGQlF5eEhRVUZITzBsQlExb3NVVUZCVVN4RFFVRkRMRWxCUVVrN1NVRkRZaXhSUVVGUkxFTkJRVU1zUzBGQlN6dEpRVU5rTEZGQlFWRXNRMEZCUXl4UFFVRlBPMGxCUTJoQ0xGRkJRVkVzUTBGQlF5eFBRVUZQTzBsQlEyaENMRkZCUVZFc1EwRkJReXhaUVVGWk8wbEJRM0pDTEZGQlFWRXNRMEZCUXl4WFFVRlhPMGxCUTNCQ0xGRkJRVkVzUTBGQlF5eG5Ra0ZCWjBJN1NVRkRla0lzVVVGQlVTeERRVUZETEZOQlFWTTdTVUZEYkVJc1VVRkJVU3hEUVVGRExHRkJRV0U3U1VGRGRFSXNVVUZCVVN4RFFVRkRMR3RDUVVGclFqdEpRVU16UWl4UlFVRlJMRU5CUVVNc2VVSkJRWGxDTzBsQlEyeERMRkZCUVZFc1EwRkJReXhuUTBGQlowTTdTVUZEZWtNc1VVRkJVU3hEUVVGRExGbEJRVms3U1VGRGNrSXNVVUZCVVN4RFFVRkRMRmxCUVZrN1NVRkRja0lzVVVGQlVTeERRVUZETEcxQ1FVRnRRanRKUVVNMVFpeFJRVUZSTEVOQlFVTXNZMEZCWXp0SlFVTjJRaXhSUVVGUkxFTkJRVU1zYlVKQlFXMUNPME5CUXpkQ0xFTkJRVU03UVVGRlJpd3lSVUZCTWtVN1FVRkRNMFVzTUVKQlFXbERMRmxCUVhOQ0xFVkJRVVVzVVVGQmEwSTdTVUZEZWtVc1NVRkJUU3hMUVVGTExFZEJRVWNzV1VGQldTeERRVUZETEU5QlFVOHNRMEZCUXl4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVNM1F5eE5RVUZOTEVOQlFVTXNTMEZCU3l4SFFVRkhMRU5CUVVNc1EwRkJRenRSUVVObUxFTkJRMFVzVVVGQlVTeExRVUZMTEZGQlFWRXNRMEZCUXl4UFFVRlBPMWxCUXpkQ0xFdEJRVXNzUzBGQlN5eERRVUZETzFsQlExZ3NXVUZCV1N4RFFVRkRMRTFCUVUwc1EwRkJReXhMUVVGTExFZEJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NSMEZCUnl4RFFVRkRMSFZDUVVGMVFqdFRRVU0zUkN4RFFVRkRPMEZCUTA0c1EwRkJRenRCUVZKRUxEUkRRVkZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3h0UWtGQk1FSXNXVUZCYzBJc1JVRkJSU3hMUVVGaE8wbEJRemRFTEVsQlFVMHNVVUZCVVN4SFFVRkpMR0ZCUVZVc1MwRkJTeXhSUVVGSkxFTkJRVU03U1VGRmRFTXNZMEZCWXl4UlFVRnJRanRSUVVNNVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4UlFVRlJMRXRCUVVzc1VVRkJVU3hEUVVGRExFOUJRVThzUTBGQlF5eERRVUZETEVOQlFVTTdXVUZEYkVNc2JVTkJRVzFETzFsQlEyNURMRTFCUVUwc1EwRkJReXhqUVVGWkxGRkJRVkVzVTBGQlRTeERRVUZETzFGQlEzQkRMRU5CUVVNN1VVRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF6dFpRVU5PTEUxQlFVMHNRMEZCU1N4UlFVRlJMRk5CUVVrc1VVRkJVU3hOUVVGSExFTkJRVU03VVVGRGNFTXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hKUVVGTkxFTkJRVU1zUjBGQlJ5eDNRa0ZCWjBJc1EwRkJReXhOUVVGTkxFTkJRVU1zVlVGQlF5eEZRVUZuUWl4RlFVRkZMRVZCUVZrN1VVRkRMMFFzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zV1VGQldTeEZRVUZGTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlF5eEZRVUZGTEVOQlFVTXNSVUZCUlN4RFFVRkRMRWRCUVVjc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETzFGQlEzQkNMRU5CUVVNN1VVRkRSQ3hOUVVGTkxFTkJRVU1zUlVGQlJTeERRVUZETzBsQlExb3NRMEZCUXl4RlFVRkZMRVZCUVVVc1EwRkJReXhEUVVGRE8wbEJSVkFzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWRCUVVjc1NVRkJTU3hYUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFFTXNSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zVDBGQlR5eERRVUZETEcxQ1FVRnRRaXhEUVVGRExGbEJRVmtzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZUVRc1QwRkJUeXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETzFGQlEySXNRMEZCUXl4RFFVRkRMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU1zVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRPMGxCUXk5Q0xFTkJRVU03U1VGRlJDeE5RVUZOTEVOQlFVTXNkVUpCUVZrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU42UWl4RFFVRkRPMEZCTVVKRUxEaENRVEJDUXp0QlFVVkVMRzlFUVVGdlJEdEJRVU53UkN4elFrRkJOa0lzVVVGQmEwSTdTVUZETjBNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJRc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF6dEpRVU51UWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRha1FzVFVGQlRTeERRVUZETEZGQlFWRXNRMEZCUXp0SlFVTnNRaXhEUVVGRE8wbEJSVVFzUlVGQlJTeERRVUZETEVOQlFVTXNaMEpCUVdkQ0xFTkJRVU1zVVVGQlVTeEZRVUZGTEZGQlFWRXNRMEZCUXl4UFFVRlBMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGFrUXNUVUZCVFN4RFFVRkRMRkZCUVZFc1EwRkJRenRKUVVOc1FpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhMUVVGTExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZETDBNc1RVRkJUU3hEUVVGRExFMUJRVTBzUTBGQlF6dEpRVU5vUWl4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eEhRVUZITEVOQlFVTTdVVUZEZUVNc1owSkJRV2RDTEVOQlFVTXNVVUZCVVN4RlFVRkZMRkZCUVZFc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZET1VNc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEpRVU5tTEVOQlFVTTdTVUZGUkN4RlFVRkZMRU5CUVVNc1EwRkJReXhuUWtGQlowSXNRMEZCUXl4UlFVRlJMRVZCUVVVc1VVRkJVU3hEUVVGRExFdEJRVXNzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTXZReXhOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzBsQlEycENMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNNVF5eE5RVUZOTEVOQlFVTXNUVUZCVFN4RFFVRkRPMGxCUTJoQ0xFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRPMEZCUTI1Q0xFTkJRVU03UVVFNVFrUXNiME5CT0VKRE8wRkJSVVFzZVVWQlFYbEZPMEZCUTNwRkxEQkNRVUZwUXl4UlFVRnJRaXhGUVVGRkxFdEJRV0VzUlVGQlJTeGxRVUYzUWp0SlFVTXhSaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEZGQlFWRXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRaQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzBsQlEyNUNMRU5CUVVNN1NVRkZSQ3hKUVVGTkxHTkJRV01zUjBGQllTeEZRVUZGTEVOQlFVTTdTVUZEY0VNc1NVRkJTU3hWUVVGVkxFZEJRVWNzUlVGQlJTeERRVUZETzBsQlEzQkNMRWxCUVUwc1QwRkJUeXhIUVVGSExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZGTVVRc1JVRkJSU3hEUVVGRExFTkJRVU1zWjBKQlFXZENMRU5CUVVNc1VVRkJVU3hGUVVGRkxGRkJRVkVzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRiRVFzTWtOQlFUSkRPMUZCUXpGRExGVkJRVlVzUjBGQlJ5eHRRa0ZCYVVJc1MwRkJTeXhOUVVGSExFTkJRVU03U1VGRGVrTXNRMEZCUXp0SlFVVkVMRVZCUVVVc1EwRkJReXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zUzBGQlN5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUXk5RExHdERRVUZyUXp0UlFVTnNReXhqUVVGakxFTkJRVU1zU1VGQlNTeERRVUZETEdWQlFXVXNTMEZCU3l4TFFVRkxMRWRCUVVjc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF5eERRVUZETzBsQlF5OUVMRU5CUVVNN1NVRkZSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eG5Ra0ZCWjBJc1EwRkJReXhSUVVGUkxFVkJRVVVzVVVGQlVTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNM1F5eGpRVUZqTEVOQlFVTXNTVUZCU1N4RFFVRkRMR1ZCUVdVc1IwRkJSeXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETEVOQlFVTTdTVUZEY2tRc1EwRkJRenRKUVVGRExFbEJRVWtzUTBGQlF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4blFrRkJaMElzUTBGQlF5eFJRVUZSTEVWQlFVVXNVVUZCVVN4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU55UkN4alFVRmpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eERRVUZETEU5QlFVOHNSMEZCUnl4SFFVRkhMRWRCUVVjc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETERaQ1FVRTJRanRKUVVOcVJpeERRVUZETzBsQlJVUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5hTEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1pVRkJaU3hIUVVGSExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNRMEZCUXp0SlFVTnlSQ3hEUVVGRE8wbEJSVVFzU1VGQlRTeGpRVUZqTEVkQlFXRXNSVUZCUlN4RFFVRkRPMGxCUlhCRExFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlETEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVTkVMRVZCUVVVc1EwRkJReXhEUVVGRExHZENRVUZuUWl4RFFVRkRMRkZCUVZFc1JVRkJSU3hSUVVGUkxFTkJRVU1zVDBGQlR5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJwRUxHTkJRV01zUTBGQlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkROVUlzUTBGQlF6dEpRVU5FTEVWQlFVVXNRMEZCUXl4RFFVRkRMR2RDUVVGblFpeERRVUZETEZGQlFWRXNSVUZCUlN4UlFVRlJMRU5CUVVNc1QwRkJUeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFGQlEycEVMR05CUVdNc1EwRkJReXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVORUxFVkJRVVVzUTBGQlF5eERRVUZETEdkQ1FVRm5RaXhEUVVGRExGRkJRVkVzUlVGQlJTeFJRVUZSTEVOQlFVTXNXVUZCV1N4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRM1JFTEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFTkJRVU03U1VGRE5VSXNRMEZCUXp0SlFVVkVMRWxCUVUwc2EwSkJRV3RDTEVkQlFXRXNSVUZCUlN4RFFVRkRPMGxCUTNoRExFVkJRVVVzUTBGQlF5eERRVUZETEdOQlFXTXNRMEZCUXl4TlFVRk5MRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU01UWl4clFrRkJhMElzUTBGQlF5eEpRVUZKTEVOQlFVTXNZMEZCWXl4RFFVRkRMRWxCUVVrc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEzQkVMRU5CUVVNN1NVRkRSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eGpRVUZqTEVOQlFVTXNUVUZCVFN4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRE9VSXNhMEpCUVd0Q0xFTkJRVU1zU1VGQlNTeERRVUZETEdOQlFXTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dEpRVU53UkN4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zYTBKQlFXdENMRU5CUVVNc1RVRkJUU3hIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEYkVNc1JVRkJSU3hEUVVGRExFTkJRVU1zVlVGQlZTeERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTm1MR2xFUVVGcFJEdFpRVU5xUkN4VlFVRlZMRWxCUVVrc1YwRkJWeXhEUVVGRE8xRkJRelZDTEVOQlFVTTdVVUZEUkN4VlFVRlZMRWxCUVVrc1owSkJRV01zUzBGQlN5eFhRVUZOTEd0Q1FVRnJRaXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNUMEZCU1N4RFFVRkRPMGxCUXpGRkxFTkJRVU03U1VGRlJDeHZSVUZCYjBVN1NVRkRjRVVzVFVGQlRTeERRVUZETEZWQlFWVXNTVUZCU1N4VFFVRlRMRU5CUVVNN1FVRkRha01zUTBGQlF6dEJRVGxFUkN3MFEwRTRSRU03UVVGRlJDdzJRa0ZCYjBNc1VVRkJhMEk3U1VGRGNFUXNUVUZCVFN4RFFVRkRMRU5CUVVNc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU5xUWl4blJFRkJaMFE3VVVGRGFFUXNTMEZCU3l4UFFVRlBMRU5CUVVNN1VVRkRZaXhMUVVGTExFdEJRVXNzUTBGQlF6dFJRVU5ZTEV0QlFVc3NUMEZCVHl4RFFVRkRPMUZCUTJJc1MwRkJTeXhUUVVGVE8xbEJRMW9zVFVGQlRTeERRVUZETEVsQlFVa3NRMEZCUXp0SlFVTm9RaXhEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNN1FVRldSQ3hyUkVGVlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUT1BfTEVWRUxfUFJPUEVSVElFUyA9IFtcbiAgICAnYmFja2dyb3VuZCcsICdwYWRkaW5nJ1xuXTtcbmZ1bmN0aW9uIGV4dHJhY3RUb3BMZXZlbFByb3BlcnRpZXModCkge1xuICAgIHJldHVybiBUT1BfTEVWRUxfUFJPUEVSVElFUy5yZWR1Y2UoZnVuY3Rpb24gKG8sIHApIHtcbiAgICAgICAgaWYgKHQgJiYgdFtwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvW3BdID0gdFtwXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICB9LCB7fSk7XG59XG5leHBvcnRzLmV4dHJhY3RUb3BMZXZlbFByb3BlcnRpZXMgPSBleHRyYWN0VG9wTGV2ZWxQcm9wZXJ0aWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEc5d2JHVjJaV3h3Y205d2N5NXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MGIzQnNaWFpsYkhCeWIzQnpMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3TzBGQmRVSkJMRWxCUVUwc2IwSkJRVzlDTEVkQlFXbERPMGxCUTNwRUxGbEJRVmtzUlVGQlJTeFRRVUZUTzBOQlEzaENMRU5CUVVNN1FVRkZSaXh0UTBGQmQwVXNRMEZCU1R0SlFVTXhSU3hOUVVGTkxFTkJRVU1zYjBKQlFXOUNMRU5CUVVNc1RVRkJUU3hEUVVGRExGVkJRVU1zUTBGQlF5eEZRVUZGTEVOQlFVTTdVVUZEZEVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1MwRkJTeXhUUVVGVExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6VkNMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRaQ3hEUVVGRE8xRkJRMFFzVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0SlFVTllMRU5CUVVNc1JVRkJSU3hGUVVGRkxFTkJRVU1zUTBGQlF6dEJRVU5VTEVOQlFVTTdRVUZRUkN3NFJFRlBReUo5IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc0ZpbHRlcih0KSB7XG4gICAgcmV0dXJuIHRbJ2ZpbHRlciddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzRmlsdGVyID0gaXNGaWx0ZXI7XG5mdW5jdGlvbiBpc0NhbGN1bGF0ZSh0KSB7XG4gICAgcmV0dXJuIHRbJ2NhbGN1bGF0ZSddICE9PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzQ2FsY3VsYXRlID0gaXNDYWxjdWxhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkSEpoYm5ObWIzSnRMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaUlzSW5OdmRYSmpaWE1pT2xzaUxpNHZMaTR2YzNKakwzUnlZVzV6Wm05eWJTNTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenRCUVZOQkxHdENRVUY1UWl4RFFVRlpPMGxCUTI1RExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNVVUZCVVN4RFFVRkRMRXRCUVVzc1UwRkJVeXhEUVVGRE8wRkJRMjVETEVOQlFVTTdRVUZHUkN3MFFrRkZRenRCUVdGRUxIRkNRVUUwUWl4RFFVRlpPMGxCUTNSRExFMUJRVTBzUTBGQlF5eERRVUZETEVOQlFVTXNWMEZCVnl4RFFVRkRMRXRCUVVzc1UwRkJVeXhEUVVGRE8wRkJRM1JETEVOQlFVTTdRVUZHUkN4clEwRkZReUo5IiwiLyoqIENvbnN0YW50cyBhbmQgdXRpbGl0aWVzIGZvciBkYXRhIHR5cGUgKi9cbi8qKiBEYXRhIHR5cGUgYmFzZWQgb24gbGV2ZWwgb2YgbWVhc3VyZW1lbnQgKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlLlFVQU5USVRBVElWRSA9ICdxdWFudGl0YXRpdmUnO1xuICAgIFR5cGUuT1JESU5BTCA9ICdvcmRpbmFsJztcbiAgICBUeXBlLlRFTVBPUkFMID0gJ3RlbXBvcmFsJztcbiAgICBUeXBlLk5PTUlOQUwgPSAnbm9taW5hbCc7XG59KShUeXBlID0gZXhwb3J0cy5UeXBlIHx8IChleHBvcnRzLlR5cGUgPSB7fSkpO1xuZXhwb3J0cy5RVUFOVElUQVRJVkUgPSBUeXBlLlFVQU5USVRBVElWRTtcbmV4cG9ydHMuT1JESU5BTCA9IFR5cGUuT1JESU5BTDtcbmV4cG9ydHMuVEVNUE9SQUwgPSBUeXBlLlRFTVBPUkFMO1xuZXhwb3J0cy5OT01JTkFMID0gVHlwZS5OT01JTkFMO1xuLyoqXG4gKiBHZXQgZnVsbCwgbG93ZXJjYXNlIHR5cGUgbmFtZSBmb3IgYSBnaXZlbiB0eXBlLlxuICogQHBhcmFtICB0eXBlXG4gKiBAcmV0dXJuIEZ1bGwgdHlwZSBuYW1lLlxuICovXG5mdW5jdGlvbiBnZXRGdWxsTmFtZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5RVUFOVElUQVRJVkU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdxdWFudGl0YXRpdmUnO1xuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVEVNUE9SQUw6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZW1wb3JhbCc7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5PUkRJTkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiAnb3JkaW5hbCc7XG4gICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5OT01JTkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbm9taW5hbCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgZ2V0IGludmFsaWQgaW5wdXQsIHJldHVybiB1bmRlZmluZWQgdHlwZS5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5nZXRGdWxsTmFtZSA9IGdldEZ1bGxOYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZEhsd1pTNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSWlMQ0p6YjNWeVkyVnpJanBiSWk0dUx5NHVMM055WXk5MGVYQmxMblJ6SWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUpCUVVGQkxEUkRRVUUwUXp0QlFVTTFReXc0UTBGQk9FTTdPenRCUVVVNVF5eEpRVUZwUWl4SlFVRkpMRU5CUzNCQ08wRkJURVFzVjBGQmFVSXNTVUZCU1R0SlFVTk9MR2xDUVVGWkxFZEJRVzFDTEdOQlFXTXNRMEZCUXp0SlFVTTVReXhaUVVGUExFZEJRV01zVTBGQlV5eERRVUZETzBsQlF5OUNMR0ZCUVZFc1IwRkJaU3hWUVVGVkxFTkJRVU03U1VGRGJFTXNXVUZCVHl4SFFVRmpMRk5CUVZNc1EwRkJRenRCUVVNNVF5eERRVUZETEVWQlRHZENMRWxCUVVrc1IwRkJTaXhaUVVGSkxFdEJRVW9zV1VGQlNTeFJRVXR3UWp0QlFVZFpMRkZCUVVFc1dVRkJXU3hIUVVGSExFbEJRVWtzUTBGQlF5eFpRVUZaTEVOQlFVTTdRVUZEYWtNc1VVRkJRU3hQUVVGUExFZEJRVWNzU1VGQlNTeERRVUZETEU5QlFVOHNRMEZCUXp0QlFVTjJRaXhSUVVGQkxGRkJRVkVzUjBGQlJ5eEpRVUZKTEVOQlFVTXNVVUZCVVN4RFFVRkRPMEZCUTNwQ0xGRkJRVUVzVDBGQlR5eEhRVUZITEVsQlFVa3NRMEZCUXl4UFFVRlBMRU5CUVVNN1FVRkZjRU03T3pzN1IwRkpSenRCUVVOSUxIRkNRVUUwUWl4SlFVRnBRanRKUVVNelF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJRMVFzU1VGQlNTeEhRVUZITEVsQlFVa3NRMEZCUXl4WFFVRlhMRVZCUVVVc1EwRkJRenRSUVVNeFFpeE5RVUZOTEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMklzUzBGQlN5eEhRVUZITEVOQlFVTTdXVUZEVkN4TFFVRkxMRzlDUVVGWk8yZENRVU5tTEUxQlFVMHNRMEZCUXl4alFVRmpMRU5CUVVNN1dVRkRlRUlzUzBGQlN5eEhRVUZITEVOQlFVTTdXVUZEVkN4TFFVRkxMR2RDUVVGUk8yZENRVU5ZTEUxQlFVMHNRMEZCUXl4VlFVRlZMRU5CUVVNN1dVRkRjRUlzUzBGQlN5eEhRVUZITEVOQlFVTTdXVUZEVkN4TFFVRkxMR1ZCUVU4N1owSkJRMVlzVFVGQlRTeERRVUZETEZOQlFWTXNRMEZCUXp0WlFVTnVRaXhMUVVGTExFZEJRVWNzUTBGQlF6dFpRVU5VTEV0QlFVc3NaVUZCVHp0blFrRkRWaXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETzFGQlEzSkNMRU5CUVVNN1NVRkRTQ3hEUVVGRE8wbEJRMFFzYTBSQlFXdEVPMGxCUTJ4RUxFMUJRVTBzUTBGQlF5eFRRVUZUTEVOQlFVTTdRVUZEYmtJc1EwRkJRenRCUVhCQ1JDeHJRMEZ2UWtNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdHJpbmdpZnkgPSByZXF1aXJlKFwianNvbi1zdGFibGUtc3RyaW5naWZ5XCIpO1xudmFyIHZlZ2FfdXRpbF8xID0gcmVxdWlyZShcInZlZ2EtdXRpbFwiKTtcbmV4cG9ydHMuZXh0ZW5kID0gdmVnYV91dGlsXzEuZXh0ZW5kO1xuZXhwb3J0cy5pc0FycmF5ID0gdmVnYV91dGlsXzEuaXNBcnJheTtcbmV4cG9ydHMuaXNPYmplY3QgPSB2ZWdhX3V0aWxfMS5pc09iamVjdDtcbmV4cG9ydHMuaXNOdW1iZXIgPSB2ZWdhX3V0aWxfMS5pc051bWJlcjtcbmV4cG9ydHMuaXNTdHJpbmcgPSB2ZWdhX3V0aWxfMS5pc1N0cmluZztcbmV4cG9ydHMudHJ1bmNhdGUgPSB2ZWdhX3V0aWxfMS50cnVuY2F0ZTtcbmV4cG9ydHMudG9TZXQgPSB2ZWdhX3V0aWxfMS50b1NldDtcbmV4cG9ydHMuc3RyaW5nVmFsdWUgPSB2ZWdhX3V0aWxfMS5zdHJpbmdWYWx1ZTtcbnZhciB2ZWdhX3V0aWxfMiA9IHJlcXVpcmUoXCJ2ZWdhLXV0aWxcIik7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgb2JqZWN0IHByb3BlcnRpZXMuXG4gKlxuICogRXhhbXBsZTogIChmcm9tIGxvZGFzaClcbiAqXG4gKiB2YXIgb2JqZWN0ID0geydhJzogMSwgJ2InOiAnMicsICdjJzogM307XG4gKiBwaWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyDihpIgeydhJzogMSwgJ2MnOiAzfVxuICpcbiAqL1xuZnVuY3Rpb24gcGljayhvYmosIHByb3BzKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbn1cbmV4cG9ydHMucGljayA9IHBpY2s7XG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBfLnBpY2s7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBvd25cbiAqIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBvYmplY3QgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gKi9cbmZ1bmN0aW9uIG9taXQob2JqLCBwcm9wcykge1xuICAgIHZhciBjb3B5ID0gZHVwbGljYXRlKG9iaik7XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBkZWxldGUgY29weVtwcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbn1cbmV4cG9ydHMub21pdCA9IG9taXQ7XG5mdW5jdGlvbiBoYXNoKGEpIHtcbiAgICBpZiAodmVnYV91dGlsXzIuaXNTdHJpbmcoYSkgfHwgdmVnYV91dGlsXzIuaXNOdW1iZXIoYSkgfHwgaXNCb29sZWFuKGEpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnkoYSk7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA+IC0xO1xufVxuZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xuLyoqIFJldHVybnMgdGhlIGFycmF5IHdpdGhvdXQgdGhlIGVsZW1lbnRzIGluIGl0ZW0gKi9cbmZ1bmN0aW9uIHdpdGhvdXQoYXJyYXksIGV4Y2x1ZGVkSXRlbXMpIHtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAhY29udGFpbnMoZXhjbHVkZWRJdGVtcywgaXRlbSk7IH0pO1xufVxuZXhwb3J0cy53aXRob3V0ID0gd2l0aG91dDtcbmZ1bmN0aW9uIHVuaW9uKGFycmF5LCBvdGhlcikge1xuICAgIHJldHVybiBhcnJheS5jb25jYXQod2l0aG91dChvdGhlciwgYXJyYXkpKTtcbn1cbmV4cG9ydHMudW5pb24gPSB1bmlvbjtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFueSBpdGVtIHJldHVybnMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gc29tZShhcnIsIGYpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKGYoYXJyW2tdLCBrLCBpKyspKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNvbWUgPSBzb21lO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGl0ZW1zIHJldHVybiB0cnVlLlxuICovXG5mdW5jdGlvbiBldmVyeShhcnIsIGYpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnIubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgaWYgKCFmKGFycltrXSwgaywgaSsrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5ldmVyeSA9IGV2ZXJ5O1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheXMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBhcnJheXMpO1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbi8qKlxuICogcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEZWVwKGRlc3QpIHtcbiAgICB2YXIgc3JjID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3JjW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYSA9IDAsIHNyY18xID0gc3JjOyBfYSA8IHNyY18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICB2YXIgcyA9IHNyY18xW19hXTtcbiAgICAgICAgZGVzdCA9IGRlZXBNZXJnZV8oZGVzdCwgcyk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZXhwb3J0cy5tZXJnZURlZXAgPSBtZXJnZURlZXA7XG4vLyByZWN1cnNpdmVseSBtZXJnZXMgc3JjIGludG8gZGVzdFxuZnVuY3Rpb24gZGVlcE1lcmdlXyhkZXN0LCBzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgICAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNyY1twXSAhPT0gJ29iamVjdCcgfHwgdmVnYV91dGlsXzIuaXNBcnJheShzcmNbcF0pIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGVzdFtwXSAhPT0gJ29iamVjdCcgfHwgZGVzdFtwXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVzdFtwXSA9IG1lcmdlRGVlcChzcmNbcF0uY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiB7fSwgc3JjW3BdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lcmdlRGVlcChkZXN0W3BdLCBzcmNbcF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gdW5pcXVlKHZhbHVlcywgZikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHUgPSB7fTtcbiAgICB2YXIgdjtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHZhbHVlc18xID0gdmFsdWVzOyBfaSA8IHZhbHVlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdmFsID0gdmFsdWVzXzFbX2ldO1xuICAgICAgICB2ID0gZih2YWwpO1xuICAgICAgICBpZiAodiBpbiB1KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB1W3ZdID0gMTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHZhbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuZXhwb3J0cy51bmlxdWUgPSB1bmlxdWU7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHdvIGRpY3Rpb25hcmllcyBkaXNhZ3JlZS4gQXBwbGllcyBvbmx5IHRvIGRlZmluZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBkaWZmZXIoZGljdCwgb3RoZXIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGljdCkge1xuICAgICAgICBpZiAoZGljdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJba2V5XSAmJiBkaWN0W2tleV0gJiYgb3RoZXJba2V5XSAhPT0gZGljdFtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5kaWZmZXIgPSBkaWZmZXI7XG5mdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICAgIGlmIChrZXkgaW4gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNJbnRlcnNlY3Rpb24gPSBoYXNJbnRlcnNlY3Rpb247XG5mdW5jdGlvbiBkaWZmZXJBcnJheShhcnJheSwgb3RoZXIpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFycmF5LnNvcnQoKTtcbiAgICBvdGhlci5zb3J0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob3RoZXJbaV0gIT09IGFycmF5W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmRpZmZlckFycmF5ID0gZGlmZmVyQXJyYXk7XG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cztcbmZ1bmN0aW9uIHZhbHMoeCkge1xuICAgIHZhciBfdmFscyA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4geCkge1xuICAgICAgICBpZiAoeC5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgX3ZhbHMucHVzaCh4W2tdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3ZhbHM7XG59XG5leHBvcnRzLnZhbHMgPSB2YWxzO1xuZnVuY3Rpb24gZHVwbGljYXRlKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuZXhwb3J0cy5kdXBsaWNhdGUgPSBkdXBsaWNhdGU7XG5mdW5jdGlvbiBpc0Jvb2xlYW4oYikge1xuICAgIHJldHVybiBiID09PSB0cnVlIHx8IGIgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgaW50byBhIHZhbGlkIHZhcmlhYmxlIG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFyTmFtZShzKSB7XG4gICAgLy8gUmVwbGFjZSBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgKGFueXRoaW5nIGJlc2lkZXMgYS16QS1aMC05Xykgd2l0aCBfXG4gICAgdmFyIGFscGhhbnVtZXJpY1MgPSBzLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xuICAgIC8vIEFkZCBfIGlmIHRoZSBzdHJpbmcgaGFzIGxlYWRpbmcgbnVtYmVycy5cbiAgICByZXR1cm4gKHMubWF0Y2goL15cXGQrLykgPyAnXycgOiAnJykgKyBhbHBoYW51bWVyaWNTO1xufVxuZXhwb3J0cy52YXJOYW1lID0gdmFyTmFtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRYUnBiQzVxY3lJc0luTnZkWEpqWlZKdmIzUWlPaUlpTENKemIzVnlZMlZ6SWpwYklpNHVMeTR1TDNOeVl5OTFkR2xzTG5SeklsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN08wRkJRVUVzYVVSQlFXMUVPMEZCUTI1RUxIVkRRVUZ6Unp0QlFVRTVSaXcyUWtGQlFTeE5RVUZOTEVOQlFVRTdRVUZCUlN3NFFrRkJRU3hQUVVGUExFTkJRVUU3UVVGQlJTd3JRa0ZCUVN4UlFVRlJMRU5CUVVFN1FVRkJSU3dyUWtGQlFTeFJRVUZSTEVOQlFVRTdRVUZCUlN3clFrRkJRU3hSUVVGUkxFTkJRVUU3UVVGQlJTd3JRa0ZCUVN4UlFVRlJMRU5CUVVFN1FVRkJSU3cwUWtGQlFTeExRVUZMTEVOQlFVRTdRVUZCUlN4clEwRkJRU3hYUVVGWExFTkJRVUU3UVVGRGJrWXNkVU5CUVhORU8wRkJSWFJFT3pzN096czdPenM3UjBGVFJ6dEJRVU5JTEdOQlFYRkNMRWRCUVZFc1JVRkJSU3hMUVVGbE8wbEJRelZETEVsQlFVMHNTVUZCU1N4SFFVRkhMRVZCUVVVc1EwRkJRenRKUVVOb1FpeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRlZCUVVNc1NVRkJTVHRSUVVOcVFpeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTTNRaXhKUVVGSkxFTkJRVU1zU1VGQlNTeERRVUZETEVkQlFVY3NSMEZCUnl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM3BDTEVOQlFVTTdTVUZEU0N4RFFVRkRMRU5CUVVNc1EwRkJRenRKUVVOSUxFMUJRVTBzUTBGQlF5eEpRVUZKTEVOQlFVTTdRVUZEWkN4RFFVRkRPMEZCVWtRc2IwSkJVVU03UVVGRlJEczdPMGRCUjBjN1FVRkRTQ3hqUVVGeFFpeEhRVUZSTEVWQlFVVXNTMEZCWlR0SlFVTTFReXhKUVVGTkxFbEJRVWtzUjBGQlJ5eFRRVUZUTEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNN1NVRkROVUlzUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4VlFVRkRMRWxCUVVrN1VVRkRha0lzVDBGQlR5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkRjRUlzUTBGQlF5eERRVUZETEVOQlFVTTdTVUZEU0N4TlFVRk5MRU5CUVVNc1NVRkJTU3hEUVVGRE8wRkJRMlFzUTBGQlF6dEJRVTVFTEc5Q1FVMURPMEZCUlVRc1kwRkJjVUlzUTBGQlRUdEpRVU42UWl4RlFVRkZMRU5CUVVNc1EwRkJReXh2UWtGQlVTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRzlDUVVGUkxFTkJRVU1zUTBGQlF5eERRVUZETEVsQlFVa3NVMEZCVXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU12UXl4TlFVRk5MRU5CUVVNc1RVRkJUU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzBsQlEyNUNMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMEZCUTNSQ0xFTkJRVU03UVVGTVJDeHZRa0ZMUXp0QlFVVkVMR3RDUVVFMFFpeExRVUZWTEVWQlFVVXNTVUZCVHp0SlFVTTNReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEU5QlFVOHNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF6dEJRVU5zUXl4RFFVRkRPMEZCUmtRc05FSkJSVU03UVVGRlJDeHhSRUZCY1VRN1FVRkRja1FzYVVKQlFUSkNMRXRCUVZVc1JVRkJSU3hoUVVGclFqdEpRVU4yUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRExFMUJRVTBzUTBGQlF5eFZRVUZCTEVsQlFVa3NTVUZCU1N4UFFVRkJMRU5CUVVNc1VVRkJVU3hEUVVGRExHRkJRV0VzUlVGQlJTeEpRVUZKTEVOQlFVTXNSVUZCT1VJc1EwRkJPRUlzUTBGQlF5eERRVUZETzBGQlF6bEVMRU5CUVVNN1FVRkdSQ3d3UWtGRlF6dEJRVVZFTEdWQlFYbENMRXRCUVZVc1JVRkJSU3hMUVVGVk8wbEJRemRETEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNc1RVRkJUU3hEUVVGRExFOUJRVThzUTBGQlF5eExRVUZMTEVWQlFVVXNTMEZCU3l4RFFVRkRMRU5CUVVNc1EwRkJRenRCUVVNM1F5eERRVUZETzBGQlJrUXNjMEpCUlVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEdOQlFYZENMRWRCUVZFc1JVRkJSU3hEUVVGelF6dEpRVU4wUlN4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRFZpeEhRVUZITEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1IwRkJSeXhEUVVGRExFVkJRVVVzUTBGQlF5eEhRVUZETEVkQlFVY3NRMEZCUXl4TlFVRk5MRVZCUVVVc1EwRkJReXhGUVVGRkxFVkJRVVVzUTBGQlF6dFJRVU5zUXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RlFVRkZMRU5CUVVNc1JVRkJSU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjBRaXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzFGQlEyUXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkRSQ3hOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETzBGQlEyWXNRMEZCUXp0QlFWSkVMRzlDUVZGRE8wRkJSVVE3TzBkQlJVYzdRVUZEUml4bFFVRjVRaXhIUVVGUkxFVkJRVVVzUTBGQmMwTTdTVUZEZUVVc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzBsQlExWXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExFZEJRVWNzUTBGQlF5eEZRVUZGTEVOQlFVTXNSMEZCUXl4SFFVRkhMRU5CUVVNc1RVRkJUU3hGUVVGRkxFTkJRVU1zUlVGQlJTeEZRVUZGTEVOQlFVTTdVVUZEYkVNc1JVRkJSU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNSMEZCUnl4RFFVRkRMRU5CUVVNc1EwRkJReXhGUVVGRkxFTkJRVU1zUlVGQlJTeERRVUZETEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRaUVVOMlFpeE5RVUZOTEVOQlFVTXNTMEZCU3l4RFFVRkRPMUZCUTJZc1EwRkJRenRKUVVOSUxFTkJRVU03U1VGRFJDeE5RVUZOTEVOQlFVTXNTVUZCU1N4RFFVRkRPMEZCUTJRc1EwRkJRenRCUVZKQkxITkNRVkZCTzBGQlJVUXNhVUpCUVhkQ0xFMUJRV0U3U1VGRGJrTXNUVUZCVFN4RFFVRkRMRVZCUVVVc1EwRkJReXhOUVVGTkxFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFVVXNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJRenRCUVVOeVF5eERRVUZETzBGQlJrUXNNRUpCUlVNN1FVRkZSRHM3UjBGRlJ6dEJRVU5JTEcxQ1FVRXdRaXhKUVVGVE8wbEJRVVVzWVVGQllUdFRRVUZpTEZWQlFXRXNSVUZCWWl4eFFrRkJZU3hGUVVGaUxFbEJRV0U3VVVGQllpdzBRa0ZCWVRzN1NVRkRhRVFzUjBGQlJ5eERRVUZETEVOQlFWa3NWVUZCUnl4RlFVRklMRmRCUVVjc1JVRkJTQ3hwUWtGQlJ5eEZRVUZJTEVsQlFVYzdVVUZCWkN4SlFVRk5MRU5CUVVNc1dVRkJRVHRSUVVOV0xFbEJRVWtzUjBGQlJ5eFZRVUZWTEVOQlFVTXNTVUZCU1N4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRE8wdEJRelZDTzBsQlEwUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRCUVVOa0xFTkJRVU03UVVGTVJDdzRRa0ZMUXp0QlFVVkVMRzFEUVVGdFF6dEJRVU51UXl4dlFrRkJiMElzU1VGQlV5eEZRVUZGTEVkQlFWRTdTVUZEY2tNc1JVRkJSU3hEUVVGRExFTkJRVU1zVDBGQlR5eEhRVUZITEV0QlFVc3NVVUZCVVN4SlFVRkpMRWRCUVVjc1MwRkJTeXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETzFGQlF6VkRMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03U1VGRFpDeERRVUZETzBsQlJVUXNSMEZCUnl4RFFVRkRMRU5CUVVNc1NVRkJUU3hEUVVGRExFbEJRVWtzUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTndRaXhGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEVkQlFVY3NRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlF6TkNMRkZCUVZFc1EwRkJRenRSUVVOWUxFTkJRVU03VVVGRFJDeEZRVUZGTEVOQlFVTXNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJReXhEUVVGRExFdEJRVXNzVTBGQlV5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTjZRaXhSUVVGUkxFTkJRVU03VVVGRFdDeERRVUZETzFGQlEwUXNSVUZCUlN4RFFVRkRMRU5CUVVNc1QwRkJUeXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETEV0QlFVc3NVVUZCVVN4SlFVRkpMRzFDUVVGUExFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eExRVUZMTEVsQlFVa3NRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkRja1VzU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4SFFVRkhMRWRCUVVjc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU51UWl4RFFVRkRPMUZCUVVNc1NVRkJTU3hEUVVGRExFVkJRVVVzUTBGQlF5eERRVUZETEU5QlFVOHNTVUZCU1N4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExGRkJRVkVzU1VGQlNTeEpRVUZKTEVOQlFVTXNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hEUVVGRExFTkJRVU1zUTBGQlF6dFpRVU16UkN4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFZEJRVWNzVTBGQlV5eERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhYUVVGWExFdEJRVXNzUzBGQlN5eEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEZEVVc1EwRkJRenRSUVVGRExFbEJRVWtzUTBGQlF5eERRVUZETzFsQlEwNHNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNM1FpeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQlJVUXNaMEpCUVRCQ0xFMUJRVmNzUlVGQlJTeERRVUZ6UWp0SlFVTXpSQ3hKUVVGTkxFOUJRVThzUjBGQlZTeEZRVUZGTEVOQlFVTTdTVUZETVVJc1NVRkJUU3hEUVVGRExFZEJRVWNzUlVGQlJTeERRVUZETzBsQlEySXNTVUZCU1N4RFFVRlRMRU5CUVVNN1NVRkRaQ3hIUVVGSExFTkJRVU1zUTBGQll5eFZRVUZOTEVWQlFVNHNhVUpCUVUwc1JVRkJUaXh2UWtGQlRTeEZRVUZPTEVsQlFVMDdVVUZCYmtJc1NVRkJUU3hIUVVGSExHVkJRVUU3VVVGRFdpeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRWRCUVVjc1EwRkJReXhEUVVGRE8xRkJRMWdzUlVGQlJTeERRVUZETEVOQlFVTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03V1VGRFdDeFJRVUZSTEVOQlFVTTdVVUZEV0N4RFFVRkRPMUZCUTBRc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXp0UlFVTlVMRTlCUVU4c1EwRkJReXhKUVVGSkxFTkJRVU1zUjBGQlJ5eERRVUZETEVOQlFVTTdTMEZEYmtJN1NVRkRSQ3hOUVVGTkxFTkJRVU1zVDBGQlR5eERRVUZETzBGQlEycENMRU5CUVVNN1FVRmlSQ3gzUWtGaFF6dEJRVkZFT3p0SFFVVkhPMEZCUTBnc1owSkJRVEJDTEVsQlFXRXNSVUZCUlN4TFFVRmpPMGxCUTNKRUxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVMHNSMEZCUnl4SlFVRkpMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGRrSXNSVUZCUlN4RFFVRkRMRU5CUVVNc1NVRkJTU3hEUVVGRExHTkJRV01zUTBGQlF5eEhRVUZITEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1dVRkROMElzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRWRCUVVjc1EwRkJReXhKUVVGSkxFbEJRVWtzUTBGQlF5eEhRVUZITEVOQlFVTXNTVUZCU1N4TFFVRkxMRU5CUVVNc1IwRkJSeXhEUVVGRExFdEJRVXNzU1VGQlNTeERRVUZETEVkQlFVY3NRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRuUWtGRGVFUXNUVUZCVFN4RFFVRkRMRWxCUVVrc1EwRkJRenRaUVVOa0xFTkJRVU03VVVGRFNDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQlZFUXNkMEpCVTBNN1FVRkZSQ3g1UWtGQlowTXNRMEZCV1N4RlFVRkZMRU5CUVZrN1NVRkRlRVFzUjBGQlJ5eERRVUZETEVOQlFVTXNTVUZCVFN4SFFVRkhMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF6dFJRVU53UWl4RlFVRkZMRU5CUVVNc1EwRkJReXhIUVVGSExFbEJRVWtzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXp0WlFVTmlMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03VVVGRFpDeERRVUZETzBsQlEwZ3NRMEZCUXp0SlFVTkVMRTFCUVUwc1EwRkJReXhMUVVGTExFTkJRVU03UVVGRFppeERRVUZETzBGQlVFUXNNRU5CVDBNN1FVRkZSQ3h4UWtGQkswSXNTMEZCVlN4RlFVRkZMRXRCUVZVN1NVRkRia1FzUlVGQlJTeERRVUZETEVOQlFVTXNTMEZCU3l4RFFVRkRMRTFCUVUwc1MwRkJTeXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVOQlFVTXNRMEZCUXp0UlFVTnNReXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBsQlEyUXNRMEZCUXp0SlFVVkVMRXRCUVVzc1EwRkJReXhKUVVGSkxFVkJRVVVzUTBGQlF6dEpRVU5pTEV0QlFVc3NRMEZCUXl4SlFVRkpMRVZCUVVVc1EwRkJRenRKUVVWaUxFZEJRVWNzUTBGQlF5eERRVUZETEVsQlFVa3NRMEZCUXl4SFFVRkhMRU5CUVVNc1JVRkJSU3hEUVVGRExFZEJRVWNzUzBGQlN5eERRVUZETEUxQlFVMHNSVUZCUlN4RFFVRkRMRVZCUVVVc1JVRkJSU3hEUVVGRE8xRkJRM1JETEVWQlFVVXNRMEZCUXl4RFFVRkRMRXRCUVVzc1EwRkJReXhEUVVGRExFTkJRVU1zUzBGQlN5eExRVUZMTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRekZDTEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRaQ3hEUVVGRE8wbEJRMGdzUTBGQlF6dEpRVVZFTEUxQlFVMHNRMEZCUXl4TFFVRkxMRU5CUVVNN1FVRkRaaXhEUVVGRE8wRkJaa1FzYTBOQlpVTTdRVUZGV1N4UlFVRkJMRWxCUVVrc1IwRkJSeXhOUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETzBGQlJXaERMR05CUVhkQ0xFTkJRWEZDTzBsQlF6TkRMRWxCUVUwc1MwRkJTeXhIUVVGUkxFVkJRVVVzUTBGQlF6dEpRVU4wUWl4SFFVRkhMRU5CUVVNc1EwRkJReXhKUVVGTkxFTkJRVU1zU1VGQlNTeERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRPMUZCUTJ4Q0xFVkJRVVVzUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4alFVRmpMRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzaENMRXRCUVVzc1EwRkJReXhKUVVGSkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRia0lzUTBGQlF6dEpRVU5JTEVOQlFVTTdTVUZEUkN4TlFVRk5MRU5CUVVNc1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRVkpFTEc5Q1FWRkRPMEZCUlVRc2JVSkJRVFpDTEVkQlFVMDdTVUZEYWtNc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF5eExRVUZMTEVOQlFVTXNTVUZCU1N4RFFVRkRMRk5CUVZNc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF5eERRVUZETzBGQlEzcERMRU5CUVVNN1FVRkdSQ3c0UWtGRlF6dEJRVVZFTEcxQ1FVRXdRaXhEUVVGTk8wbEJRemxDTEUxQlFVMHNRMEZCUXl4RFFVRkRMRXRCUVVzc1NVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eExRVUZMTEVOQlFVTTdRVUZEYmtNc1EwRkJRenRCUVVaRUxEaENRVVZETzBGQlJVUTdPMGRCUlVjN1FVRkRTQ3hwUWtGQmQwSXNRMEZCVXp0SlFVTXZRaXd5UlVGQk1rVTdTVUZETTBVc1NVRkJUU3hoUVVGaExFZEJRVWNzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXl4TFFVRkxMRVZCUVVVc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRk5VTXNNa05CUVRKRE8wbEJRek5ETEUxQlFVMHNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJReXhMUVVGTExFTkJRVU1zVFVGQlRTeERRVUZETEVkQlFVY3NSMEZCUnl4SFFVRkhMRVZCUVVVc1EwRkJReXhIUVVGSExHRkJRV0VzUTBGQlF6dEJRVU4wUkN4RFFVRkRPMEZCVGtRc01FSkJUVU1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hcmtfMSA9IHJlcXVpcmUoXCIuL21hcmtcIik7XG4vLyBUT0RPOiBtb3ZlIHRvIHZsLnNwZWMudmFsaWRhdG9yP1xudmFyIG1hcmtfMiA9IHJlcXVpcmUoXCIuL21hcmtcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbi8qKlxuICogUmVxdWlyZWQgRW5jb2RpbmcgQ2hhbm5lbHMgZm9yIGVhY2ggbWFyayB0eXBlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLkRFRkFVTFRfUkVRVUlSRURfQ0hBTk5FTF9NQVAgPSB7XG4gICAgdGV4dDogWyd0ZXh0J10sXG4gICAgbGluZTogWyd4JywgJ3knXSxcbiAgICBhcmVhOiBbJ3gnLCAneSddXG59O1xuLyoqXG4gKiBTdXBwb3J0ZWQgRW5jb2RpbmcgQ2hhbm5lbCBmb3IgZWFjaCBtYXJrIHR5cGVcbiAqL1xuZXhwb3J0cy5ERUZBVUxUX1NVUFBPUlRFRF9DSEFOTkVMX1RZUEUgPSB7XG4gICAgYmFyOiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3gnLCAneScsICdzaXplJywgJ2NvbG9yJywgJ2RldGFpbCddKSxcbiAgICBsaW5lOiB1dGlsXzEudG9TZXQoWydyb3cnLCAnY29sdW1uJywgJ3gnLCAneScsICdjb2xvcicsICdkZXRhaWwnXSksXG4gICAgYXJlYTogdXRpbF8xLnRvU2V0KFsncm93JywgJ2NvbHVtbicsICd4JywgJ3knLCAnY29sb3InLCAnZGV0YWlsJ10pLFxuICAgIHRpY2s6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAneCcsICd5JywgJ2NvbG9yJywgJ2RldGFpbCddKSxcbiAgICBjaXJjbGU6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAneCcsICd5JywgJ2NvbG9yJywgJ3NpemUnLCAnZGV0YWlsJ10pLFxuICAgIHNxdWFyZTogdXRpbF8xLnRvU2V0KFsncm93JywgJ2NvbHVtbicsICd4JywgJ3knLCAnY29sb3InLCAnc2l6ZScsICdkZXRhaWwnXSksXG4gICAgcG9pbnQ6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAneCcsICd5JywgJ2NvbG9yJywgJ3NpemUnLCAnZGV0YWlsJywgJ3NoYXBlJ10pLFxuICAgIHRleHQ6IHV0aWxfMS50b1NldChbJ3JvdycsICdjb2x1bW4nLCAnc2l6ZScsICdjb2xvcicsICd0ZXh0J10pIC8vIFRPRE8oIzcyNCkgcmV2aXNlXG59O1xuLy8gVE9ETzogY29uc2lkZXIgaWYgd2Ugc2hvdWxkIGFkZCB2YWxpZGF0ZSBtZXRob2QgYW5kXG4vLyByZXF1aXJlcyBaU2NoZW1hIGluIHRoZSBtYWluIHZlZ2EtbGl0ZSByZXBvXG4vKipcbiAqIEZ1cnRoZXIgY2hlY2sgaWYgZW5jb2RpbmcgbWFwcGluZyBvZiBhIHNwZWMgaXMgaW52YWxpZCBhbmRcbiAqIHJldHVybiBlcnJvciBpZiBpdCBpcyBpbnZhbGlkLlxuICpcbiAqIFRoaXMgY2hlY2tzIGlmXG4gKiAoMSkgYWxsIHRoZSByZXF1aXJlZCBlbmNvZGluZyBjaGFubmVscyBmb3IgdGhlIG1hcmsgdHlwZSBhcmUgc3BlY2lmaWVkXG4gKiAoMikgYWxsIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmcgY2hhbm5lbHMgYXJlIHN1cHBvcnRlZCBieSB0aGUgbWFyayB0eXBlXG4gKiBAcGFyYW0gIHtbdHlwZV19IHNwZWMgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7UmVxdWlyZWRDaGFubmVsTWFwICA9IERlZmF1bHRSZXF1aXJlZENoYW5uZWxNYXB9ICByZXF1aXJlZENoYW5uZWxNYXBcbiAqIEBwYXJhbSAge1N1cHBvcnRlZENoYW5uZWxNYXAgPSBEZWZhdWx0U3VwcG9ydGVkQ2hhbm5lbE1hcH0gc3VwcG9ydGVkQ2hhbm5lbE1hcFxuICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm4gb25lIHJlYXNvbiB3aHkgdGhlIGVuY29kaW5nIGlzIGludmFsaWQsXG4gKiAgICAgICAgICAgICAgICAgIG9yIG51bGwgaWYgdGhlIGVuY29kaW5nIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBnZXRFbmNvZGluZ01hcHBpbmdFcnJvcihzcGVjLCByZXF1aXJlZENoYW5uZWxNYXAsIHN1cHBvcnRlZENoYW5uZWxNYXApIHtcbiAgICBpZiAocmVxdWlyZWRDaGFubmVsTWFwID09PSB2b2lkIDApIHsgcmVxdWlyZWRDaGFubmVsTWFwID0gZXhwb3J0cy5ERUZBVUxUX1JFUVVJUkVEX0NIQU5ORUxfTUFQOyB9XG4gICAgaWYgKHN1cHBvcnRlZENoYW5uZWxNYXAgPT09IHZvaWQgMCkgeyBzdXBwb3J0ZWRDaGFubmVsTWFwID0gZXhwb3J0cy5ERUZBVUxUX1NVUFBPUlRFRF9DSEFOTkVMX1RZUEU7IH1cbiAgICB2YXIgbWFyayA9IG1hcmtfMS5pc01hcmtEZWYoc3BlYy5tYXJrKSA/IHNwZWMubWFyay50eXBlIDogc3BlYy5tYXJrO1xuICAgIHZhciBlbmNvZGluZyA9IHNwZWMuZW5jb2Rpbmc7XG4gICAgdmFyIHJlcXVpcmVkQ2hhbm5lbHMgPSByZXF1aXJlZENoYW5uZWxNYXBbbWFya107XG4gICAgdmFyIHN1cHBvcnRlZENoYW5uZWxzID0gc3VwcG9ydGVkQ2hhbm5lbE1hcFttYXJrXTtcbiAgICBmb3IgKHZhciBpIGluIHJlcXVpcmVkQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKCEocmVxdWlyZWRDaGFubmVsc1tpXSBpbiBlbmNvZGluZykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWlzc2luZyBlbmNvZGluZyBjaGFubmVsIFxcXCInICsgcmVxdWlyZWRDaGFubmVsc1tpXSArXG4gICAgICAgICAgICAgICAgJ1xcXCIgZm9yIG1hcmsgXFxcIicgKyBtYXJrICsgJ1xcXCInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGNoYW5uZWwgaW4gZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRDaGFubmVsc1tjaGFubmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuICdFbmNvZGluZyBjaGFubmVsIFxcXCInICsgY2hhbm5lbCArXG4gICAgICAgICAgICAgICAgJ1xcXCIgaXMgbm90IHN1cHBvcnRlZCBieSBtYXJrIHR5cGUgXFxcIicgKyBtYXJrICsgJ1xcXCInO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXJrID09PSBtYXJrXzIuQkFSICYmICFlbmNvZGluZy54ICYmICFlbmNvZGluZy55KSB7XG4gICAgICAgIHJldHVybiAnTWlzc2luZyBib3RoIHggYW5kIHkgZm9yIGJhcic7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5nZXRFbmNvZGluZ01hcHBpbmdFcnJvciA9IGdldEVuY29kaW5nTWFwcGluZ0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZG1Gc2FXUmhkR1V1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZkbUZzYVdSaGRHVXVkSE1pWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanM3UVVGQlFTd3JRa0ZCYVVNN1FVRkhha01zYlVOQlFXMURPMEZCUlc1RExDdENRVUV5UWp0QlFVTXpRaXdyUWtGQk5rSTdRVUZOTjBJN096dEhRVWRITzBGQlExVXNVVUZCUVN3MFFrRkJORUlzUjBGQmRVSTdTVUZET1VRc1NVRkJTU3hGUVVGRkxFTkJRVU1zVFVGQlRTeERRVUZETzBsQlEyUXNTVUZCU1N4RlFVRkZMRU5CUVVNc1IwRkJSeXhGUVVGRkxFZEJRVWNzUTBGQlF6dEpRVU5vUWl4SlFVRkpMRVZCUVVVc1EwRkJReXhIUVVGSExFVkJRVVVzUjBGQlJ5eERRVUZETzBOQlEycENMRU5CUVVNN1FVRlJSanM3UjBGRlJ6dEJRVU5WTEZGQlFVRXNPRUpCUVRoQ0xFZEJRWGRDTzBsQlEycEZMRWRCUVVjc1JVRkJSU3haUVVGTExFTkJRVU1zUTBGQlF5eExRVUZMTEVWQlFVVXNVVUZCVVN4RlFVRkZMRWRCUVVjc1JVRkJSU3hIUVVGSExFVkJRVVVzVFVGQlRTeEZRVUZGTEU5QlFVOHNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVOc1JTeEpRVUZKTEVWQlFVVXNXVUZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hSUVVGUkxFTkJRVU1zUTBGQlF6dEpRVU16UkN4SlFVRkpMRVZCUVVVc1dVRkJTeXhEUVVGRExFTkJRVU1zUzBGQlN5eEZRVUZGTEZGQlFWRXNSVUZCUlN4SFFVRkhMRVZCUVVVc1IwRkJSeXhGUVVGRkxFOUJRVThzUlVGQlJTeFJRVUZSTEVOQlFVTXNRMEZCUXp0SlFVTXpSQ3hKUVVGSkxFVkJRVVVzV1VGQlN5eERRVUZETEVOQlFVTXNTMEZCU3l4RlFVRkZMRkZCUVZFc1JVRkJSU3hIUVVGSExFVkJRVVVzUjBGQlJ5eEZRVUZGTEU5QlFVOHNSVUZCUlN4UlFVRlJMRU5CUVVNc1EwRkJRenRKUVVNelJDeE5RVUZOTEVWQlFVVXNXVUZCU3l4RFFVRkRMRU5CUVVNc1MwRkJTeXhGUVVGRkxGRkJRVkVzUlVGQlJTeEhRVUZITEVWQlFVVXNSMEZCUnl4RlFVRkZMRTlCUVU4c1JVRkJSU3hOUVVGTkxFVkJRVVVzVVVGQlVTeERRVUZETEVOQlFVTTdTVUZEY2tVc1RVRkJUU3hGUVVGRkxGbEJRVXNzUTBGQlF5eERRVUZETEV0QlFVc3NSVUZCUlN4UlFVRlJMRVZCUVVVc1IwRkJSeXhGUVVGRkxFZEJRVWNzUlVGQlJTeFBRVUZQTEVWQlFVVXNUVUZCVFN4RlFVRkZMRkZCUVZFc1EwRkJReXhEUVVGRE8wbEJRM0pGTEV0QlFVc3NSVUZCUlN4WlFVRkxMRU5CUVVNc1EwRkJReXhMUVVGTExFVkJRVVVzVVVGQlVTeEZRVUZGTEVkQlFVY3NSVUZCUlN4SFFVRkhMRVZCUVVVc1QwRkJUeXhGUVVGRkxFMUJRVTBzUlVGQlJTeFJRVUZSTEVWQlFVVXNUMEZCVHl4RFFVRkRMRU5CUVVNN1NVRkROMFVzU1VGQlNTeEZRVUZGTEZsQlFVc3NRMEZCUXl4RFFVRkRMRXRCUVVzc1JVRkJSU3hSUVVGUkxFVkJRVVVzVFVGQlRTeEZRVUZGTEU5QlFVOHNSVUZCUlN4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExHOUNRVUZ2UWp0RFFVTTNSU3hEUVVGRE8wRkJSVVlzYzBSQlFYTkVPMEZCUTNSRUxEaERRVUU0UXp0QlFVVTVRenM3T3pzN096czdPenM3TzBkQldVYzdRVUZEU0N4cFEwRkJkME1zU1VGQmNVSXNSVUZETTBRc2EwSkJRWEZGTEVWQlEzSkZMRzFDUVVGNVJUdEpRVVI2UlN4dFEwRkJRU3hGUVVGQkxIbEVRVUZ4UlR0SlFVTnlSU3h2UTBGQlFTeEZRVUZCTERSRVFVRjVSVHRKUVVWNlJTeEpRVUZOTEVsQlFVa3NSMEZCUnl4blFrRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVOQlFVTXNSMEZCUnl4SlFVRkpMRU5CUVVNc1NVRkJTU3hEUVVGRExFbEJRVWtzUjBGQlJ5eEpRVUZKTEVOQlFVTXNTVUZCU1N4RFFVRkRPMGxCUXk5RUxFbEJRVTBzVVVGQlVTeEhRVUZITEVsQlFVa3NRMEZCUXl4UlFVRlJMRU5CUVVNN1NVRkRMMElzU1VGQlRTeG5Ra0ZCWjBJc1IwRkJSeXhyUWtGQmEwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1EwRkJRenRKUVVOc1JDeEpRVUZOTEdsQ1FVRnBRaXhIUVVGSExHMUNRVUZ0UWl4RFFVRkRMRWxCUVVrc1EwRkJReXhEUVVGRE8wbEJSWEJFTEVkQlFVY3NRMEZCUXl4RFFVRkRMRWxCUVUwc1EwRkJReXhKUVVGSkxHZENRVUZuUWl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVOcVF5eEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1owSkJRV2RDTEVOQlFVTXNRMEZCUXl4RFFVRkRMRWxCUVVrc1VVRkJVU3hEUVVGRExFTkJRVU1zUTBGQlF5eERRVUZETzFsQlEzWkRMRTFCUVUwc1EwRkJReXcyUWtGQk5rSXNSMEZCUnl4blFrRkJaMElzUTBGQlF5eERRVUZETEVOQlFVTTdaMEpCUTNoRUxHZENRVUZuUWl4SFFVRkhMRWxCUVVrc1IwRkJSeXhKUVVGSkxFTkJRVU03VVVGRGJrTXNRMEZCUXp0SlFVTklMRU5CUVVNN1NVRkZSQ3hIUVVGSExFTkJRVU1zUTBGQlF5eEpRVUZOTEU5QlFVOHNTVUZCU1N4UlFVRlJMRU5CUVVNc1EwRkJReXhEUVVGRE8xRkJReTlDTEVWQlFVVXNRMEZCUXl4RFFVRkRMRU5CUVVNc2FVSkJRV2xDTEVOQlFVTXNUMEZCVHl4RFFVRkRMRU5CUVVNc1EwRkJReXhEUVVGRE8xbEJRMmhETEUxQlFVMHNRMEZCUXl4eFFrRkJjVUlzUjBGQlJ5eFBRVUZQTzJkQ1FVTndReXh4UTBGQmNVTXNSMEZCUnl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRE8xRkJRM2hFTEVOQlFVTTdTVUZEU0N4RFFVRkRPMGxCUlVRc1JVRkJSU3hEUVVGRExFTkJRVU1zU1VGQlNTeExRVUZMTEZWQlFVY3NTVUZCU1N4RFFVRkRMRkZCUVZFc1EwRkJReXhEUVVGRExFbEJRVWtzUTBGQlF5eFJRVUZSTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNc1EwRkJRenRSUVVNdlF5eE5RVUZOTEVOQlFVTXNPRUpCUVRoQ0xFTkJRVU03U1VGRGVFTXNRMEZCUXp0SlFVVkVMRTFCUVUwc1EwRkJReXhKUVVGSkxFTkJRVU03UVVGRFpDeERRVUZETzBGQk5VSkVMREJFUVRSQ1F5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gaXNEYXRhUmVmVW5pb25lZERvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuICdmaWVsZHMnIGluIGRvbWFpbiAmJiAhKCdkYXRhJyBpbiBkb21haW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzRGF0YVJlZlVuaW9uZWREb21haW4gPSBpc0RhdGFSZWZVbmlvbmVkRG9tYWluO1xuZnVuY3Rpb24gaXNGaWVsZFJlZlVuaW9uRG9tYWluKGRvbWFpbikge1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gJ2ZpZWxkcycgaW4gZG9tYWluICYmICdkYXRhJyBpbiBkb21haW47XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNGaWVsZFJlZlVuaW9uRG9tYWluID0gaXNGaWVsZFJlZlVuaW9uRG9tYWluO1xuZnVuY3Rpb24gaXNEYXRhUmVmRG9tYWluKGRvbWFpbikge1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gJ2ZpZWxkJyBpbiBkb21haW4gJiYgJ2RhdGEnIGluIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0RhdGFSZWZEb21haW4gPSBpc0RhdGFSZWZEb21haW47XG5mdW5jdGlvbiBpc1NpZ25hbFJlZkRvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuICdzaWduYWwnIGluIGRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1NpZ25hbFJlZkRvbWFpbiA9IGlzU2lnbmFsUmVmRG9tYWluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pZG1WbllTNXpZMmhsYldFdWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk4dUxpOXpjbU12ZG1WbllTNXpZMmhsYldFdWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdRVUZIUVN3clFrRkJLMEk3UVVGM1JpOUNMR2REUVVGMVF5eE5RVUZuUWp0SlFVTnlSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRkZCUVZFc1NVRkJTU3hOUVVGTkxFbEJRVWtzUTBGQlF5eERRVUZETEUxQlFVMHNTVUZCU1N4TlFVRk5MRU5CUVVNc1EwRkJRenRKUVVOdVJDeERRVUZETzBsQlEwUXNUVUZCVFN4RFFVRkRMRXRCUVVzc1EwRkJRenRCUVVObUxFTkJRVU03UVVGTVJDeDNSRUZMUXp0QlFVVkVMQ3RDUVVGelF5eE5RVUZuUWp0SlFVTndSQ3hGUVVGRkxFTkJRVU1zUTBGQlF5eERRVUZETEdOQlFVOHNRMEZCUXl4TlFVRk5MRU5CUVVNc1EwRkJReXhEUVVGRExFTkJRVU03VVVGRGNrSXNUVUZCVFN4RFFVRkRMRkZCUVZFc1NVRkJTU3hOUVVGTkxFbEJRVWtzVFVGQlRTeEpRVUZKTEUxQlFVMHNRMEZCUXp0SlFVTm9SQ3hEUVVGRE8wbEJRMFFzVFVGQlRTeERRVUZETEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNN1FVRk1SQ3h6UkVGTFF6dEJRVVZFTEhsQ1FVRm5ReXhOUVVGblFqdEpRVU01UXl4RlFVRkZMRU5CUVVNc1EwRkJReXhEUVVGRExHTkJRVThzUTBGQlF5eE5RVUZOTEVOQlFVTXNRMEZCUXl4RFFVRkRMRU5CUVVNN1VVRkRjRUlzVFVGQlRTeERRVUZETEU5QlFVOHNTVUZCU1N4TlFVRk5MRWxCUVVrc1RVRkJUU3hKUVVGSkxFMUJRVTBzUTBGQlF6dEpRVU5vUkN4RFFVRkRPMGxCUTBRc1RVRkJUU3hEUVVGRExFdEJRVXNzUTBGQlF6dEJRVU5tTEVOQlFVTTdRVUZNUkN3d1EwRkxRenRCUVVWRUxESkNRVUZyUXl4TlFVRm5RanRKUVVOb1JDeEZRVUZGTEVOQlFVTXNRMEZCUXl4RFFVRkRMR05CUVU4c1EwRkJReXhOUVVGTkxFTkJRVU1zUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEY2tJc1RVRkJUU3hEUVVGRExGRkJRVkVzU1VGQlNTeE5RVUZOTEVOQlFVTTdTVUZETlVJc1EwRkJRenRKUVVORUxFMUJRVTBzUTBGQlF5eExRVUZMTEVOQlFVTTdRVUZEWml4RFFVRkRPMEZCVEVRc09FTkJTME1pZlE9PSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5heGlzID0gcmVxdWlyZShcIi4vYXhpc1wiKTtcbmV4cG9ydHMuYWdncmVnYXRlID0gcmVxdWlyZShcIi4vYWdncmVnYXRlXCIpO1xuZXhwb3J0cy5iaW4gPSByZXF1aXJlKFwiLi9iaW5cIik7XG5leHBvcnRzLmNoYW5uZWwgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuZXhwb3J0cy5jb21wb3NpdGVNYXJrID0gcmVxdWlyZShcIi4vY29tcG9zaXRlbWFya1wiKTtcbnZhciBjb21waWxlXzEgPSByZXF1aXJlKFwiLi9jb21waWxlL2NvbXBpbGVcIik7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXzEuY29tcGlsZTtcbmV4cG9ydHMuY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuZXhwb3J0cy5kYXRhID0gcmVxdWlyZShcIi4vZGF0YVwiKTtcbmV4cG9ydHMuZGF0ZXRpbWUgPSByZXF1aXJlKFwiLi9kYXRldGltZVwiKTtcbmV4cG9ydHMuZW5jb2RpbmcgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbmV4cG9ydHMuZmFjZXQgPSByZXF1aXJlKFwiLi9mYWNldFwiKTtcbmV4cG9ydHMuZmllbGREZWYgPSByZXF1aXJlKFwiLi9maWVsZGRlZlwiKTtcbmV4cG9ydHMubGVnZW5kID0gcmVxdWlyZShcIi4vbGVnZW5kXCIpO1xuZXhwb3J0cy5tYXJrID0gcmVxdWlyZShcIi4vbWFya1wiKTtcbmV4cG9ydHMuc2NhbGUgPSByZXF1aXJlKFwiLi9zY2FsZVwiKTtcbmV4cG9ydHMuc29ydCA9IHJlcXVpcmUoXCIuL3NvcnRcIik7XG5leHBvcnRzLnNwZWMgPSByZXF1aXJlKFwiLi9zcGVjXCIpO1xuZXhwb3J0cy5zdGFjayA9IHJlcXVpcmUoXCIuL3N0YWNrXCIpO1xuZXhwb3J0cy50aW1lVW5pdCA9IHJlcXVpcmUoXCIuL3RpbWV1bml0XCIpO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1cIik7XG5leHBvcnRzLnR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuZXhwb3J0cy51dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmV4cG9ydHMudmFsaWRhdGUgPSByZXF1aXJlKFwiLi92YWxpZGF0ZVwiKTtcbmV4cG9ydHMudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lkbXd1YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTh1TGk5emNtTXZkbXd1ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN1FVRkJRU3hwUTBGQmRVTTdRVUZEZGtNc01rTkJRV2xFTzBGQlEycEVMQ3RDUVVGeFF6dEJRVU55UXl4MVEwRkJOa003UVVGRE4wTXNiVVJCUVhsRU8wRkJRM3BFTERaRFFVRXlRenRCUVVGdVF5dzBRa0ZCUVN4UFFVRlBMRU5CUVVFN1FVRkRaaXh4UTBGQk1rTTdRVUZETTBNc2FVTkJRWFZETzBGQlEzWkRMSGxEUVVFclF6dEJRVU12UXl4NVEwRkJLME03UVVGREwwTXNiVU5CUVhsRE8wRkJRM3BETEhsRFFVRXJRenRCUVVNdlF5eHhRMEZCTWtNN1FVRkRNME1zYVVOQlFYVkRPMEZCUTNaRExHMURRVUY1UXp0QlFVTjZReXhwUTBGQmRVTTdRVUZEZGtNc2FVTkJRWFZETzBGQlEzWkRMRzFEUVVGNVF6dEJRVU42UXl4NVEwRkJLME03UVVGREwwTXNNa05CUVdsRU8wRkJRMnBFTEdsRFFVRjFRenRCUVVOMlF5eHBRMEZCZFVNN1FVRkRka01zZVVOQlFTdERPMEZCUld4RExGRkJRVUVzVDBGQlR5eEhRVUZYTEU5QlFVOHNRMEZCUXl4cFFrRkJhVUlzUTBGQlF5eERRVUZETEU5QlFVOHNRMEZCUXlKOSIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC52ZWdhID0gZ2xvYmFsLnZlZ2EgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBhY2Nlc3NvciA9IGZ1bmN0aW9uKGZuLCBmaWVsZHMsIG5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICBmbi5maWVsZHMgPSBmaWVsZHMgfHwgW10sXG4gICAgZm4uZm5hbWUgPSBuYW1lLFxuICAgIGZuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGFjY2Vzc29yTmFtZShmbikge1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IG51bGwgOiBmbi5mbmFtZTtcbn1cblxuZnVuY3Rpb24gYWNjZXNzb3JGaWVsZHMoZm4pIHtcbiAgcmV0dXJuIGZuID09IG51bGwgPyBudWxsIDogZm4uZmllbGRzO1xufVxuXG52YXIgZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHRocm93IEVycm9yKG1lc3NhZ2UpO1xufVxuXG52YXIgc3BsaXRBY2Nlc3NQYXRoID0gZnVuY3Rpb24ocCkge1xuICB2YXIgcGF0aCA9IFtdLFxuICAgICAgcSA9IG51bGwsXG4gICAgICBiID0gMCxcbiAgICAgIG4gPSBwLmxlbmd0aCxcbiAgICAgIHMgPSAnJyxcbiAgICAgIGksIGosIGM7XG5cbiAgcCA9IHAgKyAnJztcblxuICBmdW5jdGlvbiBwdXNoKCkge1xuICAgIHBhdGgucHVzaChzICsgcC5zdWJzdHJpbmcoaSwgaikpO1xuICAgIHMgPSAnJztcbiAgICBpID0gaiArIDE7XG4gIH1cblxuICBmb3IgKGk9aj0wOyBqPG47ICsraikge1xuICAgIGMgPSBwW2pdO1xuICAgIGlmIChjID09PSAnXFxcXCcpIHMgKz0gcC5zdWJzdHJpbmcoaSwgaiksIGkgPSArK2o7XG4gICAgZWxzZSBpZiAoYyA9PT0gcSkgcHVzaCgpLCBxID0gbnVsbCwgYiA9IC0xO1xuICAgIGVsc2UgaWYgKHEpIGNvbnRpbnVlO1xuICAgIGVsc2UgaWYgKGkgPT09IGIgJiYgYyA9PT0gJ1wiJykgaSA9IGogKyAxLCBxID0gYztcbiAgICBlbHNlIGlmIChpID09PSBiICYmIGMgPT09IFwiJ1wiKSBpID0gaiArIDEsIHEgPSBjO1xuICAgIGVsc2UgaWYgKGMgPT09ICcuJyAmJiAhYikgKGogPiBpKSA/IHB1c2goKSA6IChpID0gaiArIDEpO1xuICAgIGVsc2UgaWYgKGMgPT09ICdbJykge1xuICAgICAgaWYgKGogPiBpKSBwdXNoKCk7XG4gICAgICBiID0gaSA9IGogKyAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgIGlmICghYikgZXJyb3IoJ0FjY2VzcyBwYXRoIG1pc3Npbmcgb3BlbiBicmFja2V0OiAnICsgcCk7XG4gICAgICBpZiAoYiA+IDApIHB1c2goKTtcbiAgICAgIGIgPSAwO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChiKSBlcnJvcignQWNjZXNzIHBhdGggbWlzc2luZyBjbG9zaW5nIGJyYWNrZXQ6ICcgKyBwKTtcbiAgaWYgKHEpIGVycm9yKCdBY2Nlc3MgcGF0aCBtaXNzaW5nIGNsb3NpbmcgcXVvdGU6ICcgKyBwKTtcbiAgaWYgKGogPiBpKSArK2osIHB1c2goKTtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gXyA9PT0gT2JqZWN0KF8pO1xufVxuXG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uICQoeCkge1xuICByZXR1cm4gaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKCQpICsgJ10nXG4gICAgOiBpc09iamVjdCh4KSB8fCBpc1N0cmluZyh4KSA/XG4gICAgICAvLyBPdXRwdXQgdmFsaWQgSlNPTiBhbmQgSlMgc291cmNlIHN0cmluZ3MuXG4gICAgICAvLyBTZWUgaHR0cDovL3RpbWVsZXNzcmVwby5jb20vanNvbi1pc250LWEtamF2YXNjcmlwdC1zdWJzZXRcbiAgICAgIEpTT04uc3RyaW5naWZ5KHgpLnJlcGxhY2UoJ1xcdTIwMjgnLCdcXFxcdTIwMjgnKS5yZXBsYWNlKCdcXHUyMDI5JywgJ1xcXFx1MjAyOScpXG4gICAgOiB4O1xufVxuXG52YXIgZmllbGQgPSBmdW5jdGlvbihmaWVsZCwgbmFtZSkge1xuICB2YXIgcGF0aCA9IHNwbGl0QWNjZXNzUGF0aChmaWVsZCksXG4gICAgICBjb2RlID0gJ3JldHVybiBfWycgKyBwYXRoLm1hcCgkKS5qb2luKCddWycpICsgJ107JztcblxuICByZXR1cm4gYWNjZXNzb3IoXG4gICAgRnVuY3Rpb24oJ18nLCBjb2RlKSxcbiAgICBbKGZpZWxkID0gcGF0aC5sZW5ndGg9PT0xID8gcGF0aFswXSA6IGZpZWxkKV0sXG4gICAgbmFtZSB8fCBmaWVsZFxuICApO1xufVxuXG52YXIgZW1wdHkgPSBbXTtcblxudmFyIGlkID0gZmllbGQoJ2lkJyk7XG5cbnZhciBpZGVudGl0eSA9IGFjY2Vzc29yKGZ1bmN0aW9uKF8pIHsgcmV0dXJuIF87IH0sIGVtcHR5LCAnaWRlbnRpdHknKTtcblxudmFyIHplcm8gPSBhY2Nlc3NvcihmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sIGVtcHR5LCAnemVybycpO1xuXG52YXIgb25lID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9LCBlbXB0eSwgJ29uZScpO1xuXG52YXIgdHJ1dGh5ID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LCBlbXB0eSwgJ3RydWUnKTtcblxudmFyIGZhbHN5ID0gYWNjZXNzb3IoZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSwgZW1wdHksICdmYWxzZScpO1xuXG5mdW5jdGlvbiBsb2cobWV0aG9kLCBsZXZlbCwgaW5wdXQpIHtcbiAgdmFyIGFyZ3MgPSBbbGV2ZWxdLmNvbmNhdChbXS5zbGljZS5jYWxsKGlucHV0KSk7XG4gIGNvbnNvbGVbbWV0aG9kXS5hcHBseShjb25zb2xlLCBhcmdzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG59XG5cbnZhciBOb25lICA9IDA7XG52YXIgV2FybiAgPSAxO1xudmFyIEluZm8gID0gMjtcbnZhciBEZWJ1ZyA9IDM7XG5cbnZhciBsb2dnZXIgPSBmdW5jdGlvbihfKSB7XG4gIHZhciBsZXZlbCA9IF8gfHwgTm9uZTtcbiAgcmV0dXJuIHtcbiAgICBsZXZlbDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGV2ZWwgPSArXywgdGhpcykgOiBsZXZlbDtcbiAgICB9LFxuICAgIHdhcm46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxldmVsID49IFdhcm4pIGxvZygnd2FybicsICdXQVJOJywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gSW5mbykgbG9nKCdsb2cnLCAnSU5GTycsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlYnVnOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsZXZlbCA+PSBEZWJ1ZykgbG9nKCdsb2cnLCAnREVCVUcnLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG59XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIF8gIT0gbnVsbCA/IChpc0FycmF5KF8pID8gXyA6IFtfXSkgOiBbXTtcbn1cblxudmFyIGNvbXBhcmUgPSBmdW5jdGlvbihmaWVsZHMsIG9yZGVycykge1xuICB2YXIgaWR4ID0gW10sXG4gICAgICBjbXAgPSAoZmllbGRzID0gYXJyYXkoZmllbGRzKSkubWFwKGZ1bmN0aW9uKGYsIGkpIHtcbiAgICAgICAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGxcbiAgICAgICAgICA6IChpZHgucHVzaChpKSwgc3BsaXRBY2Nlc3NQYXRoKGYpLm1hcCgkKS5qb2luKCddWycpKTtcbiAgICAgIH0pLFxuICAgICAgbiA9IGlkeC5sZW5ndGggLSAxLFxuICAgICAgb3JkID0gYXJyYXkob3JkZXJzKSxcbiAgICAgIGNvZGUgPSAndmFyIHUsdjtyZXR1cm4gJyxcbiAgICAgIGksIGosIGYsIHUsIHYsIGQsIGx0LCBndDtcblxuICBpZiAobiA8IDApIHJldHVybiBudWxsO1xuXG4gIGZvciAoaj0wOyBqPD1uOyArK2opIHtcbiAgICBpID0gaWR4W2pdO1xuICAgIGYgPSBjbXBbaV07XG4gICAgdSA9ICcodT1hWycrZisnXSknO1xuICAgIHYgPSAnKHY9YlsnK2YrJ10pJztcbiAgICBkID0gJygodj12IGluc3RhbmNlb2YgRGF0ZT8rdjp2KSwodT11IGluc3RhbmNlb2YgRGF0ZT8rdTp1KSknO1xuICAgIGx0ID0gb3JkW2ldICE9PSAnZGVzY2VuZGluZycgPyAoZ3Q9MSwgLTEpIDogKGd0PS0xLCAxKTtcbiAgICBjb2RlICs9ICcoJyArIHUrJzwnK3YrJ3x8dT09bnVsbCkmJnYhPW51bGw/JyArIGx0XG4gICAgICArICc6KHU+dnx8dj09bnVsbCkmJnUhPW51bGw/JyArIGd0XG4gICAgICArICc6JytkKychPT11JiZ2PT09dj8nICsgbHRcbiAgICAgICsgJzp2IT09diYmdT09PXU/JyArIGd0XG4gICAgICArIChpIDwgbiA/ICc6JyA6ICc6MCcpO1xuICB9XG5cbiAgcmV0dXJuIGFjY2Vzc29yKFxuICAgIEZ1bmN0aW9uKCdhJywgJ2InLCBjb2RlICsgJzsnKSxcbiAgICBmaWVsZHMuZmlsdGVyKGZ1bmN0aW9uKF8pIHsgcmV0dXJuIF8gIT0gbnVsbDsgfSlcbiAgKTtcbn1cblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gaXNGdW5jdGlvbihfKSA/IF8gOiBmdW5jdGlvbigpIHsgcmV0dXJuIF87IH07XG59XG5cbnZhciBleHRlbmQgPSBmdW5jdGlvbihfKSB7XG4gIGZvciAodmFyIHgsIGssIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAoayBpbiB4KSB7IF9ba10gPSB4W2tdOyB9XG4gIH1cbiAgcmV0dXJuIF87XG59XG5cbnZhciBleHRlbnRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgYSwgYiwgYywgdSwgdjtcblxuICBpZiAoZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikgeyBhID0gYyA9IGI7IGJyZWFrOyB9XG4gICAgdSA9IHYgPSBpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGEgPiBiKSBhID0gYiwgdSA9IGk7XG4gICAgICBpZiAoYyA8IGIpIGMgPSBiLCB2ID0gaTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KSkgIT0gbnVsbCAmJiBiID49IGIpIHsgYSA9IGMgPSBiOyBicmVhazsgfVxuICAgIHUgPSB2ID0gaTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoYSA+IGIpIGEgPSBiLCB1ID0gaTtcbiAgICAgIGlmIChjIDwgYikgYyA9IGIsIHYgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbdSwgdl07XG59XG5cbnZhciBOVUxMID0ge307XG5cbnZhciBmYXN0bWFwID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG9iaiA9IHt9LFxuICAgICAgbWFwLFxuICAgICAgdGVzdDtcblxuICBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldICE9PSBOVUxMO1xuICB9XG5cbiAgbWFwID0ge1xuICAgIHNpemU6IDAsXG4gICAgZW1wdHk6IDAsXG4gICAgb2JqZWN0OiBvYmosXG4gICAgaGFzOiBoYXMsXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoYXMoa2V5KSA/IG9ialtrZXldIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWhhcyhrZXkpKSB7XG4gICAgICAgICsrbWFwLnNpemU7XG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gTlVMTCkgLS1tYXAuZW1wdHk7XG4gICAgICB9XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGhhcyhrZXkpKSB7XG4gICAgICAgIC0tbWFwLnNpemU7XG4gICAgICAgICsrbWFwLmVtcHR5O1xuICAgICAgICBvYmpba2V5XSA9IE5VTEw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIG1hcC5zaXplID0gbWFwLmVtcHR5ID0gMDtcbiAgICAgIG1hcC5vYmplY3QgPSBvYmogPSB7fTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRlc3QgPSBfLCBtYXApIDogdGVzdDtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXh0ID0ge30sXG4gICAgICAgICAgc2l6ZSA9IDAsXG4gICAgICAgICAga2V5LCB2YWx1ZTtcbiAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodmFsdWUgIT09IE5VTEwgJiYgKCF0ZXN0IHx8ICF0ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgICBuZXh0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICArK3NpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1hcC5zaXplID0gc2l6ZTtcbiAgICAgIG1hcC5lbXB0eSA9IDA7XG4gICAgICBtYXAub2JqZWN0ID0gKG9iaiA9IG5leHQpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoaW5wdXQpIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIG1hcC5zZXQoa2V5LCBpbnB1dFtrZXldKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuICB2YXIgcHJvdG8gPSAoY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKSk7XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIHJldHVybiBwcm90bztcbn1cblxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdudW1iZXInO1xufVxuXG52YXIga2V5ID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyA/IGFycmF5KGZpZWxkcykgOiBmaWVsZHM7XG4gIHZhciBmbiA9ICEoZmllbGRzICYmIGZpZWxkcy5sZW5ndGgpXG4gICAgPyBmdW5jdGlvbigpIHsgcmV0dXJuICcnOyB9XG4gICAgOiBGdW5jdGlvbignXycsICdyZXR1cm4gXFwnXFwnKycgK1xuICAgICAgICBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gJ19bJyArIHNwbGl0QWNjZXNzUGF0aChmKS5tYXAoJCkuam9pbignXVsnKSArICddJztcbiAgICAgICAgfSkuam9pbignK1xcJ3xcXCcrJykgKyAnOycpO1xuICByZXR1cm4gYWNjZXNzb3IoZm4sIGZpZWxkcywgJ2tleScpO1xufVxuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbihjb21wYXJlLCBhcnJheTAsIGFycmF5MSwgb3V0cHV0KSB7XG4gIHZhciBuMCA9IGFycmF5MC5sZW5ndGgsXG4gICAgICBuMSA9IGFycmF5MS5sZW5ndGg7XG5cbiAgaWYgKCFuMSkgcmV0dXJuIGFycmF5MDtcbiAgaWYgKCFuMCkgcmV0dXJuIGFycmF5MTtcblxuICB2YXIgbWVyZ2VkID0gb3V0cHV0IHx8IG5ldyBhcnJheTAuY29uc3RydWN0b3IobjAgKyBuMSksXG4gICAgICBpMCA9IDAsIGkxID0gMCwgaSA9IDA7XG5cbiAgZm9yICg7IGkwPG4wICYmIGkxPG4xOyArK2kpIHtcbiAgICBtZXJnZWRbaV0gPSBjb21wYXJlKGFycmF5MFtpMF0sIGFycmF5MVtpMV0pID4gMFxuICAgICAgID8gYXJyYXkxW2kxKytdXG4gICAgICAgOiBhcnJheTBbaTArK107XG4gIH1cblxuICBmb3IgKDsgaTA8bjA7ICsraTAsICsraSkge1xuICAgIG1lcmdlZFtpXSA9IGFycmF5MFtpMF07XG4gIH1cblxuICBmb3IgKDsgaTE8bjE7ICsraTEsICsraSkge1xuICAgIG1lcmdlZFtpXSA9IGFycmF5MVtpMV07XG4gIH1cblxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG52YXIgcmVwZWF0ID0gZnVuY3Rpb24oc3RyLCByZXBzKSB7XG4gIHZhciBzID0gJyc7XG4gIHdoaWxlICgtLXJlcHMgPj0gMCkgcyArPSBzdHI7XG4gIHJldHVybiBzO1xufVxuXG52YXIgcGFkID0gZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHBhZGNoYXIsIGFsaWduKSB7XG4gIHZhciBjID0gcGFkY2hhciB8fCAnICcsXG4gICAgICBzID0gc3RyICsgJycsXG4gICAgICBuID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG5cbiAgcmV0dXJuIG4gPD0gMCA/IHNcbiAgICA6IGFsaWduID09PSAnbGVmdCcgPyByZXBlYXQoYywgbikgKyBzXG4gICAgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyByZXBlYXQoYywgfn4obi8yKSkgKyBzICsgcmVwZWF0KGMsIE1hdGguY2VpbChuLzIpKVxuICAgIDogcyArIHJlcGVhdChjLCBuKTtcbn1cblxudmFyIHBlZWsgPSBmdW5jdGlvbihhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG59XG5cbnZhciB0b1NldCA9IGZ1bmN0aW9uKF8pIHtcbiAgZm9yICh2YXIgcz17fSwgaT0wLCBuPV8ubGVuZ3RoOyBpPG47ICsraSkgc1tfW2ldXSA9IDE7XG4gIHJldHVybiBzO1xufVxuXG52YXIgdHJ1bmNhdGUgPSBmdW5jdGlvbihzdHIsIGxlbmd0aCwgYWxpZ24sIGVsbGlwc2lzKSB7XG4gIHZhciBlID0gZWxsaXBzaXMgIT0gbnVsbCA/IGVsbGlwc2lzIDogJ1xcdTIwMjYnLFxuICAgICAgcyA9IHN0ciArICcnLFxuICAgICAgbiA9IHMubGVuZ3RoLFxuICAgICAgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGUubGVuZ3RoKTtcblxuICByZXR1cm4gbiA8PSBsZW5ndGggPyBzXG4gICAgOiBhbGlnbiA9PT0gJ2xlZnQnID8gZSArIHMuc2xpY2UobiAtIGwpXG4gICAgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyBzLnNsaWNlKDAsIE1hdGguY2VpbChsLzIpKSArIGUgKyBzLnNsaWNlKG4gLSB+fihsLzIpKVxuICAgIDogcy5zbGljZSgwLCBsKSArIGU7XG59XG5cbnZhciB2aXNpdEFycmF5ID0gZnVuY3Rpb24oYXJyYXksIGZpbHRlciwgdmlzaXRvcikge1xuICBpZiAoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIHQ7XG4gICAgaWYgKGZpbHRlcikge1xuICAgICAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgICAgIGlmICh0ID0gZmlsdGVyKGFycmF5W2ldKSkgdmlzaXRvcih0LCBpLCBhcnJheSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5LmZvckVhY2godmlzaXRvcik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuYWNjZXNzb3IgPSBhY2Nlc3NvcjtcbmV4cG9ydHMuYWNjZXNzb3JOYW1lID0gYWNjZXNzb3JOYW1lO1xuZXhwb3J0cy5hY2Nlc3NvckZpZWxkcyA9IGFjY2Vzc29yRmllbGRzO1xuZXhwb3J0cy5pZCA9IGlkO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy56ZXJvID0gemVybztcbmV4cG9ydHMub25lID0gb25lO1xuZXhwb3J0cy50cnV0aHkgPSB0cnV0aHk7XG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG5leHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcbmV4cG9ydHMuTm9uZSA9IE5vbmU7XG5leHBvcnRzLldhcm4gPSBXYXJuO1xuZXhwb3J0cy5JbmZvID0gSW5mbztcbmV4cG9ydHMuRGVidWcgPSBEZWJ1ZztcbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5leHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5leHBvcnRzLmVycm9yID0gZXJyb3I7XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmV4cG9ydHMuZXh0ZW50SW5kZXggPSBleHRlbnRJbmRleDtcbmV4cG9ydHMuZmFzdG1hcCA9IGZhc3RtYXA7XG5leHBvcnRzLmZpZWxkID0gZmllbGQ7XG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMua2V5ID0ga2V5O1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5wYWQgPSBwYWQ7XG5leHBvcnRzLnBlZWsgPSBwZWVrO1xuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XG5leHBvcnRzLnNwbGl0QWNjZXNzUGF0aCA9IHNwbGl0QWNjZXNzUGF0aDtcbmV4cG9ydHMuc3RyaW5nVmFsdWUgPSAkO1xuZXhwb3J0cy50b1NldCA9IHRvU2V0O1xuZXhwb3J0cy50cnVuY2F0ZSA9IHRydW5jYXRlO1xuZXhwb3J0cy52aXNpdEFycmF5ID0gdmlzaXRBcnJheTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsImltcG9ydCB7RmllbGRPcHRpb24sIE9wdGlvbn0gZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7c3VwcGxlbWVudGVkRmllbGRPcHRpb259IGZyb20gJy4vc3VwcGxlbWVudGVkRmllbGRPcHRpb24nO1xuaW1wb3J0IHtNYXAsIG1hcCBhcyBkM21hcH0gZnJvbSAnZDMtY29sbGVjdGlvbic7XG5pbXBvcnQge0VudGVyRWxlbWVudCwgc2VsZWN0LCBTZWxlY3Rpb259IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgKiBhcyBkbCBmcm9tICdkYXRhbGliJztcbmltcG9ydCB7RmllbGREZWZ9IGZyb20gJ3ZlZ2EtbGl0ZS9idWlsZC9zcmMvZmllbGRkZWYnO1xuaW1wb3J0IHtUb3BMZXZlbEV4dGVuZGVkU3BlY30gZnJvbSAndmVnYS1saXRlL2J1aWxkL3NyYy9zcGVjJztcbmltcG9ydCB7VEVNUE9SQUx9IGZyb20gJ3ZlZ2EtbGl0ZS9idWlsZC9zcmMvdHlwZSc7XG5pbXBvcnQgKiBhcyB2bCBmcm9tICd2ZWdhLWxpdGUvYnVpbGQvc3JjL3ZsJztcblxuLy8gYnkgZGVmYXVsdCwgZGVsYXkgc2hvd2luZyB0b29sdGlwIGZvciAxMDAgbXNcbnZhciBERUxBWSA9IDEwMDtcbnZhciB0b29sdGlwUHJvbWlzZTogbnVtYmVyID0gdW5kZWZpbmVkO1xudmFyIHRvb2x0aXBBY3RpdmUgPSBmYWxzZTtcblxuZXhwb3J0IHR5cGUgVmdWaWV3ID0gYW55O1xudHlwZSBTY2VuZUdyYXBoID0ge1xuICBkYXR1bToge1xuICAgIF9mYWNldElEOiBhbnksXG4gICAgX2lkOiBhbnlcbiAgfSxcbiAgbWFyazogeyBcbiAgICBtYXJrdHlwZTogc3RyaW5nIFxuICB9XG59O1xudHlwZSBUb29sVGlwRGF0YSA9IHt0aXRsZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfTtcblxuLyoqXG4qIEV4cG9ydCBBUEkgZm9yIFZlZ2EgdmlzdWFsaXphdGlvbnM6IHZnLnRvb2x0aXAodmdWaWV3LCBvcHRpb25zKVxuKiBvcHRpb25zIGNhbiBzcGVjaWZ5IHdoZXRoZXIgdG8gc2hvdyBhbGwgZmllbGRzIG9yIHRvIHNob3cgb25seSBjdXN0b20gZmllbGRzXG4qIEl0IGNhbiBhbHNvIHByb3ZpZGUgY3VzdG9tIHRpdGxlIGFuZCBmb3JtYXQgZm9yIGZpZWxkc1xuKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZWdhKHZnVmlldzogVmdWaWV3LCBvcHRpb25zOiBPcHRpb24gPSB7fSkge1xuICAvLyBUT0RPOiBjaGFuZ2UgaXRlbSB0eXBlIHRvIHZlZ2Egc2NlbmVncmFwaFxuXG4gIC8vIGluaXRpYWxpemUgdG9vbHRpcCB3aXRoIGl0ZW0gZGF0YSBhbmQgb3B0aW9ucyBvbiBtb3VzZSBvdmVyXG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyLnRvb2x0aXBJbml0XCIsIGZ1bmN0aW9uIChldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCkge1xuICAgIGlmIChzaG91bGRTaG93VG9vbHRpcChpdGVtKSkge1xuICAgICAgLy8gY2xlYXIgZXhpc3RpbmcgcHJvbWlzZSBiZWNhdXNlIG1vdXNlIGNhbiBvbmx5IHBvaW50IGF0IG9uZSB0aGluZyBhdCBhIHRpbWVcbiAgICAgIGNhbmNlbFByb21pc2UoKTtcblxuICAgICAgdG9vbHRpcFByb21pc2UgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXQoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgfSwgb3B0aW9ucy5kZWxheSB8fCBERUxBWSk7XG4gICAgfVxuICB9KTtcblxuICAvLyB1cGRhdGUgdG9vbHRpcCBwb3NpdGlvbiBvbiBtb3VzZSBtb3ZlXG4gIC8vIChpbXBvcnRhbnQgZm9yIGxhcmdlIG1hcmtzIGUuZy4gYmFycylcbiAgdmdWaWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmUudG9vbHRpcFVwZGF0ZVwiLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkgJiYgdG9vbHRpcEFjdGl2ZSkge1xuICAgICAgdXBkYXRlKGV2ZW50LCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNsZWFyIHRvb2x0aXAgb24gbW91c2Ugb3V0XG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXQudG9vbHRpcFJlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkpIHtcbiAgICAgIGNhbmNlbFByb21pc2UoKTtcblxuICAgICAgaWYgKHRvb2x0aXBBY3RpdmUpIHtcbiAgICAgICAgY2xlYXIoZXZlbnQsIGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3Zlci50b29sdGlwSW5pdFwiKTtcbiAgICAgIHZnVmlldy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlLnRvb2x0aXBVcGRhdGVcIik7XG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0LnRvb2x0aXBSZW1vdmVcIik7XG5cbiAgICAgIGNhbmNlbFByb21pc2UoKTsgLy8gY2xlYXIgdG9vbHRpcCBwcm9taXNlXG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogRXhwb3J0IEFQSSBmb3IgVmVnYS1MaXRlIHZpc3VhbGl6YXRpb25zOiB2bC50b29sdGlwKHZnVmlldywgdmxTcGVjLCBvcHRpb25zKVxuKiBvcHRpb25zIGNhbiBzcGVjaWZ5IHdoZXRoZXIgdG8gc2hvdyBhbGwgZmllbGRzIG9yIHRvIHNob3cgb25seSBjdXN0b20gZmllbGRzXG4qIEl0IGNhbiBhbHNvIHByb3ZpZGUgY3VzdG9tIHRpdGxlIGFuZCBmb3JtYXQgZm9yIGZpZWxkc1xuKiBvcHRpb25zIGNhbiBiZSBzdXBwbGVtZW50ZWQgYnkgdmxTcGVjXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHZlZ2FMaXRlKHZnVmlldzogVmdWaWV3LCB2bFNwZWM6IFRvcExldmVsRXh0ZW5kZWRTcGVjLCBvcHRpb25zOiBPcHRpb24gPSB7fSkge1xuXG4gIG9wdGlvbnMgPSBzdXBwbGVtZW50T3B0aW9ucyhvcHRpb25zLCB2bFNwZWMpO1xuXG4gIC8vIFRPRE86IHVwZGF0ZSB0aGlzIHRvIHVzZSBuZXcgdmVnYS12aWV3IGFwaSAoYWRkRXZlbnRMaXN0ZW5lcilcbiAgLy8gaW5pdGlhbGl6ZSB0b29sdGlwIHdpdGggaXRlbSBkYXRhIGFuZCBvcHRpb25zIG9uIG1vdXNlIG92ZXJcbiAgdmdWaWV3LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGV2ZW50OiBNb3VzZUV2ZW50LCBpdGVtOiBTY2VuZUdyYXBoKSB7XG4gICAgaWYgKHNob3VsZFNob3dUb29sdGlwKGl0ZW0pKSB7XG4gICAgICAvLyBjbGVhciBleGlzdGluZyBwcm9taXNlIGJlY2F1c2UgbW91c2UgY2FuIG9ubHkgcG9pbnQgYXQgb25lIHRoaW5nIGF0IGEgdGltZVxuICAgICAgY2FuY2VsUHJvbWlzZSgpO1xuXG4gICAgICAvLyBtYWtlIGEgbmV3IHByb21pc2Ugd2l0aCB0aW1lIGRlbGF5IGZvciB0b29sdGlwXG4gICAgICB0b29sdGlwUHJvbWlzZSA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdChldmVudCwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICB9LCBvcHRpb25zLmRlbGF5IHx8IERFTEFZKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uIG9uIG1vdXNlIG1vdmVcbiAgLy8gKGltcG9ydGFudCBmb3IgbGFyZ2UgbWFya3MgZS5nLiBiYXJzKVxuICB2Z1ZpZXcuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgICBpZiAoc2hvdWxkU2hvd1Rvb2x0aXAoaXRlbSkgJiYgdG9vbHRpcEFjdGl2ZSkge1xuICAgICAgdXBkYXRlKGV2ZW50LCBpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNsZWFyIHRvb2x0aXAgb24gbW91c2Ugb3V0XG4gIHZnVmlldy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGV2ZW50OiBNb3VzZUV2ZW50LCBpdGVtOiBTY2VuZUdyYXBoKSB7XG4gICAgaWYgKHNob3VsZFNob3dUb29sdGlwKGl0ZW0pKSB7XG4gICAgICBjYW5jZWxQcm9taXNlKCk7XG5cbiAgICAgIGlmICh0b29sdGlwQWN0aXZlKSB7XG4gICAgICAgIGNsZWFyKGV2ZW50LCBpdGVtLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdmdWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXIudG9vbHRpcEluaXRcIik7XG4gICAgICB2Z1ZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZS50b29sdGlwVXBkYXRlXCIpO1xuICAgICAgdmdWaWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dC50b29sdGlwUmVtb3ZlXCIpO1xuXG4gICAgICBjYW5jZWxQcm9taXNlKCk7IC8vIGNsZWFyIHRvb2x0aXAgcHJvbWlzZVxuICAgIH1cbiAgfSBcbn07XG5cbi8qIENhbmNlbCB0b29sdGlwIHByb21pc2UgKi9cbmZ1bmN0aW9uIGNhbmNlbFByb21pc2UoKSB7XG4gIC8qIFdlIGRvbid0IGNoZWNrIGlmIHRvb2x0aXBQcm9taXNlIGlzIHZhbGlkIGJlY2F1c2UgcGFzc2luZ1xuICAgYW4gaW52YWxpZCBJRCB0byBjbGVhclRpbWVvdXQgZG9lcyBub3QgaGF2ZSBhbnkgZWZmZWN0XG4gICAoYW5kIGRvZXNuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uKS4gKi9cbiAgd2luZG93LmNsZWFyVGltZW91dCh0b29sdGlwUHJvbWlzZSk7XG4gIHRvb2x0aXBQcm9taXNlID0gdW5kZWZpbmVkO1xufVxuXG4vKiBkM21hcHBpbmcgZnJvbSBmaWVsZERlZi50eXBlIHRvIGZvcm1hdFR5cGUgKi9cbnZhciBmb3JtYXRUeXBlTWFwOiB7W3R5cGU6IHN0cmluZ106ICdudW1iZXInIHwgJ3RpbWUnfSA9IHtcbiAgXCJxdWFudGl0YXRpdmVcIjogXCJudW1iZXJcIixcbiAgXCJ0ZW1wb3JhbFwiOiBcInRpbWVcIixcbiAgXCJvcmRpbmFsXCI6IHVuZGVmaW5lZCxcbiAgXCJub21pbmFsXCI6IHVuZGVmaW5lZFxufVxuXG4vKipcbiogKFZlZ2EtTGl0ZSBvbmx5KSBTdXBwbGVtZW50IG9wdGlvbnMgd2l0aCB2bFNwZWNcbipcbiogQHBhcmFtIG9wdGlvbnMgLSB1c2VyLXByb3ZpZGVkIG9wdGlvbnNcbiogQHBhcmFtIHZsU3BlYyAtIHZlZ2EtbGl0ZSBzcGVjXG4qIEByZXR1cm4gdGhlIHZsU3BlYy1zdXBwbGVtZW50ZWQgb3B0aW9ucyBvYmplY3RcbipcbiogaWYgb3B0aW9ucy5zaG93QWxsRmllbGRzIGlzIHRydWUgb3IgdW5kZWZpbmVkLCB2bFNwZWMgd2lsbCBzdXBwbGVtZW50XG4qIG9wdGlvbnMuZmllbGRzIHdpdGggYWxsIGZpZWxkcyBpbiB0aGUgc3BlY1xuKiBpZiBvcHRpb25zLnNob3dBbGxGaWVsZHMgaXMgZmFsc2UsIHZsU3BlYyB3aWxsIG9ubHkgc3VwcGxlbWVudCBleGlzdGluZyBmaWVsZHNcbiogaW4gb3B0aW9ucy5maWVsZHNcbiovXG5mdW5jdGlvbiBzdXBwbGVtZW50T3B0aW9ucyhvcHRpb25zOiBPcHRpb24sIHZsU3BlYzogVG9wTGV2ZWxFeHRlbmRlZFNwZWMpIHtcbiAgLy8gZmllbGRzIHRvIGJlIHN1cHBsZW1lbnRlZCBieSB2bFNwZWNcbiAgdmFyIHN1cHBsZW1lbnRlZEZpZWxkczogRmllbGRPcHRpb25bXSA9IFtdO1xuXG4gIC8vIGlmIHNob3dBbGxGaWVsZHMgaXMgdHJ1ZSBvciB1bmRlZmluZWQsIHN1cHBsZW1lbnQgYWxsIGZpZWxkcyBpbiB2bFNwZWNcbiAgaWYgKG9wdGlvbnMuc2hvd0FsbEZpZWxkcyAhPT0gZmFsc2UpIHtcbiAgICB2bC5zcGVjLmZpZWxkRGVmcyh2bFNwZWMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkRGVmKSB7XG4gICAgICAvLyBnZXQgYSBmaWVsZE9wdGlvbiBpbiBvcHRpb25zIHRoYXQgbWF0Y2hlcyB0aGUgZmllbGREZWZcbiAgICAgIHZhciBmaWVsZE9wdGlvbiA9IGdldEZpZWxkT3B0aW9uKG9wdGlvbnMuZmllbGRzLCBmaWVsZERlZik7XG5cbiAgICAgIC8vIHN1cHBsZW1lbnQgdGhlIGZpZWxkT3B0aW9uIHdpdGggZmllbGREZWYgYW5kIGNvbmZpZ1xuICAgICAgdmFyIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uID0gc3VwcGxlbWVudEZpZWxkT3B0aW9uKGZpZWxkT3B0aW9uLCBmaWVsZERlZiwgdmxTcGVjKTtcblxuICAgICAgc3VwcGxlbWVudGVkRmllbGRzLnB1c2goc3VwcGxlbWVudGVkRmllbGRPcHRpb24pO1xuICAgIH0pO1xuICB9XG4gIC8vIGlmIHNob3dBbGxGaWVsZHMgaXMgZmFsc2UsIG9ubHkgc3VwcGxlbWVudCBleGlzdGluZyBmaWVsZHMgaW4gb3B0aW9ucy5maWVsZHNcbiAgZWxzZSB7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE9wdGlvbikge1xuICAgICAgICAvLyBnZXQgdGhlIGZpZWxkRGVmIGluIHZsU3BlYyB0aGF0IG1hdGNoZXMgdGhlIGZpZWxkT3B0aW9uXG4gICAgICAgIHZhciBmaWVsZERlZiA9IGdldEZpZWxkRGVmKHZsLnNwZWMuZmllbGREZWZzKHZsU3BlYyksIGZpZWxkT3B0aW9uKTtcblxuICAgICAgICAvLyBzdXBwbGVtZW50IHRoZSBmaWVsZE9wdGlvbiB3aXRoIGZpZWxkRGVmIGFuZCBjb25maWdcbiAgICAgICAgdmFyIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uID0gc3VwcGxlbWVudEZpZWxkT3B0aW9uKGZpZWxkT3B0aW9uLCBmaWVsZERlZiwgdmxTcGVjKTtcblxuICAgICAgICBzdXBwbGVtZW50ZWRGaWVsZHMucHVzaChzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbik7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMuZmllbGRzID0gc3VwcGxlbWVudGVkRmllbGRzO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiogRmluZCBhIGZpZWxkT3B0aW9uIGluIGZpZWxkT3B0aW9ucyB0aGF0IG1hdGNoZXMgYSBmaWVsZERlZlxuKlxuKiBAcGFyYW0ge09iamVjdFtdfSBmaWVsZE9wdGlvbnNzIC0gYSBsaXN0IG9mIGZpZWxkIG9wdGlvbnMgKGkuZS4gb3B0aW9ucy5maWVsZHNbXSlcbiogQHBhcmFtIHtPYmplY3R9IGZpZWxkRGVmIC0gZnJvbSB2bFNwZWNcbiogQHJldHVybiB0aGUgbWF0Y2hpbmcgZmllbGRPcHRpb24sIG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaCB3YXMgZm91bmRcbipcbiogSWYgdGhlIGZpZWxkRGVmIGlzIGFnZ3JlZ2F0ZWQsIGZpbmQgYSBmaWVsZE9wdGlvbiB0aGF0IG1hdGNoZXMgdGhlIGZpZWxkIG5hbWUgYW5kXG4qIHRoZSBhZ2dyZWdhdGlvbiBvZiB0aGUgZmllbGREZWYuXG4qIElmIHRoZSBmaWVsZERlZiBpcyBub3QgYWdncmVnYXRlZCwgZmluZCBhIGZpZWxkT3B0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgZmllbGQgbmFtZS5cbiovXG5mdW5jdGlvbiBnZXRGaWVsZE9wdGlvbihmaWVsZE9wdGlvbnM6IEZpZWxkT3B0aW9uW10sIGZpZWxkRGVmOiBGaWVsZERlZikge1xuICBpZiAoIWZpZWxkRGVmIHx8ICFmaWVsZE9wdGlvbnMgfHwgZmllbGRPcHRpb25zLmxlbmd0aCA8PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIC8vIGlmIGFnZ3JlZ2F0ZSwgbWF0Y2ggZmllbGQgbmFtZSBhbmQgYWdncmVnYXRlIG9wZXJhdGlvblxuICBpZiAoZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgLy8gdHJ5IGZpbmQgdGhlIHBlcmZlY3QgbWF0Y2g6IGZpZWxkIG5hbWUgZXF1YWxzLCBhZ2dyZWdhdGUgb3BlcmF0aW9uIGVxdWFsc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmllbGRPcHRpb24gPSBmaWVsZE9wdGlvbnNbaV07XG4gICAgICBpZiAoZmllbGRPcHRpb24uZmllbGQgPT09IGZpZWxkRGVmLmZpZWxkICYmIGZpZWxkT3B0aW9uLmFnZ3JlZ2F0ZSA9PT0gZmllbGREZWYuYWdncmVnYXRlKSB7XG4gICAgICAgIHJldHVybiBmaWVsZE9wdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cnkgZmluZCB0aGUgc2Vjb25kLWJlc3QgbWF0Y2g6IGZpZWxkIG5hbWUgZXF1YWxzLCBmaWVsZC5hZ2dyZWdhdGUgaXMgbm90IHNwZWNpZmllZFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRPcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmllbGRPcHRpb24gPSBmaWVsZE9wdGlvbnNbaV07XG4gICAgICBpZiAoZmllbGRPcHRpb24uZmllbGQgPT09IGZpZWxkRGVmLmZpZWxkICYmICFmaWVsZE9wdGlvbi5hZ2dyZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkT3B0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICAvLyBpZiBub3QgYWdncmVnYXRlLCBqdXN0IG1hdGNoIGZpZWxkIG5hbWVcbiAgZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmaWVsZE9wdGlvbiA9IGZpZWxkT3B0aW9uc1tpXTtcbiAgICAgIGlmIChmaWVsZE9wdGlvbi5maWVsZCA9PT0gZmllbGREZWYuZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkT3B0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiB1bmRlZmluZWQgaWYgbm8gbWF0Y2ggd2FzIGZvdW5kXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiogRmluZCBhIGZpZWxkRGVmIHRoYXQgbWF0Y2hlcyBhIGZpZWxkT3B0aW9uXG4qXG4qIEBwYXJhbSB7T2JqZWN0fSBmaWVsZE9wdGlvbiAtIGEgZmllbGQgb3B0aW9uIChhIG1lbWJlciBpbiBvcHRpb25zLmZpZWxkc1tdKVxuKiBAcmV0dXJuIHRoZSBtYXRjaGluZyBmaWVsZERlZiwgb3IgdW5kZWZpbmVkIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuKlxuKiBBIG1hdGNoaW5nIGZpZWxkRGVmIHNob3VsZCBoYXZlIHRoZSBzYW1lIGZpZWxkIG5hbWUgYXMgZmllbGRPcHRpb24uXG4qIElmIHRoZSBtYXRjaGluZyBmaWVsZERlZiBpcyBhZ2dyZWdhdGVkLCB0aGUgYWdncmVnYXRpb24gc2hvdWxkIG5vdCBjb250cmFkaWN0XG4qIHdpdGggdGhhdCBvZiB0aGUgZmllbGRPcHRpb24uXG4qL1xuZnVuY3Rpb24gZ2V0RmllbGREZWYoZmllbGREZWZzOiBGaWVsZERlZltdLCBmaWVsZE9wdGlvbjogRmllbGRPcHRpb24pOiBGaWVsZERlZiB7XG4gIGlmICghZmllbGRPcHRpb24gfHwgIWZpZWxkT3B0aW9uLmZpZWxkIHx8ICFmaWVsZERlZnMpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZmllbGQgbmFtZSBzaG91bGQgbWF0Y2gsIGFnZ3JlZ2F0aW9uIHNob3VsZCBub3QgZGlzYWdyZWVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZERlZnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmllbGREZWYgPSBmaWVsZERlZnNbaV07XG4gICAgaWYgKGZpZWxkRGVmLmZpZWxkID09PSBmaWVsZE9wdGlvbi5maWVsZCkge1xuICAgICAgaWYgKGZpZWxkRGVmLmFnZ3JlZ2F0ZSkge1xuICAgICAgICBpZiAoZmllbGREZWYuYWdncmVnYXRlID09PSBmaWVsZE9wdGlvbi5hZ2dyZWdhdGUgfHwgIWZpZWxkT3B0aW9uLmFnZ3JlZ2F0ZSkge1xuICAgICAgICAgIHJldHVybiBmaWVsZERlZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWVsZERlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gdW5kZWZpbmVkIGlmIG5vIG1hdGNoIHdhcyBmb3VuZFxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiogU3VwcGxlbWVudCBhIGZpZWxkT3B0aW9uIChmcm9tIG9wdGlvbnMuZmllbGRzW10pIHdpdGggYSBmaWVsZERlZiwgY29uZmlnXG4qICh3aGljaCBwcm92aWRlcyB0aW1lRm9ybWF0LCBudW1iZXJGb3JtYXQsIGNvdW50VGl0bGUpXG4qIEVpdGhlciBmaWVsZE9wdGlvbiBvciBmaWVsZERlZiBjYW4gYmUgdW5kZWZpbmVkLCBidXQgdGhleSBjYW5ub3QgYm90aCBiZSB1bmRlZmluZWQuXG4qIGNvbmZpZyAoYW5kIGl0cyBtZW1iZXJzIHRpbWVGb3JtYXQsIG51bWJlckZvcm1hdCBhbmQgY291bnRUaXRsZSkgY2FuIGJlIHVuZGVmaW5lZC5cbiogQHJldHVybiB0aGUgc3VwcGxlbWVudGVkIGZpZWxkT3B0aW9uLCBvciB1bmRlZmluZWQgb24gZXJyb3JcbiovXG5mdW5jdGlvbiBzdXBwbGVtZW50RmllbGRPcHRpb24oZmllbGRPcHRpb246IEZpZWxkT3B0aW9uLCBmaWVsZERlZjogRmllbGREZWYsIHZsU3BlYzogVG9wTGV2ZWxFeHRlbmRlZFNwZWMpIHtcbiAgLy8gbWFueSBzcGVjcyBkb24ndCBoYXZlIGNvbmZpZ1xuICB2YXIgY29uZmlnID0gdmwudXRpbC5leHRlbmQoe30sIHZsU3BlYy5jb25maWcpO1xuXG4gIC8vIGF0IGxlYXN0IG9uZSBvZiBmaWVsZE9wdGlvbiBhbmQgZmllbGREZWYgc2hvdWxkIGV4aXN0XG4gIGlmICghZmllbGRPcHRpb24gJiYgIWZpZWxkRGVmKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltUb29sdGlwXSBDYW5ub3Qgc3VwcGxlbWVudCBhIGZpZWxkIHdoZW4gZmllbGQgYW5kIGZpZWxkRGVmIGFyZSBib3RoIGVtcHR5LlwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gaWYgZWl0aGVyIG9uZSBvZiBmaWVsZE9wdGlvbiBhbmQgZmllbGREZWYgaXMgdW5kZWZpbmVkLCBtYWtlIGl0IGFuIGVtcHR5IG9iamVjdFxuICBpZiAoIWZpZWxkT3B0aW9uICYmIGZpZWxkRGVmKSBmaWVsZE9wdGlvbiA9IHt9O1xuICBpZiAoZmllbGRPcHRpb24gJiYgIWZpZWxkRGVmKSBmaWVsZERlZiA9IHt9O1xuXG4gIC8vIHRoZSBzdXBwbGVtZW50ZWQgZmllbGQgb3B0aW9uXG4gIHZhciBzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbjogc3VwcGxlbWVudGVkRmllbGRPcHRpb24gPSB7fTtcblxuICAvLyBzdXBwbGVtZW50IGEgdXNlci1wcm92aWRlZCBmaWVsZCBuYW1lIHdpdGggdW5kZXJzY29yZSBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgdG9cbiAgLy8gbWF0Y2ggdGhlIGZpZWxkIG5hbWVzIGluIGl0ZW0uZGF0dW1cbiAgLy8gZm9yIGFnZ3JlZ2F0aW9uLCB0aGlzIHdpbGwgYWRkIHByZWZpeCBcIm1lYW5fXCIgZXRjLlxuICAvLyBmb3IgdGltZVVuaXQsIHRoaXMgd2lsbCBhZGQgcHJlZml4IFwieWVhcm1vbnRoX1wiIGV0Yy5cbiAgLy8gZm9yIGJpbiwgdGhpcyB3aWxsIGFkZCBwcmVmaXggXCJiaW5fXCIgYW5kIHN1ZmZpeCBcIl9zdGFydFwiLiBMYXRlciB3ZSB3aWxsIHJlcGxhY2UgXCJfc3RhcnRcIiB3aXRoIFwiX3JhbmdlXCIuXG4gIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZpZWxkID0gZmllbGREZWYuZmllbGQgP1xuICAgIHZsLmZpZWxkRGVmLmZpZWxkKGZpZWxkRGVmKSA6IGZpZWxkT3B0aW9uLmZpZWxkO1xuXG4gIC8vIElmIGEgZmllbGREZWYgaXMgYSAoVElNRVVOSVQpVCwgd2UgY2hlY2sgaWYgdGhlIG9yaWdpbmFsIFQgaXMgcHJlc2VudCBpbiB0aGUgdmxTcGVjLlxuICAvLyBJZiBvbmx5IChUSU1FVU5JVClUIGlzIHByZXNlbnQgaW4gdmxTcGVjLCB3ZSBzZXQgYHJlbW92ZU9yaWdpbmFsVGVtcG9yYWxGaWVsZGAgdG8gVCxcbiAgLy8gd2hpY2ggd2lsbCBjYXVzZSBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVUaW1lRmllbGRzKCkgdG8gcmVtb3ZlIFQgYW5kIG9ubHkga2VlcCAoVElNRVVOSVQpVFxuICAvLyBpbiBpdGVtIGRhdGEuXG4gIC8vIElmIGJvdGggKFRJTUVVTklUKVQgYW5kIFQgYXJlIGluIHZsU3BlYywgd2Ugc2V0IGByZW1vdmVPcmlnaW5hbFRlbXBvcmFsRmllbGRgIHRvIHVuZGVmaW5lZCxcbiAgLy8gd2hpY2ggd2lsbCBsZWF2ZSBib3RoIFQgYW5kIChUSU1FVU5JVClUIGluIGl0ZW0gZGF0YS5cbiAgLy8gTm90ZTogdXNlciBzaG91bGQgbmV2ZXIgaGF2ZSB0byBwcm92aWRlIHRoaXMgYm9vbGVhbiBpbiBvcHRpb25zXG4gIGlmIChmaWVsZERlZi50eXBlID09PSBURU1QT1JBTCAmJiBmaWVsZERlZi50aW1lVW5pdCkge1xuICAgIC8vIGluIG1vc3QgY2FzZXMsIGlmIGl0J3MgYSAoVElNRVVOSVQpVCwgd2UgcmVtb3ZlIG9yaWdpbmFsIFRcbiAgICB2YXIgb3JpZ2luYWxUZW1wb3JhbEZpZWxkID0gZmllbGREZWYuZmllbGQ7XG4gICAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24ucmVtb3ZlT3JpZ2luYWxUZW1wb3JhbEZpZWxkID0gb3JpZ2luYWxUZW1wb3JhbEZpZWxkO1xuXG4gICAgLy8gaGFuZGxlIGNvcm5lciBjYXNlOiBpZiBUIGlzIHByZXNlbnQgaW4gdmxTcGVjLCB0aGVuIHdlIGtlZXAgYm90aCBUIGFuZCAoVElNRVVOSVQpVFxuICAgIHZhciBmaWVsZERlZnMgPSB2bC5zcGVjLmZpZWxkRGVmcyh2bFNwZWMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGREZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZmllbGREZWZzW2ldLmZpZWxkID09PSBvcmlnaW5hbFRlbXBvcmFsRmllbGQgJiYgIWZpZWxkRGVmc1tpXS50aW1lVW5pdCkge1xuICAgICAgICBzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbi5yZW1vdmVPcmlnaW5hbFRlbXBvcmFsRmllbGQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHN1cHBsZW1lbnQgdGl0bGVcbiAgaWYgKCFjb25maWcuY291bnRUaXRsZSkgY29uZmlnLmNvdW50VGl0bGUgPSB2bC5jb25maWcuZGVmYXVsdENvbmZpZy5jb3VudFRpdGxlOyAvLyB1c2UgdmwgZGVmYXVsdCBjb3VudFRpdGxlXG4gIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLnRpdGxlID0gZmllbGRPcHRpb24udGl0bGUgP1xuICAgIGZpZWxkT3B0aW9uLnRpdGxlIDogdmwuZmllbGREZWYudGl0bGUoZmllbGREZWYsIGNvbmZpZyk7XG5cbiAgLy8gc3VwcGxlbWVudCBmb3JtYXRUeXBlXG4gIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdFR5cGUgPSBmaWVsZE9wdGlvbi5mb3JtYXRUeXBlID9cbiAgICBmaWVsZE9wdGlvbi5mb3JtYXRUeXBlIDogZm9ybWF0VHlwZU1hcFtmaWVsZERlZi50eXBlXTtcblxuICAvLyBzdXBwbGVtZW50IGZvcm1hdFxuICBpZiAoZmllbGRPcHRpb24uZm9ybWF0KSB7XG4gICAgc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZm9ybWF0ID0gZmllbGRPcHRpb24uZm9ybWF0O1xuICB9XG4gIC8vIHdoZW4gdXNlciBkb2Vzbid0IHByb3ZpZGUgZm9ybWF0LCBzdXBwbGVtZW50IGZvcm1hdCB1c2luZyB0aW1lVW5pdCwgdGltZUZvcm1hdCwgYW5kIG51bWJlckZvcm1hdFxuICBlbHNlIHtcbiAgICBzd2l0Y2ggKHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdFR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdCA9IGZpZWxkRGVmLnRpbWVVbml0ID9cbiAgICAgICAgICAvLyBUT0RPKHplbmluZyk6IHVzZSB0ZW1wbGF0ZSBmb3IgYWxsIHRpbWUgZmllbGRzLCB0byBiZSBjb25zaXN0ZW50IHdpdGggVmVnYS1MaXRlXG4gICAgICAgICAgdmwudGltZVVuaXQuZm9ybWF0RXhwcmVzc2lvbihmaWVsZERlZi50aW1lVW5pdCwgXCJcIiwgZmFsc2UpLnNwbGl0KFwiJ1wiKVsxXVxuICAgICAgICAgIDogY29uZmlnLnRpbWVGb3JtYXQgfHwgdmwuY29uZmlnLmRlZmF1bHRDb25maWcudGltZUZvcm1hdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdCA9IGNvbmZpZy5udW1iZXJGb3JtYXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICAvLyBzdXBwbGVtZW50IGJpbiBmcm9tIGZpZWxkRGVmLCB1c2VyIHNob3VsZCBuZXZlciBoYXZlIHRvIHByb3ZpZGUgYmluIGluIG9wdGlvbnNcbiAgaWYgKGZpZWxkRGVmLmJpbikge1xuICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZpZWxkID0gc3VwcGxlbWVudGVkRmllbGRPcHRpb24uZmllbGQucmVwbGFjZShcIl9zdGFydFwiLCBcIl9yYW5nZVwiKTsgLy8gcmVwbGFjZSBzdWZmaXhcbiAgICBzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbi5iaW4gPSB0cnVlO1xuICAgIHN1cHBsZW1lbnRlZEZpZWxkT3B0aW9uLmZvcm1hdFR5cGUgPSBcInN0cmluZ1wiOyAvLyB3ZSBzaG93IGJpbiByYW5nZSBhcyBzdHJpbmcgKGUuZy4gXCI1LTEwXCIpXG4gIH1cblxuICByZXR1cm4gc3VwcGxlbWVudGVkRmllbGRPcHRpb247XG59XG5cblxuLyogSW5pdGlhbGl6ZSB0b29sdGlwIHdpdGggZGF0YSAqL1xuZnVuY3Rpb24gaW5pdChldmVudDogTW91c2VFdmVudCwgaXRlbTogU2NlbmVHcmFwaCwgb3B0aW9uczogT3B0aW9uKSB7XG4gIC8vIGdldCB0b29sdGlwIEhUTUwgcGxhY2Vob2xkZXJcbiAgdmFyIHRvb2x0aXBQbGFjZWhvbGRlciA9IGdldFRvb2x0aXBQbGFjZWhvbGRlcigpO1xuXG4gIC8vIHByZXBhcmUgZGF0YSBmb3IgdG9vbHRpcFxuICB2YXIgdG9vbHRpcERhdGEgPSBnZXRUb29sdGlwRGF0YShpdGVtLCBvcHRpb25zKTtcbiAgaWYgKCF0b29sdGlwRGF0YSB8fCB0b29sdGlwRGF0YS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAvLyBiaW5kIGRhdGEgdG8gdG9vbHRpcCBIVE1MIHBsYWNlaG9sZGVyXG4gIGJpbmREYXRhKHRvb2x0aXBQbGFjZWhvbGRlciwgdG9vbHRpcERhdGEpO1xuXG4gIHVwZGF0ZVBvc2l0aW9uKGV2ZW50LCBvcHRpb25zKTtcbiAgdXBkYXRlQ29sb3JUaGVtZShvcHRpb25zKTtcbiAgc2VsZWN0KFwiI3Zpcy10b29sdGlwXCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIik7XG4gIHRvb2x0aXBBY3RpdmUgPSB0cnVlO1xuXG4gIC8vIGludm9rZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrXG4gIGlmIChvcHRpb25zLm9uQXBwZWFyKSB7XG4gICAgb3B0aW9ucy5vbkFwcGVhcihldmVudCwgaXRlbSk7XG4gIH1cbn1cblxuLyogVXBkYXRlIHRvb2x0aXAgcG9zaXRpb24gb24gbW91c2Vtb3ZlICovXG5mdW5jdGlvbiB1cGRhdGUoZXZlbnQ6IE1vdXNlRXZlbnQsIGl0ZW06IFNjZW5lR3JhcGgsIG9wdGlvbnM6IE9wdGlvbikge1xuICB1cGRhdGVQb3NpdGlvbihldmVudCwgb3B0aW9ucyk7XG5cbiAgLy8gaW52b2tlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2tcbiAgaWYgKG9wdGlvbnMub25Nb3ZlKSB7XG4gICAgb3B0aW9ucy5vbk1vdmUoZXZlbnQsIGl0ZW0pO1xuICB9XG59XG5cbi8qIENsZWFyIHRvb2x0aXAgKi9cbmZ1bmN0aW9uIGNsZWFyKGV2ZW50OiBNb3VzZUV2ZW50LCBpdGVtOiBTY2VuZUdyYXBoLCBvcHRpb25zOiBPcHRpb24pIHtcbiAgLy8gdmlzaWJpbGl0eSBoaWRkZW4gaW5zdGVhZCBvZiBkaXNwbGF5IG5vbmVcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIGNvbXB1dGVkIHRvb2x0aXAgd2lkdGggYW5kIGhlaWdodCB0byBiZXN0IHBvc2l0aW9uIGl0XG4gIHNlbGVjdChcIiN2aXMtdG9vbHRpcFwiKS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG5cbiAgdG9vbHRpcEFjdGl2ZSA9IGZhbHNlO1xuICBjbGVhckRhdGEoKTtcbiAgY2xlYXJDb2xvclRoZW1lKCk7XG4gIGNsZWFyUG9zaXRpb24oKTtcblxuICAvLyBpbnZva2UgdXNlci1wcm92aWRlZCBjYWxsYmFja1xuICBpZiAob3B0aW9ucy5vbkRpc2FwcGVhcikge1xuICAgIG9wdGlvbnMub25EaXNhcHBlYXIoZXZlbnQsIGl0ZW0pO1xuICB9XG59XG5cblxuLyogRGVjaWRlIGlmIGEgc2NlbmVncmFwaCBpdGVtIGRlc2VydmVzIHRvb2x0aXAgKi9cbmZ1bmN0aW9uIHNob3VsZFNob3dUb29sdGlwKGl0ZW06IFNjZW5lR3JhcGgpIHtcbiAgLy8gbm8gZGF0YSwgbm8gc2hvd1xuICBpZiAoIWl0ZW0gfHwgIWl0ZW0uZGF0dW0pIHJldHVybiBmYWxzZTtcblxuICAvLyAoc21hbGwgbXVsdGlwbGVzKSBhdm9pZCBzaG93aW5nIHRvb2x0aXAgZm9yIGEgZmFjZXQncyBiYWNrZ3JvdW5kXG4gIGlmIChpdGVtLmRhdHVtLl9mYWNldElEKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gYXZvaWQgc2hvd2luZyB0b29sdGlwIGZvciBheGlzIHRpdGxlIGFuZCBsYWJlbHNcbiAgaWYgKCFpdGVtLmRhdHVtLl9pZCkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiogUHJlcGFyZSBkYXRhIGZvciB0aGUgdG9vbHRpcFxuKiBAcmV0dXJuIEFuIGFycmF5IG9mIHRvb2x0aXAgZGF0YSBbeyB0aXRsZTogLi4uLCB2YWx1ZTogLi4ufV1cbiovXG4vLyBUT0RPOiBhZGQgbWFya3R5cGVcbmZ1bmN0aW9uIGdldFRvb2x0aXBEYXRhKGl0ZW06IFNjZW5lR3JhcGgsIG9wdGlvbnM6IE9wdGlvbikge1xuICAvLyB0aGlzIGFycmF5IHdpbGwgYmUgYmluZCB0byB0aGUgdG9vbHRpcCBlbGVtZW50XG4gIHZhciB0b29sdGlwRGF0YTogVG9vbFRpcERhdGFbXTtcblxuICB2YXIgaXRlbURhdGE6IE1hcDxzdHJpbmc+ID0gZDNtYXAoaXRlbS5kYXR1bSk7XG5cbiAgLy8gVE9ETyh6ZW5pbmcpOiBmaW5kIG1vcmUga2V5cyB3aGljaCB3ZSBzaG91bGQgcmVtb3ZlIGZyb20gZGF0YSAoIzM1KVxuICB2YXIgcmVtb3ZlS2V5cyA9IFtcbiAgICBcIl9pZFwiLCBcIl9wcmV2XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIixcbiAgICBcImNvdW50X3N0YXJ0XCIsIFwiY291bnRfZW5kXCIsXG4gICAgXCJsYXlvdXRfc3RhcnRcIiwgXCJsYXlvdXRfbWlkXCIsIFwibGF5b3V0X2VuZFwiLCBcImxheW91dF9wYXRoXCIsIFwibGF5b3V0X3hcIiwgXCJsYXlvdXRfeVwiXG4gIF07XG4gIHJlbW92ZUZpZWxkcyhpdGVtRGF0YSwgcmVtb3ZlS2V5cyk7XG5cbiAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSB0aW1lIGZpZWxkcyAoaWYgYW55KVxuICByZW1vdmVEdXBsaWNhdGVUaW1lRmllbGRzKGl0ZW1EYXRhLCBvcHRpb25zLmZpZWxkcyk7XG5cbiAgLy8gY29tYmluZSBtdWx0aXBsZSByb3dzIG9mIGEgYmlubmVkIGZpZWxkIGludG8gYSBzaW5nbGUgcm93XG4gIGNvbWJpbmVCaW5GaWVsZHMoaXRlbURhdGEsIG9wdGlvbnMuZmllbGRzKTtcblxuICAvLyBUT0RPKHplbmluZyk6IHVzZSBWZWdhLUxpdGUgbGF5ZXJpbmcgdG8gc3VwcG9ydCB0b29sdGlwIG9uIGxpbmUgYW5kIGFyZWEgY2hhcnRzICgjMSlcbiAgZHJvcEZpZWxkc0ZvckxpbmVBcmVhKGl0ZW0ubWFyay5tYXJrdHlwZSwgaXRlbURhdGEpO1xuXG4gIGlmIChvcHRpb25zLnNob3dBbGxGaWVsZHMgIT09IGZhbHNlKSB7XG4gICAgdG9vbHRpcERhdGEgPSBwcmVwYXJlQWxsRmllbGRzRGF0YShpdGVtRGF0YSwgb3B0aW9ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdG9vbHRpcERhdGEgPSBwcmVwYXJlQ3VzdG9tRmllbGRzRGF0YShpdGVtRGF0YSwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdG9vbHRpcERhdGE7XG59XG5cblxuLyoqXG4qIFByZXBhcmUgY3VzdG9tIGZpZWxkcyBkYXRhIGZvciB0b29sdGlwLiBUaGlzIGZ1bmN0aW9uIGZvcm1hdHNcbiogZmllbGQgdGl0bGVzIGFuZCB2YWx1ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgZm9ybWF0dGVkIGZpZWxkcy5cbipcbiogQHBhcmFtIHtkMy5tYXB9IGl0ZW1EYXRhIC0gYSBtYXAgb2YgaXRlbS5kYXR1bVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHVzZXItcHJvdmlkZWQgb3B0aW9uc1xuKiBAcmV0dXJuIEFuIGFycmF5IG9mIGZvcm1hdHRlZCBmaWVsZHMgc3BlY2lmaWVkIGJ5IG9wdGlvbnMgW3sgdGl0bGU6IC4uLiwgdmFsdWU6IC4uLn1dXG4qL1xuZnVuY3Rpb24gcHJlcGFyZUN1c3RvbUZpZWxkc0RhdGEoaXRlbURhdGE6IE1hcDxzdHJpbmc+LCBvcHRpb25zOiBPcHRpb24pIHtcbiAgdmFyIHRvb2x0aXBEYXRhOiBUb29sVGlwRGF0YVtdID0gW107XG5cbiAgb3B0aW9ucy5maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRPcHRpb24pIHtcbiAgICAvLyBwcmVwYXJlIGZpZWxkIHRpdGxlXG4gICAgdmFyIHRpdGxlID0gZmllbGRPcHRpb24udGl0bGUgPyBmaWVsZE9wdGlvbi50aXRsZSA6IGZpZWxkT3B0aW9uLmZpZWxkO1xuXG4gICAgLy8gZ2V0IChyYXcpIGZpZWxkIHZhbHVlXG4gICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUoaXRlbURhdGEsIGZpZWxkT3B0aW9uLmZpZWxkKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgLy8gZm9ybWF0IHZhbHVlXG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gY3VzdG9tRm9ybWF0KHZhbHVlLCBmaWVsZE9wdGlvbi5mb3JtYXRUeXBlLCBmaWVsZE9wdGlvbi5mb3JtYXQpIHx8IGF1dG9Gb3JtYXQodmFsdWUpO1xuXG4gICAgLy8gYWRkIGZvcm1hdHRlZCBkYXRhIHRvIHRvb2x0aXBEYXRhXG4gICAgdG9vbHRpcERhdGEucHVzaCh7IHRpdGxlOiB0aXRsZSwgdmFsdWU6IGZvcm1hdHRlZFZhbHVlIH0pO1xuXG4gIH0pO1xuXG4gIHJldHVybiB0b29sdGlwRGF0YTtcbn1cblxuLyoqXG4qIEdldCBhIGZpZWxkIHZhbHVlIGZyb20gYSBkYXRhIG1hcC5cbiogQHBhcmFtIHtkMy5tYXB9IGl0ZW1EYXRhIC0gYSBtYXAgb2YgaXRlbS5kYXR1bVxuKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgLSB0aGUgbmFtZSBvZiB0aGUgZmllbGQuIEl0IGNhbiBjb250YWluIFwiLlwiIHRvIHNwZWNpZnlcbiogdGhhdCB0aGUgZmllbGQgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIGl0ZW0uZGF0dW1cbiogQHJldHVybiB0aGUgZmllbGQgdmFsdWUgb24gc3VjY2VzcywgdW5kZWZpbmVkIG90aGVyd2lzZVxuKi9cbi8vIFRPRE8oemVuaW5nKTogTXV0ZSBcIkNhbm5vdCBmaW5kIGZpZWxkXCIgd2FybmluZ3MgZm9yIGNvbXBvc2l0ZSB2aXMgKGlzc3VlICMzOSlcbmZ1bmN0aW9uIGdldFZhbHVlKGl0ZW1EYXRhOiBNYXA8c3RyaW5nPiwgZmllbGQ6IHN0cmluZykge1xuICB2YXIgdmFsdWU6IHN0cmluZztcblxuICB2YXIgYWNjZXNzb3JzOiBzdHJpbmdbXSA9IGZpZWxkLnNwbGl0KCcuJyk7XG5cbiAgLy8gZ2V0IHRoZSBmaXJzdCBhY2Nlc3NvciBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5XG4gIHZhciBmaXJzdEFjY2Vzc29yOiBzdHJpbmcgPSBhY2Nlc3NvcnNbMF07XG4gIGFjY2Vzc29ycy5zaGlmdCgpO1xuXG4gIGlmIChpdGVtRGF0YS5oYXMoZmlyc3RBY2Nlc3NvcikpIHtcbiAgICB2YWx1ZSA9IGl0ZW1EYXRhLmdldChmaXJzdEFjY2Vzc29yKTtcblxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgYWNjZXNzb3JzLCB1c2UgdGhlbSB0byBnZXQgdGhlIHZhbHVlXG4gICAgYWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKGEpIHtcbiAgICAgIGlmICh2YWx1ZVthXSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlW2FdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJbVG9vbHRpcF0gQ2Fubm90IGZpbmQgZmllbGQgXCIgKyBmaWVsZCArIFwiIGluIGRhdGEuXCIpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4qIFByZXBhcmUgZGF0YSBmb3IgYWxsIGZpZWxkcyBpbiBpdGVtRGF0YSBmb3IgdG9vbHRpcC4gVGhpcyBmdW5jdGlvblxuKiBmb3JtYXRzIGZpZWxkIHRpdGxlcyBhbmQgdmFsdWVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGZvcm1hdHRlZCBmaWVsZHMuXG4qXG4qIEBwYXJhbSB7ZDMubWFwfSBpdGVtRGF0YSAtIGEgbWFwIG9mIGl0ZW0uZGF0dW1cbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB1c2VyLXByb3ZpZGVkIG9wdGlvbnNcbiogQHJldHVybiBBbGwgZmllbGRzIGluIGl0ZW1EYXRhLCBmb3JtYXR0ZWQsIGluIHRoZSBmb3JtIG9mIGFuIGFycmF5OiBbeyB0aXRsZTogLi4uLCB2YWx1ZTogLi4ufV1cbipcbiogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHMgaXRlbURhdGEgdG8gYmUgc2ltcGxlIHtmaWVsZDp2YWx1ZX0gcGFpcnMuXG4qIEl0IHdpbGwgbm90IHRyeSB0byBwYXJzZSB2YWx1ZSBpZiBpdCBpcyBhbiBvYmplY3QuIElmIHZhbHVlIGlzIGFuIG9iamVjdCwgcGxlYXNlXG4qIHVzZSBwcmVwYXJlQ3VzdG9tRmllbGRzRGF0YSgpIGluc3RlYWQuXG4qL1xuZnVuY3Rpb24gcHJlcGFyZUFsbEZpZWxkc0RhdGEoaXRlbURhdGE6IE1hcDxzdHJpbmc+LCBvcHRpb25zOiBPcHRpb24pIHtcbiAgdmFyIHRvb2x0aXBEYXRhOiBUb29sVGlwRGF0YVtdID0gW107XG5cbiAgLy8gaGVyZSwgZmllbGRPcHRpb25zIHN0aWxsIHByb3ZpZGVzIGZvcm1hdFxuICB2YXIgZmllbGRPcHRpb25zID0gZDNtYXAob3B0aW9ucy5maWVsZHMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZpZWxkOyB9KTtcblxuICBpdGVtRGF0YS5lYWNoKGZ1bmN0aW9uICh2YWx1ZTogc3RyaW5nLCBmaWVsZDogc3RyaW5nKSB7XG4gICAgLy8gcHJlcGFyZSB0aXRsZVxuICAgIHZhciB0aXRsZTtcbiAgICBpZiAoZmllbGRPcHRpb25zLmhhcyhmaWVsZCkgJiYgZmllbGRPcHRpb25zLmdldChmaWVsZCkudGl0bGUpIHtcbiAgICAgIHRpdGxlID0gZmllbGRPcHRpb25zLmdldChmaWVsZCkudGl0bGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGl0bGUgPSBmaWVsZDtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgdmFsdWVcbiAgICBpZiAoZmllbGRPcHRpb25zLmhhcyhmaWVsZCkpIHtcbiAgICAgIHZhciBmb3JtYXRUeXBlID0gZmllbGRPcHRpb25zLmdldChmaWVsZCkuZm9ybWF0VHlwZTtcbiAgICAgIHZhciBmb3JtYXQgPSBmaWVsZE9wdGlvbnMuZ2V0KGZpZWxkKS5mb3JtYXQ7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGN1c3RvbUZvcm1hdCh2YWx1ZSwgZm9ybWF0VHlwZSwgZm9ybWF0KSB8fCBhdXRvRm9ybWF0KHZhbHVlKTtcblxuICAgIC8vIGFkZCBmb3JtYXR0ZWQgZGF0YSB0byB0b29sdGlwRGF0YVxuICAgIHRvb2x0aXBEYXRhLnB1c2goeyB0aXRsZTogdGl0bGUsIHZhbHVlOiBmb3JtYXR0ZWRWYWx1ZSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvb2x0aXBEYXRhO1xufVxuXG4vKipcbiogUmVtb3ZlIG11bHRpcGxlIGZpZWxkcyBmcm9tIGEgdG9vbHRpcCBkYXRhIG1hcCwgdXNpbmcgcmVtb3ZlS2V5c1xuKlxuKiBDZXJ0YWluIG1ldGEgZGF0YSBmaWVsZHMgKGUuZy4gXCJfaWRcIiwgXCJfcHJldlwiKSBzaG91bGQgYmUgaGlkZGVuIGluIHRoZSB0b29sdGlwXG4qIGJ5IGRlZmF1bHQuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZXNlIGZpZWxkcyBmcm9tIHRvb2x0aXAgZGF0YS5cbiogQHBhcmFtIHtkMy5tYXB9IGRhdGFNYXAgLSB0aGUgZGF0YSBtYXAgdGhhdCBjb250YWlucyB0b29sdGlwIGRhdGEuXG4qIEBwYXJhbSB7c3RyaW5nW119IHJlbW92ZUtleXMgLSB0aGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkYXRhTWFwLlxuKi9cbmZ1bmN0aW9uIHJlbW92ZUZpZWxkcyhkYXRhTWFwOiBNYXA8c3RyaW5nPiwgcmVtb3ZlS2V5czogc3RyaW5nW10pIHtcbiAgcmVtb3ZlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkYXRhTWFwLnJlbW92ZShrZXkpO1xuICB9KVxufVxuXG4vKipcbiAqIFdoZW4gYSB0ZW1wb3JhbCBmaWVsZCBoYXMgdGltZVVuaXQsIGl0ZW1EYXRhIHdpbGwgZ2l2ZSB1cyBkdXBsaWNhdGVkIGZpZWxkc1xuICogKGUuZy4sIFllYXIgYW5kIFlFQVIoWWVhcikpLiBJbiB0b29sdGlwIHdhbnQgdG8gZGlzcGxheSB0aGUgZmllbGQgV0lUSCB0aGVcbiAqIHRpbWVVbml0IGFuZCByZW1vdmUgdGhlIGZpZWxkIHRoYXQgZG9lc24ndCBoYXZlIHRpbWVVbml0LlxuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVUaW1lRmllbGRzKGl0ZW1EYXRhOiBNYXA8c3RyaW5nPiwgb3B0RmllbGRzOiBzdXBwbGVtZW50ZWRGaWVsZE9wdGlvbltdKSB7XG4gIGlmICghb3B0RmllbGRzKSByZXR1cm47XG5cbiAgb3B0RmllbGRzLmZvckVhY2goZnVuY3Rpb24gKG9wdEZpZWxkKSB7XG4gICAgaWYgKG9wdEZpZWxkLnJlbW92ZU9yaWdpbmFsVGVtcG9yYWxGaWVsZCkge1xuICAgICAgcmVtb3ZlRmllbGRzKGl0ZW1EYXRhLCBbb3B0RmllbGQucmVtb3ZlT3JpZ2luYWxUZW1wb3JhbEZpZWxkXSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4qIENvbWJpbmUgbXVsdGlwbGUgYmlubmVkIGZpZWxkcyBpbiBpdGVtRGF0YSBpbnRvIG9uZSBmaWVsZC4gVGhlIHZhbHVlIG9mIHRoZSBmaWVsZFxuKiBpcyBhIHN0cmluZyB0aGF0IGRlc2NyaWJlcyB0aGUgYmluIHJhbmdlLlxuKlxuKiBAcGFyYW0ge2QzLm1hcH0gaXRlbURhdGEgLSBhIG1hcCBvZiBpdGVtLmRhdHVtXG4qIEBwYXJhbSB7T2JqZWN0W119IGZpZWxkT3B0aW9ucyAtIGEgbGlzdCBvZiBmaWVsZCBvcHRpb25zIChpLmUuIG9wdGlvbnMuZmllbGRzW10pXG4qIEByZXR1cm4gaXRlbURhdGEgd2l0aCBjb21iaW5lZCBiaW4gZmllbGRzXG4qL1xuZnVuY3Rpb24gY29tYmluZUJpbkZpZWxkcyhpdGVtRGF0YTogTWFwPHN0cmluZz4sIGZpZWxkT3B0aW9uczogRmllbGRPcHRpb25bXSkge1xuICBpZiAoIWZpZWxkT3B0aW9ucykgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBmaWVsZE9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGRPcHRpb24pIHtcbiAgICBpZiAoZmllbGRPcHRpb24uYmluID09PSB0cnVlKSB7XG5cbiAgICAgIC8vIGdldCBiaW5uZWQgZmllbGQgbmFtZXNcbiAgICAgIHZhciBiaW5fZmllbGRfcmFuZ2UgPSBmaWVsZE9wdGlvbi5maWVsZDtcbiAgICAgIHZhciBiaW5fZmllbGRfc3RhcnQgPSBiaW5fZmllbGRfcmFuZ2UucmVwbGFjZSgnX3JhbmdlJywgJ19zdGFydCcpO1xuICAgICAgdmFyIGJpbl9maWVsZF9taWQgPSBiaW5fZmllbGRfcmFuZ2UucmVwbGFjZSgnX3JhbmdlJywgJ19taWQnKTtcbiAgICAgIHZhciBiaW5fZmllbGRfZW5kID0gYmluX2ZpZWxkX3JhbmdlLnJlcGxhY2UoJ19yYW5nZScsICdfZW5kJyk7XG5cbiAgICAgIC8vIHVzZSBzdGFydCB2YWx1ZSBhbmQgZW5kIHZhbHVlIHRvIGNvbXB1dGUgcmFuZ2VcbiAgICAgIC8vIHNhdmUgdGhlIGNvbXB1dGVkIHJhbmdlIGluIGJpbl9maWVsZF9zdGFydFxuICAgICAgdmFyIHN0YXJ0VmFsdWUgPSBpdGVtRGF0YS5nZXQoYmluX2ZpZWxkX3N0YXJ0KTtcbiAgICAgIHZhciBlbmRWYWx1ZSA9IGl0ZW1EYXRhLmdldChiaW5fZmllbGRfZW5kKTtcbiAgICAgIGlmICgoc3RhcnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSAmJiAoZW5kVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gc3RhcnRWYWx1ZSArICctJyArIGVuZFZhbHVlO1xuICAgICAgICBpdGVtRGF0YS5zZXQoYmluX2ZpZWxkX3JhbmdlLCByYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBiaW5fZmllbGRfbWlkLCBiaW5fZmllbGRfZW5kLCBhbmQgYmluX2ZpZWxkX3JhbmdlIGZyb20gaXRlbURhdGFcbiAgICAgIHZhciBiaW5SZW1vdmVLZXlzID0gW107XG4gICAgICBiaW5SZW1vdmVLZXlzLnB1c2goYmluX2ZpZWxkX3N0YXJ0LCBiaW5fZmllbGRfbWlkLCBiaW5fZmllbGRfZW5kKTtcbiAgICAgIHJlbW92ZUZpZWxkcyhpdGVtRGF0YSwgYmluUmVtb3ZlS2V5cyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXRlbURhdGE7XG59XG5cbi8qKlxuKiBEcm9wIGZpZWxkcyBmb3IgbGluZSBhbmQgYXJlYSBtYXJrcy5cbipcbiogTGluZXMgYW5kIGFyZWFzIGFyZSBkZWZpbmVkIGJ5IGEgc2VyaWVzIG9mIGRhdHVtLiBXZSBvdmVybGF5IHBvaW50IG1hcmtzXG4qIG9uIHRvcCBvZiBsaW5lcyBhbmQgYXJlYXMgdG8gYWxsb3cgdG9vbHRpcCB0byBzaG93IGFsbCBkYXRhIGluIHRoZSBzZXJpZXMuXG4qIEZvciB0aGUgbGluZSBtYXJrcyBhbmQgYXJlYSBtYXJrcyB1bmRlcm5lYXRoLCB3ZSBvbmx5IHNob3cgbm9taW5hbCBmaWVsZHNcbiogaW4gdG9vbHRpcC4gVGhpcyBpcyBiZWNhdXNlIGxpbmUgLyBhcmVhIG1hcmtzIG9ubHkgZ2l2ZSB1cyB0aGUgbGFzdCBkYXR1bVxuKiBpbiB0aGVpciBzZXJpZXMuIEl0IG9ubHkgbWFrZSBzZW5zZSB0byBzaG93IHRoZSBub21pbmFsIGZpZWxkcyAoZS5nLiwgc3ltYm9sXG4qID0gQVBQTCwgQU1aTiwgR09PRywgSUJNLCBNU0ZUKSBiZWNhdXNlIHRoZXNlIGZpZWxkcyBkb24ndCB0ZW5kIHRvIGNoYW5nZSBhbG9uZ1xuKiB0aGUgbGluZSAvIGFyZWEgYm9yZGVyLlxuKi9cbmZ1bmN0aW9uIGRyb3BGaWVsZHNGb3JMaW5lQXJlYShtYXJrdHlwZTogc3RyaW5nLCBpdGVtRGF0YTogTWFwPHN0cmluZz4pIHtcbiAgaWYgKG1hcmt0eXBlID09PSBcImxpbmVcIiB8fCBtYXJrdHlwZSA9PT0gXCJhcmVhXCIpIHtcbiAgICB2YXIgcXVhbktleXM6IHN0cmluZ1tdID0gW107XG4gICAgaXRlbURhdGEuZWFjaChmdW5jdGlvbiAoZmllbGQsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKGRsLnR5cGUodmFsdWUpKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICBxdWFuS2V5cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlbW92ZUZpZWxkcyhpdGVtRGF0YSwgcXVhbktleXMpO1xuICB9XG59XG5cbi8qKlxuKiBGb3JtYXQgdmFsdWUgdXNpbmcgZm9ybWF0VHlwZSBhbmQgZm9ybWF0XG4qIEBwYXJhbSB2YWx1ZSAtIGEgZmllbGQgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4qIEBwYXJhbSBmb3JtYXRUeXBlIC0gdGhlIGZvcmFtdFR5cGUgY2FuIGJlOiBcInRpbWVcIiwgXCJudW1iZXJcIiwgb3IgXCJzdHJpbmdcIlxuKiBAcGFyYW0gZm9ybWF0IC0gYSBkMyB0aW1lIGZvcm1hdCBzcGVjaWZpZXIsIG9yIGEgZDMgbnVtYmVyIGZvcm1hdCBzcGVjaWZpZXIsIG9yIHVuZGVmaW5lZFxuKiBAcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdmFsdWUsIG9yIHVuZGVmaW5lZCBpZiB2YWx1ZSBvciBmb3JtYXRUeXBlIGlzIG1pc3NpbmdcbiovXG5mdW5jdGlvbiBjdXN0b21Gb3JtYXQodmFsdWU6IHN0cmluZywgZm9ybWF0VHlwZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuO1xuICBpZiAoIWZvcm1hdFR5cGUpIHJldHVybjtcblxuICBzd2l0Y2ggKGZvcm1hdFR5cGUpIHtcbiAgICBjYXNlIFwidGltZVwiOlxuICAgICAgcmV0dXJuIGZvcm1hdCA/IGRsLmZvcm1hdC50aW1lKGZvcm1hdCkodmFsdWUpIDogZGwuZm9ybWF0LmF1dG8udGltZSgpKHZhbHVlKTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gZm9ybWF0ID8gZGwuZm9ybWF0Lm51bWJlcihmb3JtYXQpKHZhbHVlKSA6IGRsLmZvcm1hdC5hdXRvLm51bWJlcigpKHZhbHVlKTtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiogQXV0b21hdGljYWxseSBmb3JtYXQgYSB0aW1lLCBudW1iZXIgb3Igc3RyaW5nIHZhbHVlXG4qIEByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aW1lLCBudW1iZXIgb3Igc3RyaW5nIHZhbHVlXG4qL1xuZnVuY3Rpb24gYXV0b0Zvcm1hdCh2YWx1ZTogc3RyaW5nKSB7XG4gIHN3aXRjaCAoZGwudHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgcmV0dXJuIGRsLmZvcm1hdC5hdXRvLnRpbWUoKSh2YWx1ZSk7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIGRsLmZvcm1hdC5hdXRvLm51bWJlcigpKHZhbHVlKTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cblxuLyoqXG4qIEdldCB0aGUgdG9vbHRpcCBIVE1MIHBsYWNlaG9sZGVyIGJ5IGlkIHNlbGVjdG9yIFwiI3Zpcy10b29sdGlwXCJcbiogSWYgbm9uZSBleGlzdHMsIGNyZWF0ZSBhIHBsYWNlaG9sZGVyLlxuKiBAcmV0dXJucyB0aGUgSFRNTCBwbGFjZWhvbGRlciBmb3IgdG9vbHRpcFxuKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBQbGFjZWhvbGRlcigpIHtcbiAgdmFyIHRvb2x0aXBQbGFjZWhvbGRlcjtcblxuICBpZiAoc2VsZWN0KFwiI3Zpcy10b29sdGlwXCIpLmVtcHR5KCkpIHtcbiAgICB0b29sdGlwUGxhY2Vob2xkZXIgPSBzZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImRpdlwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCBcInZpcy10b29sdGlwXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwidmctdG9vbHRpcFwiKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0b29sdGlwUGxhY2Vob2xkZXIgPSBzZWxlY3QoXCIjdmlzLXRvb2x0aXBcIik7XG4gIH1cblxuICByZXR1cm4gdG9vbHRpcFBsYWNlaG9sZGVyO1xufVxuXG4vKipcbiogQmluZCB0b29sdGlwRGF0YSB0byB0aGUgdG9vbHRpcCBwbGFjZWhvbGRlclxuKi9cbmZ1bmN0aW9uIGJpbmREYXRhKHRvb2x0aXBQbGFjZWhvbGRlcjogU2VsZWN0aW9uPEVsZW1lbnQgfCBFbnRlckVsZW1lbnQgfCBEb2N1bWVudCB8IFdpbmRvdywge30sIEhUTUxFbGVtZW50LCBhbnk+LCB0b29sdGlwRGF0YTogVG9vbFRpcERhdGFbXSkge1xuICB0b29sdGlwUGxhY2Vob2xkZXIuc2VsZWN0QWxsKFwidGFibGVcIikucmVtb3ZlKCk7XG4gIHZhciB0b29sdGlwUm93cyA9IHRvb2x0aXBQbGFjZWhvbGRlci5hcHBlbmQoXCJ0YWJsZVwiKS5zZWxlY3RBbGwoXCIudG9vbHRpcC1yb3dcIilcbiAgICAuZGF0YSh0b29sdGlwRGF0YSk7XG5cbiAgdG9vbHRpcFJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXG4gIHZhciByb3cgPSB0b29sdGlwUm93cy5lbnRlcigpLmFwcGVuZChcInRyXCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvb2x0aXAtcm93XCIpO1xuICByb3cuYXBwZW5kKFwidGRcIikuYXR0cihcImNsYXNzXCIsIFwia2V5XCIpLnRleHQoZnVuY3Rpb24gKGQ6IFRvb2xUaXBEYXRhKSB7IHJldHVybiBkLnRpdGxlICsgXCI6XCI7IH0pO1xuICByb3cuYXBwZW5kKFwidGRcIikuYXR0cihcImNsYXNzXCIsIFwidmFsdWVcIikudGV4dChmdW5jdGlvbiAoZDogVG9vbFRpcERhdGEpIHsgcmV0dXJuIGQudmFsdWU7IH0pO1xufVxuXG4vKipcbiogQ2xlYXIgdG9vbHRpcCBkYXRhXG4qL1xuZnVuY3Rpb24gY2xlYXJEYXRhKCkge1xuICBzZWxlY3QoXCIjdmlzLXRvb2x0aXBcIikuc2VsZWN0QWxsKFwiLnRvb2x0aXAtcm93XCIpLmRhdGEoW10pXG4gICAgLmV4aXQoKS5yZW1vdmUoKTtcbn1cblxuLyoqXG4qIFVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uXG4qIERlZmF1bHQgcG9zaXRpb24gaXMgMTBweCByaWdodCBvZiBhbmQgMTBweCBiZWxvdyB0aGUgY3Vyc29yLiBUaGlzIGNhbiBiZVxuKiBvdmVyd3JpdHRlbiBieSBvcHRpb25zLm9mZnNldFxuKi9cbmZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGV2ZW50OiBNb3VzZUV2ZW50LCBvcHRpb25zOiBPcHRpb24pIHtcbiAgLy8gZGV0ZXJtaW5lIHggYW5kIHkgb2Zmc2V0cywgZGVmYXVsdHMgYXJlIDEwcHhcbiAgdmFyIG9mZnNldFggPSAxMDtcbiAgdmFyIG9mZnNldFkgPSAxMDtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vZmZzZXQgJiYgKG9wdGlvbnMub2Zmc2V0LnggIT09IHVuZGVmaW5lZCkgJiYgKG9wdGlvbnMub2Zmc2V0LnggIT09IG51bGwpKSB7XG4gICAgb2Zmc2V0WCA9IG9wdGlvbnMub2Zmc2V0Lng7XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vZmZzZXQgJiYgKG9wdGlvbnMub2Zmc2V0LnkgIT09IHVuZGVmaW5lZCkgJiYgKG9wdGlvbnMub2Zmc2V0LnkgIT09IG51bGwpKSB7XG4gICAgb2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0Lnk7XG4gIH1cblxuICAvL1RPRE86IHVzZSB0aGUgY29ycmVjdCBkMyB0eXBlXG4gIHNlbGVjdChcIiN2aXMtdG9vbHRpcFwiKVxuICAgIC5zdHlsZShcInRvcFwiLCBmdW5jdGlvbiAodGhpczogSFRNTEVsZW1lbnQpIHtcbiAgICAgIC8vIGJ5IGRlZmF1bHQ6IHB1dCB0b29sdGlwIDEwcHggYmVsb3cgY3Vyc29yXG4gICAgICAvLyBpZiB0b29sdGlwIGlzIGNsb3NlIHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdywgcHV0IHRvb2x0aXAgMTBweCBhYm92ZSBjdXJzb3JcbiAgICAgIHZhciB0b29sdGlwSGVpZ2h0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICBpZiAoZXZlbnQuY2xpZW50WSArIHRvb2x0aXBIZWlnaHQgKyBvZmZzZXRZIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKGV2ZW50LmNsaWVudFkgKyBvZmZzZXRZKSArIFwicHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgKGV2ZW50LmNsaWVudFkgLSB0b29sdGlwSGVpZ2h0IC0gb2Zmc2V0WSkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSlcbiAgICAuc3R5bGUoXCJsZWZ0XCIsIGZ1bmN0aW9uICh0aGlzOiBIVE1MRWxlbWVudCkge1xuICAgICAgLy8gYnkgZGVmYXVsdDogcHV0IHRvb2x0aXAgMTBweCB0byB0aGUgcmlnaHQgb2YgY3Vyc29yXG4gICAgICAvLyBpZiB0b29sdGlwIGlzIGNsb3NlIHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSB3aW5kb3csIHB1dCB0b29sdGlwIDEwIHB4IHRvIHRoZSBsZWZ0IG9mIGN1cnNvclxuICAgICAgdmFyIHRvb2x0aXBXaWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICBpZiAoZXZlbnQuY2xpZW50WCArIHRvb2x0aXBXaWR0aCArIG9mZnNldFggPCB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgICAgICByZXR1cm4gXCJcIiArIChldmVudC5jbGllbnRYICsgb2Zmc2V0WCkgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIiArIChldmVudC5jbGllbnRYIC0gdG9vbHRpcFdpZHRoIC0gb2Zmc2V0WCkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSk7XG59XG5cbi8qIENsZWFyIHRvb2x0aXAgcG9zaXRpb24gKi9cbmZ1bmN0aW9uIGNsZWFyUG9zaXRpb24oKSB7XG4gIHNlbGVjdChcIiN2aXMtdG9vbHRpcFwiKVxuICAgIC5zdHlsZShcInRvcFwiLCBcIi05OTk5cHhcIilcbiAgICAuc3R5bGUoXCJsZWZ0XCIsIFwiLTk5OTlweFwiKTtcbn1cblxuLyoqXG4qIFVwZGF0ZSB0b29sdGlwIGNvbG9yIHRoZW1lIGFjY29yZGluZyB0byBvcHRpb25zLmNvbG9yVGhlbWVcbipcbiogSWYgY29sb3JUaGVtZSA9PT0gXCJkYXJrXCIsIGFwcGx5IGRhcmsgdGhlbWUgdG8gdG9vbHRpcC5cbiogT3RoZXJ3aXNlIGFwcGx5IGxpZ2h0IGNvbG9yIHRoZW1lLlxuKi9cbmZ1bmN0aW9uIHVwZGF0ZUNvbG9yVGhlbWUob3B0aW9uczogT3B0aW9uKSB7XG4gIGNsZWFyQ29sb3JUaGVtZSgpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29sb3JUaGVtZSA9PT0gXCJkYXJrXCIpIHtcbiAgICBzZWxlY3QoXCIjdmlzLXRvb2x0aXBcIikuY2xhc3NlZChcImRhcmstdGhlbWVcIiwgdHJ1ZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VsZWN0KFwiI3Zpcy10b29sdGlwXCIpLmNsYXNzZWQoXCJsaWdodC10aGVtZVwiLCB0cnVlKTtcbiAgfVxufVxuXG4vKiBDbGVhciBjb2xvciB0aGVtZXMgKi9cbmZ1bmN0aW9uIGNsZWFyQ29sb3JUaGVtZSgpIHtcbiAgc2VsZWN0KFwiI3Zpcy10b29sdGlwXCIpLmNsYXNzZWQoXCJkYXJrLXRoZW1lIGxpZ2h0LXRoZW1lXCIsIGZhbHNlKTtcbn1cbiJdfQ==
